{"project": "Cli", "bug_id": 1, "classes_modified": [{"class_name": "org.apache.commons.cli.CommandLine", "buggy_version": "/**\n * Copyright 1999-2001,2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\n/** \n * <p>Represents list of arguments parsed against\n * a {@link Options} descriptor.<p>\n *\n * <p>It allows querying of a boolean {@link #hasOption(String opt)},\n * in addition to retrieving the {@link #getOptionValue(String opt)}\n * for options requiring arguments.</p>\n *\n * <p>Additionally, any left-over or unrecognized arguments,\n * are available for further processing.</p>\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @author John Keyes (john at integralsource.com)\n */\npublic class CommandLine {\n\n    /** the unrecognised options/arguments */\n    private List args = new LinkedList();\n\n    /** the processed options */\n    private Map options = new HashMap();\n    private Map names = new HashMap();\n\n    /** Map of unique options for ease to get complete list of options */\n//    private Set allOptions = new HashSet();\n    private Map hashcodeMap = new HashMap();\n\n    /**\n     * Creates a command line.\n     */\n    CommandLine()\n    {\n        // nothing to do\n    }\n\n    /** \n     * Query to see if an option has been set.\n     *\n     * @param opt Short name of the option\n     * @return true if set, false if not\n     */\n    public boolean hasOption(String opt)\n    {\n        return options.containsKey(opt);\n    }\n\n    /** \n     * Query to see if an option has been set.\n     *\n     * @param opt character name of the option\n     * @return true if set, false if not\n     */\n    public boolean hasOption(char opt)\n    {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @param opt the name of the option\n     * @return the type of this <code>Option</code>\n     */\n    public Object getOptionObject(String opt)\n    {\n        String res = getOptionValue(opt);\n\n        if (!options.containsKey(opt))\n        {\n            return null;\n        }\n\n        Object type = ((Option) options.get(opt)).getType();\n\n        return (res == null)        ? null : TypeHandler.createValue(res, type);\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @param opt the name of the option\n     * @return the type of opt\n     */\n    public Object getOptionObject(char opt)\n    {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieve the argument, if any, of this option.\n     *\n     * @param opt the name of the option\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(String opt)\n    {\n        String[] values = getOptionValues(opt);\n\n        return (values == null) ? null : values[0];\n    }\n\n    /** \n     * Retrieve the argument, if any, of this option.\n     *\n     * @param opt the character name of the option\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(char opt)\n    {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt string name of the option\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        String key = opt;\n        if (names.containsKey(opt))\n        {\n            key = (String) names.get(opt);\n        }\n        if (options.containsKey(key))\n        {\n            return ((Option) options.get(key)).getValues();\n        }\n\n        return null;\n        }\n\n    /**\n     * <p>Retrieves the option object given the long or short option as a String</p>\n     * @param opt short or long name of the option\n     * @return Canonicalized option\n     */\n\n\n    /** \n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(char opt)\n    {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt name of the option\n     * @param defaultValue is the default value to be returned if the option \n     * is not specified\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(String opt, String defaultValue)\n    {\n        String answer = getOptionValue(opt);\n\n        return (answer != null) ? answer : defaultValue;\n    }\n\n    /** \n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option \n     * is not specified\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(char opt, String defaultValue)\n    {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /** \n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array\n     */\n    public String[] getArgs()\n    {\n        String[] answer = new String[args.size()];\n\n        args.toArray(answer);\n\n        return answer;\n    }\n\n    /** \n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a <code>List</code>.\n     */\n    public List getArgList()\n    {\n        return args;\n    }\n\n    /** \n     * jkeyes\n     * - commented out until it is implemented properly\n     * <p>Dump state, suitable for debugging.</p>\n     *\n     * @return Stringified form of this object\n     */\n\n    /*\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n            \n        buf.append(\"[ CommandLine: [ options: \");\n        buf.append(options.toString());\n        buf.append(\" ] [ args: \");\n        buf.append(args.toString());\n        buf.append(\" ] ]\");\n            \n        return buf.toString();\n    }\n    */\n\n    /**\n     * Add left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognised option/argument.\n     */\n    void addArg(String arg)\n    {\n        args.add(arg);\n    }\n\n    /**\n     * Add an option to the command line.  The values of \n     * the option are stored.\n     *\n     * @param opt the processed option\n     */\n    void addOption(Option opt)\n    {\n        hashcodeMap.put(new Integer(opt.hashCode()), opt);\n        String key = opt.getKey();\n        if (key == null)\n        {\n            key = opt.getLongOpt();\n        }\n        else\n        {\n            names.put(opt.getLongOpt(), key);\n        }\n        options.put(key, opt);\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an <code>Iterator</code> over the processed {@link Option} \n     * members of this {@link CommandLine}\n     */\n    public Iterator iterator()\n    {\n        return hashcodeMap.values().iterator();\n    }\n\n    /**\n     * Returns an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions()\n    {\n        Collection processed = options.values();\n\n        // reinitialise array\n        Option[] optionsArray = new Option[processed.size()];\n\n        // return the array\n        return (Option[]) processed.toArray(optionsArray);\n    }\n}\n", "fixed_version": "/**\n * Copyright 1999-2001,2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\n/** \n * <p>Represents list of arguments parsed against\n * a {@link Options} descriptor.<p>\n *\n * <p>It allows querying of a boolean {@link #hasOption(String opt)},\n * in addition to retrieving the {@link #getOptionValue(String opt)}\n * for options requiring arguments.</p>\n *\n * <p>Additionally, any left-over or unrecognized arguments,\n * are available for further processing.</p>\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @author John Keyes (john at integralsource.com)\n */\npublic class CommandLine {\n\n    /** the unrecognised options/arguments */\n    private List args = new LinkedList();\n\n    /** the processed options */\n    private Set options = new HashSet();\n\n    /** Map of unique options for ease to get complete list of options */\n//    private Set allOptions = new HashSet();\n\n    /**\n     * Creates a command line.\n     */\n    CommandLine()\n    {\n        // nothing to do\n    }\n\n    /** \n     * Query to see if an option has been set.\n     *\n     * @param opt Short name of the option\n     * @return true if set, false if not\n     */\n    public boolean hasOption(String opt)\n    {\n        return options.contains( resolveOption(opt));\n    }\n\n    /** \n     * Query to see if an option has been set.\n     *\n     * @param opt character name of the option\n     * @return true if set, false if not\n     */\n    public boolean hasOption(char opt)\n    {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @param opt the name of the option\n     * @return the type of this <code>Option</code>\n     */\n    public Object getOptionObject(String opt)\n    {\n        String res = getOptionValue(opt);\n\n        Option option = resolveOption(opt);\n        if (option == null)\n        {\n            return null;\n        }\n\n        Object type = option.getType();\n\n        return (res == null)        ? null : TypeHandler.createValue(res, type);\n    }\n\n    /**\n     * Return the <code>Object</code> type of this <code>Option</code>.\n     *\n     * @param opt the name of the option\n     * @return the type of opt\n     */\n    public Object getOptionObject(char opt)\n    {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieve the argument, if any, of this option.\n     *\n     * @param opt the name of the option\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(String opt)\n    {\n        String[] values = getOptionValues(opt);\n\n        return (values == null) ? null : values[0];\n    }\n\n    /** \n     * Retrieve the argument, if any, of this option.\n     *\n     * @param opt the character name of the option\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String getOptionValue(char opt)\n    {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt string name of the option\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(String opt)\n    {\n        Option key = resolveOption( opt );\n\n        if (options.contains(key))\n        {\n            return key.getValues();\n        }\n\n        return null;\n        }\n\n    /**\n     * <p>Retrieves the option object given the long or short option as a String</p>\n     * @param opt short or long name of the option\n     * @return Canonicalized option\n     */\n    private Option resolveOption( String opt )\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        for ( Iterator it = options.iterator(); it.hasNext(); )\n        {\n            Option option = (Option) it.next();\n            if (opt.equals(option.getOpt()))\n            {\n                return option;\n            }\n            if (opt.equals( option.getLongOpt()))\n            {\n                return option;\n        }\n\n        }\n        return null;\n    }\n\n    /** \n     * Retrieves the array of values, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @return Values of the argument if option is set, and has an argument,\n     * otherwise null.\n     */\n    public String[] getOptionValues(char opt)\n    {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /** \n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt name of the option\n     * @param defaultValue is the default value to be returned if the option \n     * is not specified\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(String opt, String defaultValue)\n    {\n        String answer = getOptionValue(opt);\n\n        return (answer != null) ? answer : defaultValue;\n    }\n\n    /** \n     * Retrieve the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option \n     * is not specified\n     * @return Value of the argument if option is set, and has an argument,\n     * otherwise <code>defaultValue</code>.\n     */\n    public String getOptionValue(char opt, String defaultValue)\n    {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /** \n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array\n     */\n    public String[] getArgs()\n    {\n        String[] answer = new String[args.size()];\n\n        args.toArray(answer);\n\n        return answer;\n    }\n\n    /** \n     * Retrieve any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a <code>List</code>.\n     */\n    public List getArgList()\n    {\n        return args;\n    }\n\n    /** \n     * jkeyes\n     * - commented out until it is implemented properly\n     * <p>Dump state, suitable for debugging.</p>\n     *\n     * @return Stringified form of this object\n     */\n\n    /*\n    public String toString() {\n        StringBuffer buf = new StringBuffer();\n            \n        buf.append(\"[ CommandLine: [ options: \");\n        buf.append(options.toString());\n        buf.append(\" ] [ args: \");\n        buf.append(args.toString());\n        buf.append(\" ] ]\");\n            \n        return buf.toString();\n    }\n    */\n\n    /**\n     * Add left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognised option/argument.\n     */\n    void addArg(String arg)\n    {\n        args.add(arg);\n    }\n\n    /**\n     * Add an option to the command line.  The values of \n     * the option are stored.\n     *\n     * @param opt the processed option\n     */\n    void addOption(Option opt)\n    {\n        options.add(opt);\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an <code>Iterator</code> over the processed {@link Option} \n     * members of this {@link CommandLine}\n     */\n    public Iterator iterator()\n    {\n        return options.iterator();\n    }\n\n    /**\n     * Returns an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions()\n    {\n        Collection processed = options;\n\n        // reinitialise array\n        Option[] optionsArray = new Option[processed.size()];\n\n        // return the array\n        return (Option[]) processed.toArray(optionsArray);\n    }\n}"}]}
{"project": "Cli", "bug_id": 2, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Copyright 1999-2001,2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private ArrayList tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * <p>Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.</p>\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, \n                               boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n        String token;\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, \n                                               token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token)) {\n                \ttokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[] {  });\n    }\n\n    /**\n     * <p>Adds the remaining tokens to the processed tokens list.</p>\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if ((currentOption != null) && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.</p>\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(\"-\" + ch);\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Copyright 1999-2001,2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private ArrayList tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * <p>Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.</p>\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, \n                               boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n        String token;\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, \n                                               token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token)) {\n                \ttokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[] {  });\n    }\n\n    /**\n     * <p>Adds the remaining tokens to the processed tokens list.</p>\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if ((currentOption != null) && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.</p>\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        int tokenLength = token.length();\n\n        for (int i = 1; i < tokenLength; i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n            boolean hasOption = options.hasOption(ch);\n\n            if (hasOption)\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}"}]}
{"project": "Cli", "bug_id": 3, "classes_modified": [{"class_name": "org.apache.commons.cli.TypeHandler", "buggy_version": "/*\n * Copyright 1999-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.io.File;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n  * This is a temporary implementation. TypeHandler will handle the \n  * pluggableness of OptionTypes and it will direct all of these types \n  * of conversion functionalities to ConvertUtils component in Commons \n  * alreayd. BeanUtils I think.\n  *\n  * @author Henri Yandell (bayard @ generationjava.com)\n  * @version $Revision$\n  */\npublic class TypeHandler {\n\n    /**\n     * <p>Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.</p>\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     */\n    public static Object createValue(String str, Object obj)\n    {\n        return createValue(str, (Class) obj);\n    }\n\n    /**\n     * <p>Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.</p>\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     */\n    public static Object createValue(String str, Class clazz)\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * <p>Create an Object from the classname and empty constructor.</p>\n      *\n      * @param str the argument value\n      * @return the initialised object, or null if it couldn't create \n      * the Object.\n      */\n    public static Object createObject(String str)\n    {\n        Class cl = null;\n\n        try\n        {\n            cl = Class.forName(str);\n        }\n        catch (ClassNotFoundException cnfe)\n        {\n            System.err.println(\"Unable to find: \" + str);\n\n            return null;\n        }\n\n        Object instance = null;\n\n        try\n        {\n            instance = cl.newInstance();\n        }\n        catch (InstantiationException cnfe)\n        {\n            System.err.println(\"InstantiationException; Unable to create: \"\n                               + str);\n\n            return null;\n        }\n        catch (IllegalAccessException cnfe)\n        {\n            System.err.println(\"IllegalAccessException; Unable to create: \"\n                               + str);\n\n            return null;\n        }\n\n        return instance;\n    }\n\n    /**\n     * <p>Create a number from a String. If a . is present, it creates a \n     *    Double, otherwise a Long. </p>\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>, if <code>str</code>\n     * is not a number, null is returned.\n     */\n    public static Number createNumber(String str)\n    {\n        try\n        {\n            return org.apache.commons.lang.math.NumberUtils.createNumber(str);\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>Returns the class whose name is <code>str</code>.</p>\n     *\n     * @param str the class name\n     * @return The class if it is found, otherwise return null\n     */\n    public static Class createClass(String str)\n    {\n        try\n        {\n            return Class.forName(str);\n        }\n        catch (ClassNotFoundException cnfe)\n        {\n            System.err.println(\"Unable to find: \" + str);\n\n            return null;\n        }\n    }\n\n    /**\n     * <p>Returns the date represented by <code>str</code>.</p>\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     */\n    public static Date createDate(String str)\n    {\n        Date date = null;\n\n        if (date == null)\n        {\n            System.err.println(\"Unable to parse: \" + str);\n        }\n\n        return date;\n    }\n\n    /**\n     * <p>Returns the URL represented by <code>str</code>.</p>\n     *\n     * @param str the URL string\n     * @return The URL is <code>str</code> is well-formed, otherwise\n     * return null.\n     */\n    public static URL createURL(String str)\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (MalformedURLException mue)\n        {\n            System.err.println(\"Unable to parse: \" + str);\n\n            return null;\n        }\n    }\n\n    /**\n     * <p>Returns the File represented by <code>str</code>.</p>\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * <p>Returns the File[] represented by <code>str</code>.</p>\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     */\n    public static File[] createFiles(String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        return null;\n    }\n}\n", "fixed_version": "/*\n * Copyright 1999-2005 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.io.File;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n  * This is a temporary implementation. TypeHandler will handle the \n  * pluggableness of OptionTypes and it will direct all of these types \n  * of conversion functionalities to ConvertUtils component in Commons \n  * alreayd. BeanUtils I think.\n  *\n  * @author Henri Yandell (bayard @ generationjava.com)\n  * @version $Revision$\n  */\npublic class TypeHandler {\n\n    /**\n     * <p>Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.</p>\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     */\n    public static Object createValue(String str, Object obj)\n    {\n        return createValue(str, (Class) obj);\n    }\n\n    /**\n     * <p>Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.</p>\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     */\n    public static Object createValue(String str, Class clazz)\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * <p>Create an Object from the classname and empty constructor.</p>\n      *\n      * @param str the argument value\n      * @return the initialised object, or null if it couldn't create \n      * the Object.\n      */\n    public static Object createObject(String str)\n    {\n        Class cl = null;\n\n        try\n        {\n            cl = Class.forName(str);\n        }\n        catch (ClassNotFoundException cnfe)\n        {\n            System.err.println(\"Unable to find: \" + str);\n\n            return null;\n        }\n\n        Object instance = null;\n\n        try\n        {\n            instance = cl.newInstance();\n        }\n        catch (InstantiationException cnfe)\n        {\n            System.err.println(\"InstantiationException; Unable to create: \"\n                               + str);\n\n            return null;\n        }\n        catch (IllegalAccessException cnfe)\n        {\n            System.err.println(\"IllegalAccessException; Unable to create: \"\n                               + str);\n\n            return null;\n        }\n\n        return instance;\n    }\n\n    /**\n     * <p>Create a number from a String. If a . is present, it creates a \n     *    Double, otherwise a Long. </p>\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>, if <code>str</code>\n     * is not a number, null is returned.\n     */\n    public static Number createNumber(String str)\n    {\n        try\n        {\n            if( str != null )\n            {\n                if( str.indexOf('.') != -1 )\n                {\n                    return Double.valueOf(str);\n                }\n                else\n                {\n                    return Long.valueOf(str);\n                }\n            }\n        }\n        catch (NumberFormatException nfe)\n        {\n            System.err.println(nfe.getMessage());\n        }\n\n        return null;\n    }\n\n    /**\n     * <p>Returns the class whose name is <code>str</code>.</p>\n     *\n     * @param str the class name\n     * @return The class if it is found, otherwise return null\n     */\n    public static Class createClass(String str)\n    {\n        try\n        {\n            return Class.forName(str);\n        }\n        catch (ClassNotFoundException cnfe)\n        {\n            System.err.println(\"Unable to find: \" + str);\n\n            return null;\n        }\n    }\n\n    /**\n     * <p>Returns the date represented by <code>str</code>.</p>\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     */\n    public static Date createDate(String str)\n    {\n        Date date = null;\n\n        if (date == null)\n        {\n            System.err.println(\"Unable to parse: \" + str);\n        }\n\n        return date;\n    }\n\n    /**\n     * <p>Returns the URL represented by <code>str</code>.</p>\n     *\n     * @param str the URL string\n     * @return The URL is <code>str</code> is well-formed, otherwise\n     * return null.\n     */\n    public static URL createURL(String str)\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (MalformedURLException mue)\n        {\n            System.err.println(\"Unable to parse: \" + str);\n\n            return null;\n        }\n    }\n\n    /**\n     * <p>Returns the File represented by <code>str</code>.</p>\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * <p>Returns the File[] represented by <code>str</code>.</p>\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     */\n    public static File[] createFiles(String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        return null;\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 4, "classes_modified": [{"class_name": "org.apache.commons.cli.Parser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    private CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // initialise members\n        this.options = options;\n\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        requiredOptions = options.getRequiredOptions();\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(this.options, \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !options.hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValue(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer();\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (options.hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    private void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = options.hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = options.getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            requiredOptions.remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (options.getOptionGroup(opt) != null)\n        {\n            OptionGroup group = options.getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                requiredOptions.remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    private CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // initialise members\n        this.options = options;\n\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        requiredOptions = options.getRequiredOptions();\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(this.options, \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !options.hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValue(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (requiredOptions.size() > 0)\n        {\n            Iterator iter = requiredOptions.iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (options.hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    private void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = options.hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = options.getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            requiredOptions.remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (options.getOptionGroup(opt) != null)\n        {\n            OptionGroup group = options.getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                requiredOptions.remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 5, "classes_modified": [{"class_name": "org.apache.commons.cli.Util", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n *\n * @author John Keyes (john at integralsource.com)\n */\nclass Util {\n\n    /**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\")) {\n            str = str.substring(1, str.length());\n        }\n        if (str.endsWith(\"\\\"\")) {\n            str = str.substring(0, str.length()-1);\n        }\n        return str;\n    }\n}", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n *\n * @author John Keyes (john at integralsource.com)\n */\nclass Util {\n\n    /**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str == null) {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\")) {\n            str = str.substring(1, str.length());\n        }\n        if (str.endsWith(\"\\\"\")) {\n            str = str.substring(0, str.length()-1);\n        }\n        return str;\n    }\n}"}]}
{"project": "Cli", "bug_id": 7, "classes_modified": [{"class_name": "org.apache.commons.cli2.builder.PatternBuilder", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.builder;\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.validation.ClassValidator;\nimport org.apache.commons.cli2.validation.DateValidator;\nimport org.apache.commons.cli2.validation.FileValidator;\nimport org.apache.commons.cli2.validation.NumberValidator;\nimport org.apache.commons.cli2.validation.UrlValidator;\nimport org.apache.commons.cli2.validation.Validator;\n\n/**\n * Builds Options using a String pattern\n */\n//TODO Document and link to the acceptable patterns\npublic class PatternBuilder {\n\n    private final GroupBuilder gbuilder;\n    private final DefaultOptionBuilder obuilder;\n    private final ArgumentBuilder abuilder;\n\n    /**\n     * Creates a new PatternBuilder\n     */\n    public PatternBuilder() {\n        this(\n            new GroupBuilder(),\n            new DefaultOptionBuilder(),\n            new ArgumentBuilder());\n    }\n\n    /**\n     * Creates a new PatternBuilder\n     * @param gbuilder the GroupBuilder to use\n     * @param obuilder the DefaultOptionBuilder to use\n     * @param abuilder the ArgumentBuilder to use\n     */\n    public PatternBuilder(\n        final GroupBuilder gbuilder,\n        final DefaultOptionBuilder obuilder,\n        final ArgumentBuilder abuilder) {\n        this.gbuilder = gbuilder;\n        this.obuilder = obuilder;\n        this.abuilder = abuilder;\n    }\n\n    private final Set options = new HashSet();\n\n    /**\n     * Creates a new Option instance.\n     * @return a new Option instance\n     */\n    public Option create() {\n        final Option option;\n\n        if (options.size() == 1) {\n            option = (Option)options.iterator().next();\n        }\n        else {\n            gbuilder.reset();\n            for (final Iterator i = options.iterator(); i.hasNext();) {\n                gbuilder.withOption((Option)i.next());\n            }\n            option = gbuilder.create();\n        }\n\n        reset();\n\n        return option;\n    }\n\n    /**\n     * Resets this builder\n     */\n    public PatternBuilder reset() {\n        options.clear();\n        return this;\n    }\n\n    private void createOption(\n        final char type,\n        final boolean required,\n        final char opt) {\n        final Argument argument;\n        if (type != ' ') {\n            abuilder.reset();\n            abuilder.withValidator(validator(type));\n            if (required) {\n                abuilder.withMinimum(1);\n            }\n            if (type != '*') {\n                abuilder.withMaximum(1);\n            }\n            argument = abuilder.create();\n        }\n        else {\n            argument = null;\n        }\n\n        obuilder.reset();\n        obuilder.withArgument(argument);\n        obuilder.withShortName(String.valueOf(opt));\n        obuilder.withRequired(required);\n\n        options.add(obuilder.create());\n    }\n\n    /**\n     * Builds an Option using a pattern string.\n     * @param pattern the pattern to build from\n     */\n    public void withPattern(final String pattern) {\n        int sz = pattern.length();\n\n        char opt = ' ';\n        char ch = ' ';\n        char type = ' ';\n        boolean required = false;\n\n        for (int i = 0; i < sz; i++) {\n            ch = pattern.charAt(i);\n\n            switch (ch) {\n                case '!' :\n                    required = true;\n                    break;\n                case '@' :\n                case ':' :\n                case '%' :\n                case '+' :\n                case '#' :\n                case '<' :\n                case '>' :\n                case '*' :\n                case '/' :\n                    type = ch;\n                    break;\n                default :\n                    if (opt != ' ') {\n                        createOption(type, required, opt);\n                        required = false;\n                        type = ' ';\n                    }\n\n                    opt = ch;\n            }\n        }\n\n        if (opt != ' ') {\n            createOption(type, required, opt);\n        }\n    }\n\n    private static Validator validator(final char c) {\n        switch (c) {\n            case '@' :\n                final ClassValidator classv = new ClassValidator();\n                classv.setInstance(true);\n                return classv;\n            case '+' :\n                final ClassValidator instancev = new ClassValidator();\n                return instancev;\n                //case ':':// no validator needed for a string\n            case '%' :\n                return NumberValidator.getNumberInstance();\n            case '#' :\n                return DateValidator.getDateInstance();\n            case '<' :\n                final FileValidator existingv = new FileValidator();\n                existingv.setExisting(true);\n                existingv.setFile(true);\n                return existingv;\n            case '>' :\n            case '*' :\n                return new FileValidator();\n            case '/' :\n                return new UrlValidator();\n            default :\n                return null;\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.builder;\n\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.validation.ClassValidator;\nimport org.apache.commons.cli2.validation.DateValidator;\nimport org.apache.commons.cli2.validation.FileValidator;\nimport org.apache.commons.cli2.validation.NumberValidator;\nimport org.apache.commons.cli2.validation.UrlValidator;\nimport org.apache.commons.cli2.validation.Validator;\n\n/**\n * Builds Options using a String pattern\n */\n//TODO Document and link to the acceptable patterns\npublic class PatternBuilder {\n\n    private final GroupBuilder gbuilder;\n    private final DefaultOptionBuilder obuilder;\n    private final ArgumentBuilder abuilder;\n\n    /**\n     * Creates a new PatternBuilder\n     */\n    public PatternBuilder() {\n        this(\n            new GroupBuilder(),\n            new DefaultOptionBuilder(),\n            new ArgumentBuilder());\n    }\n\n    /**\n     * Creates a new PatternBuilder\n     * @param gbuilder the GroupBuilder to use\n     * @param obuilder the DefaultOptionBuilder to use\n     * @param abuilder the ArgumentBuilder to use\n     */\n    public PatternBuilder(\n        final GroupBuilder gbuilder,\n        final DefaultOptionBuilder obuilder,\n        final ArgumentBuilder abuilder) {\n        this.gbuilder = gbuilder;\n        this.obuilder = obuilder;\n        this.abuilder = abuilder;\n    }\n\n    private final Set options = new LinkedHashSet();\n\n    /**\n     * Creates a new Option instance.\n     * @return a new Option instance\n     */\n    public Option create() {\n        final Option option;\n\n        if (options.size() == 1) {\n            option = (Option)options.iterator().next();\n        }\n        else {\n            gbuilder.reset();\n            for (final Iterator i = options.iterator(); i.hasNext();) {\n                gbuilder.withOption((Option)i.next());\n            }\n            option = gbuilder.create();\n        }\n\n        reset();\n\n        return option;\n    }\n\n    /**\n     * Resets this builder\n     */\n    public PatternBuilder reset() {\n        options.clear();\n        return this;\n    }\n\n    private void createOption(\n        final char type,\n        final boolean required,\n        final char opt) {\n        final Argument argument;\n        if (type != ' ') {\n            abuilder.reset();\n            abuilder.withValidator(validator(type));\n            if (required) {\n                abuilder.withMinimum(1);\n            }\n            if (type != '*') {\n                abuilder.withMaximum(1);\n            }\n            argument = abuilder.create();\n        }\n        else {\n            argument = null;\n        }\n\n        obuilder.reset();\n        obuilder.withArgument(argument);\n        obuilder.withShortName(String.valueOf(opt));\n        obuilder.withRequired(required);\n\n        options.add(obuilder.create());\n    }\n\n    /**\n     * Builds an Option using a pattern string.\n     * @param pattern the pattern to build from\n     */\n    public void withPattern(final String pattern) {\n        int sz = pattern.length();\n\n        char opt = ' ';\n        char ch = ' ';\n        char type = ' ';\n        boolean required = false;\n\n        for (int i = 0; i < sz; i++) {\n            ch = pattern.charAt(i);\n\n            switch (ch) {\n                case '!' :\n                    required = true;\n                    break;\n                case '@' :\n                case ':' :\n                case '%' :\n                case '+' :\n                case '#' :\n                case '<' :\n                case '>' :\n                case '*' :\n                case '/' :\n                    type = ch;\n                    break;\n                default :\n                    if (opt != ' ') {\n                        createOption(type, required, opt);\n                        required = false;\n                        type = ' ';\n                    }\n\n                    opt = ch;\n            }\n        }\n\n        if (opt != ' ') {\n            createOption(type, required, opt);\n        }\n    }\n\n    private static Validator validator(final char c) {\n        switch (c) {\n            case '@' :\n                final ClassValidator classv = new ClassValidator();\n                classv.setInstance(true);\n                return classv;\n            case '+' :\n                final ClassValidator instancev = new ClassValidator();\n                return instancev;\n                //case ':':// no validator needed for a string\n            case '%' :\n                return NumberValidator.getNumberInstance();\n            case '#' :\n                return DateValidator.getDateInstance();\n            case '<' :\n                final FileValidator existingv = new FileValidator();\n                existingv.setExisting(true);\n                existingv.setFile(true);\n                return existingv;\n            case '>' :\n            case '*' :\n                return new FileValidator();\n            case '/' :\n                return new UrlValidator();\n            default :\n                return null;\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 8, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n **/\npublic class HelpFormatter {\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return this.defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return this.defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return this.defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return this.defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return this.defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return this.defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return this.defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return this.defaultArgName;\n    }\n\n\n    // ------------------------------------------------------------------ Public\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, \n                          boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n                  autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n                  defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n                  footer, false);\n    }\n\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, \n                           Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n                                                                 .append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, new OptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n                     buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private static void appendOptionGroup(final StringBuffer buff, \n                                          final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, new OptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n                             String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * <p>Render the specified Options and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((startPos + width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n\n    /**\n     * <p>Return a String of padding of length <code>len</code>.</p>\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Remove the trailing whitespace from the specified String.</p>\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * <p>This class implements the <code>Comparator</code> interface\n     * for comparing Options.</p>\n     */\n    private static class OptionComparator\n        implements Comparator {\n\n        /**\n         * <p>Compares its two arguments for order. Returns a negative \n         * integer, zero, or a positive integer as the first argument \n         * is less than, equal to, or greater than the second.</p>\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         *\n         * @return a negative integer, zero, or a positive integer as \n         * the first argument is less than, equal to, or greater than the \n         * second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option)o1;\n            Option opt2 = (Option)o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n **/\npublic class HelpFormatter {\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return this.defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return this.defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return this.defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return this.defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return this.defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return this.defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return this.defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return this.defaultArgName;\n    }\n\n\n    // ------------------------------------------------------------------ Public\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, \n                          boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n                  autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n                  defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n                  footer, false);\n    }\n\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, \n                           Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n                                                                 .append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, new OptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n                     buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private static void appendOptionGroup(final StringBuffer buff, \n                                          final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, new OptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n                             String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * <p>Render the specified Options and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, new OptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((startPos + width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n\n    /**\n     * <p>Return a String of padding of length <code>len</code>.</p>\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Remove the trailing whitespace from the specified String.</p>\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * <p>This class implements the <code>Comparator</code> interface\n     * for comparing Options.</p>\n     */\n    private static class OptionComparator\n        implements Comparator {\n\n        /**\n         * <p>Compares its two arguments for order. Returns a negative \n         * integer, zero, or a positive integer as the first argument \n         * is less than, equal to, or greater than the second.</p>\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         *\n         * @return a negative integer, zero, or a positive integer as \n         * the first argument is less than, equal to, or greater than the \n         * second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option)o1;\n            Option opt2 = (Option)o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 9, "classes_modified": [{"class_name": "org.apache.commons.cli.Parser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = getOptions().getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = getOptions().getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 10, "classes_modified": [{"class_name": "org.apache.commons.cli.Parser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = options.getRequiredOptions();\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = getOptions().getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <p><code>Parser</code> creates {@link CommandLine}s.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic abstract class Parser implements CommandLineParser {\n\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions() {\n        return options;\n    }\n\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n\n    /**\n     * <p>Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse \n     * method.</p>\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, \n                                        boolean stopAtNonOption);\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments)\n                      throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties)\n        throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * <p>Parses the specified <code>arguments</code> \n     * based on the specifed {@link Options}.</p>\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @param stopAtNonOption specifies whether to stop \n     * interpreting the arguments when a non option has \n     * been encountered and to add them to the CommandLines\n     * args list.\n     *\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             boolean stopAtNonOption)\n        throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption stop parsing the arguments when the first\n     * non option is encountered.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, \n                             Properties properties, boolean stopAtNonOption)\n        throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), \n                                               arguments, \n                                               stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * <p>Sets the values of Options using the values in \n     * <code>properties</code>.</p>\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if ((opt.getValues() == null)\n                        || (opt.getValues().length == 0))\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value) \n                           || \"true\".equalsIgnoreCase(value)\n                           || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * <p>Throws a {@link MissingOptionException} if all of the\n     * required options are no present.</p>\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.substring(0, buff.length() - 2));\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the \n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter)\n        throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if ((opt.getValues() == null) && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(\"Missing argument for option:\"\n                                               + opt.getKey());\n        }\n    }\n\n    /**\n     * <p>Process the Option specified by <code>arg</code>\n     * using the values retrieved from the specfied iterator\n     * <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command \n     * line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not\n     * represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter)\n        throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" \n                                                  + arg);\n        }\n        \n        // get the option represented by arg\n        final Option opt = getOptions().getOption(arg);\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 11, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n */\npublic class HelpFormatter {\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return this.defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return this.defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return this.defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return this.defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return this.defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return this.defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return this.defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return this.defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator() \n    {\n        return this.optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator) \n    {\n        if ( comparator == null ) \n        {\n            this.optionComparator = new OptionComparator();\n        } \n        else \n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n\n    // ------------------------------------------------------------------ Public\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, \n                          boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n                  autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n                  defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n                  footer, false);\n    }\n\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, \n                           Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n                                                                 .append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator() );\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n                     buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, \n                                          final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator() );\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n                             String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * <p>Render the specified Options and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator() );\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((startPos + width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n\n    /**\n     * <p>Return a String of padding of length <code>len</code>.</p>\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Remove the trailing whitespace from the specified String.</p>\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * <p>This class implements the <code>Comparator</code> interface\n     * for comparing Options.</p>\n     */\n    private static class OptionComparator\n        implements Comparator {\n\n        /**\n         * <p>Compares its two arguments for order. Returns a negative \n         * integer, zero, or a positive integer as the first argument \n         * is less than, equal to, or greater than the second.</p>\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         *\n         * @return a negative integer, zero, or a positive integer as \n         * the first argument is less than, equal to, or greater than the \n         * second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option)o1;\n            Option opt2 = (Option)o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n */\npublic class HelpFormatter {\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return this.defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return this.defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return this.defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return this.defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return this.defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return this.defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return this.defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return this.defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator() \n    {\n        return this.optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator) \n    {\n        if ( comparator == null ) \n        {\n            this.optionComparator = new OptionComparator();\n        } \n        else \n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n\n    // ------------------------------------------------------------------ Public\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, \n                          boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.</p>\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, \n                          String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, \n                  autoUsage);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.</p>\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, \n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, \n                  defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, \n                  footer, false);\n    }\n\n\n    /**\n     * <p>Print the help for <code>options</code> with the specified\n     * command line syntax.</p>\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, \n                           Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n                                                                 .append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator() );\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n                     buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, \n                                          final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator() );\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * <p>Print the specified text to the specified PrintWriter.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, \n                             String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * <p>Render the specified Options and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, \n                                         Options options, int leftPad, \n                                         int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n        Option option;\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator() );\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix)\n                      .append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix)\n                      .append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix)\n                          .append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max)       ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos+1;\n        }\n        else if ((startPos + width) >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length())        ? (-1) : pos;\n    }\n\n    /**\n     * <p>Return a String of padding of length <code>len</code>.</p>\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Remove the trailing whitespace from the specified String.</p>\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * <p>This class implements the <code>Comparator</code> interface\n     * for comparing Options.</p>\n     */\n    private static class OptionComparator\n        implements Comparator {\n\n        /**\n         * <p>Compares its two arguments for order. Returns a negative \n         * integer, zero, or a positive integer as the first argument \n         * is less than, equal to, or greater than the second.</p>\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         *\n         * @return a negative integer, zero, or a positive integer as \n         * the first argument is less than, equal to, or greater than the \n         * second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option)o1;\n            Option opt2 = (Option)o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 12, "classes_modified": [{"class_name": "org.apache.commons.cli.GnuParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The class GnuParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class GnuParser extends Parser {\n\n    /**\n     * <p>This flatten method does so using the following rules:\n     * <ol>\n     *  <li>If an {@link Option} exists for the first character of \n     *  the <code>arguments</code> entry <b>AND</b> an {@link Option} \n     *  does not exist for the whole <code>argument</code> then\n     *  add the first character as an option to the processed tokens\n     *  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     *  <li>Otherwise just add the token to the processed tokens list.\n     *  </li>\n     * </ol>\n     * </p>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        List tokens = new ArrayList();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++)\n        {\n            String arg = arguments[i];\n\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is --foo=value or -foo=value\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++)\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The class GnuParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class GnuParser extends Parser {\n\n    /**\n     * <p>This flatten method does so using the following rules:\n     * <ol>\n     *  <li>If an {@link Option} exists for the first character of \n     *  the <code>arguments</code> entry <b>AND</b> an {@link Option} \n     *  does not exist for the whole <code>argument</code> then\n     *  add the first character as an option to the processed tokens\n     *  list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     *  <li>Otherwise just add the token to the processed tokens list.\n     *  </li>\n     * </ol>\n     * </p>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop \n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        List tokens = new ArrayList();\n\n        boolean eatTheRest = false;\n\n        for (int i = 0; i < arguments.length; i++)\n        {\n            String arg = arguments[i];\n\n            if (\"--\".equals(arg))\n            {\n                eatTheRest = true;\n                tokens.add(\"--\");\n            }\n            else if (\"-\".equals(arg))\n            {\n                tokens.add(\"-\");\n            }\n            else if (arg.startsWith(\"-\"))\n            {\n                String opt = Util.stripLeadingHyphens(arg);\n\n                if (options.hasOption(opt))\n                {\n                    tokens.add(arg);\n                }\n                else\n                {\n                    if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n                    {\n                        // the format is --foo=value or -foo=value\n                        tokens.add(arg.substring(0, arg.indexOf('='))); // --foo\n                        tokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n                    }\n                    else if (options.hasOption(arg.substring(0, 2)))\n                    {\n                        // the format is a special properties option (-Dproperty=value)\n                        tokens.add(arg.substring(0, 2)); // -D\n                        tokens.add(arg.substring(2)); // property=value\n                    }\n                    else\n                    {\n                        eatTheRest = stopAtNonOption;\n                        tokens.add(arg);\n                    }\n                }\n            }\n            else\n            {\n                tokens.add(arg);\n            }\n\n            if (eatTheRest)\n            {\n                for (i++; i < arguments.length; i++)\n                {\n                    tokens.add(arguments[i]);\n                }\n            }\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 13, "classes_modified": [{"class_name": "org.apache.commons.cli2.WriteableCommandLine", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n/**\n * A CommandLine that detected values and options can be written to.\n */\npublic interface WriteableCommandLine extends CommandLine {\n\n    /**\n     * Adds an Option to the CommandLine\n     * @param option the Option to add\n     */\n    void addOption(final Option option);\n\n    /**\n     * Adds a value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the value to add\n     */\n    void addValue(final Option option, final Object value);\n\n    /**\n     * Retrieves the Argument values specified on the command line for the\n     * specified Option, this doesn't return any values supplied\n     * programmatically as defaults.\n     *\n     * @param option the Option associated with the values\n     * @return a list of values or an empty List if none are found\n     */\n\n    /**\n     * Sets the default values for an Option in the CommandLine\n     * @param option the Option to add to\n     * @param defaultValues the defaults for the option\n     */\n    void setDefaultValues(final Option option, final List defaultValues);\n\n    /**\n     * Adds a switch value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the switch value to add\n     * @throws IllegalStateException if the switch has already been added\n     */\n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    /**\n     * Sets the default state for a Switch in the CommandLine.\n     * @param option the Option to add to\n     * @param defaultSwitch the defaults state for ths switch\n     */\n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    /**\n     * Adds a property value to a name in the CommandLine.\n     * Replaces any existing value for the property.\n     *\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final String property, final String value);\n\n    /**\n     * Detects whether the argument looks like an Option trigger\n     * @param argument the argument to test\n     * @return true if the argument looks like an Option trigger\n     */\n    boolean looksLikeOption(final String argument);\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n/**\n * A CommandLine that detected values and options can be written to.\n */\npublic interface WriteableCommandLine extends CommandLine {\n\n    /**\n     * Adds an Option to the CommandLine\n     * @param option the Option to add\n     */\n    void addOption(final Option option);\n\n    /**\n     * Adds a value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the value to add\n     */\n    void addValue(final Option option, final Object value);\n\n    /**\n     * Retrieves the Argument values specified on the command line for the\n     * specified Option, this doesn't return any values supplied\n     * programmatically as defaults.\n     *\n     * @param option the Option associated with the values\n     * @return a list of values or an empty List if none are found\n     */\n    List getUndefaultedValues(final Option option);\n\n    /**\n     * Sets the default values for an Option in the CommandLine\n     * @param option the Option to add to\n     * @param defaultValues the defaults for the option\n     */\n    void setDefaultValues(final Option option, final List defaultValues);\n\n    /**\n     * Adds a switch value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the switch value to add\n     * @throws IllegalStateException if the switch has already been added\n     */\n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    /**\n     * Sets the default state for a Switch in the CommandLine.\n     * @param option the Option to add to\n     * @param defaultSwitch the defaults state for ths switch\n     */\n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    /**\n     * Adds a property value to a name in the CommandLine.\n     * Replaces any existing value for the property.\n     *\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final String property, final String value);\n\n    /**\n     * Detects whether the argument looks like an Option trigger\n     * @param argument the argument to test\n     * @return true if the argument looks like an Option trigger\n     */\n    boolean looksLikeOption(final String argument);\n}\n"}, {"class_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          final List defaultValues) {\n        // First grab the command line values\n        List valueList = (List) values.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // Thirdly try the option's default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        // Finally use an empty list\n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }\n\n      // First grab the command line values\n\n      // Finally use an empty list\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public void addProperty(final String property,\n                            final String value) {\n        properties.setProperty(property, value);\n    }\n\n    public String getProperty(final String property,\n                              final String defaultValue) {\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties() {\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          final List defaultValues) {\n        // First grab the command line values\n        List valueList = (List) values.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // Thirdly try the option's default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n\n        // Finally use an empty list\n        if (valueList == null) {\n            valueList = Collections.EMPTY_LIST;\n        }\n\n        return valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public void addProperty(final String property,\n                            final String value) {\n        properties.setProperty(property, value);\n    }\n\n    public String getProperty(final String property,\n                              final String defaultValue) {\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties() {\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n"}, {"class_name": "org.apache.commons.cli2.option.ArgumentImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\nimport org.apache.commons.cli2.validation.InvalidArgumentException;\nimport org.apache.commons.cli2.validation.Validator;\n\n/**\n * An implementation of an Argument.\n */\npublic class ArgumentImpl\n    extends OptionImpl implements Argument {\n    private static final char NUL = '\\0';\n\n    /**\n     * The default value for the initial separator char.\n     */\n    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n\n    /**\n     * The default value for the subsequent separator char.\n     */\n    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n\n    /**\n     * The default token to indicate that remaining arguments should be consumed\n     * as values.\n     */\n    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n    private final String name;\n    private final String description;\n    private final int minimum;\n    private final int maximum;\n    private final char initialSeparator;\n    private final char subsequentSeparator;\n    private final boolean subsequentSplit;\n    private final Validator validator;\n    private final String consumeRemaining;\n    private final List defaultValues;\n    private final ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n    /**\n     * Creates a new Argument instance.\n     *\n     * @param name\n     *            The name of the argument\n     * @param description\n     *            A description of the argument\n     * @param minimum\n     *            The minimum number of values needed to be valid\n     * @param maximum\n     *            The maximum number of values allowed to be valid\n     * @param initialSeparator\n     *            The char separating option from value\n     * @param subsequentSeparator\n     *            The char separating values from each other\n     * @param validator\n     *            The object responsible for validating the values\n     * @param consumeRemaining\n     *            The String used for the \"consuming option\" group\n     * @param valueDefaults\n     *            The values to be used if none are specified.\n     * @param id\n     *            The id of the option, 0 implies automatic assignment.\n     *\n     * @see OptionImpl#OptionImpl(int,boolean)\n     */\n    public ArgumentImpl(final String name,\n                        final String description,\n                        final int minimum,\n                        final int maximum,\n                        final char initialSeparator,\n                        final char subsequentSeparator,\n                        final Validator validator,\n                        final String consumeRemaining,\n                        final List valueDefaults,\n                        final int id) {\n        super(id, false);\n\n        this.name = (name == null) ? \"arg\" : name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.initialSeparator = initialSeparator;\n        this.subsequentSeparator = subsequentSeparator;\n        this.subsequentSplit = subsequentSeparator != NUL;\n        this.validator = validator;\n        this.consumeRemaining = consumeRemaining;\n        this.defaultValues = valueDefaults;\n\n        if (minimum > maximum) {\n            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n        }\n\n        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n            if (valueDefaults.size() < minimum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n            }\n\n            if (valueDefaults.size() > maximum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n            }\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public void processValues(final WriteableCommandLine commandLine,\n                              final ListIterator arguments,\n                              final Option option)\n        throws OptionException {\n        // count of arguments processed for this option.\n        int argumentCount = 0;\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            // should we ignore things that look like options?\n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            // does it look like an option?\n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            // should we split the string up?\n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            // it must be a value as it is\n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        return true;\n    }\n\n    public Set getPrefixes() {\n        return Collections.EMPTY_SET;\n    }\n\n    public void process(WriteableCommandLine commandLine,\n                        ListIterator args)\n        throws OptionException {\n        processValues(commandLine, args, this);\n    }\n\n    public char getInitialSeparator() {\n        return this.initialSeparator;\n    }\n\n    public char getSubsequentSeparator() {\n        return this.subsequentSeparator;\n    }\n\n    public Set getTriggers() {\n        return Collections.EMPTY_SET;\n    }\n\n    public String getConsumeRemaining() {\n        return this.consumeRemaining;\n    }\n\n    public List getDefaultValues() {\n        return this.defaultValues;\n    }\n\n    public Validator getValidator() {\n        return this.validator;\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        validate(commandLine, this);\n    }\n\n    public void validate(final WriteableCommandLine commandLine,\n                         final Option option)\n        throws OptionException {\n        final List values = commandLine.getValues(option);\n\n        if (values.size() < minimum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n        }\n\n        if (values.size() > maximum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                      (String) values.get(maximum));\n        }\n\n        if (validator != null) {\n            try {\n                validator.validate(values);\n            } catch (InvalidArgumentException ive) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                          ive.getMessage());\n            }\n        }\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        // do we display the outer optionality\n        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        // allow numbering if multiple args\n        final boolean numbered =\n            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\n        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n        // if infinite args are allowed then crop the list\n        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\n        int i = 0;\n\n        // for each argument\n        while (i < max) {\n            // if we're past the first add a space\n            if (i > 0) {\n                buffer.append(' ');\n            }\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n\n            if (bracketed) {\n                buffer.append('<');\n            }\n\n            // add name\n            buffer.append(name);\n            ++i;\n\n            // if numbering\n            if (numbered) {\n                buffer.append(i);\n            }\n\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n\n        // if infinite args are allowed\n        if (maximum == Integer.MAX_VALUE) {\n            // append elipsis\n            buffer.append(\" ...\");\n        }\n\n        // for each argument\n        while (i > 0) {\n            --i;\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final HelpLine helpLine = new HelpLineImpl(this, depth);\n\n        return Collections.singletonList(helpLine);\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    /**\n     * If there are any leading or trailing quotes remove them from the\n     * specified token.\n     *\n     * @param token\n     *            the token to strip leading and trailing quotes\n     *\n     * @return String the possibly modified token\n     */\n    public String stripBoundaryQuotes(String token) {\n        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n            return token;\n        }\n\n        token = token.substring(1, token.length() - 1);\n\n        return token;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n        defaultValues(commandLine, this);\n    }\n\n    public void defaultValues(final WriteableCommandLine commandLine,\n                              final Option option) {\n        commandLine.setDefaultValues(option, defaultValues);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\nimport org.apache.commons.cli2.validation.InvalidArgumentException;\nimport org.apache.commons.cli2.validation.Validator;\n\n/**\n * An implementation of an Argument.\n */\npublic class ArgumentImpl\n    extends OptionImpl implements Argument {\n    private static final char NUL = '\\0';\n\n    /**\n     * The default value for the initial separator char.\n     */\n    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n\n    /**\n     * The default value for the subsequent separator char.\n     */\n    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n\n    /**\n     * The default token to indicate that remaining arguments should be consumed\n     * as values.\n     */\n    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n    private final String name;\n    private final String description;\n    private final int minimum;\n    private final int maximum;\n    private final char initialSeparator;\n    private final char subsequentSeparator;\n    private final boolean subsequentSplit;\n    private final Validator validator;\n    private final String consumeRemaining;\n    private final List defaultValues;\n    private final ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n    /**\n     * Creates a new Argument instance.\n     *\n     * @param name\n     *            The name of the argument\n     * @param description\n     *            A description of the argument\n     * @param minimum\n     *            The minimum number of values needed to be valid\n     * @param maximum\n     *            The maximum number of values allowed to be valid\n     * @param initialSeparator\n     *            The char separating option from value\n     * @param subsequentSeparator\n     *            The char separating values from each other\n     * @param validator\n     *            The object responsible for validating the values\n     * @param consumeRemaining\n     *            The String used for the \"consuming option\" group\n     * @param valueDefaults\n     *            The values to be used if none are specified.\n     * @param id\n     *            The id of the option, 0 implies automatic assignment.\n     *\n     * @see OptionImpl#OptionImpl(int,boolean)\n     */\n    public ArgumentImpl(final String name,\n                        final String description,\n                        final int minimum,\n                        final int maximum,\n                        final char initialSeparator,\n                        final char subsequentSeparator,\n                        final Validator validator,\n                        final String consumeRemaining,\n                        final List valueDefaults,\n                        final int id) {\n        super(id, false);\n\n        this.name = (name == null) ? \"arg\" : name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.initialSeparator = initialSeparator;\n        this.subsequentSeparator = subsequentSeparator;\n        this.subsequentSplit = subsequentSeparator != NUL;\n        this.validator = validator;\n        this.consumeRemaining = consumeRemaining;\n        this.defaultValues = valueDefaults;\n\n        if (minimum > maximum) {\n            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n        }\n\n        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n            if (valueDefaults.size() < minimum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n            }\n\n            if (valueDefaults.size() > maximum) {\n                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n            }\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public void processValues(final WriteableCommandLine commandLine,\n                              final ListIterator arguments,\n                              final Option option)\n        throws OptionException {\n        // count of arguments processed for this option.\n        int argumentCount = commandLine.getUndefaultedValues(option).size();\n\n        while (arguments.hasNext() && (argumentCount < maximum)) {\n            final String allValuesQuoted = (String) arguments.next();\n            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n            // should we ignore things that look like options?\n            if (allValuesQuoted.equals(consumeRemaining)) {\n                while (arguments.hasNext() && (argumentCount < maximum)) {\n                    ++argumentCount;\n                    commandLine.addValue(option, arguments.next());\n                }\n            }\n            // does it look like an option?\n            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n                arguments.previous();\n\n                break;\n            }\n            // should we split the string up?\n            else if (subsequentSplit) {\n                final StringTokenizer values =\n                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\n                arguments.remove();\n\n                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n                    ++argumentCount;\n\n                    final String token = values.nextToken();\n                    commandLine.addValue(option, token);\n                    arguments.add(token);\n                }\n\n                if (values.hasMoreTokens()) {\n                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                              values.nextToken());\n                }\n            }\n            // it must be a value as it is\n            else {\n                ++argumentCount;\n                commandLine.addValue(option, allValues);\n            }\n        }\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        return true;\n    }\n\n    public Set getPrefixes() {\n        return Collections.EMPTY_SET;\n    }\n\n    public void process(WriteableCommandLine commandLine,\n                        ListIterator args)\n        throws OptionException {\n        processValues(commandLine, args, this);\n    }\n\n    public char getInitialSeparator() {\n        return this.initialSeparator;\n    }\n\n    public char getSubsequentSeparator() {\n        return this.subsequentSeparator;\n    }\n\n    public Set getTriggers() {\n        return Collections.EMPTY_SET;\n    }\n\n    public String getConsumeRemaining() {\n        return this.consumeRemaining;\n    }\n\n    public List getDefaultValues() {\n        return this.defaultValues;\n    }\n\n    public Validator getValidator() {\n        return this.validator;\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        validate(commandLine, this);\n    }\n\n    public void validate(final WriteableCommandLine commandLine,\n                         final Option option)\n        throws OptionException {\n        final List values = commandLine.getValues(option);\n\n        if (values.size() < minimum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n        }\n\n        if (values.size() > maximum) {\n            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                      (String) values.get(maximum));\n        }\n\n        if (validator != null) {\n            try {\n                validator.validate(values);\n            } catch (InvalidArgumentException ive) {\n                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n                                          ive.getMessage());\n            }\n        }\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        // do we display the outer optionality\n        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        // allow numbering if multiple args\n        final boolean numbered =\n            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\n        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n        // if infinite args are allowed then crop the list\n        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\n        int i = 0;\n\n        // for each argument\n        while (i < max) {\n            // if we're past the first add a space\n            if (i > 0) {\n                buffer.append(' ');\n            }\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append('[');\n            }\n\n            if (bracketed) {\n                buffer.append('<');\n            }\n\n            // add name\n            buffer.append(name);\n            ++i;\n\n            // if numbering\n            if (numbered) {\n                buffer.append(i);\n            }\n\n            if (bracketed) {\n                buffer.append('>');\n            }\n        }\n\n        // if infinite args are allowed\n        if (maximum == Integer.MAX_VALUE) {\n            // append elipsis\n            buffer.append(\" ...\");\n        }\n\n        // for each argument\n        while (i > 0) {\n            --i;\n\n            // if the next arg is optional\n            if ((i >= minimum) && (optional || (i > 0))) {\n                buffer.append(']');\n            }\n        }\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final HelpLine helpLine = new HelpLineImpl(this, depth);\n\n        return Collections.singletonList(helpLine);\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    /**\n     * If there are any leading or trailing quotes remove them from the\n     * specified token.\n     *\n     * @param token\n     *            the token to strip leading and trailing quotes\n     *\n     * @return String the possibly modified token\n     */\n    public String stripBoundaryQuotes(String token) {\n        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n            return token;\n        }\n\n        token = token.substring(1, token.length() - 1);\n\n        return token;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n        defaultValues(commandLine, this);\n    }\n\n    public void defaultValues(final WriteableCommandLine commandLine,\n                              final Option option) {\n        commandLine.setDefaultValues(option, defaultValues);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 14, "classes_modified": [{"class_name": "org.apache.commons.cli2.option.GroupImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 15, "classes_modified": [{"class_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // augment the list with the default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n                // if there are more default values as specified, add them to\n                // the list.\n                    // copy the list first\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 16, "classes_modified": [{"class_name": "org.apache.commons.cli2.Option", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\n/**\n * The super type of all options representing a particular element of the\n * command line interface.\n */\npublic interface Option {\n\n    /**\n     * Processes String arguments into a CommandLine.\n     *\n     * The iterator will initially point at the first argument to be processed\n     * and at the end of the method should point to the first argument not\n     * processed. This method MUST process at least one argument from the\n     * ListIterator.\n     *\n     * @param commandLine\n     *            The CommandLine object to store results in\n     * @param args\n     *            The arguments to process\n     * @throws OptionException\n     *             if any problems occur\n     */\n    void process(\n        final WriteableCommandLine commandLine,\n        final ListIterator args)\n        throws OptionException;\n\n    /**\n     * Adds defaults to a CommandLine.\n     *\n     * Any defaults for this option are applied as well as the defaults for\n     * any contained options\n     *\n     * @param commandLine\n     *            The CommandLine object to store defaults in\n     */\n    void defaults(final WriteableCommandLine commandLine);\n\n    /**\n     * Indicates whether this Option will be able to process the particular\n     * argument.\n     *\n     * @param argument\n     *            The argument to be tested\n     * @return true if the argument can be processed by this Option\n     */\n    boolean canProcess(final WriteableCommandLine commandLine, final String argument);\n\n    /**\n     * Indicates whether this Option will be able to process the particular\n     * argument. The ListIterator must be restored to the initial state before\n     * returning the boolean.\n     *\n     * @see #canProcess(WriteableCommandLine,String)\n     * @param arguments\n     *            the ListIterator over String arguments\n     * @return true if the argument can be processed by this Option\n     */\n    boolean canProcess(final WriteableCommandLine commandLine, final ListIterator arguments);\n\n    /**\n     * Identifies the argument prefixes that should trigger this option. This\n     * is used to decide which of many Options should be tried when processing\n     * a given argument string.\n     *\n     * The returned Set must not be null.\n     *\n     * @return The set of triggers for this Option\n     */\n    Set getTriggers();\n\n    /**\n     * Identifies the argument prefixes that should be considered options. This\n     * is used to identify whether a given string looks like an option or an\n     * argument value. Typically an option would return the set [--,-] while\n     * switches might offer [-,+].\n     *\n     * The returned Set must not be null.\n     *\n     * @return The set of prefixes for this Option\n     */\n    Set getPrefixes();\n\n    /**\n     * Checks that the supplied CommandLine is valid with respect to this\n     * option.\n     *\n     * @param commandLine\n     *            The CommandLine to check.\n     * @throws OptionException\n     *             if the CommandLine is not valid.\n     */\n    void validate(final WriteableCommandLine commandLine)\n        throws OptionException;\n\n    /**\n     * Builds up a list of HelpLineImpl instances to be presented by HelpFormatter.\n     *\n     * @see HelpLine\n     * @see org.apache.commons.cli2.util.HelpFormatter\n     * @param depth\n     *            the initial indent depth\n     * @param helpSettings\n     *            the HelpSettings that should be applied\n     * @param comp\n     *            a comparator used to sort options when applicable.\n     * @return a List of HelpLineImpl objects\n     */\n    List helpLines(\n        final int depth,\n        final Set helpSettings,\n        final Comparator comp);\n\n    /**\n     * Appends usage information to the specified StringBuffer\n     *\n     * @param buffer the buffer to append to\n     * @param helpSettings a set of display settings @see DisplaySetting\n     * @param comp a comparator used to sort the Options\n     */\n    void appendUsage(\n        final StringBuffer buffer,\n        final Set helpSettings,\n        final Comparator comp);\n\n    /**\n     * The preferred name of an option is used for generating help and usage\n     * information.\n     *\n     * @return The preferred name of the option\n     */\n    String getPreferredName();\n\n    /**\n     * Returns a description of the option. This string is used to build help\n     * messages as in the HelpFormatter.\n     *\n     * @see org.apache.commons.cli2.util.HelpFormatter\n     * @return a description of the option.\n     */\n    String getDescription();\n\n    /**\n     * Returns the id of the option.  This can be used in a loop and switch\n     * construct:\n     *\n     * <code>\n     * for(Option o : cmd.getOptions()){\n     *     switch(o.getId()){\n     *         case POTENTIAL_OPTION:\n     *             ...\n     *     }\n     * }\n     * </code>\n     *\n     * The returned value is not guarenteed to be unique.\n     *\n     * @return the id of the option.\n     */\n    int getId();\n\n    /**\n     * Recursively searches for an option with the supplied trigger.\n     *\n     * @param trigger the trigger to search for.\n     * @return the matching option or null.\n     */\n    Option findOption(final String trigger);\n\n    /**\n     * Indicates whether this option is required to be present.\n     * @return true iff the CommandLine will be invalid without this Option\n     */\n    boolean isRequired();\n\n    /**\n     * Returns the parent of this option. Options can be organized in a\n     * hierarchical manner if they are added to groups. This method can be used\n     * for obtaining the parent option of this option. The result may be\n     * <b>null</b> if this option does not have a parent.\n     *\n     * @return the parent of this option\n     */\n\n    /**\n     * Sets the parent of this option. This method is called when the option is\n     * added to a group. Storing the parent of an option makes it possible to\n     * keep track of hierarchical relations between options. For instance, if an\n     * option is identified while parsing a command line, the group this option\n     * belongs to can also be added to the command line.\n     *\n     * @param parent the parent option\n     */\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\n/**\n * The super type of all options representing a particular element of the\n * command line interface.\n */\npublic interface Option {\n\n    /**\n     * Processes String arguments into a CommandLine.\n     *\n     * The iterator will initially point at the first argument to be processed\n     * and at the end of the method should point to the first argument not\n     * processed. This method MUST process at least one argument from the\n     * ListIterator.\n     *\n     * @param commandLine\n     *            The CommandLine object to store results in\n     * @param args\n     *            The arguments to process\n     * @throws OptionException\n     *             if any problems occur\n     */\n    void process(\n        final WriteableCommandLine commandLine,\n        final ListIterator args)\n        throws OptionException;\n\n    /**\n     * Adds defaults to a CommandLine.\n     *\n     * Any defaults for this option are applied as well as the defaults for\n     * any contained options\n     *\n     * @param commandLine\n     *            The CommandLine object to store defaults in\n     */\n    void defaults(final WriteableCommandLine commandLine);\n\n    /**\n     * Indicates whether this Option will be able to process the particular\n     * argument.\n     *\n     * @param argument\n     *            The argument to be tested\n     * @return true if the argument can be processed by this Option\n     */\n    boolean canProcess(final WriteableCommandLine commandLine, final String argument);\n\n    /**\n     * Indicates whether this Option will be able to process the particular\n     * argument. The ListIterator must be restored to the initial state before\n     * returning the boolean.\n     *\n     * @see #canProcess(WriteableCommandLine,String)\n     * @param arguments\n     *            the ListIterator over String arguments\n     * @return true if the argument can be processed by this Option\n     */\n    boolean canProcess(final WriteableCommandLine commandLine, final ListIterator arguments);\n\n    /**\n     * Identifies the argument prefixes that should trigger this option. This\n     * is used to decide which of many Options should be tried when processing\n     * a given argument string.\n     *\n     * The returned Set must not be null.\n     *\n     * @return The set of triggers for this Option\n     */\n    Set getTriggers();\n\n    /**\n     * Identifies the argument prefixes that should be considered options. This\n     * is used to identify whether a given string looks like an option or an\n     * argument value. Typically an option would return the set [--,-] while\n     * switches might offer [-,+].\n     *\n     * The returned Set must not be null.\n     *\n     * @return The set of prefixes for this Option\n     */\n    Set getPrefixes();\n\n    /**\n     * Checks that the supplied CommandLine is valid with respect to this\n     * option.\n     *\n     * @param commandLine\n     *            The CommandLine to check.\n     * @throws OptionException\n     *             if the CommandLine is not valid.\n     */\n    void validate(final WriteableCommandLine commandLine)\n        throws OptionException;\n\n    /**\n     * Builds up a list of HelpLineImpl instances to be presented by HelpFormatter.\n     *\n     * @see HelpLine\n     * @see org.apache.commons.cli2.util.HelpFormatter\n     * @param depth\n     *            the initial indent depth\n     * @param helpSettings\n     *            the HelpSettings that should be applied\n     * @param comp\n     *            a comparator used to sort options when applicable.\n     * @return a List of HelpLineImpl objects\n     */\n    List helpLines(\n        final int depth,\n        final Set helpSettings,\n        final Comparator comp);\n\n    /**\n     * Appends usage information to the specified StringBuffer\n     *\n     * @param buffer the buffer to append to\n     * @param helpSettings a set of display settings @see DisplaySetting\n     * @param comp a comparator used to sort the Options\n     */\n    void appendUsage(\n        final StringBuffer buffer,\n        final Set helpSettings,\n        final Comparator comp);\n\n    /**\n     * The preferred name of an option is used for generating help and usage\n     * information.\n     *\n     * @return The preferred name of the option\n     */\n    String getPreferredName();\n\n    /**\n     * Returns a description of the option. This string is used to build help\n     * messages as in the HelpFormatter.\n     *\n     * @see org.apache.commons.cli2.util.HelpFormatter\n     * @return a description of the option.\n     */\n    String getDescription();\n\n    /**\n     * Returns the id of the option.  This can be used in a loop and switch\n     * construct:\n     *\n     * <code>\n     * for(Option o : cmd.getOptions()){\n     *     switch(o.getId()){\n     *         case POTENTIAL_OPTION:\n     *             ...\n     *     }\n     * }\n     * </code>\n     *\n     * The returned value is not guarenteed to be unique.\n     *\n     * @return the id of the option.\n     */\n    int getId();\n\n    /**\n     * Recursively searches for an option with the supplied trigger.\n     *\n     * @param trigger the trigger to search for.\n     * @return the matching option or null.\n     */\n    Option findOption(final String trigger);\n\n    /**\n     * Indicates whether this option is required to be present.\n     * @return true iff the CommandLine will be invalid without this Option\n     */\n    boolean isRequired();\n\n    /**\n     * Returns the parent of this option. Options can be organized in a\n     * hierarchical manner if they are added to groups. This method can be used\n     * for obtaining the parent option of this option. The result may be\n     * <b>null</b> if this option does not have a parent.\n     *\n     * @return the parent of this option\n     */\n    Option getParent();\n\n    /**\n     * Sets the parent of this option. This method is called when the option is\n     * added to a group. Storing the parent of an option makes it possible to\n     * keep track of hierarchical relations between options. For instance, if an\n     * option is identified while parsing a command line, the group this option\n     * belongs to can also be added to the command line.\n     *\n     * @param parent the parent option\n     */\n    void setParent(Option parent);\n}\n"}, {"class_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n        Option parent = option.getParent();\n        while (parent != null && !options.contains(parent)) {\n            options.add(parent);\n            parent = parent.getParent();\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    public boolean looksLikeOption(final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            final String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n"}, {"class_name": "org.apache.commons.cli2.option.GroupImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum) {\n        super(0, false);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.setParent(this);\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (commandLine.looksLikeOption(arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (commandLine.looksLikeOption(arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional =\n            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    public boolean isRequired() {\n        return getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n"}, {"class_name": "org.apache.commons.cli2.option.OptionImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A base implementation of Option providing limited ground work for further\n * Option implementations.\n */\npublic abstract class OptionImpl implements Option {\n    private final int id;\n    private final boolean required;\n\n    /**\n     * Creates an OptionImpl with the specified id\n     * @param id the unique id of this Option\n     * @param required true iff this Option must be present\n     */\n    public OptionImpl(final int id,\n                      final boolean required) {\n        this.id = id;\n        this.required = required;\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final ListIterator arguments) {\n        if (arguments.hasNext()) {\n            final String argument = (String) arguments.next();\n            arguments.previous();\n\n            return canProcess(commandLine, argument);\n        } else {\n            return false;\n        }\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n        appendUsage(buffer, DisplaySetting.ALL, null);\n\n        return buffer.toString();\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public boolean equals(final Object thatObj) {\n        if (thatObj instanceof OptionImpl) {\n            final OptionImpl that = (OptionImpl) thatObj;\n\n            return (getId() == that.getId()) &&\n                   equals(getPreferredName(), that.getPreferredName()) &&\n                   equals(getDescription(), that.getDescription()) &&\n                   equals(getPrefixes(), that.getPrefixes()) &&\n                   equals(getTriggers(), that.getTriggers());\n        } else {\n            return false;\n        }\n    }\n\n    private boolean equals(Object left,\n                           Object right) {\n        if ((left == null) && (right == null)) {\n            return true;\n        } else if ((left == null) || (right == null)) {\n            return false;\n        } else {\n            return left.equals(right);\n        }\n    }\n\n    public int hashCode() {\n        int hashCode = getId();\n        if (getPreferredName() != null) {\n            hashCode = (hashCode * 37) + getPreferredName().hashCode();\n        }\n\n        if (getDescription() != null) {\n            hashCode = (hashCode * 37) + getDescription().hashCode();\n        }\n\n        hashCode = (hashCode * 37) + getPrefixes().hashCode();\n        hashCode = (hashCode * 37) + getTriggers().hashCode();\n\n        return hashCode;\n    }\n\n    public Option findOption(String trigger) {\n        if (getTriggers().contains(trigger)) {\n            return this;\n        } else {\n            return null;\n        }\n    }\n\n    public boolean isRequired() {\n        return required;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        // nothing to do normally\n    }\n\n\n\n    protected void checkPrefixes(final Set prefixes) {\n        // nothing to do if empty prefix list\n        if (prefixes.isEmpty()) {\n            return;\n        }\n\n        // check preferred name\n        checkPrefix(prefixes, getPreferredName());\n\n        // check triggers\n        this.getTriggers();\n\n        for (final Iterator i = getTriggers().iterator(); i.hasNext();) {\n            checkPrefix(prefixes, (String) i.next());\n        }\n    }\n\n    private void checkPrefix(final Set prefixes,\n                             final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return;\n            }\n        }\n\n        final ResourceHelper helper = ResourceHelper.getResourceHelper();\n        final String message =\n            helper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\n                              prefixes.toString());\n        throw new IllegalArgumentException(message);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.Iterator;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A base implementation of Option providing limited ground work for further\n * Option implementations.\n */\npublic abstract class OptionImpl implements Option {\n    private final int id;\n    private final boolean required;\n    private Option parent;\n\n    /**\n     * Creates an OptionImpl with the specified id\n     * @param id the unique id of this Option\n     * @param required true iff this Option must be present\n     */\n    public OptionImpl(final int id,\n                      final boolean required) {\n        this.id = id;\n        this.required = required;\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final ListIterator arguments) {\n        if (arguments.hasNext()) {\n            final String argument = (String) arguments.next();\n            arguments.previous();\n\n            return canProcess(commandLine, argument);\n        } else {\n            return false;\n        }\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n        appendUsage(buffer, DisplaySetting.ALL, null);\n\n        return buffer.toString();\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public boolean equals(final Object thatObj) {\n        if (thatObj instanceof OptionImpl) {\n            final OptionImpl that = (OptionImpl) thatObj;\n\n            return (getId() == that.getId()) &&\n                   equals(getPreferredName(), that.getPreferredName()) &&\n                   equals(getDescription(), that.getDescription()) &&\n                   equals(getPrefixes(), that.getPrefixes()) &&\n                   equals(getTriggers(), that.getTriggers());\n        } else {\n            return false;\n        }\n    }\n\n    private boolean equals(Object left,\n                           Object right) {\n        if ((left == null) && (right == null)) {\n            return true;\n        } else if ((left == null) || (right == null)) {\n            return false;\n        } else {\n            return left.equals(right);\n        }\n    }\n\n    public int hashCode() {\n        int hashCode = getId();\n        if (getPreferredName() != null) {\n            hashCode = (hashCode * 37) + getPreferredName().hashCode();\n        }\n\n        if (getDescription() != null) {\n            hashCode = (hashCode * 37) + getDescription().hashCode();\n        }\n\n        hashCode = (hashCode * 37) + getPrefixes().hashCode();\n        hashCode = (hashCode * 37) + getTriggers().hashCode();\n\n        return hashCode;\n    }\n\n    public Option findOption(String trigger) {\n        if (getTriggers().contains(trigger)) {\n            return this;\n        } else {\n            return null;\n        }\n    }\n\n    public boolean isRequired() {\n        return required;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        // nothing to do normally\n    }\n\n    public Option getParent() {\n        return parent;\n    }\n\n    public void setParent(Option parent) {\n        this.parent = parent;\n    }\n\n    protected void checkPrefixes(final Set prefixes) {\n        // nothing to do if empty prefix list\n        if (prefixes.isEmpty()) {\n            return;\n        }\n\n        // check preferred name\n        checkPrefix(prefixes, getPreferredName());\n\n        // check triggers\n        this.getTriggers();\n\n        for (final Iterator i = getTriggers().iterator(); i.hasNext();) {\n            checkPrefix(prefixes, (String) i.next());\n        }\n    }\n\n    private void checkPrefix(final Set prefixes,\n                             final String trigger) {\n        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n            String prefix = (String) i.next();\n\n            if (trigger.startsWith(prefix)) {\n                return;\n            }\n        }\n\n        final ResourceHelper helper = ResourceHelper.getResourceHelper();\n        final String message =\n            helper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\n                              prefixes.toString());\n        throw new IllegalArgumentException(message);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 17, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * If it is a hyphen then add the hyphen directly to\n     * the processed tokens list.\n     *\n     * @param hyphen The hyphen token\n     */\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (this.options.hasOption(token))\n        {\n            currentOption = this.options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 18, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n    private void processSingleHyphen(String hyphen)\n    {\n        tokens.add(hyphen);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n            tokens.add(token);\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 19, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n            tokens.add(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n            tokens.add(token);\n        }\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 20, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the \n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @see Parser\n * @version $Revision$\n */\npublic class PosixParser extends Parser {\n\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries, set <code>eatTheRest</code>\n     * to false and set <code>currentOption</code> to null.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n        currentOption = null;\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt) && stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(opt);\n                    if (pos != -1) {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * <p>If there is a current option and it can have an argument\n     * value then add the token to the processed tokens list and \n     * set the current option to null.</p>\n     *\n     * <p>If there is a current option and it can have argument\n     * values then add the token to the processed tokens list.</p>\n     *\n     * <p>If there is not a current option add the special token\n     * \"<b>--</b>\" and the current <code>value</code> to the processed\n     * tokens list.  The add all the remaining <code>argument</code>\n     * values to the processed tokens list.</p>\n     *\n     * @param value The current token\n     */\n    private void process(String value)\n    {\n        if (currentOption != null && currentOption.hasArg())\n        {\n            if (currentOption.hasArg())\n            {\n                tokens.add(value);\n                currentOption = null;\n            }\n            else if (currentOption.hasArgs())\n            {\n                tokens.add(value);\n            }\n        }\n        else\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n            tokens.add(value);\n        }\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * set the current option and add the token to the processed \n     * list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then ignore the current token and add the remaining tokens\n     * to the processed tokens list directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        tokens.add(token);\n    }\n\n    /**\n     * <p>Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there \n     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 21, "classes_modified": [{"class_name": "org.apache.commons.cli2.WriteableCommandLine", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n/**\n * A CommandLine that detected values and options can be written to.\n */\npublic interface WriteableCommandLine extends CommandLine {\n\n    /**\n     * Adds an Option to the CommandLine\n     * @param option the Option to add\n     */\n    void addOption(final Option option);\n\n    /**\n     * Adds a value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the value to add\n     */\n    void addValue(final Option option, final Object value);\n\n    /**\n     * Retrieves the Argument values specified on the command line for the\n     * specified Option, this doesn't return any values supplied\n     * programmatically as defaults.\n     *\n     * @param option the Option associated with the values\n     * @return a list of values or an empty List if none are found\n     */\n    List getUndefaultedValues(final Option option);\n\n    /**\n     * Sets the default values for an Option in the CommandLine\n     * @param option the Option to add to\n     * @param defaultValues the defaults for the option\n     */\n    void setDefaultValues(final Option option, final List defaultValues);\n\n    /**\n     * Adds a switch value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the switch value to add\n     * @throws IllegalStateException if the switch has already been added\n     */\n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    /**\n     * Sets the default state for a Switch in the CommandLine.\n     * @param option the Option to add to\n     * @param defaultSwitch the defaults state for ths switch\n     */\n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    /**\n     * Adds a property value to a name in the CommandLine.\n     * Replaces any existing value for the property.\n     *\n     * @param option the Option to add to\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final Option option, final String property, final String value);\n\n    /**\n     * Adds a property value to the default property set.\n     * Replaces any existing value for the property.\n     *\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final String property, final String value);\n\n    /**\n     * Detects whether the argument looks like an Option trigger\n     * @param argument the argument to test\n     * @return true if the argument looks like an Option trigger\n     */\n    boolean looksLikeOption(final String argument);\n\n    /**\n     * Returns the option that is currently processed.\n     *\n     * @return the current option\n     */\n\n    /**\n     * Sets the current option. This method is called by concrete option\n     * implementations during command line processing. It enables the command\n     * line to keep track about the option that is currently processed.\n     *\n     * @param currentOption the new current option\n     */\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2;\n\nimport java.util.List;\n\n/**\n * A CommandLine that detected values and options can be written to.\n */\npublic interface WriteableCommandLine extends CommandLine {\n\n    /**\n     * Adds an Option to the CommandLine\n     * @param option the Option to add\n     */\n    void addOption(final Option option);\n\n    /**\n     * Adds a value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the value to add\n     */\n    void addValue(final Option option, final Object value);\n\n    /**\n     * Retrieves the Argument values specified on the command line for the\n     * specified Option, this doesn't return any values supplied\n     * programmatically as defaults.\n     *\n     * @param option the Option associated with the values\n     * @return a list of values or an empty List if none are found\n     */\n    List getUndefaultedValues(final Option option);\n\n    /**\n     * Sets the default values for an Option in the CommandLine\n     * @param option the Option to add to\n     * @param defaultValues the defaults for the option\n     */\n    void setDefaultValues(final Option option, final List defaultValues);\n\n    /**\n     * Adds a switch value to an Option in the CommandLine.\n     * @param option the Option to add to\n     * @param value the switch value to add\n     * @throws IllegalStateException if the switch has already been added\n     */\n    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n\n    /**\n     * Sets the default state for a Switch in the CommandLine.\n     * @param option the Option to add to\n     * @param defaultSwitch the defaults state for ths switch\n     */\n    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n\n    /**\n     * Adds a property value to a name in the CommandLine.\n     * Replaces any existing value for the property.\n     *\n     * @param option the Option to add to\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final Option option, final String property, final String value);\n\n    /**\n     * Adds a property value to the default property set.\n     * Replaces any existing value for the property.\n     *\n     * @param property the name of the property\n     * @param value the value of the property\n     */\n    void addProperty(final String property, final String value);\n\n    /**\n     * Detects whether the argument looks like an Option trigger\n     * @param argument the argument to test\n     * @return true if the argument looks like an Option trigger\n     */\n    boolean looksLikeOption(final String argument);\n\n    /**\n     * Returns the option that is currently processed.\n     *\n     * @return the current option\n     */\n    Option getCurrentOption();\n\n    /**\n     * Sets the current option. This method is called by concrete option\n     * implementations during command line processing. It enables the command\n     * line to keep track about the option that is currently processed.\n     *\n     * @param currentOption the new current option\n     */\n    void setCurrentOption(Option currentOption);\n}\n"}, {"class_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n    }\n\n\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n        Option parent = option.getParent();\n        while (parent != null && !options.contains(parent)) {\n            options.add(parent);\n            parent = parent.getParent();\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n\n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    /**\n     * Tests whether the passed in trigger looks like an option. This\n     * implementation first checks whether the passed in string starts with a\n     * prefix that indicates an option. If this is the case, it is also checked\n     * whether an option of this name is known for the current option. (This can\n     * lead to reentrant invocations of this method, so care has to be taken\n     * about this.)\n     *\n     * @param trigger the command line element to test\n     * @return a flag whether this element seems to be an option\n     */\n    public boolean looksLikeOption(final String trigger)\n    {\n            // this is a reentrant call\n\n            for (final Iterator i = prefixes.iterator(); i.hasNext();)\n            {\n                final String prefix = (String) i.next();\n\n                if (trigger.startsWith(prefix))\n                {\n                        return true;\n                }\n            }\n            return false;\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.commandline;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.option.PropertyOption;\nimport org.apache.commons.cli2.resource.ResourceConstants;\nimport org.apache.commons.cli2.resource.ResourceHelper;\n\n/**\n * A WriteableCommandLine implementation allowing Options to write their\n * processed information to a CommandLine.\n */\npublic class WriteableCommandLineImpl\n    extends CommandLineImpl implements WriteableCommandLine {\n    private final Map optionToProperties = new HashMap();\n//    private final Properties properties = new Properties();\n    private final List options = new ArrayList();\n    private final Map nameToOption = new HashMap();\n    private final Map values = new HashMap();\n    private final Map switches = new HashMap();\n    private final Map defaultValues = new HashMap();\n    private final Map defaultSwitches = new HashMap();\n    private final List normalised;\n    private final Set prefixes;\n    private Option currentOption;\n    private String checkForOption;\n\n    /**\n     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n     * hold the parsed arguments.\n     *\n     * @param rootOption the CommandLine's root Option\n     * @param arguments the arguments this CommandLine represents\n     */\n    public WriteableCommandLineImpl(final Option rootOption,\n                                    final List arguments) {\n        this.prefixes = rootOption.getPrefixes();\n        this.normalised = arguments;\n        setCurrentOption(rootOption);\n    }\n\n    public Option getCurrentOption() {\n        return currentOption;\n    }\n\n    public void setCurrentOption(Option currentOption) {\n        this.currentOption = currentOption;\n    }\n\n    public void addOption(Option option) {\n        options.add(option);\n        nameToOption.put(option.getPreferredName(), option);\n\n        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n            nameToOption.put(i.next(), option);\n        }\n\n        // ensure that all parent options are also added\n        Option parent = option.getParent();\n        while (parent != null && !options.contains(parent)) {\n            options.add(parent);\n            parent = parent.getParent();\n        }\n    }\n\n    public void addValue(final Option option,\n                         final Object value) {\n        if (option instanceof Argument) {\n            addOption(option);\n        }\n\n        List valueList = (List) values.get(option);\n\n        if (valueList == null) {\n            valueList = new ArrayList();\n            values.put(option, valueList);\n        }\n\n        valueList.add(value);\n    }\n\n    public void addSwitch(final Option option,\n                          final boolean value) {\n        addOption(option);\n\n        if (switches.containsKey(option)) {\n            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n        } else {\n            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n        }\n    }\n\n    public boolean hasOption(final Option option) {\n        final boolean present = options.contains(option);\n\n        return present;\n    }\n\n    public Option getOption(final String trigger) {\n        return (Option) nameToOption.get(trigger);\n    }\n\n    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if (defaultValues == null || defaultValues.isEmpty()) {\n            defaultValues = (List) this.defaultValues.get(option);\n        }\n\n        // augment the list with the default values\n        if (defaultValues != null && !defaultValues.isEmpty()) {\n            if (valueList == null || valueList.isEmpty()) {\n                valueList = defaultValues;\n            } else {\n                // if there are more default values as specified, add them to\n                // the list.\n                if (defaultValues.size() > valueList.size()) {\n                    // copy the list first\n                    valueList = new ArrayList(valueList);\n                    for (int i=valueList.size(); i<defaultValues.size(); i++) {\n                        valueList.add(defaultValues.get(i));\n                    }\n                }\n            }\n        }\n\n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }\n\n    public List getUndefaultedValues(Option option) {\n      // First grab the command line values\n      List valueList = (List) values.get(option);\n\n      // Finally use an empty list\n      if (valueList == null) {\n        valueList = Collections.EMPTY_LIST;\n      }\n\n      return valueList;\n    }\n\n    public Boolean getSwitch(final Option option,\n                             final Boolean defaultValue) {\n        // First grab the command line values\n        Boolean bool = (Boolean) switches.get(option);\n\n        // Secondly try the defaults supplied to the method\n        if (bool == null) {\n            bool = defaultValue;\n        }\n\n        // Thirdly try the option's default values\n        if (bool == null) {\n            bool = (Boolean) this.defaultSwitches.get(option);\n        }\n\n        return bool;\n    }\n\n    public String getProperty(final String property) {\n        return getProperty(new PropertyOption(), property);\n    }\n\n    public void addProperty(final Option option,\n                            final String property,\n                            final String value) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            properties = new Properties();\n            optionToProperties.put(option, properties);\n        }\n        properties.setProperty(property, value);\n    }\n\n    public void addProperty(final String property, final String value) {\n        addProperty(new PropertyOption(), property, value);\n    }\n\n    public String getProperty(final Option option,\n                              final String property,\n                              final String defaultValue) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return defaultValue;\n        }\n        return properties.getProperty(property, defaultValue);\n    }\n\n    public Set getProperties(final Option option) {\n        Properties properties = (Properties) optionToProperties.get(option);\n        if (properties == null) {\n            return Collections.EMPTY_SET;\n        }\n        return Collections.unmodifiableSet(properties.keySet());\n    }\n\n    public Set getProperties() {\n        return getProperties(new PropertyOption());\n    }\n\n    /**\n     * Tests whether the passed in trigger looks like an option. This\n     * implementation first checks whether the passed in string starts with a\n     * prefix that indicates an option. If this is the case, it is also checked\n     * whether an option of this name is known for the current option. (This can\n     * lead to reentrant invocations of this method, so care has to be taken\n     * about this.)\n     *\n     * @param trigger the command line element to test\n     * @return a flag whether this element seems to be an option\n     */\n    public boolean looksLikeOption(final String trigger)\n    {\n        if (checkForOption != null)\n        {\n            // this is a reentrant call\n            return !checkForOption.equals(trigger);\n        }\n\n        checkForOption = trigger;\n        try\n        {\n            for (final Iterator i = prefixes.iterator(); i.hasNext();)\n            {\n                final String prefix = (String) i.next();\n\n                if (trigger.startsWith(prefix))\n                {\n                    if (getCurrentOption().canProcess(this, trigger)\n                            || getCurrentOption().findOption(trigger) != null)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n        finally\n        {\n            checkForOption = null;\n        }\n    }\n\n    public String toString() {\n        final StringBuffer buffer = new StringBuffer();\n\n        // need to add group header\n        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n            final String arg = (String) i.next();\n\n            if (arg.indexOf(' ') >= 0) {\n                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n            } else {\n                buffer.append(arg);\n            }\n\n            if (i.hasNext()) {\n                buffer.append(' ');\n            }\n        }\n\n        return buffer.toString();\n    }\n\n    public List getOptions() {\n        return Collections.unmodifiableList(options);\n    }\n\n    public Set getOptionTriggers() {\n        return Collections.unmodifiableSet(nameToOption.keySet());\n    }\n\n    public void setDefaultValues(final Option option,\n                                 final List defaults) {\n        if (defaults == null) {\n            defaultValues.remove(option);\n        } else {\n            defaultValues.put(option, defaults);\n        }\n    }\n\n    public void setDefaultSwitch(final Option option,\n                                 final Boolean defaultSwitch) {\n        if (defaultSwitch == null) {\n            defaultSwitches.remove(option);\n        } else {\n            defaultSwitches.put(option, defaultSwitch);\n        }\n    }\n\n    public List getNormalised() {\n        return Collections.unmodifiableList(normalised);\n    }\n}\n"}, {"class_name": "org.apache.commons.cli2.option.GroupImpl", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     * @param required a flag whether this group is required\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum,\n                     final boolean required) {\n        super(0, required);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.setParent(this);\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (looksLikeOption(commandLine, arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (looksLikeOption(commandLine, arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired();\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional = !isRequired()\n                && (helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL) ||\n                        helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL_CHILD_GROUP));\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    /**\n     * Tests whether this option is required. For groups we evaluate the\n     * <code>required</code> flag common to all options, but also take the\n     * minimum constraints into account.\n     *\n     * @return a flag whether this option is required\n     */\n    public boolean isRequired()\n    {\n        return (getParent() == null || super.isRequired()) && getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n\n    /**\n     * Helper method for testing whether an element of the command line looks\n     * like an option. This method queries the command line, but sets the\n     * current option first.\n     *\n     * @param commandLine the command line\n     * @param trigger the trigger to be checked\n     * @return a flag whether this element looks like an option\n     */\n    private boolean looksLikeOption(final WriteableCommandLine commandLine,\n            final String trigger) {\n            return commandLine.looksLikeOption(trigger);\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.cli2.option;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\nimport org.apache.commons.cli2.Argument;\nimport org.apache.commons.cli2.DisplaySetting;\nimport org.apache.commons.cli2.Group;\nimport org.apache.commons.cli2.HelpLine;\nimport org.apache.commons.cli2.Option;\nimport org.apache.commons.cli2.OptionException;\nimport org.apache.commons.cli2.WriteableCommandLine;\nimport org.apache.commons.cli2.resource.ResourceConstants;\n\n/**\n * An implementation of Group\n */\npublic class GroupImpl\n    extends OptionImpl implements Group {\n    private final String name;\n    private final String description;\n    private final List options;\n    private final int minimum;\n    private final int maximum;\n    private final List anonymous;\n    private final SortedMap optionMap;\n    private final Set prefixes;\n\n    /**\n     * Creates a new GroupImpl using the specified parameters.\n     *\n     * @param options the Options and Arguments that make up the Group\n     * @param name the name of this Group, or null\n     * @param description a description of this Group\n     * @param minimum the minimum number of Options for a valid CommandLine\n     * @param maximum the maximum number of Options for a valid CommandLine\n     * @param required a flag whether this group is required\n     */\n    public GroupImpl(final List options,\n                     final String name,\n                     final String description,\n                     final int minimum,\n                     final int maximum,\n                     final boolean required) {\n        super(0, required);\n\n        this.name = name;\n        this.description = description;\n        this.minimum = minimum;\n        this.maximum = maximum;\n\n        // store a copy of the options to be used by the\n        // help methods\n        this.options = Collections.unmodifiableList(options);\n\n        // anonymous Argument temporary storage\n        final List newAnonymous = new ArrayList();\n\n        // map (key=trigger & value=Option) temporary storage\n        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n        // prefixes temporary storage\n        final Set newPrefixes = new HashSet();\n\n        // process the options\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.setParent(this);\n\n            if (option instanceof Argument) {\n                i.remove();\n                newAnonymous.add(option);\n            } else {\n                final Set triggers = option.getTriggers();\n\n                for (Iterator j = triggers.iterator(); j.hasNext();) {\n                    newOptionMap.put(j.next(), option);\n                }\n\n                // store the prefixes\n                newPrefixes.addAll(option.getPrefixes());\n            }\n        }\n\n        this.anonymous = Collections.unmodifiableList(newAnonymous);\n        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n    }\n\n    public boolean canProcess(final WriteableCommandLine commandLine,\n                              final String arg) {\n        if (arg == null) {\n            return false;\n        }\n\n        // if arg does not require bursting\n        if (optionMap.containsKey(arg)) {\n            return true;\n        }\n\n        // filter\n        final Map tailMap = optionMap.tailMap(arg);\n\n        // check if bursting is required\n        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n            final Option option = (Option) iter.next();\n\n            if (option.canProcess(commandLine, arg)) {\n                return true;\n            }\n        }\n\n        if (looksLikeOption(commandLine, arg)) {\n            return false;\n        }\n\n        // anonymous argument(s) means we can process it\n        if (anonymous.size() > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    public Set getPrefixes() {\n        return prefixes;\n    }\n\n    public Set getTriggers() {\n        return optionMap.keySet();\n    }\n\n    public void process(final WriteableCommandLine commandLine,\n                        final ListIterator arguments)\n        throws OptionException {\n        String previous = null;\n\n        // [START process each command line token\n        while (arguments.hasNext()) {\n            // grab the next argument\n            final String arg = (String) arguments.next();\n\n            // if we have just tried to process this instance\n            if (arg == previous) {\n                // rollback and abort\n                arguments.previous();\n\n                break;\n            }\n\n            // remember last processed instance\n            previous = arg;\n\n            final Option opt = (Option) optionMap.get(arg);\n\n            // option found\n            if (opt != null) {\n                arguments.previous();\n                opt.process(commandLine, arguments);\n            }\n            // [START option NOT found\n            else {\n                // it might be an anonymous argument continue search\n                // [START argument may be anonymous\n                if (looksLikeOption(commandLine, arg)) {\n                    // narrow the search\n                    final Collection values = optionMap.tailMap(arg).values();\n\n                    boolean foundMemberOption = false;\n\n                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n                        final Option option = (Option) i.next();\n\n                        if (option.canProcess(commandLine, arg)) {\n                            foundMemberOption = true;\n                            arguments.previous();\n                            option.process(commandLine, arguments);\n                        }\n                    }\n\n                    // back track and abort this group if necessary\n                    if (!foundMemberOption) {\n                        arguments.previous();\n\n                        return;\n                    }\n                } // [END argument may be anonymous\n\n                // [START argument is NOT anonymous\n                else {\n                    // move iterator back, current value not used\n                    arguments.previous();\n\n                    // if there are no anonymous arguments then this group can't\n                    // process the argument\n                    if (anonymous.isEmpty()) {\n                        break;\n                    }\n\n                    // TODO: why do we iterate over all anonymous arguments?\n                    // canProcess will always return true?\n                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                        final Argument argument = (Argument) i.next();\n\n                        if (argument.canProcess(commandLine, arguments)) {\n                            argument.process(commandLine, arguments);\n                        }\n                    }\n                } // [END argument is NOT anonymous\n            } // [END option NOT found\n        } // [END process each command line token\n    }\n\n    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired();\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n                validate = true;\n            }\n\n            if (validate) {\n                option.validate(commandLine);\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }\n\n    public String getPreferredName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp) {\n        appendUsage(buffer, helpSettings, comp, \"|\");\n    }\n\n    public void appendUsage(final StringBuffer buffer,\n                            final Set helpSettings,\n                            final Comparator comp,\n                            final String separator) {\n        final Set helpSettingsCopy = new HashSet(helpSettings);\n\n        final boolean optional = !isRequired()\n                && (helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL) ||\n                        helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL_CHILD_GROUP));\n\n        final boolean expanded =\n            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\n        final boolean named =\n            !expanded ||\n            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\n        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\n        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\n        final boolean both = named && expanded;\n\n        if (optional) {\n            buffer.append('[');\n        }\n\n        if (named) {\n            buffer.append(name);\n        }\n\n        if (both) {\n            buffer.append(\" (\");\n        }\n\n        if (expanded) {\n            final Set childSettings;\n\n            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n                childSettings = DisplaySetting.NONE;\n            } else {\n                childSettings = new HashSet(helpSettingsCopy);\n                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n            }\n\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option.\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n\n                // append usage information\n                option.appendUsage(buffer, childSettings, comp);\n\n                // add separators as needed\n                if (i.hasNext()) {\n                    buffer.append(separator);\n                }\n            }\n        }\n\n        if (both) {\n            buffer.append(')');\n        }\n\n        if (optional && outer) {\n            buffer.append(']');\n        }\n\n        if (arguments) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                buffer.append(' ');\n\n                final Option option = (Option) i.next();\n                option.appendUsage(buffer, helpSettingsCopy, comp);\n            }\n        }\n\n        if (optional && !outer) {\n            buffer.append(']');\n        }\n    }\n\n    public List helpLines(final int depth,\n                          final Set helpSettings,\n                          final Comparator comp) {\n        final List helpLines = new ArrayList();\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n            final HelpLine helpLine = new HelpLineImpl(this, depth);\n            helpLines.add(helpLine);\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n            // grab a list of the group's options.\n            final List list;\n\n            if (comp == null) {\n                // default to using the initial order\n                list = options;\n            } else {\n                // sort options if comparator is supplied\n                list = new ArrayList(options);\n                Collections.sort(list, comp);\n            }\n\n            // for each option\n            for (final Iterator i = list.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n                final Option option = (Option) i.next();\n                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n            }\n        }\n\n        return helpLines;\n    }\n\n    /**\n     * Gets the member Options of thie Group.\n     * Note this does not include any Arguments\n     * @return only the non Argument Options of the Group\n     */\n    public List getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the anonymous Arguments of this Group.\n     * @return the Argument options of this Group\n     */\n    public List getAnonymous() {\n        return anonymous;\n    }\n\n    public Option findOption(final String trigger) {\n        final Iterator i = getOptions().iterator();\n\n        while (i.hasNext()) {\n            final Option option = (Option) i.next();\n            final Option found = option.findOption(trigger);\n\n            if (found != null) {\n                return found;\n            }\n        }\n\n        return null;\n    }\n\n    public int getMinimum() {\n        return minimum;\n    }\n\n    public int getMaximum() {\n        return maximum;\n    }\n\n    /**\n     * Tests whether this option is required. For groups we evaluate the\n     * <code>required</code> flag common to all options, but also take the\n     * minimum constraints into account.\n     *\n     * @return a flag whether this option is required\n     */\n    public boolean isRequired()\n    {\n        return (getParent() == null || super.isRequired()) && getMinimum() > 0;\n    }\n\n    public void defaults(final WriteableCommandLine commandLine) {\n        super.defaults(commandLine);\n\n        for (final Iterator i = options.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n\n        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n            final Option option = (Option) i.next();\n            option.defaults(commandLine);\n        }\n    }\n\n    /**\n     * Helper method for testing whether an element of the command line looks\n     * like an option. This method queries the command line, but sets the\n     * current option first.\n     *\n     * @param commandLine the command line\n     * @param trigger the trigger to be checked\n     * @return a flag whether this element looks like an option\n     */\n    private boolean looksLikeOption(final WriteableCommandLine commandLine,\n            final String trigger) {\n        Option oldOption = commandLine.getCurrentOption();\n        try {\n            commandLine.setCurrentOption(this);\n            return commandLine.looksLikeOption(trigger);\n        } finally {\n            commandLine.setCurrentOption(oldOption);\n        }\n    }\n}\n\n\nclass ReverseStringComparator implements Comparator {\n    private static final Comparator instance = new ReverseStringComparator();\n\n    private ReverseStringComparator() {\n        // just making sure nobody else creates one\n    }\n\n    /**\n     * Gets a singleton instance of a ReverseStringComparator\n     * @return the singleton instance\n     */\n    public static final Comparator getInstance() {\n        return instance;\n    }\n\n    public int compare(final Object o1,\n                       final Object o2) {\n        final String s1 = (String) o1;\n        final String s2 = (String) o2;\n\n        return -s1.compareTo(s2);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 22, "classes_modified": [{"class_name": "org.apache.commons.cli.PosixParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class PosixParser extends Parser\n{\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries and set <code>eatTheRest</code>\n     * to false.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of\n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see\n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled\n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt))\n                {\n                    processNonOptionToken(token);\n                }\n                else\n                {\n                    \n                    tokens.add(opt);\n                    if (pos != -1)\n                    {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2 || options.hasOption(token))\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current <code>value</code>\n     * to the processed tokens list. Then add all the remaining\n     * <code>argument</code> values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(String value)\n    {\n            eatTheRest = true;\n            tokens.add(\"--\");\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * add the token to the processed list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then add the remaining tokens to the processed tokens list\n     * directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (stopAtNonOption && !options.hasOption(token))\n        {\n            eatTheRest = true;\n        }\n\n\n        tokens.add(token);\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        Option currentOption;\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * The class PosixParser provides an implementation of the\n * {@link Parser#flatten(Options,String[],boolean) flatten} method.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class PosixParser extends Parser\n{\n    /** holder for flattened tokens */\n    private List tokens = new ArrayList();\n\n    /** specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** holder for the current option */\n    private Option currentOption;\n\n    /** the command line Options */\n    private Options options;\n\n    /**\n     * Resets the members to their original state i.e. remove\n     * all of <code>tokens</code> entries and set <code>eatTheRest</code>\n     * to false.\n     */\n    private void init()\n    {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of\n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see\n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled\n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */\n    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt))\n                {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n                else\n                {\n                    currentOption = options.getOption(opt);\n                    \n                    tokens.add(opt);\n                    if (pos != -1)\n                    {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2 || options.hasOption(token))\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                processNonOptionToken(token, stopAtNonOption);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(Iterator iter)\n    {\n        if (eatTheRest)\n        {\n            while (iter.hasNext())\n            {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current <code>value</code>\n     * to the processed tokens list. Then add all the remaining\n     * <code>argument</code> values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(String value, boolean stopAtNonOption)\n    {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n        {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>If an {@link Option} exists for <code>token</code> then\n     * add the token to the processed list.</p>\n     *\n     * <p>If an {@link Option} does not exist and <code>stopAtNonOption</code>\n     * is set then add the remaining tokens to the processed tokens list\n     * directly.</p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt\n     * at the first non option.\n     */\n    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (stopAtNonOption && !options.hasOption(token))\n        {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token.substring(i), true);\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 23, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            int lastPos = pos;\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            } else\n            if (pos == lastPos)\n            {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 24, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n                                            \"- no room for the description\");\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 25, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the begining of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text\n     * \n     * Passing in a null parameter will set the ordering to the default mode\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 26, "classes_modified": [{"class_name": "org.apache.commons.cli.OptionBuilder", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Object type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n\n\n        // PMM 9/6/02 - these were missing\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Object newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n            // create the option\n        Option option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n\n        // return the Option instance\n        return option;\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Object type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n\n\n        // PMM 9/6/02 - these were missing\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Object newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 27, "classes_modified": [{"class_name": "org.apache.commons.cli.OptionGroup", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @author John Keyes ( john at integralsource.com )\n * @version $Revision$, $Date$\n */\npublic class OptionGroup implements Serializable\n{\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private Map optionMap = new HashMap();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getOpt()))\n        {\n            selected = option.getOpt();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer();\n\n        Iterator iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = (Option) iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            buff.append(\" \");\n            buff.append(option.getDescription());\n\n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @author John Keyes ( john at integralsource.com )\n * @version $Revision$, $Date$\n */\npublic class OptionGroup implements Serializable\n{\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private Map optionMap = new HashMap();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer();\n\n        Iterator iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = (Option) iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            buff.append(\" \");\n            buff.append(option.getDescription());\n\n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 28, "classes_modified": [{"class_name": "org.apache.commons.cli.Parser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specfied iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties)\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specfied iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n\n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 29, "classes_modified": [{"class_name": "org.apache.commons.cli.Util", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\nclass Util\n{\n    /**\n     * Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str == null)\n        {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * Contains useful helper methods for classes within this package.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\nclass Util\n{\n    /**\n     * Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(String str)\n    {\n        if (str == null)\n        {\n            return null;\n        }\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }\n\n    /**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n        {\n            str = str.substring(1, length - 1);\n        }\n        \n        return str;\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 30, "classes_modified": [{"class_name": "org.apache.commons.cli.DefaultParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{    \n    protected CommandLine cmd;\n    protected Options options;\n\n    /** \n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n    \n    /** The last option parsed. */\n    protected Option currentOption;\n    \n    /** Flag indicating if tokens should no longer be analysed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n    \n    /** The required options expected to be found when parsing the command line. */\n    protected List expectedOpts;\n    \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }\n        \n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (int i = 0; i < arguments.length; i++)\n            {\n                handleToken(arguments[i]);\n            }\n        }\n        \n        // check the arguments of the last option\n        checkRequiredArgs();\n        \n        // add the default options\n        handleProperties(properties);\n        \n        checkRequiredOptions();\n        \n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = options.getOption(option);\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            \n                // get the value from the properties\n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {       \n        // if there are required options that have not been processsed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     * \n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     * \n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     * \n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     * \n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n        \n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     * \n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        \n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L\n     * --L=V\n     * --L V\n     * --l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);                                   \n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption((String) matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n        \n        String opt = token.substring(0, pos);\n        \n        List matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption((String) matchingOpts.get(0));\n            \n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     * \n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int pos = t.indexOf('=');\n        \n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n                \n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n            \n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     * \n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n        \n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        \n        option = (Option) option.clone();\n        \n        updateRequiredOptions(option);\n        \n        cmd.addOption(option);\n        \n        if (option.hasArg())\n        {\n            currentOption = option;            \n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     * \n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n                \n                if (currentOption != null && (token.length() != (i + 1)))\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {                \n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @author Emmanuel Bourg\n * @version $Revision$, $Date$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{    \n    protected CommandLine cmd;\n    protected Options options;\n\n    /** \n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n    \n    /** The last option parsed. */\n    protected Option currentOption;\n    \n    /** Flag indicating if tokens should no longer be analysed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n    \n    /** The required options expected to be found when parsing the command line. */\n    protected List expectedOpts;\n    \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }\n        \n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (int i = 0; i < arguments.length; i++)\n            {\n                handleToken(arguments[i]);\n            }\n        }\n        \n        // check the arguments of the last option\n        checkRequiredArgs();\n        \n        // add the default options\n        handleProperties(properties);\n        \n        checkRequiredOptions();\n        \n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n        \n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n                \n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                \n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {       \n        // if there are required options that have not been processsed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     * \n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n        \n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n        \n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     * \n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     * \n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     * \n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     * \n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n        \n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     * \n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        \n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L\n     * --L=V\n     * --L V\n     * --l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);                                   \n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption((String) matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n        \n        String opt = token.substring(0, pos);\n        \n        List matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption((String) matchingOpts.get(0));\n            \n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     * \n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     * \n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int pos = t.indexOf('=');\n        \n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n                \n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n            \n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     * \n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n        \n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n        \n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        \n        option = (Option) option.clone();\n        \n        updateRequiredOptions(option);\n        \n        cmd.addOption(option);\n        \n        if (option.hasArg())\n        {\n            currentOption = option;            \n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     * \n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n                \n                if (currentOption != null && (token.length() != (i + 1)))\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {                \n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n"}, {"class_name": "org.apache.commons.cli.Parser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            \n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specfied iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n        \n        // update the required options and groups\n        updateRequiredOptions(opt);\n        \n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n        \n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     * \n     * @param opt\n     */\n    private void updateRequiredOptions(Option opt) throws ParseException\n    {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Properties;\n\n/**\n * <code>Parser</code> creates {@link CommandLine}s.\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @deprecated The two-pass parsing with the flatten method is not enough flexible to handle complex cases\n */\npublic abstract class Parser implements CommandLineParser\n{\n    /** commandline instance */\n    protected CommandLine cmd;\n\n    /** current Options */\n    private Options options;\n\n    /** list of required options strings */\n    private List requiredOptions;\n\n    protected void setOptions(final Options options)\n    {\n        this.options = options;\n        this.requiredOptions = new ArrayList(options.getRequiredOptions());\n    }\n\n    protected Options getOptions()\n    {\n        return options;\n    }\n\n    protected List getRequiredOptions()\n    {\n        return requiredOptions;\n    }\n\n    /**\n     * Subclasses must implement this method to reduce\n     * the <code>arguments</code> that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop\n     * flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Parses the specified <code>arguments</code> based\n     * on the specifed {@link Options}.\n     *\n     * @param options the <code>Options</code>\n     * @param arguments the <code>arguments</code>\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the\n     * arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the specified <code>arguments</code>\n     * based on the specifed {@link Options}.\n     *\n     * @param options         the <code>Options</code>\n     * @param arguments       the <code>arguments</code>\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     * @return the <code>CommandLine</code>\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and\n     * properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     *\n     * @since 1.1\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n        {\n            Option opt = (Option) it.next();\n            opt.clearValues();\n        }\n        \n        // clear the data from the groups\n        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n        {\n            OptionGroup group = (OptionGroup) it.next();\n            group.setSelected(null);\n        }        \n\n        // initialise members\n        setOptions(options);\n\n        cmd = new CommandLine();\n\n        boolean eatTheRest = false;\n\n        if (arguments == null)\n        {\n            arguments = new String[0];\n        }\n\n        List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\n        ListIterator iterator = tokenList.listIterator();\n\n        // process each flattened token\n        while (iterator.hasNext())\n        {\n            String t = (String) iterator.next();\n\n            // the value is the double-dash\n            if (\"--\".equals(t))\n            {\n                eatTheRest = true;\n            }\n\n            // the value is a single dash\n            else if (\"-\".equals(t))\n            {\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n                else\n                {\n                    cmd.addArg(t);\n                }\n            }\n\n            // the value is an option\n            else if (t.startsWith(\"-\"))\n            {\n                if (stopAtNonOption && !getOptions().hasOption(t))\n                {\n                    eatTheRest = true;\n                    cmd.addArg(t);\n                }\n                else\n                {\n                    processOption(t, iterator);\n                }\n            }\n\n            // the value is an argument\n            else\n            {\n                cmd.addArg(t);\n\n                if (stopAtNonOption)\n                {\n                    eatTheRest = true;\n                }\n            }\n\n            // eat the remaining tokens\n            if (eatTheRest)\n            {\n                while (iterator.hasNext())\n                {\n                    String str = (String) iterator.next();\n\n                    // ensure only one double-dash is added\n                    if (!\"--\".equals(str))\n                    {\n                        cmd.addArg(str);\n                    }\n                }\n            }\n        }\n\n        processProperties(properties);\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    protected void processProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n            \n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            \n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n            \n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n     * @throws ParseException if an argument value is required\n     * and it is has not been found.\n     */\n    public void processArgs(Option opt, ListIterator iter) throws ParseException\n    {\n        // loop until an option is found\n        while (iter.hasNext())\n        {\n            String str = (String) iter.next();\n\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\"))\n            {\n                iter.previous();\n                break;\n            }\n\n            // found a value\n            try\n            {\n                opt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n            }\n            catch (RuntimeException exp)\n            {\n                iter.previous();\n                break;\n            }\n        }\n\n        if (opt.getValues() == null && !opt.hasOptionalArg())\n        {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by <code>arg</code> using the values\n     * retrieved from the specfied iterator <code>iter</code>.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     *\n     * @throws ParseException if <code>arg</code> does not represent an Option\n     */\n    protected void processOption(String arg, ListIterator iter) throws ParseException\n    {\n        boolean hasOption = getOptions().hasOption(arg);\n\n        // if there is no option throw an UnrecognisedOptionException\n        if (!hasOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n\n        // get the option represented by arg\n        Option opt = (Option) getOptions().getOption(arg).clone();\n        \n        // update the required options and groups\n        updateRequiredOptions(opt);\n        \n        // if the option takes an argument value\n        if (opt.hasArg())\n        {\n            processArgs(opt, iter);\n        }\n        \n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     * \n     * @param opt\n     */\n    private void updateRequiredOptions(Option opt) throws ParseException\n    {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired())\n        {\n            getRequiredOptions().remove(opt.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null)\n        {\n            OptionGroup group = getOptions().getOptionGroup(opt);\n\n            if (group.isRequired())\n            {\n                getRequiredOptions().remove(group);\n            }\n\n            group.setSelected(opt);\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 31, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        StringBuffer sb = new StringBuffer(len);\n\n        for (int i = 0; i < len; ++i)\n        {\n            sb.append(' ');\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n"}, {"class_name": "org.apache.commons.cli.Option", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** <p>Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.</p>\n *\n * <p>An Option is not created independantly, but is create through\n * an instance of {@link Options}.<p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @version $Revision$, $Date$\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** the name of the option */\n    private String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName = \"arg\";\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Object type;\n\n    /** the list of argument values **/\n    private List values = new ArrayList();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String longOpt, boolean hasArg, String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     * \n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    /** \n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     * \n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     */\n    public void setType(Object type)\n    {\n        this.type = type;\n    }\n\n    /** \n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /** \n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(String description)\n    {\n        this.description = description;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /** \n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     * \n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /** \n     * Returns the number of argument values this Option can take.\n     *\n     * @return num the number of argument values\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     * \n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or \n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the \n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if ther\n     * is no value.\n     *\n     * @return the value/first value of this Option or the \n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(String defaultValue)\n    {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array \n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array \n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List getValuesList()\n    {\n        return values;\n    }\n\n    /** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public \n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n     * a RuntimeException so as to maintain backwards compat at the API level. \n     *\n     * After calling this method, it is very likely you will want to call \n     * clearValues(). \n     *\n     * @throws RuntimeException\n     */\n    public Object clone()\n    {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal \n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n     * @deprecated\n     * @throws UnsupportedOperationException\n     */\n    public boolean addValue(String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     * \n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     * \n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** <p>Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.</p>\n *\n * <p>An Option is not created independantly, but is create through\n * an instance of {@link Options}.<p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @version $Revision$, $Date$\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** the name of the option */\n    private String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName;\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Object type;\n\n    /** the list of argument values **/\n    private List values = new ArrayList();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String longOpt, boolean hasArg, String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     * \n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    /** \n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     * \n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     */\n    public void setType(Object type)\n    {\n        this.type = type;\n    }\n\n    /** \n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /** \n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(String description)\n    {\n        this.description = description;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /** \n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     * \n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /** \n     * Returns the number of argument values this Option can take.\n     *\n     * @return num the number of argument values\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     * \n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or \n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the \n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if ther\n     * is no value.\n     *\n     * @return the value/first value of this Option or the \n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(String defaultValue)\n    {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array \n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array \n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List getValuesList()\n    {\n        return values;\n    }\n\n    /** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public \n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n     * a RuntimeException so as to maintain backwards compat at the API level. \n     *\n     * After calling this method, it is very likely you will want to call \n     * clearValues(). \n     *\n     * @throws RuntimeException\n     */\n    public Object clone()\n    {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal \n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n     * @deprecated\n     * @throws UnsupportedOperationException\n     */\n    public boolean addValue(String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     * \n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     * \n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n"}, {"class_name": "org.apache.commons.cli.OptionBuilder", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Object type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    static\n    {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = \"arg\";\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Object newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try\n        {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Object type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    static\n    {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Object newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try\n        {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 32, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n"}]}
{"project": "Cli", "bug_id": 33, "classes_modified": [{"class_name": "org.apache.commons.cli.HelpFormatter", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Render the specified text width a maximum width. This method differs\n     * from renderWrappedText by not removing leading spaces after a new line.\n     * \n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n            // cannot happen\n\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\n\n/** \n * A formatter of help messages for the current command line options\n *\n * @author Slawek Zachcial\n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n */\npublic class HelpFormatter\n{\n    // --------------------------------------------------------------- Constants\n\n    /** default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** the string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /** default separator displayed between a long Option and its value */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    // -------------------------------------------------------------- Attributes\n\n    /**\n     * number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setWidth methods instead.\n     */\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLeftPadding methods instead.\n     */\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setDescPadding methods instead.\n     */\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * the string to display at the begining of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setSyntaxPrefix methods instead.\n     */\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * the new line string\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setNewLine methods instead.\n     */\n    public String defaultNewLine = System.getProperty(\"line.separator\");\n\n    /**\n     * the shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setOptPrefix methods instead.\n     */\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * the long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setLongOptPrefix methods instead.\n     */\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /** The separator displayed between the long option and its value. */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * the name of the argument\n     *\n     * @deprecated Scope will be made private for next major version\n     * - use get/setArgName methods instead.\n     */\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     * \n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator optionComparator = new OptionComparator();\n    \n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(int width)\n    {\n        this.defaultWidth = width;\n    }\n\n    /**\n     * Returns the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth()\n    {\n        return defaultWidth;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(int padding)\n    {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Returns the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding()\n    {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(int padding)\n    {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Returns the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding()\n    {\n        return defaultDescPad;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(String prefix)\n    {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix()\n    {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(String newline)\n    {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Returns the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine()\n    {\n        return defaultNewLine;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(String prefix)\n    {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix()\n    {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(String prefix)\n    {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Set the separator displayed between a long option and its value.\n     * Ensure that the separator specified is supported by the parser used,\n     * typically ' ' or '='.\n     * \n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(String longOptSeparator)\n    {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Returns the separator displayed between a long option and its value.\n     * \n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator()\n    {\n        return longOptSeparator;\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(String name)\n    {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Returns the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName()\n    {\n        return defaultArgName;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text.\n     * Defaults to case-insensitive alphabetical sorting by option key.\n     * \n     * @since 1.2\n     */\n    public Comparator getOptionComparator()\n    {\n        return optionComparator;\n    }\n\n    /**\n     * Set the comparator used to sort the options when they output in help text.\n     * Passing in a null parameter will set the ordering to the default mode.\n     * \n     * @since 1.2\n     */\n    public void setOptionComparator(Comparator comparator)\n    {\n        if (comparator == null)\n        {\n            this.optionComparator = new OptionComparator();\n        }\n        else\n        {\n            this.optionComparator = comparator;\n        }\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, Options options, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to \n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     */\n    public void printHelp(String cmdLineSyntax, String header, Options options, String footer, boolean autoUsage)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header, Options options, String footer)\n    {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated \n     * usage statement\n     */\n    public void printHelp(int width, String cmdLineSyntax, String header,\n                          Options options, String footer, boolean autoUsage)\n    {\n        PrintWriter pw = new PrintWriter(System.out);\n\n        printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, \n                          String header, Options options, int leftPad, \n                          int descPad, String footer)\n    {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n\n    /**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the begining of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated\n     * usage statement\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\n                          String header, Options options, int leftPad,\n                          int descPad, String footer, boolean autoUsage)\n    {\n        if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n        {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n\n        if (autoUsage)\n        {\n            printUsage(pw, width, cmdLineSyntax, options);\n        }\n        else\n        {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n\n        if ((header != null) && (header.trim().length() > 0))\n        {\n            printWrapped(pw, width, header);\n        }\n\n        printOptions(pw, width, options, leftPad, descPad);\n\n        if ((footer != null) && (footer.trim().length() > 0))\n        {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer.  \n     * The clause is wrapped in square brackets if the group is required.\n     * The display of the options is handled by appendOption\n     * @param buff the StringBuffer to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuffer,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)\n    {\n        if (!group.isRequired())\n        {\n            buff.append(\"[\");\n        }\n\n        List optList = new ArrayList(group.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // for each option in the OptionGroup\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, (Option) i.next(), true);\n\n            if (i.hasNext())\n            {\n                buff.append(\" | \");\n            }\n        }\n\n        if (!group.isRequired())\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        \n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || option.getArgName().length() != 0))\n        {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        \n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n    \n    /**\n     * Print the cmdLineSyntax to the specified writer, using the\n     * specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     */\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedTextBlock(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n    // --------------------------------------------------------------- Protected\n\n    /**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer();\n            \n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                String argName = option.getArgName();\n                if (argName != null && argName.length() == 0)\n                {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                }\n                else\n                {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ((text.length() > width) && (pos == nextLineTabStop - 1))\n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Render the specified text width a maximum width. This method differs\n     * from renderWrappedText by not removing leading spaces after a new line.\n     * \n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private StringBuffer renderWrappedTextBlock(StringBuffer sb, int width, int nextLineTabStop, String text) {\n        try {\n            BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    sb.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                renderWrappedText(sb, width, nextLineTabStop, line);\n            }\n        } catch (IOException e) {\n            // cannot happen\n        }\n\n        return sb;\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        \n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Return a String of padding of length <code>len</code>.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(int len)\n    {\n        char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        \n        return new String(padding);\n    }\n\n    /**\n     * Remove the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     *\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(String s)\n    {\n        if ((s == null) || (s.length() == 0))\n        {\n            return s;\n        }\n\n        int pos = s.length();\n\n        while ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n        {\n            --pos;\n        }\n\n        return s.substring(0, pos);\n    }\n\n    // ------------------------------------------------------ Package protected\n    // ---------------------------------------------------------------- Private\n    // ---------------------------------------------------------- Inner classes\n    /**\n     * This class implements the <code>Comparator</code> interface\n     * for comparing Options.\n     */\n    private static class OptionComparator implements Comparator\n    {\n\n        /**\n         * Compares its two arguments for order. Returns a negative\n         * integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param o1 The first Option to be compared.\n         * @param o2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as\n         *         the first argument is less than, equal to, or greater than the\n         *         second.\n         */\n        public int compare(Object o1, Object o2)\n        {\n            Option opt1 = (Option) o1;\n            Option opt2 = (Option) o2;\n\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n\n}\n"}]}
{"project": "Cli", "bug_id": 34, "classes_modified": [{"class_name": "org.apache.commons.cli.Option", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** <p>Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.</p>\n *\n * <p>An Option is not created independantly, but is create through\n * an instance of {@link Options}.<p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @version $Revision$, $Date$\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** the name of the option */\n    private String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName;\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Class type;\n\n    /** the list of argument values **/\n    private List values = new ArrayList();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String longOpt, boolean hasArg, String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     * \n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    /** \n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     * \n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     */\n    public void setType(Class type)\n    {\n        this.type = type;\n    }\n\n    /** \n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /** \n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(String description)\n    {\n        this.description = description;\n    }\n\n    /** \n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /** \n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     * \n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /** \n     * Returns the number of argument values this Option can take.\n     *\n     * @return num the number of argument values\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     * \n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or \n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the \n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if ther\n     * is no value.\n     *\n     * @return the value/first value of this Option or the \n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(String defaultValue)\n    {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array \n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array \n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List getValuesList()\n    {\n        return values;\n    }\n\n    /** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public \n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n     * a RuntimeException so as to maintain backwards compat at the API level. \n     *\n     * After calling this method, it is very likely you will want to call \n     * clearValues(). \n     *\n     * @throws RuntimeException\n     */\n    public Object clone()\n    {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal \n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n     * @deprecated\n     * @throws UnsupportedOperationException\n     */\n    public boolean addValue(String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     * \n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     * \n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** <p>Describes a single command-line option.  It maintains\n * information regarding the short-name of the option, the long-name,\n * if any exists, a flag indicating if an argument is required for\n * this option, and a self-documenting description of the option.</p>\n *\n * <p>An Option is not created independantly, but is create through\n * an instance of {@link Options}.<p>\n *\n * @see org.apache.commons.cli.Options\n * @see org.apache.commons.cli.CommandLine\n *\n * @author bob mcwhirter (bob @ werken.com)\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n * @version $Revision$, $Date$\n */\npublic class Option implements Cloneable, Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** constant that specifies the number of argument values has not been specified */\n    public static final int UNINITIALIZED = -1;\n\n    /** constant that specifies the number of argument values is infinite */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /** the name of the option */\n    private String opt;\n\n    /** the long representation of the option */\n    private String longOpt;\n\n    /** the name of the argument for this option */\n    private String argName;\n\n    /** description of the option */\n    private String description;\n\n    /** specifies whether this option is required to be present */\n    private boolean required;\n\n    /** specifies whether the argument value of this Option is optional */\n    private boolean optionalArg;\n\n    /** the number of argument values this option can have */\n    private int numberOfArgs = UNINITIALIZED;\n\n    /** the type of this Option */\n    private Class type = String.class;\n\n    /** the list of argument values **/\n    private List values = new ArrayList();\n\n    /** the character that is the value separator */\n    private char valuesep;\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String description) throws IllegalArgumentException\n    {\n        this(opt, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, boolean hasArg, String description) throws IllegalArgumentException\n    {\n        this(opt, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param opt short representation of the option\n     * @param longOpt the long representation of the option\n     * @param hasArg specifies whether the Option takes an argument or not\n     * @param description describes the function of the option\n     *\n     * @throws IllegalArgumentException if there are any non valid\n     * Option characters in <code>opt</code>.\n     */\n    public Option(String opt, String longOpt, boolean hasArg, String description)\n           throws IllegalArgumentException\n    {\n        // ensure that the option is valid\n        OptionValidator.validateOption(opt);\n\n        this.opt = opt;\n        this.longOpt = longOpt;\n\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg)\n        {\n            this.numberOfArgs = 1;\n        }\n\n        this.description = description;\n    }\n\n    /**\n     * Returns the id of this Option.  This is only set when the\n     * Option shortOpt is a single character.  This is used for switch\n     * statements.\n     *\n     * @return the id of this Option\n     */\n    public int getId()\n    {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Returns the 'unique' Option identifier.\n     * \n     * @return the 'unique' Option identifier\n     */\n    String getKey()\n    {\n        // if 'opt' is null, then it is a 'long' option\n        if (opt == null)\n        {\n            return longOpt;\n        }\n\n        return opt;\n    }\n\n    /** \n     * Retrieve the name of this Option.\n     *\n     * It is this String which can be used with\n     * {@link CommandLine#hasOption(String opt)} and\n     * {@link CommandLine#getOptionValue(String opt)} to check\n     * for existence and argument.\n     *\n     * @return The name of this option\n     */\n    public String getOpt()\n    {\n        return opt;\n    }\n\n    /**\n     * Retrieve the type of this Option.\n     * \n     * @return The type of this option\n     */\n    public Object getType()\n    {\n        return type;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option\n     */\n    public void setType(Class type)\n    {\n        this.type = type;\n    }\n\n    /** \n     * Retrieve the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name\n     */\n    public String getLongOpt()\n    {\n        return longOpt;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option\n     */\n    public void setLongOpt(String longOpt)\n    {\n        this.longOpt = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have\n     * an optional argument.\n     */\n    public void setOptionalArg(boolean optionalArg)\n    {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * @return whether this Option can have an optional argument\n     */\n    public boolean hasOptionalArg()\n    {\n        return optionalArg;\n    }\n\n    /** \n     * Query to see if this Option has a long name\n     *\n     * @return boolean flag indicating existence of a long name\n     */\n    public boolean hasLongOpt()\n    {\n        return longOpt != null;\n    }\n\n    /** \n     * Query to see if this Option requires an argument\n     *\n     * @return boolean flag indicating if an argument is required\n     */\n    public boolean hasArg()\n    {\n        return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Retrieve the self-documenting description of this Option\n     *\n     * @return The string description of this option\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option\n     *\n     * @param description The description of this option\n     * @since 1.1\n     */\n    public void setDescription(String description)\n    {\n        this.description = description;\n    }\n\n    /** \n     * Query to see if this Option is mandatory\n     *\n     * @return boolean flag indicating whether this Option is mandatory\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(String argName)\n    {\n        this.argName = argName;\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName()\n    {\n        return argName;\n    }\n\n    /**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }\n\n    /** \n     * Query to see if this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed\n     */\n    public boolean hasArgs()\n    {\n        return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n    }\n\n    /** \n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values\n     */\n    public void setArgs(int num)\n    {\n        this.numberOfArgs = num;\n    }\n\n    /**\n     * Sets the value separator.  For example if the argument value\n     * was a Java property, the value separator would be '='.\n     *\n     * @param sep The value separator.\n     */\n    public void setValueSeparator(char sep)\n    {\n        this.valuesep = sep;\n    }\n\n    /**\n     * Returns the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator()\n    {\n        return valuesep;\n    }\n\n    /**\n     * Return whether this Option has specified a value separator.\n     * \n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator()\n    {\n        return valuesep > 0;\n    }\n\n    /** \n     * Returns the number of argument values this Option can take.\n     *\n     * @return num the number of argument values\n     */\n    public int getArgs()\n    {\n        return numberOfArgs;\n    }\n\n    /**\n     * Adds the specified value to this Option.\n     * \n     * @param value is a/the value of this Option\n     */\n    void addValueForProcessing(String value)\n    {\n        switch (numberOfArgs)\n        {\n            case UNINITIALIZED:\n                throw new RuntimeException(\"NO_ARGS_ALLOWED\");\n\n            default:\n                processValue(value);\n        }\n    }\n\n    /**\n     * Processes the value.  If this Option has a value separator\n     * the value will have to be parsed into individual tokens.  When\n     * n-1 tokens have been processed and there are more value separators\n     * in the value, parsing is ceased and the remaining characters are\n     * added as a single token.\n     *\n     * @param value The String to be processed.\n     *\n     * @since 1.0.1\n     */\n    private void processValue(String value)\n    {\n        // this Option has a separator character\n        if (hasValueSeparator())\n        {\n            // get the separator character\n            char sep = getValueSeparator();\n\n            // store the index for the value separator\n            int index = value.indexOf(sep);\n\n            // while there are more value separators\n            while (index != -1)\n            {\n                // next value to be added \n                if (values.size() == (numberOfArgs - 1))\n                {\n                    break;\n                }\n\n                // store\n                add(value.substring(0, index));\n\n                // parse\n                value = value.substring(index + 1);\n\n                // get new index\n                index = value.indexOf(sep);\n            }\n        }\n\n        // store the actual value or the last value that has been parsed\n        add(value);\n    }\n\n    /**\n     * Add the value to this Option.  If the number of arguments\n     * is greater than zero and there is enough space in the list then\n     * add the value.  Otherwise, throw a runtime exception.\n     *\n     * @param value The value to be added to this Option\n     *\n     * @since 1.0.1\n     */\n    private void add(String value)\n    {\n        if (!acceptsArg())\n        {\n            throw new RuntimeException(\"Cannot add value, list full.\");\n        }\n\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @return the value/first value of this Option or \n     * <code>null</code> if there is no value.\n     */\n    public String getValue()\n    {\n        return hasNoValues() ? null : (String) values.get(0);\n    }\n\n    /**\n     * Returns the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or \n     * <code>null</code> if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1\n     * or greater than the number of the values for this Option.\n     */\n    public String getValue(int index) throws IndexOutOfBoundsException\n    {\n        return hasNoValues() ? null : (String) values.get(index);\n    }\n\n    /**\n     * Returns the value/first value of this Option or the \n     * <code>defaultValue</code> if there is no value.\n     *\n     * @param defaultValue The value to be returned if ther\n     * is no value.\n     *\n     * @return the value/first value of this Option or the \n     * <code>defaultValue</code> if there are no values.\n     */\n    public String getValue(String defaultValue)\n    {\n        String value = getValue();\n\n        return (value != null) ? value : defaultValue;\n    }\n\n    /**\n     * Return the values of this Option as a String array \n     * or null if there are no values\n     *\n     * @return the values of this Option as a String array \n     * or null if there are no values\n     */\n    public String[] getValues()\n    {\n        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n    }\n\n    /**\n     * @return the values of this Option as a List\n     * or null if there are no values\n     */\n    public List getValuesList()\n    {\n        return values;\n    }\n\n    /** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n\n    /**\n     * Returns whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues()\n    {\n        return values.isEmpty();\n    }\n\n    public boolean equals(Object o)\n    {\n        if (this == o)\n        {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass())\n        {\n            return false;\n        }\n\n        Option option = (Option) o;\n\n\n        if (opt != null ? !opt.equals(option.opt) : option.opt != null)\n        {\n            return false;\n        }\n        if (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        int result;\n        result = opt != null ? opt.hashCode() : 0;\n        result = 31 * result + (longOpt != null ? longOpt.hashCode() : 0);\n        return result;\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public \n     * and in 1.1 rather than throwing a CloneNotSupportedException it throws \n     * a RuntimeException so as to maintain backwards compat at the API level. \n     *\n     * After calling this method, it is very likely you will want to call \n     * clearValues(). \n     *\n     * @throws RuntimeException\n     */\n    public Object clone()\n    {\n        try\n        {\n            Option option = (Option) super.clone();\n            option.values = new ArrayList(values);\n            return option;\n        }\n        catch (CloneNotSupportedException cnse)\n        {\n            throw new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n        }\n    }\n\n    /**\n     * Clear the Option values. After a parse is complete, these are left with\n     * data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues()\n    {\n        values.clear();\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal \n     * API that was made public in 1.0. It currently throws an UnsupportedOperationException. \n     * @deprecated\n     * @throws UnsupportedOperationException\n     */\n    public boolean addValue(String value)\n    {\n        throw new UnsupportedOperationException(\"The addValue method is not intended for client use. \"\n                + \"Subclasses should use the addValueForProcessing method instead. \");\n    }\n\n    /**\n     * Tells if the option can accept more arguments.\n     * \n     * @return false if the maximum number of arguments is reached\n     * @since 1.3\n     */\n    boolean acceptsArg()\n    {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n    }\n\n    /**\n     * Tells if the option requires more arguments to be valid.\n     * \n     * @return false if the option doesn't require more arguments\n     * @since 1.3\n     */\n    boolean requiresArg()\n    {\n        if (optionalArg)\n        {\n            return false;\n        }\n        if (numberOfArgs == UNLIMITED_VALUES)\n        {\n            return values.size() < 1;\n        }\n        else\n        {\n            return acceptsArg();\n        }\n    }\n}\n"}, {"class_name": "org.apache.commons.cli.OptionBuilder", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * <p>This class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a></p>\n * \n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Class type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    static\n    {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = null;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Class newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try\n        {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\n/**\n * OptionBuilder allows the user to create Options using descriptive methods.\n *\n * <p>Details on the Builder pattern can be found at\n * <a href=\"http://c2.com/cgi-bin/wiki?BuilderPattern\">\n * http://c2.com/cgi-bin/wiki?BuilderPattern</a>.</p>\n *\n * <p>This class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a></p>\n * \n * @author John Keyes (john at integralsource.com)\n * @version $Revision$, $Date$\n * @since 1.0\n */\npublic final class OptionBuilder\n{\n    /** long option */\n    private static String longopt;\n\n    /** option description */\n    private static String description;\n\n    /** argument name */\n    private static String argName;\n\n    /** is required? */\n    private static boolean required;\n\n    /** the number of arguments */\n    private static int numberOfArgs = Option.UNINITIALIZED;\n\n    /** option type */\n    private static Class type;\n\n    /** option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** value separator for argument value */\n    private static char valuesep;\n\n    /** option builder instance */\n    private static OptionBuilder instance = new OptionBuilder();\n\n    static\n    {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder()\n    {\n        // hide the constructor\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset()\n    {\n        description = null;\n        argName = null;\n        longopt = null;\n        type = String.class;\n        required = false;\n        numberOfArgs = Option.UNINITIALIZED;\n        optionalArg = false;\n        valuesep = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(String newLongopt)\n    {\n        OptionBuilder.longopt = newLongopt;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will require an argument value if\n     * <code>hasArg</code> is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(boolean hasArg)\n    {\n        OptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(String name)\n    {\n        OptionBuilder.argName = name;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired()\n    {\n        OptionBuilder.required = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses <code>sep</code> as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator(':')\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(char sep)\n    {\n        OptionBuilder.valuesep = sep;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created uses '<code>=</code>' as a means to\n     * separate argument values.\n     *\n     * <b>Example:</b>\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator()\n     *                           .create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator()\n    {\n        OptionBuilder.valuesep = '=';\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will be required if <code>required</code>\n     * is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(boolean newRequired)\n    {\n        OptionBuilder.required = newRequired;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created can have <code>num</code> argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(int num)\n    {\n        OptionBuilder.numberOfArgs = num;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg()\n    {\n        OptionBuilder.numberOfArgs = 1;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs()\n    {\n        OptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs - the maximum number of optional arguments\n     * the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(int numArgs)\n    {\n        OptionBuilder.numberOfArgs = numArgs;\n        OptionBuilder.optionalArg = true;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance\n     * of <code>type</code>.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withType(Class newType)\n    {\n        OptionBuilder.type = newType;\n\n        return instance;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(String newDescription)\n    {\n        OptionBuilder.description = newDescription;\n\n        return instance;\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(char opt) throws IllegalArgumentException\n    {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Create an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>longOpt</code> has not been set.\n     */\n    public static Option create() throws IllegalArgumentException\n    {\n        if (longopt == null)\n        {\n            OptionBuilder.reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Create an Option using the current settings and with\n     * the specified Option <code>char</code>.\n     *\n     * @param opt the <code>java.lang.String</code> representation\n     * of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if <code>opt</code> is not\n     * a valid character.  See Option.\n     */\n    public static Option create(String opt) throws IllegalArgumentException\n    {\n        Option option = null;\n        try\n        {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longopt);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(numberOfArgs);\n            option.setType(type);\n            option.setValueSeparator(valuesep);\n            option.setArgName(argName);\n        }\n        finally\n        {\n            // reset the OptionBuilder properties\n            OptionBuilder.reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 35, "classes_modified": [{"class_name": "org.apache.commons.cli.Options", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n *\n * @version $Id$\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<Object>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     * The option does not take an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(String opt, String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, boolean hasArg, String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     * The leading hyphens in the name are ignored (up to 2).\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     * @param opt the option whose OptionGroup is being queried.\n     *\n     * @return the OptionGroup if <code>opt</code> is part\n     * of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n *\n * @version $Id$\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<Object>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     * The option does not take an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(String opt, String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, boolean hasArg, String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     * The leading hyphens in the name are ignored (up to 2).\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n        if(longOpts.keySet().contains(opt)) {\n            return Collections.singletonList(opt);\n        }\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     * @param opt the option whose OptionGroup is being queried.\n     *\n     * @return the OptionGroup if <code>opt</code> is part\n     * of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 36, "classes_modified": [{"class_name": "org.apache.commons.cli.OptionGroup", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new HashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * A group of mutually exclusive options.\n *\n * @version $Id$\n */\npublic class OptionGroup implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n    \n    /** hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<String, Option>();\n\n    /** the name of the selected option */\n    private String selected;\n\n    /** specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Add the specified <code>Option</code> to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(Option option)\n    {\n        // key   - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n\n        return this;\n    }\n\n    /**\n     * @return the names of the options in this group as a \n     * <code>Collection</code>\n     */\n    public Collection<String> getNames()\n    {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * @return the options in this group as a <code>Collection</code>\n     */\n    public Collection<Option> getOptions()\n    {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Set the selected option of this group to <code>name</code>.\n     *\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has \n     * already been selected.\n     */\n    public void setSelected(Option option) throws AlreadySelectedException\n    {\n        if (option == null)\n        {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        \n        // if no option has already been selected or the \n        // same option is being reselected then set the\n        // selected member variable\n        if (selected == null || selected.equals(option.getKey()))\n        {\n            selected = option.getKey();\n        }\n        else\n        {\n            throw new AlreadySelectedException(this, option);\n        }\n    }\n\n    /**\n     * @return the selected option name\n     */\n    public String getSelected()\n    {\n        return selected;\n    }\n\n    /**\n     * @param required specifies if this group is required\n     */\n    public void setRequired(boolean required)\n    {\n        this.required = required;\n    }\n\n    /**\n     * Returns whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired()\n    {\n        return required;\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     * \n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder();\n        \n        Iterator<Option> iter = getOptions().iterator();\n\n        buff.append(\"[\");\n\n        while (iter.hasNext())\n        {\n            Option option = iter.next();\n\n            if (option.getOpt() != null)\n            {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            }\n            else\n            {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n            \n            if (option.getDescription() != null)\n            {\n                buff.append(\" \");\n                buff.append(option.getDescription());\n            }\n            \n            if (iter.hasNext())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        buff.append(\"]\");\n\n        return buff.toString();\n    }\n}\n"}, {"class_name": "org.apache.commons.cli.Options", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n *\n * @version $Id$\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<Object>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new java.util.HashMap<String, OptionGroup>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     * The option does not take an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(String opt, String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, boolean hasArg, String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     * The leading hyphens in the name are ignored (up to 2).\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n        if (longOpts.keySet().contains(opt))\n        {\n            return Collections.singletonList(opt);\n        }\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     * @param opt the option whose OptionGroup is being queried.\n     *\n     * @return the OptionGroup if <code>opt</code> is part\n     * of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Main entry-point into the library.\n * <p>\n * Options represents a collection of {@link Option} objects, which\n * describe the possible options for a command-line.\n * <p>\n * It may flexibly parse long and short options, with or without\n * values.  Additionally, it may parse only a portion of a commandline,\n * allowing for flexible multi-stage parsing.\n *\n * @see org.apache.commons.cli.CommandLine\n *\n * @version $Id$\n */\npublic class Options implements Serializable\n{\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** a map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<String, Option>();\n\n    /** a map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<Object>();\n\n    /** a map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<String, OptionGroup>();\n\n    /**\n     * Add the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(OptionGroup group)\n    {\n        if (group.isRequired())\n        {\n            requiredOpts.add(group);\n        }\n\n        for (Option option : group.getOptions())\n        {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n\n            optionGroups.put(option.getKey(), group);\n        }\n\n        return this;\n    }\n\n    /**\n     * Lists the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups()\n    {\n        return new HashSet<OptionGroup>(optionGroups.values());\n    }\n\n    /**\n     * Add an option that only contains a short name.\n     * The option does not take an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(String opt, String description)\n    {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Add an option that only contains a short-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, boolean hasArg, String description)\n    {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Add an option that contains a short-name and a long-name.\n     * It may be specified as requiring an argument.\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signally if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n    {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(Option opt)\n    {\n        String key = opt.getKey();\n\n        // add it to the long option list\n        if (opt.hasLongOpt())\n        {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n\n        // if the option is required add it to the required list\n        if (opt.isRequired())\n        {\n            if (requiredOpts.contains(key))\n            {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n\n        shortOpts.put(key, opt);\n\n        return this;\n    }\n\n    /**\n     * Retrieve a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions()\n    {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions()\n    {\n        return new ArrayList<Option>(shortOpts.values());\n    }\n\n    /**\n     * Returns the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List getRequiredOptions()\n    {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Retrieve the {@link Option} matching the long or short name specified.\n     * The leading hyphens in the name are ignored (up to 2).\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        if (shortOpts.containsKey(opt))\n        {\n            return shortOpts.get(opt);\n        }\n\n        return longOpts.get(opt);\n    }\n\n    /**\n     * Returns the options with a long name starting with the name specified.\n     * \n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n        \n        List<String> matchingOpts = new ArrayList<String>();\n\n        // for a perfect match return the single option only\n        if (longOpts.keySet().contains(opt))\n        {\n            return Collections.singletonList(opt);\n        }\n\n        for (String longOpt : longOpts.keySet())\n        {\n            if (longOpt.startsWith(opt))\n            {\n                matchingOpts.add(longOpt);\n            }\n        }\n        \n        return matchingOpts;\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return longOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(String opt)\n    {\n        opt = Util.stripLeadingHyphens(opt);\n\n        return shortOpts.containsKey(opt);\n    }\n\n    /**\n     * Returns the OptionGroup the <code>opt</code> belongs to.\n     * @param opt the option whose OptionGroup is being queried.\n     *\n     * @return the OptionGroup if <code>opt</code> is part\n     * of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(Option opt)\n    {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 37, "classes_modified": [{"class_name": "org.apache.commons.cli.DefaultParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @version $Id$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n    \n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n \n    /** The last option parsed. */\n    protected Option currentOption;\n \n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n \n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n        // remove leading \"-\" and \"=value\"\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * --L=V\n     * --L V\n     * --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     *\n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @version $Id$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n    \n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n \n    /** The last option parsed. */\n    protected Option currentOption;\n \n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n \n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * --L=V\n     * --L V\n     * --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     *\n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 38, "classes_modified": [{"class_name": "org.apache.commons.cli.DefaultParser", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @version $Id$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n    \n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n \n    /** The last option parsed. */\n    protected Option currentOption;\n \n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n \n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        return options.hasShortOption(optName);\n        // check for several concatenated short options\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * --L=V\n     * --L V\n     * --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     *\n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * Default parser.\n * \n * @version $Id$\n * @since 1.3\n */\npublic class DefaultParser implements CommandLineParser\n{\n    /** The command-line instance. */\n    protected CommandLine cmd;\n    \n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. <tt>true</tt> to stop\n     * the parsing and add the remaining tokens to the args list.\n     * <tt>false</tt> to throw an exception. \n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n \n    /** The last option parsed. */\n    protected Option currentOption;\n \n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n \n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n \n    public CommandLine parse(Options options, String[] arguments) throws ParseException\n    {\n        return parse(options, arguments, null);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options    the specified Options\n     * @param arguments  the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n    {\n        return parse(options, arguments, properties, false);\n    }\n\n    public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n    {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options         the specified Options\n     * @param arguments       the command line arguments\n     * @param properties      command line option name-value pairs\n     * @param stopAtNonOption if <tt>true</tt> an unrecognized argument stops\n     *     the parsing and the remaining arguments are added to the \n     *     {@link CommandLine}s args list. If <tt>false</tt> an unrecognized\n     *     argument triggers a ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered\n     * while parsing the command line tokens.\n     */\n    public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\n            throws ParseException\n    {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList(options.getRequiredOptions());\n\n        // clear the data from the groups\n        for (OptionGroup group : options.getOptionGroups())\n        {\n            group.setSelected(null);\n        }\n\n        cmd = new CommandLine();\n\n        if (arguments != null)\n        {\n            for (String argument : arguments)\n            {\n                handleToken(argument);\n            }\n        }\n\n        // check the arguments of the last option\n        checkRequiredArgs();\n\n        // add the default options\n        handleProperties(properties);\n\n        checkRequiredOptions();\n\n        return cmd;\n    }\n\n    /**\n     * Sets the values of Options using the values in <code>properties</code>.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(Properties properties) throws ParseException\n    {\n        if (properties == null)\n        {\n            return;\n        }\n\n        for (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            Option opt = options.getOption(option);\n            if (opt == null)\n            {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n\n            // if the option is part of a group, check if another option of the group has been selected\n            OptionGroup group = options.getOptionGroup(opt);\n            boolean selected = group != null && group.getSelected() != null;\n\n            if (!cmd.hasOption(option) && !selected)\n            {\n                // get the value from the properties\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    private void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty())\n        {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Throw a {@link MissingArgumentException} if the current option\n     * didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException\n    {\n        if (currentOption != null && currentOption.requiresArg())\n        {\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Handle any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(String token) throws ParseException\n    {\n        currentToken = token;\n\n        if (skipParsing)\n        {\n            cmd.addArg(token);\n        }\n        else if (\"--\".equals(token))\n        {\n            skipParsing = true;\n        }\n        else if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n        {\n            currentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n        }\n        else if (token.startsWith(\"--\"))\n        {\n            handleLongOption(token);\n        }\n        else if (token.startsWith(\"-\") && !\"-\".equals(token))\n        {\n            handleShortAndLongOption(token);\n        }\n        else\n        {\n            handleUnknownToken(token);\n        }\n\n        if (currentOption != null && !currentOption.acceptsArg())\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Returns true is the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(String token)\n    {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Check if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(String token)\n    {\n        try\n        {\n            Double.parseDouble(token);\n            return true;\n        }\n        catch (NumberFormatException e)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * Tells if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(String token)\n    {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tells if the token looks like a short option.\n     * \n     * @param token\n     */\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName))\n        {\n            return true;\n        }\n        // check for several concatenated short options\n        return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    /**\n     * Tells if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(String token)\n    {\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        int pos = token.indexOf(\"=\");\n        String t = pos == -1 ? token : token.substring(0, pos);\n\n        if (!options.getMatchingOptions(t).isEmpty())\n        {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        else if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n        {\n            // -LV\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an \n     * UnrecognizedOptionException is thrown. Otherwise the token is added \n     * to the arguments of the command line. If the stopAtNonOption flag \n     * is set, this stops the parsing and the remaining tokens are added \n     * as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(String token) throws ParseException\n    {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption)\n        {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n\n        cmd.addArg(token);\n        if (stopAtNonOption)\n        {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * --L=V\n     * --L V\n     * --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(String token) throws ParseException\n    {\n        if (token.indexOf('=') == -1)\n        {\n            handleLongOptionWithoutEqual(token);\n        }\n        else\n        {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L\n     * -L\n     * --l\n     * -l\n     * \n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(String token) throws ParseException\n    {\n        List<String> matchingOpts = options.getMatchingOptions(token);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        }\n        else\n        {\n            handleOption(options.getOption(matchingOpts.get(0)));\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V\n     * -L=V\n     * --l=V\n     * -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(String token) throws ParseException\n    {\n        int pos = token.indexOf('=');\n\n        String value = token.substring(pos + 1);\n\n        String opt = token.substring(0, pos);\n\n        List<String> matchingOpts = options.getMatchingOptions(opt);\n        if (matchingOpts.isEmpty())\n        {\n            handleUnknownToken(currentToken);\n        }\n        else if (matchingOpts.size() > 1)\n        {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        }\n        else\n        {\n            Option option = options.getOption(matchingOpts.get(0));\n\n            if (option.acceptsArg())\n            {\n                handleOption(option);\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S\n     * -SV\n     * -S V\n     * -S=V\n     * -S1S2\n     * -S1S2 V\n     * -SV1=V2\n     *\n     * -L\n     * -LV\n     * -L V\n     * -L=V\n     * -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleShortAndLongOption(String token) throws ParseException\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int pos = t.indexOf('=');\n\n        if (t.length() == 1)\n        {\n            // -S\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else\n            {\n                handleUnknownToken(token);\n            }\n        }\n        else if (pos == -1)\n        {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(t))\n            {\n                handleOption(options.getOption(t));\n            }\n            else if (!options.getMatchingOptions(t).isEmpty())\n            {\n                // -L or -l\n                handleLongOptionWithoutEqual(token);\n            }\n            else\n            {\n                // look for a long prefix (-Xmx512m)\n                String opt = getLongPrefix(t);\n\n                if (opt != null && options.getOption(opt).acceptsArg())\n                {\n                    handleOption(options.getOption(opt));\n                    currentOption.addValueForProcessing(t.substring(opt.length()));\n                    currentOption = null;\n                }\n                else if (isJavaProperty(t))\n                {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(t.substring(0, 1)));\n                    currentOption.addValueForProcessing(t.substring(1));\n                    currentOption = null;\n                }\n                else\n                {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(token);\n                }\n            }\n        }\n        else\n        {\n            // equal sign found (-xxx=yyy)\n            String opt = t.substring(0, pos);\n            String value = t.substring(pos + 1);\n\n            if (opt.length() == 1)\n            {\n                // -S=V\n                Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg())\n                {\n                    handleOption(option);\n                    currentOption.addValueForProcessing(value);\n                    currentOption = null;\n                }\n                else\n                {\n                    handleUnknownToken(token);\n                }\n            }\n            else if (isJavaProperty(opt))\n            {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.addValueForProcessing(opt.substring(1));\n                currentOption.addValueForProcessing(value);\n                currentOption = null;\n            }\n            else\n            {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(token);\n            }\n        }\n    }\n\n    /**\n     * Search for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(String token)\n    {\n        String t = Util.stripLeadingHyphens(token);\n\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--)\n        {\n            String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix))\n            {\n                opt = prefix;\n                break;\n            }\n        }\n        \n        return opt;\n    }\n\n    /**\n     * Check if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(String token)\n    {\n        String opt = token.substring(0, 1);\n        Option option = options.getOption(opt);\n\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    private void handleOption(Option option) throws ParseException\n    {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n\n        option = (Option) option.clone();\n\n        updateRequiredOptions(option);\n\n        cmd.addOption(option);\n\n        if (option.hasArg())\n        {\n            currentOption = option;\n        }\n        else\n        {\n            currentOption = null;\n        }\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(Option option) throws AlreadySelectedException\n    {\n        if (option.isRequired())\n        {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null)\n        {\n            OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired())\n            {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n\n    /**\n     * Breaks <code>token</code> into its constituent parts\n     * using the following algorithm.\n     *\n     * <ul>\n     *  <li>ignore the first character (\"<b>-</b>\")</li>\n     *  <li>foreach remaining character check if an {@link Option}\n     *  exists with that id.</li>\n     *  <li>if an {@link Option} does exist then add that character\n     *  prepended with \"<b>-</b>\" to the list of processed tokens.</li>\n     *  <li>if the {@link Option} can have an argument value and there\n     *  are remaining characters in the token then add the remaining\n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also\n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered\n     *                        while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(String token) throws ParseException\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                handleOption(options.getOption(ch));\n\n                if (currentOption != null && token.length() != i + 1)\n                {\n                    // add the trail as an argument of the option\n                    currentOption.addValueForProcessing(token.substring(i + 1));\n                    break;\n                }\n            }\n            else\n            {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n        }\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 39, "classes_modified": [{"class_name": "org.apache.commons.cli.TypeHandler", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n *\n * @version $Id$\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n *\n * @version $Id$\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n    public static FileInputStream openFile(String str) throws ParseException\n    {\n        try\n        {\n            return new FileInputStream(str);\n        }\n        catch (FileNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find file: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n"}]}
{"project": "Cli", "bug_id": 40, "classes_modified": [{"class_name": "org.apache.commons.cli.TypeHandler", "buggy_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n    public static FileInputStream openFile(String str) throws ParseException\n    {\n        try\n        {\n            return new FileInputStream(str);\n        }\n        catch (FileNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find file: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n", "fixed_version": "/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.cli;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport java.util.Date;\n\n/**\n * This is a temporary implementation. TypeHandler will handle the\n * pluggableness of OptionTypes and it will direct all of these types\n * of conversion functionalities to ConvertUtils component in Commons\n * already. BeanUtils I think.\n */\npublic class TypeHandler\n{\n    /**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */\n    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \" + clazz);\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n    /**\n     * Create a number from a String. If a . is present, it creates a\n     * Double, otherwise a Long.\n     *\n     * @param str the value\n     * @return the number represented by <code>str</code>\n     * @throws ParseException if <code>str</code> is not a number\n     */\n    public static Number createNumber(final String str) throws ParseException\n    {\n        try\n        {\n            if (str.indexOf('.') != -1)\n            {\n                return Double.valueOf(str);\n            }\n            return Long.valueOf(str);\n        }\n        catch (final NumberFormatException e)\n        {\n            throw new ParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns the class whose name is <code>classname</code>.\n     *\n     * @param classname the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String classname) throws ParseException\n    {\n        try\n        {\n            return Class.forName(classname);\n        }\n        catch (final ClassNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n    }\n\n    /**\n     * Returns the date represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the date string\n     * @return The date if <code>str</code> is a valid date string,\n     * otherwise return null.\n     * @throws UnsupportedOperationException always\n     */\n    public static Date createDate(final String str)\n    {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Returns the URL represented by <code>str</code>.\n     *\n     * @param str the URL string\n     * @return The URL in <code>str</code> is well-formed\n     * @throws ParseException if the URL in <code>str</code> is not well-formed\n     */\n    public static URL createURL(final String str) throws ParseException\n    {\n        try\n        {\n            return new URL(str);\n        }\n        catch (final MalformedURLException e)\n        {\n            throw new ParseException(\"Unable to parse the URL: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File represented by <code>str</code>.\n     *\n     * @param str the File location\n     * @return The file represented by <code>str</code>.\n     */\n    public static File createFile(final String str)\n    {\n        return new File(str);\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by <code>str</code>.\n     *\n     * @param str the file location\n     * @return The file input stream represented by <code>str</code>.\n     * @throws ParseException if the file is not exist or not readable\n     */\n    public static FileInputStream openFile(String str) throws ParseException\n    {\n        try\n        {\n            return new FileInputStream(str);\n        }\n        catch (FileNotFoundException e)\n        {\n            throw new ParseException(\"Unable to find file: \" + str);\n        }\n    }\n\n    /**\n     * Returns the File[] represented by <code>str</code>.\n     * <p>\n     * This method is not yet implemented and always throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param str the paths to the files\n     * @return The File[] represented by <code>str</code>.\n     * @throws UnsupportedOperationException always\n     */\n    public static File[] createFiles(final String str)\n    {\n        // to implement/port:\n        //        return FileW.findFiles(str);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n}\n"}]}
