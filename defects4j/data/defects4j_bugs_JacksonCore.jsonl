{"project": "JacksonCore", "bug_id": 1, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.io.NumberInput", "buggy_version": "package com.fasterxml.jackson.core.io;\n\nimport java.math.BigDecimal;\n\npublic final class NumberInput\n{\n    /**\n     * Textual representation of a double constant that can cause nasty problems\n     * with JDK (see http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308).\n     */\n    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n\n    /**\n     * Constants needed for parsing longs from basic int parsing methods\n     */\n    final static long L_BILLION = 1000000000;\n\n    final static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\n    final static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n    \n    /**\n     * Fast method for parsing integers that are known to fit into\n     * regular 32-bit signed int type. This means that length is\n     * between 1 and 9 digits (inclusive)\n     *<p>\n     * Note: public to let unit tests call it\n     */\n    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\n                            num = (num * 10) + (digitChars[offset] - '0');\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }\n\n    /**\n     * Helper method to (more) efficiently parse integer numbers from\n     * String values.\n     */\n    public static int parseInt(String str)\n    {\n        /* Ok: let's keep strategy simple: ignoring optional minus sign,\n         * we'll accept 1 - 9 digits and parse things efficiently;\n         * otherwise just defer to JDK parse functionality.\n         */\n        char c = str.charAt(0);\n        int length = str.length();\n        boolean negative = (c == '-');\n        int offset = 1;\n        // must have 1 - 9 digits after optional sign:\n        // negative?\n        if (negative) {\n            if (length == 1 || length > 10) {\n                return Integer.parseInt(str);\n            }\n            c = str.charAt(offset++);\n        } else {\n            if (length > 9) {\n                return Integer.parseInt(str);\n            }\n        }\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        int num = c - '0';\n        if (offset < length) {\n            c = str.charAt(offset++);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            if (offset < length) {\n                c = str.charAt(offset++);\n                if (c > '9' || c < '0') {\n                    return Integer.parseInt(str);\n                }\n                num = (num * 10) + (c - '0');\n                // Let's just loop if we have more than 3 digits:\n                if (offset < length) {\n                    do {\n                        c = str.charAt(offset++);\n                        if (c > '9' || c < '0') {\n                            return Integer.parseInt(str);\n                        }\n                        num = (num * 10) + (c - '0');\n                    } while (offset < length);\n                }\n            }\n        }\n        return negative ? -num : num;\n    }\n    \n    public static long parseLong(char[] digitChars, int offset, int len)\n    {\n        // Note: caller must ensure length is [10, 18]\n        int len1 = len-9;\n        long val = parseInt(digitChars, offset, len1) * L_BILLION;\n        return val + (long) parseInt(digitChars, offset+len1, 9);\n    }\n\n    public static long parseLong(String str)\n    {\n        /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n         * that is, if we know they must be ints, call int parsing\n         */\n        int length = str.length();\n        if (length <= 9) {\n            return (long) parseInt(str);\n        }\n        // !!! TODO: implement efficient 2-int parsing...\n        return Long.parseLong(str);\n    }\n    \n    /**\n     * Helper method for determining if given String representation of\n     * an integral number would fit in 64-bit Java long or not.\n     * Note that input String must NOT contain leading minus sign (even\n     * if 'negative' is set to true).\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(char[] digitChars, int offset, int len,\n            boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        if (len < cmpLen) return true;\n        if (len > cmpLen) return false;\n\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = digitChars[offset+i] - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Similar to {@link #inLongRange(char[],int,int,boolean)}, but\n     * with String argument\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(String numberStr, boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        int actualLen = numberStr.length();\n        if (actualLen < cmpLen) return true;\n        if (actualLen > cmpLen) return false;\n\n        // could perhaps just use String.compareTo()?\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = numberStr.charAt(i) - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    public static int parseAsInt(String input, int defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use integer parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (int) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Integer.parseInt(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static long parseAsLong(String input, long defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use long parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (long) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Long.parseLong(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n    \n    public static double parseAsDouble(String input, double defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        try {\n            return parseDouble(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static double parseDouble(String numStr) throws NumberFormatException\n    {\n        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n        /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n         * only in JDK 1.6. In practice, should not really matter.\n         */\n        if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n            return Double.MIN_VALUE;\n        }\n        return Double.parseDouble(numStr);\n    }\n\n    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n            return new BigDecimal(numStr);\n    }\n\n    public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {\n        return parseBigDecimal(buffer, 0, buffer.length);\n    }\n    \n    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n            throws NumberFormatException\n    {\n            return new BigDecimal(buffer, offset, len);\n    }\n\n}\n", "fixed_version": "package com.fasterxml.jackson.core.io;\n\nimport java.math.BigDecimal;\n\npublic final class NumberInput\n{\n    /**\n     * Textual representation of a double constant that can cause nasty problems\n     * with JDK (see http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308).\n     */\n    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n\n    /**\n     * Constants needed for parsing longs from basic int parsing methods\n     */\n    final static long L_BILLION = 1000000000;\n\n    final static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\n    final static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n    \n    /**\n     * Fast method for parsing integers that are known to fit into\n     * regular 32-bit signed int type. This means that length is\n     * between 1 and 9 digits (inclusive)\n     *<p>\n     * Note: public to let unit tests call it\n     */\n    public static int parseInt(char[] digitChars, int offset, int len)\n    {\n        int num = digitChars[offset] - '0';\n        len += offset;\n        // This looks ugly, but appears the fastest way (as per measurements)\n        if (++offset < len) {\n            num = (num * 10) + (digitChars[offset] - '0');\n            if (++offset < len) {\n                num = (num * 10) + (digitChars[offset] - '0');\n                if (++offset < len) {\n                    num = (num * 10) + (digitChars[offset] - '0');\n                    if (++offset < len) {\n                        num = (num * 10) + (digitChars[offset] - '0');\n                        if (++offset < len) {\n                            num = (num * 10) + (digitChars[offset] - '0');\n                            if (++offset < len) {\n                                num = (num * 10) + (digitChars[offset] - '0');\n                                if (++offset < len) {\n                                    num = (num * 10) + (digitChars[offset] - '0');\n                                    if (++offset < len) {\n                                        num = (num * 10) + (digitChars[offset] - '0');\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return num;\n    }\n\n    /**\n     * Helper method to (more) efficiently parse integer numbers from\n     * String values.\n     */\n    public static int parseInt(String str)\n    {\n        /* Ok: let's keep strategy simple: ignoring optional minus sign,\n         * we'll accept 1 - 9 digits and parse things efficiently;\n         * otherwise just defer to JDK parse functionality.\n         */\n        char c = str.charAt(0);\n        int length = str.length();\n        boolean negative = (c == '-');\n        int offset = 1;\n        // must have 1 - 9 digits after optional sign:\n        // negative?\n        if (negative) {\n            if (length == 1 || length > 10) {\n                return Integer.parseInt(str);\n            }\n            c = str.charAt(offset++);\n        } else {\n            if (length > 9) {\n                return Integer.parseInt(str);\n            }\n        }\n        if (c > '9' || c < '0') {\n            return Integer.parseInt(str);\n        }\n        int num = c - '0';\n        if (offset < length) {\n            c = str.charAt(offset++);\n            if (c > '9' || c < '0') {\n                return Integer.parseInt(str);\n            }\n            num = (num * 10) + (c - '0');\n            if (offset < length) {\n                c = str.charAt(offset++);\n                if (c > '9' || c < '0') {\n                    return Integer.parseInt(str);\n                }\n                num = (num * 10) + (c - '0');\n                // Let's just loop if we have more than 3 digits:\n                if (offset < length) {\n                    do {\n                        c = str.charAt(offset++);\n                        if (c > '9' || c < '0') {\n                            return Integer.parseInt(str);\n                        }\n                        num = (num * 10) + (c - '0');\n                    } while (offset < length);\n                }\n            }\n        }\n        return negative ? -num : num;\n    }\n    \n    public static long parseLong(char[] digitChars, int offset, int len)\n    {\n        // Note: caller must ensure length is [10, 18]\n        int len1 = len-9;\n        long val = parseInt(digitChars, offset, len1) * L_BILLION;\n        return val + (long) parseInt(digitChars, offset+len1, 9);\n    }\n\n    public static long parseLong(String str)\n    {\n        /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n         * that is, if we know they must be ints, call int parsing\n         */\n        int length = str.length();\n        if (length <= 9) {\n            return (long) parseInt(str);\n        }\n        // !!! TODO: implement efficient 2-int parsing...\n        return Long.parseLong(str);\n    }\n    \n    /**\n     * Helper method for determining if given String representation of\n     * an integral number would fit in 64-bit Java long or not.\n     * Note that input String must NOT contain leading minus sign (even\n     * if 'negative' is set to true).\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(char[] digitChars, int offset, int len,\n            boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        if (len < cmpLen) return true;\n        if (len > cmpLen) return false;\n\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = digitChars[offset+i] - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Similar to {@link #inLongRange(char[],int,int,boolean)}, but\n     * with String argument\n     *\n     * @param negative Whether original number had a minus sign (which is\n     *    NOT passed to this method) or not\n     */\n    public static boolean inLongRange(String numberStr, boolean negative)\n    {\n        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n        int cmpLen = cmpStr.length();\n        int actualLen = numberStr.length();\n        if (actualLen < cmpLen) return true;\n        if (actualLen > cmpLen) return false;\n\n        // could perhaps just use String.compareTo()?\n        for (int i = 0; i < cmpLen; ++i) {\n            int diff = numberStr.charAt(i) - cmpStr.charAt(i);\n            if (diff != 0) {\n                return (diff < 0);\n            }\n        }\n        return true;\n    }\n\n    public static int parseAsInt(String input, int defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use integer parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (int) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Integer.parseInt(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static long parseAsLong(String input, long defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        // One more thing: use long parsing for 'simple'\n        int i = 0;\n        if (i < len) { // skip leading sign:\n            char c = input.charAt(0);\n            if (c == '+') { // for plus, actually physically remove\n                input = input.substring(1);\n                len = input.length();\n            } else if (c == '-') { // minus, just skip for checks, must retain\n                ++i;\n            }\n        }\n        for (; i < len; ++i) {\n            char c = input.charAt(i);\n            // if other symbols, parse as Double, coerce\n            if (c > '9' || c < '0') {\n                try {\n                    return (long) parseDouble(input);\n                } catch (NumberFormatException e) {\n                    return defaultValue;\n                }\n            }\n        }\n        try {\n            return Long.parseLong(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n    \n    public static double parseAsDouble(String input, double defaultValue)\n    {\n        if (input == null) {\n            return defaultValue;\n        }\n        input = input.trim();\n        int len = input.length();\n        if (len == 0) {\n            return defaultValue;\n        }\n        try {\n            return parseDouble(input);\n        } catch (NumberFormatException e) { }\n        return defaultValue;\n    }\n\n    public static double parseDouble(String numStr) throws NumberFormatException\n    {\n        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n        /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n         * only in JDK 1.6. In practice, should not really matter.\n         */\n        if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n            return Double.MIN_VALUE;\n        }\n        return Double.parseDouble(numStr);\n    }\n\n    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n        try {\n            return new BigDecimal(numStr);\n        } catch (NumberFormatException e) {\n            throw _badBigDecimal(numStr);\n        }\n    }\n\n    public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {\n        return parseBigDecimal(buffer, 0, buffer.length);\n    }\n    \n    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n            throws NumberFormatException\n    {\n        try {\n            return new BigDecimal(buffer, offset, len);\n        } catch (NumberFormatException e) {\n            throw _badBigDecimal(new String(buffer, offset, len));\n        }\n    }\n\n    private static NumberFormatException _badBigDecimal(String str) {\n        return new NumberFormatException(\"Value \\\"\"+str+\"\\\" can not be represented as BigDecimal\");\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.util.TextBuffer", "buggy_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator)\n    {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = findBuffer(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] findBuffer(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset()\n    {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null) {\n            return true;\n        }\n        // not if we have String as value\n        if (_resultString != null) {\n            return false;\n        }\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) {\n            return _inputBuffer;\n        }\n        if (_resultArray != null) {\n            return _resultArray;\n        }\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments) {\n            return _currentSegment;\n        }\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray()\n    {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = buildResultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble()\n        throws NumberFormatException\n    {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = findBuffer(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = findBuffer(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() {\n        return _currentSize;\n    }\n\n    public void setCurrentLength(int len) {\n        _currentSize = len;\n    }\n\n    public char[] finishCurrentSegment()\n    {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        // Let's grow segments by 50%\n        int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN);\n        char[] curr = _charArray(newLen);\n        _currentSize = 0;\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50%\n        final int len = curr.length;\n        // Must grow by at least 1 char, no matter what\n        int newLen = (len == MAX_SEGMENT_LEN) ?\n            (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override\n    public String toString() {\n         return contentsAsString();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = findBuffer(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        int oldLen = curr.length;\n        // Let's grow segments by 50% minimum\n        int sizeAddition = oldLen >> 1;\n        if (sizeAddition < minNewSegmentSize) {\n            sizeAddition = minNewSegmentSize;\n        }\n        _currentSize = 0;\n        _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n    }\n\n    private char[] buildResultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = _charArray(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = (char[]) _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] _charArray(int len) {\n        return new char[len];\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator)\n    {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = findBuffer(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] findBuffer(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset()\n    {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null) {\n            return true;\n        }\n        // not if we have String as value\n        if (_resultString != null) {\n            return false;\n        }\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) {\n            return _inputBuffer;\n        }\n        if (_resultArray != null) {\n            return _resultArray;\n        }\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments) {\n            return _currentSegment;\n        }\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray()\n    {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = buildResultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble()\n        throws NumberFormatException\n    {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = findBuffer(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = findBuffer(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() {\n        return _currentSize;\n    }\n\n    public void setCurrentLength(int len) {\n        _currentSize = len;\n    }\n\n    public char[] finishCurrentSegment()\n    {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        // Let's grow segments by 50%\n        int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN);\n        char[] curr = _charArray(newLen);\n        _currentSize = 0;\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50%\n        final int len = curr.length;\n        // Must grow by at least 1 char, no matter what\n        int newLen = (len == MAX_SEGMENT_LEN) ?\n            (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override\n    public String toString() {\n         return contentsAsString();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = findBuffer(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        int oldLen = curr.length;\n        // Let's grow segments by 50% minimum\n        int sizeAddition = oldLen >> 1;\n        if (sizeAddition < minNewSegmentSize) {\n            sizeAddition = minNewSegmentSize;\n        }\n        _currentSize = 0;\n        _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n    }\n\n    private char[] buildResultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = _charArray(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = (char[]) _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] _charArray(int len) {\n        return new char[len];\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 2, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n        // caller had pushed it back, before calling; reset\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic final class ReaderBasedJsonParser\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _reader;\n    }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg)\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(eofMsg);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers()\n        throws IOException\n    {\n        super._releaseBuffers();\n        char[] buf = _inputBuffer;\n        if (buf != null) {\n            _inputBuffer = null;\n            _ioContext.releaseTokenBuffer(buf);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n            throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException, JsonParseException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        _symbols.release();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == '.') { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == 'e' || ch == 'E') { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(ch);\n            }\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return _parseNumber2(negative);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private JsonToken _parseNumber2(boolean negative) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(negative, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        /* First: let's try to see if we have a simple name: one that does\n         * not cross input buffer boundary, and does not contain escape\n         * sequences.\n         */\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        int start = _inputPtr;\n                        _inputPtr = ptr+1; // to skip the quote\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, and not a number\n            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inputPtr = _inputPtr;\n        int inputLen = _inputEnd;\n        char[] inputBuffer = _inputBuffer;\n\n        while (true) {\n            if (inputPtr >= inputLen) {\n                _inputPtr = inputPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inputPtr = _inputPtr;\n                inputLen = _inputEnd;\n            }\n            char c = inputBuffer[inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inputPtr;\n                    c = _decodeEscaped();\n                    inputPtr = _inputPtr;\n                    inputLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inputPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inputPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i >= 64) {\n                return i;\n            }\n            switch (codes[i]) {\n            case -1:\n                _throwInvalidSpace(i);\n            case 0:\n                return i;\n            case 1:\n                continue;\n            case '\\n':\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case '\\r':\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n */\npublic final class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected BytesToNameCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Low-level reading, other\n    /**********************************************************\n     */\n\n    @Override\n    protected boolean loadMore()\n        throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected boolean _loadToHaveAtLeast(int minAvailable)\n        throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        Name n = _parseFieldName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        // Let's do a quickie check:\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private JsonToken _nextTokenNotInObject(int i)\n        throws IOException, JsonParseException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        // Merge found symbols, if any:\n        _symbols.release();\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n    \n    @Override\n    public boolean nextFieldName(SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { // yes, match!\n                            _inputPtr = end+1; // skip current value first\n                            // First part is simple; setting of name\n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            // But then we also must handle following value etc\n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private void _isNextTokenNameYes()\n        throws IOException, JsonParseException\n    {\n        // very first thing: common case, colon, value, no white space\n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private boolean _isNextTokenNameMaybe(int i, SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // and this is back to standard nextToken()\n            \n        Name n = _parseFieldName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /* (note: in 1.6 and prior, part of \"Utf8NumericParser\"\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }\n    \n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private int _verifyNoLeadingZeroes()\n        throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n        // caller had pushed it back, before calling; reset\n        // TODO? Handle UTF-8 char decoding for error reporting\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected Name parseMediumName(int q2, final int[] codes)\n        throws IOException, JsonParseException\n    {\n        // Ok, got 5 name bytes so far\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected Name slowParseName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private Name parseName(int q1, int ch, int lastQuadBytes)\n        throws IOException, JsonParseException\n    {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private Name parseName(int q1, int q2, int ch, int lastQuadBytes)\n        throws IOException, JsonParseException\n    {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, or ones crossing input buffer boundary). In any case,\n     * needs to be able to handle more exceptional cases, gets\n     * slower, and hance is offlined to a separate method.\n     */\n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes)\n        throws IOException, JsonParseException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected Name _handleOddName(int ch)\n        throws IOException, JsonParseException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected Name _parseAposName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private Name findName(int q1, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private Name findName(int q1, int q2, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n        throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private Name addName(int[] quads, int qlen, int lastQuadBytes)\n        throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i)\n        throws IOException\n    {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n            return;\n        }\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    protected void _reportInvalidToken(String matchedPart)\n       throws IOException\n    {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here (nor fast).\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            char c = (char) _decodeCharForError(i);\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n    \n    private final int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                // Is this good enough error message?\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private int _skipColon() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        // first fast case: we just got a colon without white space:\n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            // need to skip potential leading space\n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            // either way, found colon, skip through trailing WS\n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = (int) firstByte;\n        if (c < 0) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n */\npublic final class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected BytesToNameCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Low-level reading, other\n    /**********************************************************\n     */\n\n    @Override\n    protected boolean loadMore()\n        throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected boolean _loadToHaveAtLeast(int minAvailable)\n        throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case VALUE_STRING:\n            // fall through\n        case VALUE_NUMBER_INT:\n        case VALUE_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken) {\n                \n            case FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken) {\n            case FIELD_NAME:\n                return 0;\n            case VALUE_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case VALUE_NUMBER_INT:\n            case VALUE_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        Name n = _parseFieldName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        // Let's do a quickie check:\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private JsonToken _nextTokenNotInObject(int i)\n        throws IOException, JsonParseException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n        // Merge found symbols, if any:\n        _symbols.release();\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n    \n    @Override\n    public boolean nextFieldName(SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { // yes, match!\n                            _inputPtr = end+1; // skip current value first\n                            // First part is simple; setting of name\n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            // But then we also must handle following value etc\n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private void _isNextTokenNameYes()\n        throws IOException, JsonParseException\n    {\n        // very first thing: common case, colon, value, no white space\n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private boolean _isNextTokenNameMaybe(int i, SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // and this is back to standard nextToken()\n            \n        Name n = _parseFieldName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /* (note: in 1.6 and prior, part of \"Utf8NumericParser\"\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }\n    \n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private int _verifyNoLeadingZeroes()\n        throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected Name _parseFieldName(int i)\n        throws IOException, JsonParseException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected Name parseMediumName(int q2, final int[] codes)\n        throws IOException, JsonParseException\n    {\n        // Ok, got 5 name bytes so far\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q)\n        throws IOException, JsonParseException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected Name slowParseName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private Name parseName(int q1, int ch, int lastQuadBytes)\n        throws IOException, JsonParseException\n    {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private Name parseName(int q1, int q2, int ch, int lastQuadBytes)\n        throws IOException, JsonParseException\n    {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, or ones crossing input buffer boundary). In any case,\n     * needs to be able to handle more exceptional cases, gets\n     * slower, and hance is offlined to a separate method.\n     */\n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes)\n        throws IOException, JsonParseException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected Name _handleOddName(int ch)\n        throws IOException, JsonParseException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected Name _parseAposName()\n        throws IOException, JsonParseException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private Name findName(int q1, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private Name findName(int q1, int q2, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n        throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private Name addName(int[] quads, int qlen, int lastQuadBytes)\n        throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i)\n        throws IOException\n    {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n            return;\n        }\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    protected void _reportInvalidToken(String matchedPart)\n       throws IOException\n    {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg)\n        throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here (nor fast).\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            char c = (char) _decodeCharForError(i);\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n    \n    private final int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                // Is this good enough error message?\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private int _skipColon() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        // first fast case: we just got a colon without white space:\n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            // need to skip potential leading space\n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            // either way, found colon, skip through trailing WS\n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = (int) firstByte;\n        if (c < 0) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 3, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected BytesToNameCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        // If we have offset, need to omit that from byte offset, so:\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore()\n        throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable)\n        throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        Name n = _parseName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        // Let's do a quickie check:\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i)\n        throws IOException, JsonParseException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n    \n    @Override\n    public boolean nextFieldName(SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { // yes, match!\n                            _inputPtr = end+1; // skip current value first\n                            // First part is simple; setting of name\n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            // But then we also must handle following value etc\n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private final void _isNextTokenNameYes()\n        throws IOException, JsonParseException\n    {\n        // very first thing: common case, colon, value, no white space\n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // and this is back to standard nextToken()\n            \n        Name n = _parseName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /* (note: in 1.6 and prior, part of \"Utf8NumericParser\"\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }\n    \n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes()\n        throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected Name _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected Name parseMediumName(int q2, final int[] codes) throws IOException\n    {\n        // Ok, got 5 name bytes so far\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q) throws IOException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected Name slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n    {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n    {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, or ones crossing input buffer boundary). In any case,\n     * needs to be able to handle more exceptional cases, gets\n     * slower, and hance is offlined to a separate method.\n     */\n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected Name _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected Name _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final Name findName(int q1, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final Name findName(int q1, int q2, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n        throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n        throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i)\n        throws IOException\n    {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n            return;\n        }\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n    \n    private final int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                // Is this good enough error message?\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private final int _skipColon() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        // first fast case: we just got a colon without white space:\n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            // need to skip potential leading space\n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            // either way, found colon, skip through trailing WS\n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = (int) firstByte;\n        if (c < 0) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.*;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    // White-space processing is done all the time, pre-fetch as well\n    private final static int[] _icWS = CharTypes.getInputCodeWS();\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected BytesToNameCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, BytesToNameCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore()\n        throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable)\n        throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength()\n        throws IOException, JsonParseException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException, JsonParseException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n        throws IOException, JsonParseException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer)\n        throws IOException, JsonParseException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        Name n = _parseName(i);\n        _parsingContext.setCurrentName(n.getName());\n        _currToken = JsonToken.FIELD_NAME;\n\n        // Let's do a quickie check:\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n            ++_inputPtr;\n        } else {\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i)\n        throws IOException, JsonParseException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parseNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n    \n    @Override\n    public boolean nextFieldName(SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            if ((_inputPtr + len) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    final int ptr = _inputPtr;\n                    while (true) {\n                        if (offset == len) { // yes, match!\n                            _inputPtr = end+1; // skip current value first\n                            // First part is simple; setting of name\n                            _parsingContext.setCurrentName(str.getValue());\n                            _currToken = JsonToken.FIELD_NAME;\n                            // But then we also must handle following value etc\n                            _isNextTokenNameYes();\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n                            break;\n                        }\n                        ++offset;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    private final void _isNextTokenNameYes()\n        throws IOException, JsonParseException\n    {\n        // very first thing: common case, colon, value, no white space\n        int i;\n        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n            i = _inputBuffer[++_inputPtr];\n            ++_inputPtr;\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return;\n            }\n            if (i == INT_LCURLY) {\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            }\n            if (i == INT_LBRACKET) {\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            }\n            i &= 0xFF;\n            if (i <= INT_SPACE || i == INT_SLASH) {\n            \t--_inputPtr;\n                i = _skipWS();\n            }\n        } else {\n            i = _skipColon();\n        }\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parseNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str)\n        throws IOException, JsonParseException\n    {\n        // // // and this is back to standard nextToken()\n            \n        Name n = _parseName(i);\n        final boolean match;\n        {\n            String nameStr = n.getName();\n            _parsingContext.setCurrentName(nameStr);\n            match = nameStr.equals(str.getValue());\n        }\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipWS();\n        if (i != INT_COLON) {\n            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n        }\n        i = _skipWS();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue)\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /* (note: in 1.6 and prior, part of \"Utf8NumericParser\"\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parseNumber(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }\n    \n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength)\n        throws IOException, JsonParseException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == '.' || c == 'e' || c == 'E') {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes()\n        throws IOException, JsonParseException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength)\n        throws IOException, JsonParseException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected Name _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i, codes);\n                        }\n                        if (i == INT_QUOTE) { // one byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // one byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // one byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected Name parseMediumName(int q2, final int[] codes) throws IOException\n    {\n        // Ok, got 5 name bytes so far\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        return parseLongName(i);\n    }\n\n    protected Name parseLongName(int q) throws IOException\n    {\n        // As explained above, will ignore UTF-8 encoding at this point\n        final int[] codes = _icLatin1;\n        int qlen = 2;\n\n        while (true) {\n            /* Let's offline if we hit buffer boundary (otherwise would\n             * need to [try to] align input, which is bit complicated\n             * and may not always be possible)\n             */\n            if ((_inputEnd - _inputPtr) < 4) {\n                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n            }\n            // Otherwise can skip boundary checks for 4 bytes in loop\n\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected Name slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n    {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n    {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, or ones crossing input buffer boundary). In any case,\n     * needs to be able to handle more exceptional cases, gets\n     * slower, and hance is offlined to a separate method.\n     */\n    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected Name _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected Name _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return BytesToNameCanonicalizer.getEmptyName();\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final Name findName(int q1, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final Name findName(int q1, int q2, int lastQuadBytes)\n        throws JsonParseException\n    {\n        // Usually we'll find it from the canonical symbol table already\n        Name name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n        throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = lastQuad;\n        Name name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n        throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected void _matchToken(String matchStr, int i)\n        throws IOException\n    {\n        final int len = matchStr.length();\n    \n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n            return;\n        }\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n    \n    private final int _skipWS() throws IOException\n    {\n        final int[] codes = _icWS;\n        while (_inputPtr < _inputEnd || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                // Is this good enough error message?\n                if (i < 32) {\n                    _throwInvalidSpace(i);\n                }\n                _reportInvalidChar(i);\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        final int[] codes = _icWS;\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (codes[i]) {\n            case 0: // done!\n                return i;\n            case 1: // skip\n                continue;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(i);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(i);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(i);\n                break;\n            case INT_LF:\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n                break;\n            case INT_CR:\n                _skipCR();\n                break;\n            case '/':\n                _skipComment();\n                break;\n            case '#':\n                if (!_skipYAMLComment()) {\n                    return i;\n                }\n                break;\n            default: // e.g. -1\n                _reportInvalidChar(i);\n            }\n        }\n        // We ran out of input...\n        _handleEOF();\n        return -1;\n    }\n\n    /**\n     * Helper method for matching and skipping a colon character,\n     * optionally surrounded by white space\n     */\n    private final int _skipColon() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        // first fast case: we just got a colon without white space:\n        int i = _inputBuffer[_inputPtr++];\n        if (i == INT_COLON) {\n            if (_inputPtr < _inputEnd) {\n                i = _inputBuffer[_inputPtr] & 0xFF;\n                if (i > INT_SPACE && i != INT_SLASH) {\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n        } else {\n            // need to skip potential leading space\n            i &= 0xFF;\n            \n            space_loop:\n            while (true) {\n                switch (i) {\n                case ' ':\n                case '\\t':\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case '/':\n                    _skipComment();\n                    break;\n                default:\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    break space_loop;\n                }\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                i = _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n        }\n\n            // either way, found colon, skip through trailing WS\n        while (_inputPtr < _inputEnd || loadMore()) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH) {\n                    return i;\n                }\n                _skipComment();\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = (int) firstByte;\n        if (c < 0) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 4, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.util.TextBuffer", "buggy_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] buf(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal() throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above intended maximum, slow to increase by 25%\n        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override public String toString() { return contentsAsString(); }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        // Let's grow segments by 50% minimum\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] buf(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal() throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        // but above intended maximum, slow to increase by 25%\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override public String toString() { return contentsAsString(); }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        // Let's grow segments by 50% minimum\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 5, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.JsonPointer", "buggy_version": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 6, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.JsonPointer", "buggy_version": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * Implementation of\n * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n * specification.\n * Pointer instances can be used to locate logical JSON nodes for things like\n * tree traversal (see {@link TreeNode#at}).\n * It may be used in future for filtering of streaming JSON content\n * as well (not implemented yet for 2.3).\n *<p>\n * Instances are fully immutable and can be shared, cached.\n * \n * @author Tatu Saloranta\n * \n * @since 2.3\n */\npublic class JsonPointer\n{\n    /**\n     * Marker instance used to represent segment that matches current\n     * node or position.\n     */\n    protected final static JsonPointer EMPTY = new JsonPointer();\n    \n    /**\n     * Reference to rest of the pointer beyond currently matching\n     * segment (if any); null if this pointer refers to a matching\n     * segment.\n     */\n    protected final JsonPointer _nextSegment;\n    \n    /**\n     * We will retain representation of the pointer, as a String,\n     * so that {@link #toString} should be as efficient as possible.\n     */\n    protected final String _asString;\n    \n    protected final String _matchingPropertyName;\n\n    protected final int _matchingElementIndex;\n\n    /*\n    /**********************************************************\n    /* Cosntruction\n    /**********************************************************\n     */\n    \n    /**\n     * Constructor used for creating \"empty\" instance, used to represent\n     * state that matches current node.\n     */\n    protected JsonPointer() {\n        _nextSegment = null;\n        _matchingPropertyName = \"\";\n        _matchingElementIndex = -1;\n        _asString = \"\";\n    }\n\n    /**\n     * Constructor used for creating non-empty Segments\n     */\n    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n        _asString = fullString;\n        _nextSegment = next;\n        // Ok; may always be a property\n        _matchingPropertyName = segment;\n        _matchingElementIndex = _parseIndex(segment);\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method that parses given input and construct matching pointer\n     * instance, if it represents a valid JSON Pointer: if not, a\n     * {@link IllegalArgumentException} is thrown.\n     * \n     * @throws IllegalArgumentException Thrown if the input does not present a valid JSON Pointer\n     *   expression: currently the only such expression is one that does NOT start with\n     *   a slash ('/').\n     */\n    public static JsonPointer compile(String input) throws IllegalArgumentException\n    {\n        // First quick checks for well-known 'empty' pointer\n        if ((input == null) || input.length() == 0) {\n            return EMPTY;\n        }\n        // And then quick validity check:\n        if (input.charAt(0) != '/') {\n            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n        }\n        return _parseTail(input);\n    }\n\n    /**\n     * Alias for {@link #compile}; added to make instances automatically\n     * deserializable by Jackson databind.\n     */\n    public static JsonPointer valueOf(String input) { return compile(input); }\n\n    /* Factory method that composes a pointer instance, given a set\n     * of 'raw' segments: raw meaning that no processing will be done,\n     * no escaping may is present.\n     * \n     * @param segments\n     * \n     * @return Constructed path instance\n     */\n    /* TODO!\n    public static JsonPointer fromSegment(String... segments)\n    {\n        if (segments.length == 0) {\n            return EMPTY;\n        }\n        JsonPointer prev = null;\n                \n        for (String segment : segments) {\n            JsonPointer next = new JsonPointer()\n        }\n    }\n    */\n    \n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************\n     */\n\n    public boolean matches() { return _nextSegment == null; }\n    public String getMatchingProperty() { return _matchingPropertyName; }\n    public int getMatchingIndex() { return _matchingElementIndex; }\n    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n\n    public JsonPointer matchProperty(String name) {\n        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    public JsonPointer matchElement (int index) {\n        if ((index != _matchingElementIndex) || (index < 0)) {\n            return null;\n        }\n        return _nextSegment;\n    }\n\n    /**\n     * Accessor for getting a \"sub-pointer\", instance where current segment\n     * has been removed and pointer includes rest of segments;\n     */\n    public JsonPointer tail() {\n        return _nextSegment;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard method overrides\n    /**********************************************************\n     */\n\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [core#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        // [core#176]: no leading zeroes allowed\n        char c = str.charAt(0);\n        if (c <= '0') {\n            return (len == 1 && c == '0') ? 0 : -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        for (int i = 1; i < len; ++i) {\n            c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n            if (c == '~' && i < end) { // possibly, quote\n                return _parseQuotedTail(input, i);\n            }\n            // otherwise, loop on\n        }\n        // end of the road, no escapes\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n\n    /**\n     * Method called to parse tail of pointer path, when a potentially\n     * escaped character has been seen.\n     * \n     * @param input Full input for the tail being parsed\n     * @param i Offset to character after tilde\n     */\n    protected static JsonPointer _parseQuotedTail(String input, int i) {\n        final int end = input.length();\n        StringBuilder sb = new StringBuilder(Math.max(16, end));\n        if (i > 2) {\n            sb.append(input, 1, i-1);\n        }\n        _appendEscape(sb, input.charAt(i++));\n        while (i < end) {\n            char c = input.charAt(i);\n            if (c == '/') { // end is nigh!\n                return new JsonPointer(input, sb.toString(),\n                        _parseTail(input.substring(i))); // need to push back slash\n            }\n            ++i;\n            if (c == '~' && i < end) {\n                _appendEscape(sb, input.charAt(i++));\n                continue;\n            }\n            sb.append(c);\n        }\n        // end of the road, last segment\n        return new JsonPointer(input, sb.toString(), EMPTY);\n    }\n    \n    private static void _appendEscape(StringBuilder sb, char c) {\n        if (c == '0') {\n            c = '~';\n        } else if (c == '1') {\n            c = '/';\n        } else {\n            sb.append('~');\n        }\n        sb.append(c);\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 7, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.JsonWriteContext", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Extension of {@link JsonStreamContext}, which implements\n * core methods needed, and also exposes\n * more complete API to generator implementation classes.\n */\npublic class JsonWriteContext extends JsonStreamContext\n{\n    // // // Return values for writeValue()\n\n    public final static int STATUS_OK_AS_IS = 0;\n    public final static int STATUS_OK_AFTER_COMMA = 1;\n    public final static int STATUS_OK_AFTER_COLON = 2;\n    public final static int STATUS_OK_AFTER_SPACE = 3; // in root context\n    public final static int STATUS_EXPECT_VALUE = 4;\n    public final static int STATUS_EXPECT_NAME = 5;\n\n    /**\n     * Parent context for this context; null for root context.\n     */\n    protected final JsonWriteContext _parent;\n\n    // // // Optional duplicate detection\n\n    protected DupDetector _dups;\n\n    /*\n    /**********************************************************\n    /* Simple instance reuse slots; speed up things\n    /* a bit (10-15%) for docs with lots of small\n    /* arrays/objects\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _child = null;\n\n    /*\n    /**********************************************************\n    /* Location/state information (minus source reference)\n    /**********************************************************\n     */\n    \n    /**\n     * Name of the field of which value is to be parsed; only\n     * used for OBJECT contexts\n     */\n    protected String _currentName;\n\n    /**\n     * @since 2.5\n     */\n    protected Object _currentValue;\n    \n    /**\n     * Marker used to indicate that we just received a name, and\n     * now expect a value\n     */\n    protected boolean _gotName;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected JsonWriteContext(int type, JsonWriteContext parent, DupDetector dups) {\n        super();\n        _type = type;\n        _parent = parent;\n        _dups = dups;\n        _index = -1;\n    }\n\n    protected JsonWriteContext reset(int type) {\n        _type = type;\n        _index = -1;\n        _currentName = null;\n        _gotName = false;\n        _currentValue = null;\n        if (_dups != null) { _dups.reset(); }\n        return this;\n    }\n\n    public JsonWriteContext withDupDetector(DupDetector dups) {\n        _dups = dups;\n        return this;\n    }\n\n    @Override\n    public Object getCurrentValue() {\n        return _currentValue;\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _currentValue = v;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @deprecated Since 2.3; use method that takes argument\n     */\n    @Deprecated\n    public static JsonWriteContext createRootContext() { return createRootContext(null); }\n\n    public static JsonWriteContext createRootContext(DupDetector dd) {\n        return new JsonWriteContext(TYPE_ROOT, null, dd);\n    }\n\n    public JsonWriteContext createChildArrayContext() {\n        JsonWriteContext ctxt = _child;\n        if (ctxt == null) {\n            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this, (_dups == null) ? null : _dups.child());\n            return ctxt;\n        }\n        return ctxt.reset(TYPE_ARRAY);\n    }\n\n    public JsonWriteContext createChildObjectContext() {\n        JsonWriteContext ctxt = _child;\n        if (ctxt == null) {\n            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this, (_dups == null) ? null : _dups.child());\n            return ctxt;\n        }\n        return ctxt.reset(TYPE_OBJECT);\n    }\n\n    // // // Shared API\n\n    @Override public final JsonWriteContext getParent() { return _parent; }\n    @Override public final String getCurrentName() { return _currentName; }\n\n    public DupDetector getDupDetector() {\n        return _dups;\n    }\n    \n    // // // API sub-classes are to implement\n\n    /**\n     * Method that writer is to call before it writes a field name.\n     *\n     * @return Index of the field entry (0-based)\n     */\n    public int writeFieldName(String name) throws JsonProcessingException {\n        if (_gotName) {\n            return JsonWriteContext.STATUS_EXPECT_VALUE;\n        }\n        _gotName = true;\n        _currentName = name;\n        if (_dups != null) { _checkDup(_dups, name); }\n        return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n\n    private final void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n    }\n    \n    public int writeValue() {\n        // Most likely, object:\n        if (_type == TYPE_OBJECT) {\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n\n        // Ok, array?\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        \n        // Nope, root context\n        // No commas within root context, but need space\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }\n\n    // // // Internally used abstract methods\n\n    protected void appendDesc(StringBuilder sb) {\n        if (_type == TYPE_OBJECT) {\n            sb.append('{');\n            if (_currentName != null) {\n                sb.append('\"');\n                // !!! TODO: Name chars should be escaped?\n                sb.append(_currentName);\n                sb.append('\"');\n            } else {\n                sb.append('?');\n            }\n            sb.append('}');\n        } else if (_type == TYPE_ARRAY) {\n            sb.append('[');\n            sb.append(getCurrentIndex());\n            sb.append(']');\n        } else {\n            // nah, ROOT:\n            sb.append(\"/\");\n        }\n    }\n\n    // // // Overridden standard methods\n\n    /**\n     * Overridden to provide developer writeable \"JsonPath\" representation\n     * of the context.\n     */\n    @Override public String toString() {\n        StringBuilder sb = new StringBuilder(64);\n        appendDesc(sb);\n        return sb.toString();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Extension of {@link JsonStreamContext}, which implements\n * core methods needed, and also exposes\n * more complete API to generator implementation classes.\n */\npublic class JsonWriteContext extends JsonStreamContext\n{\n    // // // Return values for writeValue()\n\n    public final static int STATUS_OK_AS_IS = 0;\n    public final static int STATUS_OK_AFTER_COMMA = 1;\n    public final static int STATUS_OK_AFTER_COLON = 2;\n    public final static int STATUS_OK_AFTER_SPACE = 3; // in root context\n    public final static int STATUS_EXPECT_VALUE = 4;\n    public final static int STATUS_EXPECT_NAME = 5;\n\n    /**\n     * Parent context for this context; null for root context.\n     */\n    protected final JsonWriteContext _parent;\n\n    // // // Optional duplicate detection\n\n    protected DupDetector _dups;\n\n    /*\n    /**********************************************************\n    /* Simple instance reuse slots; speed up things\n    /* a bit (10-15%) for docs with lots of small\n    /* arrays/objects\n    /**********************************************************\n     */\n\n    protected JsonWriteContext _child = null;\n\n    /*\n    /**********************************************************\n    /* Location/state information (minus source reference)\n    /**********************************************************\n     */\n    \n    /**\n     * Name of the field of which value is to be parsed; only\n     * used for OBJECT contexts\n     */\n    protected String _currentName;\n\n    /**\n     * @since 2.5\n     */\n    protected Object _currentValue;\n    \n    /**\n     * Marker used to indicate that we just received a name, and\n     * now expect a value\n     */\n    protected boolean _gotName;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected JsonWriteContext(int type, JsonWriteContext parent, DupDetector dups) {\n        super();\n        _type = type;\n        _parent = parent;\n        _dups = dups;\n        _index = -1;\n    }\n\n    protected JsonWriteContext reset(int type) {\n        _type = type;\n        _index = -1;\n        _currentName = null;\n        _gotName = false;\n        _currentValue = null;\n        if (_dups != null) { _dups.reset(); }\n        return this;\n    }\n\n    public JsonWriteContext withDupDetector(DupDetector dups) {\n        _dups = dups;\n        return this;\n    }\n\n    @Override\n    public Object getCurrentValue() {\n        return _currentValue;\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _currentValue = v;\n    }\n    \n    /*\n    /**********************************************************\n    /* Factory methods\n    /**********************************************************\n     */\n\n    /**\n     * @deprecated Since 2.3; use method that takes argument\n     */\n    @Deprecated\n    public static JsonWriteContext createRootContext() { return createRootContext(null); }\n\n    public static JsonWriteContext createRootContext(DupDetector dd) {\n        return new JsonWriteContext(TYPE_ROOT, null, dd);\n    }\n\n    public JsonWriteContext createChildArrayContext() {\n        JsonWriteContext ctxt = _child;\n        if (ctxt == null) {\n            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this, (_dups == null) ? null : _dups.child());\n            return ctxt;\n        }\n        return ctxt.reset(TYPE_ARRAY);\n    }\n\n    public JsonWriteContext createChildObjectContext() {\n        JsonWriteContext ctxt = _child;\n        if (ctxt == null) {\n            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this, (_dups == null) ? null : _dups.child());\n            return ctxt;\n        }\n        return ctxt.reset(TYPE_OBJECT);\n    }\n\n    // // // Shared API\n\n    @Override public final JsonWriteContext getParent() { return _parent; }\n    @Override public final String getCurrentName() { return _currentName; }\n\n    public DupDetector getDupDetector() {\n        return _dups;\n    }\n    \n    // // // API sub-classes are to implement\n\n    /**\n     * Method that writer is to call before it writes a field name.\n     *\n     * @return Index of the field entry (0-based)\n     */\n    public int writeFieldName(String name) throws JsonProcessingException {\n        if (_gotName) {\n            return JsonWriteContext.STATUS_EXPECT_VALUE;\n        }\n        _gotName = true;\n        _currentName = name;\n        if (_dups != null) { _checkDup(_dups, name); }\n        return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n\n    private final void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n    }\n    \n    public int writeValue() {\n        // Most likely, object:\n        if (_type == TYPE_OBJECT) {\n            if (!_gotName) {\n                return STATUS_EXPECT_NAME;\n            }\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n\n        // Ok, array?\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        \n        // Nope, root context\n        // No commas within root context, but need space\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }\n\n    // // // Internally used abstract methods\n\n    protected void appendDesc(StringBuilder sb) {\n        if (_type == TYPE_OBJECT) {\n            sb.append('{');\n            if (_currentName != null) {\n                sb.append('\"');\n                // !!! TODO: Name chars should be escaped?\n                sb.append(_currentName);\n                sb.append('\"');\n            } else {\n                sb.append('?');\n            }\n            sb.append('}');\n        } else if (_type == TYPE_ARRAY) {\n            sb.append('[');\n            sb.append(getCurrentIndex());\n            sb.append(']');\n        } else {\n            // nah, ROOT:\n            sb.append(\"/\");\n        }\n    }\n\n    // // // Overridden standard methods\n\n    /**\n     * Overridden to provide developer writeable \"JsonPath\" representation\n     * of the context.\n     */\n    @Override public String toString() {\n        StringBuilder sb = new StringBuilder(64);\n        appendDesc(sb);\n        return sb.toString();\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 8, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.util.TextBuffer", "buggy_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] buf(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal() throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    /**\n     * @since 2.6\n     */\n    public String setCurrentAndReturn(int len) {\n        _currentSize = len;\n        // We can simplify handling here compared to full `contentsAsString()`:\n        if (_segmentSize > 0) { // longer text; call main method\n            return contentsAsString();\n        }\n        // more common case: single segment\n        int currLen = _currentSize;\n        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n        _resultString = str;\n        return str;\n    }\n    \n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        // but above intended maximum, slow to increase by 25%\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override public String toString() { return contentsAsString(); }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        // Let's grow segments by 50% minimum\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.io.NumberInput;\n\n/**\n * TextBuffer is a class similar to {@link StringBuffer}, with\n * following differences:\n *<ul>\n *  <li>TextBuffer uses segments character arrays, to avoid having\n *     to do additional array copies when array is not big enough.\n *     This means that only reallocating that is necessary is done only once:\n *     if and when caller\n *     wants to access contents in a linear array (char[], String).\n *    </li>\n*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n*     it will just act as a wrapper to a single char array managed\n*     by another object (like parser that owns it)\n *    </li>\n *  <li>TextBuffer is not synchronized.\n *    </li>\n * </ul>\n */\npublic final class TextBuffer\n{\n    final static char[] NO_CHARS = new char[0];\n\n    /**\n     * Let's start with sizable but not huge buffer, will grow as necessary\n     */\n    final static int MIN_SEGMENT_LEN = 1000;\n    \n    /**\n     * Let's limit maximum segment length to something sensible\n     * like 256k\n     */\n    final static int MAX_SEGMENT_LEN = 0x40000;\n    \n    /*\n    /**********************************************************\n    /* Configuration:\n    /**********************************************************\n     */\n\n    private final BufferRecycler _allocator;\n\n    /*\n    /**********************************************************\n    /* Shared input buffers\n    /**********************************************************\n     */\n\n    /**\n     * Shared input buffer; stored here in case some input can be returned\n     * as is, without being copied to collector's own buffers. Note that\n     * this is read-only for this Object.\n     */\n    private char[] _inputBuffer;\n\n    /**\n     * Character offset of first char in input buffer; -1 to indicate\n     * that input buffer currently does not contain any useful char data\n     */\n    private int _inputStart;\n\n    private int _inputLen;\n\n    /*\n    /**********************************************************\n    /* Aggregation segments (when not using input buf)\n    /**********************************************************\n     */\n\n    /**\n     * List of segments prior to currently active segment.\n     */\n    private ArrayList<char[]> _segments;\n\n    /**\n     * Flag that indicates whether _seqments is non-empty\n     */\n    private boolean _hasSegments = false;\n\n    // // // Currently used segment; not (yet) contained in _seqments\n\n    /**\n     * Amount of characters in segments in {@link _segments}\n     */\n    private int _segmentSize;\n\n    private char[] _currentSegment;\n\n    /**\n     * Number of characters in currently active (last) segment\n     */\n    private int _currentSize;\n\n    /*\n    /**********************************************************\n    /* Caching of results\n    /**********************************************************\n     */\n\n    /**\n     * String that will be constructed when the whole contents are\n     * needed; will be temporarily stored in case asked for again.\n     */\n    private String _resultString;\n\n    private char[] _resultArray;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public TextBuffer(BufferRecycler allocator) {\n        _allocator = allocator;\n    }\n\n    /**\n     * Method called to indicate that the underlying buffers should now\n     * be recycled if they haven't yet been recycled. Although caller\n     * can still use this text buffer, it is not advisable to call this\n     * method if that is likely, since next time a buffer is needed,\n     * buffers need to reallocated.\n     * Note: calling this method automatically also clears contents\n     * of the buffer.\n     */\n    public void releaseBuffers()\n    {\n        if (_allocator == null) {\n            resetWithEmpty();\n        } else {\n            if (_currentSegment != null) {\n                // First, let's get rid of all but the largest char array\n                resetWithEmpty();\n                // And then return that array\n                char[] buf = _currentSegment;\n                _currentSegment = null;\n                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n            }\n        }\n    }\n\n    /**\n     * Method called to clear out any content text buffer may have, and\n     * initializes buffer to use non-shared data.\n     */\n    public void resetWithEmpty()\n    {\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    /**\n     * Method called to initialize the buffer with a shared copy of data;\n     * this means that buffer will just have pointers to actual data. It\n     * also means that if anything is to be appended to the buffer, it\n     * will first have to unshare it (make a local copy).\n     */\n    public void resetWithShared(char[] buf, int start, int len)\n    {\n        // First, let's clear intermediate values, if any:\n        _resultString = null;\n        _resultArray = null;\n\n        // Then let's mark things we need about input buffer\n        _inputBuffer = buf;\n        _inputStart = start;\n        _inputLen = len;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n    }\n\n    public void resetWithCopy(char[] buf, int start, int len)\n    {\n        _inputBuffer = null;\n        _inputStart = -1; // indicates shared buffer not used\n        _inputLen = 0;\n\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        } else if (_currentSegment == null) {\n            _currentSegment = buf(len);\n        }\n        _currentSize = _segmentSize = 0;\n        append(buf, start, len);\n    }\n\n    public void resetWithString(String value)\n    {\n        _inputBuffer = null;\n        _inputStart = -1;\n        _inputLen = 0;\n\n        _resultString = value;\n        _resultArray = null;\n\n        if (_hasSegments) {\n            clearSegments();\n        }\n        _currentSize = 0;\n        \n    }\n    \n    /**\n     * Helper method used to find a buffer to use, ideally one\n     * recycled earlier.\n     */\n    private char[] buf(int needed)\n    {\n        if (_allocator != null) {\n            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n        }\n        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n    }\n\n    private void clearSegments()\n    {\n        _hasSegments = false;\n        /* Let's start using _last_ segment from list; for one, it's\n         * the biggest one, and it's also most likely to be cached\n         */\n        /* 28-Aug-2009, tatu: Actually, the current segment should\n         *   be the biggest one, already\n         */\n        //_currentSegment = _segments.get(_segments.size() - 1);\n        _segments.clear();\n        _currentSize = _segmentSize = 0;\n    }\n\n    /*\n    /**********************************************************\n    /* Accessors for implementing public interface\n    /**********************************************************\n     */\n\n    /**\n     * @return Number of characters currently stored by this collector\n     */\n    public int size() {\n        if (_inputStart >= 0) { // shared copy from input buf\n            return _inputLen;\n        }\n        if (_resultArray != null) {\n            return _resultArray.length;\n        }\n        if (_resultString != null) {\n            return _resultString.length();\n        }\n        // local segmented buffers\n        return _segmentSize + _currentSize;\n    }\n\n    public int getTextOffset() {\n        /* Only shared input buffer can have non-zero offset; buffer\n         * segments start at 0, and if we have to create a combo buffer,\n         * that too will start from beginning of the buffer\n         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n                    int currLen = _currentSize;\n                    \n                    if (segLen == 0) { // yup\n                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n                    } else { // no, need to combine\n                        StringBuilder sb = new StringBuilder(segLen + currLen);\n                        // First stored segments\n                        if (_segments != null) {\n                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                                char[] curr = _segments.get(i);\n                                sb.append(curr, 0, curr.length);\n                            }\n                        }\n                        // And finally, current segment:\n                        sb.append(_currentSegment, 0, _currentSize);\n                        _resultString = sb.toString();\n                    }\n                }\n            }\n        }\n        return _resultString;\n    }\n \n    public char[] contentsAsArray() {\n        char[] result = _resultArray;\n        if (result == null) {\n            _resultArray = result = resultArray();\n        }\n        return result;\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */\n    public BigDecimal contentsAsDecimal() throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if ((_inputStart >= 0) && (_inputBuffer != null)) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if ((_segmentSize == 0) && (_currentSegment != null)) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }\n\n    /**\n     * Convenience method for converting contents of the buffer\n     * into a Double value.\n     */\n    public double contentsAsDouble() throws NumberFormatException {\n        return NumberInput.parseDouble(contentsAsString());\n    }\n\n    /*\n    /**********************************************************\n    /* Public mutators:\n    /**********************************************************\n     */\n\n    /**\n     * Method called to make sure that buffer is not using shared input\n     * buffer; if it is, it will copy such contents to private buffer.\n     */\n    public void ensureNotShared() {\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n    }\n\n    public void append(char c) {\n        // Using shared buffer so far?\n        if (_inputStart >= 0) {\n            unshare(16);\n        }\n        _resultString = null;\n        _resultArray = null;\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        if (_currentSize >= curr.length) {\n            expand(1);\n            curr = _currentSegment;\n        }\n        curr[_currentSize++] = c;\n    }\n\n    public void append(char[] c, int start, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n            \n        if (max >= len) {\n            System.arraycopy(c, start, curr, _currentSize, len);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            System.arraycopy(c, start, curr, _currentSize, max);\n            start += max;\n            len -= max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            System.arraycopy(c, start, _currentSegment, 0, amount);\n            _currentSize += amount;\n            start += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    public void append(String str, int offset, int len)\n    {\n        // Can't append to shared buf (sanity check)\n        if (_inputStart >= 0) {\n            unshare(len);\n        }\n        _resultString = null;\n        _resultArray = null;\n\n        // Room in current segment?\n        char[] curr = _currentSegment;\n        int max = curr.length - _currentSize;\n        if (max >= len) {\n            str.getChars(offset, offset+len, curr, _currentSize);\n            _currentSize += len;\n            return;\n        }\n        // No room for all, need to copy part(s):\n        if (max > 0) {\n            str.getChars(offset, offset+max, curr, _currentSize);\n            len -= max;\n            offset += max;\n        }\n        /* And then allocate new segment; we are guaranteed to now\n         * have enough room in segment.\n         */\n        // Except, as per [Issue-24], not for HUGE appends... so:\n        do {\n            expand(len);\n            int amount = Math.min(_currentSegment.length, len);\n            str.getChars(offset, offset+amount, _currentSegment, 0);\n            _currentSize += amount;\n            offset += amount;\n            len -= amount;\n        } while (len > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Raw access, for high-performance use:\n    /**********************************************************\n     */\n\n    public char[] getCurrentSegment()\n    {\n        /* Since the intention of the caller is to directly add stuff into\n         * buffers, we should NOT have anything in shared buffer... ie. may\n         * need to unshare contents.\n         */\n        if (_inputStart >= 0) {\n            unshare(1);\n        } else {\n            char[] curr = _currentSegment;\n            if (curr == null) {\n                _currentSegment = buf(0);\n            } else if (_currentSize >= curr.length) {\n                // Plus, we better have room for at least one more char\n                expand(1);\n            }\n        }\n        return _currentSegment;\n    }\n\n    public char[] emptyAndGetCurrentSegment()\n    {\n        // inlined 'resetWithEmpty()'\n        _inputStart = -1; // indicates shared buffer not used\n        _currentSize = 0;\n        _inputLen = 0;\n\n        _inputBuffer = null;\n        _resultString = null;\n        _resultArray = null;\n\n        // And then reset internal input buffers, if necessary:\n        if (_hasSegments) {\n            clearSegments();\n        }\n        char[] curr = _currentSegment;\n        if (curr == null) {\n            _currentSegment = curr = buf(0);\n        }\n        return curr;\n    }\n\n    public int getCurrentSegmentSize() { return _currentSize; }\n    public void setCurrentLength(int len) { _currentSize = len; }\n\n    /**\n     * @since 2.6\n     */\n    public String setCurrentAndReturn(int len) {\n        _currentSize = len;\n        // We can simplify handling here compared to full `contentsAsString()`:\n        if (_segmentSize > 0) { // longer text; call main method\n            return contentsAsString();\n        }\n        // more common case: single segment\n        int currLen = _currentSize;\n        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n        _resultString = str;\n        return str;\n    }\n    \n    public char[] finishCurrentSegment() {\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        _hasSegments = true;\n        _segments.add(_currentSegment);\n        int oldLen = _currentSegment.length;\n        _segmentSize += oldLen;\n        _currentSize = 0;\n\n        // Let's grow segments by 50%\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        char[] curr = carr(newLen);\n        _currentSegment = curr;\n        return curr;\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        int newLen = len + (len >> 1);\n        // but above intended maximum, slow to increase by 25%\n        if (newLen > MAX_SEGMENT_LEN) {\n            newLen = len + (len >> 2);\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n\n    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     * \n     * @param minSize Required minimum strength of the current segment\n     *\n     * @since 2.4.0\n     */\n    public char[] expandCurrentSegment(int minSize) {\n        char[] curr = _currentSegment;\n        if (curr.length >= minSize) return curr;\n        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n        return curr;\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods:\n    /**********************************************************\n     */\n\n    /**\n     * Note: calling this method may not be as efficient as calling\n     * {@link #contentsAsString}, since it's not guaranteed that resulting\n     * String is cached.\n     */\n    @Override public String toString() { return contentsAsString(); }\n\n    /*\n    /**********************************************************\n    /* Internal methods:\n    /**********************************************************\n     */\n\n    /**\n     * Method called if/when we need to append content when we have been\n     * initialized to use shared buffer.\n     */\n    private void unshare(int needExtra)\n    {\n        int sharedLen = _inputLen;\n        _inputLen = 0;\n        char[] inputBuf = _inputBuffer;\n        _inputBuffer = null;\n        int start = _inputStart;\n        _inputStart = -1;\n\n        // Is buffer big enough, or do we need to reallocate?\n        int needed = sharedLen+needExtra;\n        if (_currentSegment == null || needed > _currentSegment.length) {\n            _currentSegment = buf(needed);\n        }\n        if (sharedLen > 0) {\n            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n        }\n        _segmentSize = 0;\n        _currentSize = sharedLen;\n    }\n\n    /**\n     * Method called when current segment is full, to allocate new\n     * segment.\n     */\n    private void expand(int minNewSegmentSize)\n    {\n        // First, let's move current segment to segment list:\n        if (_segments == null) {\n            _segments = new ArrayList<char[]>();\n        }\n        char[] curr = _currentSegment;\n        _hasSegments = true;\n        _segments.add(curr);\n        _segmentSize += curr.length;\n        _currentSize = 0;\n        int oldLen = curr.length;\n        \n        // Let's grow segments by 50% minimum\n        int newLen = oldLen + (oldLen >> 1);\n        if (newLen < MIN_SEGMENT_LEN) {\n            newLen = MIN_SEGMENT_LEN;\n        } else if (newLen > MAX_SEGMENT_LEN) {\n            newLen = MAX_SEGMENT_LEN;\n        }\n        _currentSegment = carr(newLen);\n    }\n\n    private char[] resultArray()\n    {\n        if (_resultString != null) { // Can take a shortcut...\n            return _resultString.toCharArray();\n        }\n        // Do we use shared array?\n        if (_inputStart >= 0) {\n            final int len = _inputLen;\n            if (len < 1) {\n                return NO_CHARS;\n            }\n            final int start = _inputStart;\n            if (start == 0) {\n                return Arrays.copyOf(_inputBuffer, len);\n            }\n            return Arrays.copyOfRange(_inputBuffer, start, start+len);\n        }\n        // nope, not shared\n        int size = size();\n        if (size < 1) {\n            return NO_CHARS;\n        }\n        int offset = 0;\n        final char[] result = carr(size);\n        if (_segments != null) {\n            for (int i = 0, len = _segments.size(); i < len; ++i) {\n                char[] curr = _segments.get(i);\n                int currLen = curr.length;\n                System.arraycopy(curr, 0, result, offset, currLen);\n                offset += currLen;\n            }\n        }\n        System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n        return result;\n    }\n\n    private char[] carr(int len) { return new char[len]; }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 9, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.base.ParserMinimalBase", "buggy_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    // Control chars:\n    protected final static int INT_TAB = '\\t';\n    protected final static int INT_LF = '\\n';\n    protected final static int INT_CR = '\\r';\n    protected final static int INT_SPACE = 0x0020;\n\n    // Markup\n    protected final static int INT_LBRACKET = '[';\n    protected final static int INT_RBRACKET = ']';\n    protected final static int INT_LCURLY = '{';\n    protected final static int INT_RCURLY = '}';\n    protected final static int INT_QUOTE = '\"';\n    protected final static int INT_BACKSLASH = '\\\\';\n    protected final static int INT_SLASH = '/';\n    protected final static int INT_COLON = ':';\n    protected final static int INT_COMMA = ',';\n    protected final static int INT_HASH = '#';\n\n    // fp numbers\n    protected final static int INT_PERIOD = '.';\n    protected final static int INT_e = 'e';\n    protected final static int INT_E = 'E';\n\n    /*\n    /**********************************************************\n    /* Minimal generally useful state\n    /**********************************************************\n     */\n    \n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    // NOTE: had base impl in 2.3 and before; but shouldn't\n    // public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Configuration overrides if any\n    /**********************************************************\n     */\n\n    // from base class:\n\n    //public void enableFeature(Feature f)\n    //public void disableFeature(Feature f)\n    //public void setFeature(Feature f, boolean state)\n    //public boolean isFeatureEnabled(Feature f)\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        /* Implementation should be as trivial as follows; only\n         * needs to change if we are to skip other tokens (for\n         * example, if comments were exposed as tokens)\n         */\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        /* Since proper matching of start/end markers is handled\n         * by nextToken(), we'll just count nesting levels here\n         */\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                /* given constraints, above should never return;\n                 * however, FindBugs doesn't know about it and\n                 * complains... so let's add dummy break here\n                 */\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name);\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base64 decoding\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that can be used for base64 decoding in cases where\n     * encoded content has already been read as a String.\n     */\n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException\n    {\n        // just call helper method introduced in 2.2.3\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    /**\n     * @param bindex Relative index within base64 character unit; between 0\n     *   and 3 (as unit has exactly 4 characters)\n     *   \n     * @deprecated in 2.2.3; should migrate away\n     */\n    @Deprecated\n    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n        throws JsonParseException\n    {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        throw _constructError(base);\n    }\n\n    /**\n     *   \n     * @deprecated in 2.2.3; should migrate away\n     */\n    @Deprecated\n    protected void _reportBase64EOF() throws JsonParseException {\n        throw _constructError(\"Unexpected end-of-String in base64 content\");\n    }\n\n    /*\n    /**********************************************************\n    /* Coercion helper methods (overridable)\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to determine whether we are currently pointing to\n     * a String value of \"null\" (NOT a null token); and, if so, that parser\n     * is to recognize and return it similar to if it was real null token.\n     * \n     * @since 2.3\n     */\n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n    \n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n    \n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException\n    {\n        if (ch < 0) { // sanity check\n            _reportInvalidEOF();\n        }\n        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\";\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken);\n    }\n\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        _reportError(\"Unexpected end-of-input\"+msg);\n    }\n\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n\n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    /**\n     * Method called to report a problem with unquoted control character.\n     * Note: starting with version 1.4, it is possible to suppress\n     * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n     */\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        // JACKSON-208; possible to allow unquoted control chars:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        // as per [JACKSON-300]\n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        // and [JACKSON-548]\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n    \n    /*\n    /**********************************************************\n    /* Error reporting, generic\n    /**********************************************************\n     */\n\n    protected final static String _getCharDesc(int ch)\n    {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(msg, getCurrentLocation(), t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n    \n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { // never occurs\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    // Control chars:\n    protected final static int INT_TAB = '\\t';\n    protected final static int INT_LF = '\\n';\n    protected final static int INT_CR = '\\r';\n    protected final static int INT_SPACE = 0x0020;\n\n    // Markup\n    protected final static int INT_LBRACKET = '[';\n    protected final static int INT_RBRACKET = ']';\n    protected final static int INT_LCURLY = '{';\n    protected final static int INT_RCURLY = '}';\n    protected final static int INT_QUOTE = '\"';\n    protected final static int INT_BACKSLASH = '\\\\';\n    protected final static int INT_SLASH = '/';\n    protected final static int INT_COLON = ':';\n    protected final static int INT_COMMA = ',';\n    protected final static int INT_HASH = '#';\n\n    // fp numbers\n    protected final static int INT_PERIOD = '.';\n    protected final static int INT_e = 'e';\n    protected final static int INT_E = 'E';\n\n    /*\n    /**********************************************************\n    /* Minimal generally useful state\n    /**********************************************************\n     */\n    \n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    // NOTE: had base impl in 2.3 and before; but shouldn't\n    // public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Configuration overrides if any\n    /**********************************************************\n     */\n\n    // from base class:\n\n    //public void enableFeature(Feature f)\n    //public void disableFeature(Feature f)\n    //public void setFeature(Feature f, boolean state)\n    //public boolean isFeatureEnabled(Feature f)\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        /* Implementation should be as trivial as follows; only\n         * needs to change if we are to skip other tokens (for\n         * example, if comments were exposed as tokens)\n         */\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        /* Since proper matching of start/end markers is handled\n         * by nextToken(), we'll just count nesting levels here\n         */\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                /* given constraints, above should never return;\n                 * however, FindBugs doesn't know about it and\n                 * complains... so let's add dummy break here\n                 */\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name);\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return getLongValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base64 decoding\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that can be used for base64 decoding in cases where\n     * encoded content has already been read as a String.\n     */\n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException\n    {\n        // just call helper method introduced in 2.2.3\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    /**\n     * @param bindex Relative index within base64 character unit; between 0\n     *   and 3 (as unit has exactly 4 characters)\n     *   \n     * @deprecated in 2.2.3; should migrate away\n     */\n    @Deprecated\n    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n        throws JsonParseException\n    {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        throw _constructError(base);\n    }\n\n    /**\n     *   \n     * @deprecated in 2.2.3; should migrate away\n     */\n    @Deprecated\n    protected void _reportBase64EOF() throws JsonParseException {\n        throw _constructError(\"Unexpected end-of-String in base64 content\");\n    }\n\n    /*\n    /**********************************************************\n    /* Coercion helper methods (overridable)\n    /**********************************************************\n     */\n    \n    /**\n     * Helper method used to determine whether we are currently pointing to\n     * a String value of \"null\" (NOT a null token); and, if so, that parser\n     * is to recognize and return it similar to if it was real null token.\n     * \n     * @since 2.3\n     */\n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n    \n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n    \n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException\n    {\n        if (ch < 0) { // sanity check\n            _reportInvalidEOF();\n        }\n        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\";\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken);\n    }\n\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        _reportError(\"Unexpected end-of-input\"+msg);\n    }\n\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n\n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    /**\n     * Method called to report a problem with unquoted control character.\n     * Note: starting with version 1.4, it is possible to suppress\n     * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n     */\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        // JACKSON-208; possible to allow unquoted control chars:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        // as per [JACKSON-300]\n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        // and [JACKSON-548]\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n    \n    /*\n    /**********************************************************\n    /* Error reporting, generic\n    /**********************************************************\n     */\n\n    protected final static String _getCharDesc(int ch)\n    {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(msg, getCurrentLocation(), t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n    \n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { // never occurs\n            throw new RuntimeException(e);\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     * \n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n            \n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n        \n        int intLen = 1; // already got one\n        \n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n        \n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n        \n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n    \n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n \n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n    \n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n    \n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     * \n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n    \n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n    \n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n    \n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, traversal\n   /**********************************************************\n    */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    @Override\n    public boolean nextFieldName(SerializableString str)\n         throws IOException\n     */\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n            \n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n        \n        int intLen = 1; // already got one\n        \n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n        \n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n        \n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n    \n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n    \n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n  \n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n    \n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n    \n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n \n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n    \n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n    \n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n    \n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n    \n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n\n        // First, need to ensure we know the starting location of token\n        // after skipping leading white space\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n    \n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n    \n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n    \n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n    \n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n    \n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        return new JsonLocation(_ioContext.getSourceReference(),\n                getTokenCharacterOffset(), -1L, // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    // As per [Issue#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n\n        // First, need to ensure we know the starting location of token\n        // after skipping leading white space\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        \n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n    \n    \n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        switch (nextToken().id()) {\n        case ID_TRUE:\n            return Boolean.TRUE;\n        case ID_FALSE:\n            return Boolean.FALSE;\n        default:\n            return null;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consequtively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n    \n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 10, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer", "buggy_version": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    /**\n     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n     * themselves).\n     */\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n\n    /**\n     * Let's not expand symbol tables past some maximum size;\n     * this should protected against OOMEs caused by large documents\n     * with unique (~= random) names.\n     * Size is in \n     */\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n\n    /**\n     * No point in trying to construct tiny tables, just need to resize soon.\n     */\n    final static int MIN_HASH_SIZE = 16;\n    \n    /**\n     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n     * this corresponds to 256k main hash index. This should allow for enough distinct\n     * names for almost any case, while preventing ballooning for cases where names\n     * are unique (or close thereof).\n     */\n    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n\n    /*\n    /**********************************************************\n    /* Linkage, needed for merging symbol tables\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the root symbol table, for child tables, so\n     * that they can merge table information back as necessary.\n     */\n    final protected ByteQuadsCanonicalizer _parent;\n\n    /**\n     * Member that is only used by the root table instance: root\n     * passes immutable state into child instances, and children\n     * may return new state if they add entries to the table.\n     * Child tables do NOT use the reference.\n     */\n    final protected AtomicReference<TableInfo> _tableInfo;\n    \n    /**\n     * Seed value we use as the base to make hash codes non-static between\n     * different runs, but still stable for lifetime of a single symbol table\n     * instance.\n     * This is done for security reasons, to avoid potential DoS attack via\n     * hash collisions.\n     */\n    final private int _seed;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Whether canonical symbol Strings are to be intern()ed before added\n     * to the table or not.\n     *<p>\n     * NOTE: non-final to allow disabling intern()ing in case of excessive\n     * collisions.\n     */\n    protected boolean _intern;\n\n    /**\n     * Flag that indicates whether we should throw an exception if enough \n     * hash collisions are detected (true); or just worked around (false).\n     * \n     * @since 2.4\n     */\n    protected final boolean _failOnDoS;\n    \n    /*\n    /**********************************************************\n    /* First, main hash area info\n    /**********************************************************\n     */\n\n    /**\n     * Primary hash information area: consists of <code>2 * _hashSize</code>\n     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n     * structure (details of which may be tweaked depending on expected rates\n     * of collisions).\n     */\n    protected int[] _hashArea;\n\n    /**\n     * Number of slots for primary entries within {@link #_hashArea}; which is\n     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n     * primary covers only half of the area; plus, additional area for longer\n     * symbols after hash area).\n     */\n    protected int _hashSize;\n\n    /**\n     * Offset within {@link #_hashArea} where secondary entries start\n     */\n    protected int _secondaryStart;\n\n    /**\n     * Offset within {@link #_hashArea} where tertiary entries start\n     */\n    protected int _tertiaryStart;\n    \n    /**\n     * Constant that determines size of buckets for tertiary entries:\n     * <code>1 &lt;&lt; _tertiaryShift</code> is the size, and shift value\n     * is also used for translating from primary offset into\n     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n     *<p>\n     * Default value is 2, for buckets of 4 slots; grows bigger with\n     * bigger table sizes.\n     */\n    protected int _tertiaryShift;\n\n    /**\n     * Total number of Strings in the symbol table; only used for child tables.\n     */\n    protected int _count;\n\n    /**\n     * Array that contains <code>String</code> instances matching\n     * entries in {@link #_hashArea}.\n     * Contains nulls for unused entries. Note that this size is twice\n     * that of {@link #_hashArea}\n     */\n    protected String[] _names;\n\n    /*\n    /**********************************************************\n    /* Then information on collisions etc\n    /**********************************************************\n     */\n\n    /**\n     * Pointer to the offset within spill-over area where there is room\n     * for more spilled over entries (if any).\n     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n     */\n    protected int _spilloverEnd;\n\n    /**\n     * Offset within {@link #_hashArea} that follows main slots and contains\n     * quads for longer names (13 bytes or longers), and points to the\n     * first available int that may be used for appending quads of the next\n     * long name.\n     * Note that long name area follows immediately after the fixed-size\n     * main hash area ({@link #_hashArea}).\n     */\n    protected int _longNameOffset;\n\n    /**\n     * This flag is set if, after adding a new entry, it is deemed\n     * that a rehash is warranted if any more entries are to be added.\n     */\n    private transient boolean _needRehash;\n\n    /*\n    /**********************************************************\n    /* Sharing, versioning\n    /**********************************************************\n     */\n\n    // // // Which of the buffers may be shared (and are copy-on-write)?\n\n    /**\n     * Flag that indicates whether underlying data structures for\n     * the main hash area are shared or not. If they are, then they\n     * need to be handled in copy-on-write way, i.e. if they need\n     * to be modified, a copy needs to be made first; at this point\n     * it will not be shared any more, and can be modified.\n     *<p>\n     * This flag needs to be checked both when adding new main entries,\n     * and when adding new collision list queues (i.e. creating a new\n     * collision list head entry)\n     */\n    private boolean _hashShared;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n     * symbol tables: ones used for merging and sharing common symbols\n     * \n     * @param sz Initial primary hash area size\n     * @param intern Whether Strings contained should be {@link String#intern}ed\n     * @param seed Random seed valued used to make it more difficult to cause\n     *   collisions (used for collision-based DoS attacks).\n     */\n    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        // Sanity check: let's now allow hash sizes below certain minimum value\n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            // Also; size must be 2^N; otherwise hash algorithm won't\n            // work... so let's just pad it up, if so\n            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    /**\n     * Constructor used when creating a child instance\n     */\n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n            int seed, boolean failOnDoS, TableInfo state)\n    {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; // not used by child tables\n\n        // Then copy shared state\n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; // right after primary area\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        // and then set other state to reflect sharing status\n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle: factory methods, merging\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot() {\n        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n         * based attacks.\n         */\n        long now = System.currentTimeMillis();\n        // ensure it's not 0; and might as well require to be odd so:\n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    /**\n     * Factory method used to create actual symbol table instance to\n     * use for parsing.\n     */\n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    /**\n     * Method called by the using code to indicate it is done\n     * with this instance. This lets instance merge accumulated\n     * changes into parent (if need be), safely and efficiently,\n     * and without calling code having to know about parent\n     * information\n     */\n    public void release()\n    {\n        // we will try to merge if child table has new entries\n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            /* Let's also mark this instance as dirty, so that just in\n             * case release was too early, there's no corruption of possibly shared data.\n             */\n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState)\n    {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        // Should usually grow; but occasionally could also shrink if (but only if)\n        // collision list overflow ends up clearing some collision lists.\n        if (childCount == currState.count) {\n            return;\n        }\n\n        // One caveat: let's try to avoid problems with degenerate cases of documents with\n        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n        // One way to do this is to just purge tables if they grow\n        // too large, and that's what we'll do here.\n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            // At any rate, need to clean up the tables\n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    /*\n    /**********************************************************\n    /* API, accessors\n    /**********************************************************\n     */\n\n    public int size()\n    {\n        if (_tableInfo != null) { // root table\n            return _tableInfo.get().count;\n        }\n        // nope, child table\n        return _count;\n    }\n\n    /**\n     * Returns number of primary slots table has currently\n     */\n    public int bucketCount() { return _hashSize; }\n\n    /**\n     * Method called to check to quickly see if a child symbol table\n     * may have gotten additional entries. Used for checking to see\n     * if a child table should be merged into shared table.\n     */\n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    /**\n     * Method mostly needed by unit tests; calculates number of\n     * entries that are in the primary slot set. These are\n     * \"perfect\" entries, accessible with a single lookup\n     */\n    public int primaryCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in secondary buckets\n     */\n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in tertiary buckets\n     */\n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in shared spillover area\n     */\n    public int spilloverCount() {\n        // difference between spillover end, start, divided by 4 (four ints per slot)\n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, accessing symbols\n    /**********************************************************\n     */\n\n    public String findName(int q1)\n    {\n        int offset = _calcOffset(calcHash(q1));\n        // first: primary match?\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary? single slot shared by N/2 primaries\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n\n        // tertiary lookup & spillovers best to offline\n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2)\n    {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3)\n    {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen)\n    {\n        /* This version differs significantly, because longer names do not fit within cell.\n         * Rather, they contain hash in main slot, and offset+length to extension area\n         * that contains actual quads.\n         */\n        if (qlen < 4) { // another sanity check\n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            // probable but not guaranteed: verify\n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access from spill-over areas\n    /**********************************************************\n     */\n\n    private String _findSecondary(int origOffset, int q1)\n    {\n        // tertiary area division is dynamic. First; its size is N/4 compared to\n        // primary hash size; and offsets are for 4 int slots. So to get to logical\n        // index would shift by 4. But! Tertiary area is further split into buckets,\n        // determined by shift value. And finally, from bucket back into physical offsets\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        // but if tertiary full, check out spill-over area as last resort\n        // shared spillover starts at 7/8 of the main hash area\n        // (which is sized at 2 * _hashSize), so:\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n    {\n        final int[] hashArea = _hashArea;\n        // spillOffset assumed to be physical index right into quad string\n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: // always at least 4\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n    {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* API, mutators\n    /**********************************************************\n     */\n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n    \n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        if (_spilloverEnd >= hashArea.length) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen)\n    {\n        int start = _longNameOffset;\n        \n        // note: at this point we must already be shared. But may not have enough space\n        if ((start + qlen) > _hashArea.length) {\n            // try to increment in reasonable chunks; at least space that we need\n            int toAdd = (start + qlen) - _hashArea.length;\n            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    /*\n    /**********************************************************\n    /* Hash calculation\n    /**********************************************************\n     */\n\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n        hash ^= (hash >>> 12);\n        return hash;\n    }\n\n    public int calcHash(int q1, int q2)\n    {\n        // For two quads, let's change algorithm a bit, to spice\n        // things up (can do bit more processing anyway)\n        int hash = q1;\n\n        hash += (hash >>> 15); // try mixing first and second byte pairs first\n        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n        hash += (q2 * MULT); // then add second quad\n        hash ^= _seed;\n        hash += (hash >>> 16); // and shuffle some more\n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3)\n    { // use same algorithm as multi-byte, tested to work well\n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen)\n    {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        // and finally shuffle some more once done\n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    /*\n    /**********************************************************\n    /* Rehashing\n    /**********************************************************\n     */\n\n    private void rehash()\n    {\n        _needRehash = false;\n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _hashShared = false;\n\n        // And then we can first deal with the main hash area. Since we are expanding\n        // linearly (double up), we know there'll be no collisions during this phase.\n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        // double up main hash area, but do not expand long-name area:\n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); // 4 ints per entry\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        // and simply double up name array\n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        // Plus we can scan only through the primary hash area, looking for non-empty\n        // slots, without worrying about ordering. This should never reduce priority\n        // of existing entries: primaries remain primaries; however, due to increased\n        // space, secondaries may become primaries etc\n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { // empty slot, skip\n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                // #0 is hash, #1 offset\n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        // Sanity checks: since corruption difficult to detect, assert explicitly\n        // with production code\n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    /**\n     * Helper method called to empty all shared symbols, but to leave\n     * arrays allocated\n     */\n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        // reset spill-over to empty (starting at 7/8 of hash area)\n        _spilloverEnd = _spilloverStart();\n        // and long name area to empty, starting immediately after hash area\n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that calculates start of the spillover area\n     */\n    private final int _spilloverStart() {\n        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n        // So basically multiply by 7\n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions()\n    {\n        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots)\n    {\n        // first: we only get 1/4 of slots of primary, to divide\n        int tertSlots = (primarySlots) >> 2;\n        \n        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n            return 5;\n        }\n        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n            return 6;\n        }\n        // and biggest buckets have 32 slots\n        return 7;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Immutable value class used for sharing information as efficiently\n     * as possible, by only require synchronization of reference manipulation\n     * but not access to contents.\n     * \n     * @since 2.1\n     */\n    private final static class TableInfo\n    {\n        public final int size;\n        public final int count;\n        public final int tertiaryShift;\n        public final int[] mainHash;\n        public final String[] names;\n        public final int spilloverEnd;\n        public final int longNameOffset;\n\n        public TableInfo(int size, int count, int tertiaryShift, \n                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n        {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src)\n        {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, // hashSize\n                    0, // count\n                    tertShift,\n                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n                    new String[sz << 1], // names == 2x slots\n                    hashAreaSize - sz, // at 7/8 of the total area\n                    hashAreaSize // longNameOffset, immediately after main hashes\n            );\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    /**\n     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n     * themselves).\n     */\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n\n    /**\n     * Let's not expand symbol tables past some maximum size;\n     * this should protected against OOMEs caused by large documents\n     * with unique (~= random) names.\n     * Size is in \n     */\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n\n    /**\n     * No point in trying to construct tiny tables, just need to resize soon.\n     */\n    final static int MIN_HASH_SIZE = 16;\n    \n    /**\n     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n     * this corresponds to 256k main hash index. This should allow for enough distinct\n     * names for almost any case, while preventing ballooning for cases where names\n     * are unique (or close thereof).\n     */\n    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n\n    /*\n    /**********************************************************\n    /* Linkage, needed for merging symbol tables\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the root symbol table, for child tables, so\n     * that they can merge table information back as necessary.\n     */\n    final protected ByteQuadsCanonicalizer _parent;\n\n    /**\n     * Member that is only used by the root table instance: root\n     * passes immutable state into child instances, and children\n     * may return new state if they add entries to the table.\n     * Child tables do NOT use the reference.\n     */\n    final protected AtomicReference<TableInfo> _tableInfo;\n    \n    /**\n     * Seed value we use as the base to make hash codes non-static between\n     * different runs, but still stable for lifetime of a single symbol table\n     * instance.\n     * This is done for security reasons, to avoid potential DoS attack via\n     * hash collisions.\n     */\n    final private int _seed;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Whether canonical symbol Strings are to be intern()ed before added\n     * to the table or not.\n     *<p>\n     * NOTE: non-final to allow disabling intern()ing in case of excessive\n     * collisions.\n     */\n    protected boolean _intern;\n\n    /**\n     * Flag that indicates whether we should throw an exception if enough \n     * hash collisions are detected (true); or just worked around (false).\n     * \n     * @since 2.4\n     */\n    protected final boolean _failOnDoS;\n    \n    /*\n    /**********************************************************\n    /* First, main hash area info\n    /**********************************************************\n     */\n\n    /**\n     * Primary hash information area: consists of <code>2 * _hashSize</code>\n     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n     * structure (details of which may be tweaked depending on expected rates\n     * of collisions).\n     */\n    protected int[] _hashArea;\n\n    /**\n     * Number of slots for primary entries within {@link #_hashArea}; which is\n     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n     * primary covers only half of the area; plus, additional area for longer\n     * symbols after hash area).\n     */\n    protected int _hashSize;\n\n    /**\n     * Offset within {@link #_hashArea} where secondary entries start\n     */\n    protected int _secondaryStart;\n\n    /**\n     * Offset within {@link #_hashArea} where tertiary entries start\n     */\n    protected int _tertiaryStart;\n    \n    /**\n     * Constant that determines size of buckets for tertiary entries:\n     * <code>1 &lt;&lt; _tertiaryShift</code> is the size, and shift value\n     * is also used for translating from primary offset into\n     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n     *<p>\n     * Default value is 2, for buckets of 4 slots; grows bigger with\n     * bigger table sizes.\n     */\n    protected int _tertiaryShift;\n\n    /**\n     * Total number of Strings in the symbol table; only used for child tables.\n     */\n    protected int _count;\n\n    /**\n     * Array that contains <code>String</code> instances matching\n     * entries in {@link #_hashArea}.\n     * Contains nulls for unused entries. Note that this size is twice\n     * that of {@link #_hashArea}\n     */\n    protected String[] _names;\n\n    /*\n    /**********************************************************\n    /* Then information on collisions etc\n    /**********************************************************\n     */\n\n    /**\n     * Pointer to the offset within spill-over area where there is room\n     * for more spilled over entries (if any).\n     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n     */\n    protected int _spilloverEnd;\n\n    /**\n     * Offset within {@link #_hashArea} that follows main slots and contains\n     * quads for longer names (13 bytes or longers), and points to the\n     * first available int that may be used for appending quads of the next\n     * long name.\n     * Note that long name area follows immediately after the fixed-size\n     * main hash area ({@link #_hashArea}).\n     */\n    protected int _longNameOffset;\n\n    /**\n     * This flag is set if, after adding a new entry, it is deemed\n     * that a rehash is warranted if any more entries are to be added.\n     */\n    private transient boolean _needRehash;\n\n    /*\n    /**********************************************************\n    /* Sharing, versioning\n    /**********************************************************\n     */\n\n    // // // Which of the buffers may be shared (and are copy-on-write)?\n\n    /**\n     * Flag that indicates whether underlying data structures for\n     * the main hash area are shared or not. If they are, then they\n     * need to be handled in copy-on-write way, i.e. if they need\n     * to be modified, a copy needs to be made first; at this point\n     * it will not be shared any more, and can be modified.\n     *<p>\n     * This flag needs to be checked both when adding new main entries,\n     * and when adding new collision list queues (i.e. creating a new\n     * collision list head entry)\n     */\n    private boolean _hashShared;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n     * symbol tables: ones used for merging and sharing common symbols\n     * \n     * @param sz Initial primary hash area size\n     * @param intern Whether Strings contained should be {@link String#intern}ed\n     * @param seed Random seed valued used to make it more difficult to cause\n     *   collisions (used for collision-based DoS attacks).\n     */\n    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        // Sanity check: let's now allow hash sizes below certain minimum value\n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            // Also; size must be 2^N; otherwise hash algorithm won't\n            // work... so let's just pad it up, if so\n            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    /**\n     * Constructor used when creating a child instance\n     */\n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n            int seed, boolean failOnDoS, TableInfo state)\n    {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; // not used by child tables\n\n        // Then copy shared state\n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; // right after primary area\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        // and then set other state to reflect sharing status\n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle: factory methods, merging\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot() {\n        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n         * based attacks.\n         */\n        long now = System.currentTimeMillis();\n        // ensure it's not 0; and might as well require to be odd so:\n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    /**\n     * Factory method used to create actual symbol table instance to\n     * use for parsing.\n     */\n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    /**\n     * Method called by the using code to indicate it is done\n     * with this instance. This lets instance merge accumulated\n     * changes into parent (if need be), safely and efficiently,\n     * and without calling code having to know about parent\n     * information\n     */\n    public void release()\n    {\n        // we will try to merge if child table has new entries\n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            /* Let's also mark this instance as dirty, so that just in\n             * case release was too early, there's no corruption of possibly shared data.\n             */\n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState)\n    {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        // Should usually grow; but occasionally could also shrink if (but only if)\n        // collision list overflow ends up clearing some collision lists.\n        if (childCount == currState.count) {\n            return;\n        }\n\n        // One caveat: let's try to avoid problems with degenerate cases of documents with\n        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n        // One way to do this is to just purge tables if they grow\n        // too large, and that's what we'll do here.\n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            // At any rate, need to clean up the tables\n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    /*\n    /**********************************************************\n    /* API, accessors\n    /**********************************************************\n     */\n\n    public int size()\n    {\n        if (_tableInfo != null) { // root table\n            return _tableInfo.get().count;\n        }\n        // nope, child table\n        return _count;\n    }\n\n    /**\n     * Returns number of primary slots table has currently\n     */\n    public int bucketCount() { return _hashSize; }\n\n    /**\n     * Method called to check to quickly see if a child symbol table\n     * may have gotten additional entries. Used for checking to see\n     * if a child table should be merged into shared table.\n     */\n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    /**\n     * Method mostly needed by unit tests; calculates number of\n     * entries that are in the primary slot set. These are\n     * \"perfect\" entries, accessible with a single lookup\n     */\n    public int primaryCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in secondary buckets\n     */\n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in tertiary buckets\n     */\n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in shared spillover area\n     */\n    public int spilloverCount() {\n        // difference between spillover end, start, divided by 4 (four ints per slot)\n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, accessing symbols\n    /**********************************************************\n     */\n\n    public String findName(int q1)\n    {\n        int offset = _calcOffset(calcHash(q1));\n        // first: primary match?\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary? single slot shared by N/2 primaries\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n\n        // tertiary lookup & spillovers best to offline\n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2)\n    {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3)\n    {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen)\n    {\n        /* This version differs significantly, because longer names do not fit within cell.\n         * Rather, they contain hash in main slot, and offset+length to extension area\n         * that contains actual quads.\n         */\n        if (qlen < 4) { // another sanity check\n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            // probable but not guaranteed: verify\n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access from spill-over areas\n    /**********************************************************\n     */\n\n    private String _findSecondary(int origOffset, int q1)\n    {\n        // tertiary area division is dynamic. First; its size is N/4 compared to\n        // primary hash size; and offsets are for 4 int slots. So to get to logical\n        // index would shift by 4. But! Tertiary area is further split into buckets,\n        // determined by shift value. And finally, from bucket back into physical offsets\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        // but if tertiary full, check out spill-over area as last resort\n        // shared spillover starts at 7/8 of the main hash area\n        // (which is sized at 2 * _hashSize), so:\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n    {\n        final int[] hashArea = _hashArea;\n        // spillOffset assumed to be physical index right into quad string\n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: // always at least 4\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n    {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* API, mutators\n    /**********************************************************\n     */\n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n    \n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen)\n    {\n        int start = _longNameOffset;\n        \n        // note: at this point we must already be shared. But may not have enough space\n        if ((start + qlen) > _hashArea.length) {\n            // try to increment in reasonable chunks; at least space that we need\n            int toAdd = (start + qlen) - _hashArea.length;\n            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    /*\n    /**********************************************************\n    /* Hash calculation\n    /**********************************************************\n     */\n\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n        hash ^= (hash << 3); // shuffle back a bit\n        hash += (hash >>> 12); // and bit more\n        return hash;\n    }\n\n    public int calcHash(int q1, int q2)\n    {\n        // For two quads, let's change algorithm a bit, to spice\n        // things up (can do bit more processing anyway)\n        int hash = q1;\n\n        hash += (hash >>> 15); // try mixing first and second byte pairs first\n        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n        hash += (q2 * MULT); // then add second quad\n        hash ^= _seed;\n        hash += (hash >>> 16); // and shuffle some more\n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3)\n    { // use same algorithm as multi-byte, tested to work well\n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen)\n    {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        // and finally shuffle some more once done\n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    /*\n    /**********************************************************\n    /* Rehashing\n    /**********************************************************\n     */\n\n    private void rehash()\n    {\n        _needRehash = false;\n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _hashShared = false;\n\n        // And then we can first deal with the main hash area. Since we are expanding\n        // linearly (double up), we know there'll be no collisions during this phase.\n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        // double up main hash area, but do not expand long-name area:\n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); // 4 ints per entry\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        // and simply double up name array\n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        // Plus we can scan only through the primary hash area, looking for non-empty\n        // slots, without worrying about ordering. This should never reduce priority\n        // of existing entries: primaries remain primaries; however, due to increased\n        // space, secondaries may become primaries etc\n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { // empty slot, skip\n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                // #0 is hash, #1 offset\n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        // Sanity checks: since corruption difficult to detect, assert explicitly\n        // with production code\n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    /**\n     * Helper method called to empty all shared symbols, but to leave\n     * arrays allocated\n     */\n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        // reset spill-over to empty (starting at 7/8 of hash area)\n        _spilloverEnd = _spilloverStart();\n        // and long name area to empty, starting immediately after hash area\n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that calculates start of the spillover area\n     */\n    private final int _spilloverStart() {\n        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n        // So basically multiply by 7\n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions()\n    {\n        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots)\n    {\n        // first: we only get 1/4 of slots of primary, to divide\n        int tertSlots = (primarySlots) >> 2;\n        \n        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n            return 5;\n        }\n        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n            return 6;\n        }\n        // and biggest buckets have 32 slots\n        return 7;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Immutable value class used for sharing information as efficiently\n     * as possible, by only require synchronization of reference manipulation\n     * but not access to contents.\n     * \n     * @since 2.1\n     */\n    private final static class TableInfo\n    {\n        public final int size;\n        public final int count;\n        public final int tertiaryShift;\n        public final int[] mainHash;\n        public final String[] names;\n        public final int spilloverEnd;\n        public final int longNameOffset;\n\n        public TableInfo(int size, int count, int tertiaryShift, \n                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n        {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src)\n        {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, // hashSize\n                    0, // count\n                    tertShift,\n                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n                    new String[sz << 1], // names == 2x slots\n                    hashAreaSize - sz, // at 7/8 of the total area\n                    hashAreaSize // longNameOffset, immediately after main hashes\n            );\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 11, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer", "buggy_version": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    /**\n     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n     * themselves).\n     */\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n\n    /**\n     * Let's not expand symbol tables past some maximum size;\n     * this should protected against OOMEs caused by large documents\n     * with unique (~= random) names.\n     * Size is in \n     */\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n\n    /**\n     * No point in trying to construct tiny tables, just need to resize soon.\n     */\n    final static int MIN_HASH_SIZE = 16;\n    \n    /**\n     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n     * this corresponds to 256k main hash index. This should allow for enough distinct\n     * names for almost any case, while preventing ballooning for cases where names\n     * are unique (or close thereof).\n     */\n    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n\n    /*\n    /**********************************************************\n    /* Linkage, needed for merging symbol tables\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the root symbol table, for child tables, so\n     * that they can merge table information back as necessary.\n     */\n    final protected ByteQuadsCanonicalizer _parent;\n\n    /**\n     * Member that is only used by the root table instance: root\n     * passes immutable state into child instances, and children\n     * may return new state if they add entries to the table.\n     * Child tables do NOT use the reference.\n     */\n    final protected AtomicReference<TableInfo> _tableInfo;\n    \n    /**\n     * Seed value we use as the base to make hash codes non-static between\n     * different runs, but still stable for lifetime of a single symbol table\n     * instance.\n     * This is done for security reasons, to avoid potential DoS attack via\n     * hash collisions.\n     */\n    final private int _seed;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Whether canonical symbol Strings are to be intern()ed before added\n     * to the table or not.\n     *<p>\n     * NOTE: non-final to allow disabling intern()ing in case of excessive\n     * collisions.\n     */\n    protected boolean _intern;\n\n    /**\n     * Flag that indicates whether we should throw an exception if enough \n     * hash collisions are detected (true); or just worked around (false).\n     * \n     * @since 2.4\n     */\n    protected final boolean _failOnDoS;\n    \n    /*\n    /**********************************************************\n    /* First, main hash area info\n    /**********************************************************\n     */\n\n    /**\n     * Primary hash information area: consists of <code>2 * _hashSize</code>\n     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n     * structure (details of which may be tweaked depending on expected rates\n     * of collisions).\n     */\n    protected int[] _hashArea;\n\n    /**\n     * Number of slots for primary entries within {@link #_hashArea}; which is\n     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n     * primary covers only half of the area; plus, additional area for longer\n     * symbols after hash area).\n     */\n    protected int _hashSize;\n\n    /**\n     * Offset within {@link #_hashArea} where secondary entries start\n     */\n    protected int _secondaryStart;\n\n    /**\n     * Offset within {@link #_hashArea} where tertiary entries start\n     */\n    protected int _tertiaryStart;\n    \n    /**\n     * Constant that determines size of buckets for tertiary entries:\n     * <code>1 &lt;&lt; _tertiaryShift</code> is the size, and shift value\n     * is also used for translating from primary offset into\n     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n     *<p>\n     * Default value is 2, for buckets of 4 slots; grows bigger with\n     * bigger table sizes.\n     */\n    protected int _tertiaryShift;\n\n    /**\n     * Total number of Strings in the symbol table; only used for child tables.\n     */\n    protected int _count;\n\n    /**\n     * Array that contains <code>String</code> instances matching\n     * entries in {@link #_hashArea}.\n     * Contains nulls for unused entries. Note that this size is twice\n     * that of {@link #_hashArea}\n     */\n    protected String[] _names;\n\n    /*\n    /**********************************************************\n    /* Then information on collisions etc\n    /**********************************************************\n     */\n\n    /**\n     * Pointer to the offset within spill-over area where there is room\n     * for more spilled over entries (if any).\n     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n     */\n    protected int _spilloverEnd;\n\n    /**\n     * Offset within {@link #_hashArea} that follows main slots and contains\n     * quads for longer names (13 bytes or longers), and points to the\n     * first available int that may be used for appending quads of the next\n     * long name.\n     * Note that long name area follows immediately after the fixed-size\n     * main hash area ({@link #_hashArea}).\n     */\n    protected int _longNameOffset;\n\n    /**\n     * This flag is set if, after adding a new entry, it is deemed\n     * that a rehash is warranted if any more entries are to be added.\n     */\n    private transient boolean _needRehash;\n\n    /*\n    /**********************************************************\n    /* Sharing, versioning\n    /**********************************************************\n     */\n\n    // // // Which of the buffers may be shared (and are copy-on-write)?\n\n    /**\n     * Flag that indicates whether underlying data structures for\n     * the main hash area are shared or not. If they are, then they\n     * need to be handled in copy-on-write way, i.e. if they need\n     * to be modified, a copy needs to be made first; at this point\n     * it will not be shared any more, and can be modified.\n     *<p>\n     * This flag needs to be checked both when adding new main entries,\n     * and when adding new collision list queues (i.e. creating a new\n     * collision list head entry)\n     */\n    private boolean _hashShared;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n     * symbol tables: ones used for merging and sharing common symbols\n     * \n     * @param sz Initial primary hash area size\n     * @param intern Whether Strings contained should be {@link String#intern}ed\n     * @param seed Random seed valued used to make it more difficult to cause\n     *   collisions (used for collision-based DoS attacks).\n     */\n    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        // Sanity check: let's now allow hash sizes below certain minimum value\n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            // Also; size must be 2^N; otherwise hash algorithm won't\n            // work... so let's just pad it up, if so\n            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    /**\n     * Constructor used when creating a child instance\n     */\n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n            int seed, boolean failOnDoS, TableInfo state)\n    {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; // not used by child tables\n\n        // Then copy shared state\n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; // right after primary area\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        // and then set other state to reflect sharing status\n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle: factory methods, merging\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot() {\n        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n         * based attacks.\n         */\n        long now = System.currentTimeMillis();\n        // ensure it's not 0; and might as well require to be odd so:\n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    /**\n     * Factory method used to create actual symbol table instance to\n     * use for parsing.\n     */\n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    /**\n     * Method called by the using code to indicate it is done\n     * with this instance. This lets instance merge accumulated\n     * changes into parent (if need be), safely and efficiently,\n     * and without calling code having to know about parent\n     * information\n     */\n    public void release()\n    {\n        // we will try to merge if child table has new entries\n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            /* Let's also mark this instance as dirty, so that just in\n             * case release was too early, there's no corruption of possibly shared data.\n             */\n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState)\n    {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        // Should usually grow; but occasionally could also shrink if (but only if)\n        // collision list overflow ends up clearing some collision lists.\n        if (childCount == currState.count) {\n            return;\n        }\n\n        // One caveat: let's try to avoid problems with degenerate cases of documents with\n        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n        // One way to do this is to just purge tables if they grow\n        // too large, and that's what we'll do here.\n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            // At any rate, need to clean up the tables\n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    /*\n    /**********************************************************\n    /* API, accessors\n    /**********************************************************\n     */\n\n    public int size()\n    {\n        if (_tableInfo != null) { // root table\n            return _tableInfo.get().count;\n        }\n        // nope, child table\n        return _count;\n    }\n\n    /**\n     * Returns number of primary slots table has currently\n     */\n    public int bucketCount() { return _hashSize; }\n\n    /**\n     * Method called to check to quickly see if a child symbol table\n     * may have gotten additional entries. Used for checking to see\n     * if a child table should be merged into shared table.\n     */\n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    /**\n     * Method mostly needed by unit tests; calculates number of\n     * entries that are in the primary slot set. These are\n     * \"perfect\" entries, accessible with a single lookup\n     */\n    public int primaryCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in secondary buckets\n     */\n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in tertiary buckets\n     */\n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in shared spillover area\n     */\n    public int spilloverCount() {\n        // difference between spillover end, start, divided by 4 (four ints per slot)\n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, accessing symbols\n    /**********************************************************\n     */\n\n    public String findName(int q1)\n    {\n        int offset = _calcOffset(calcHash(q1));\n        // first: primary match?\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary? single slot shared by N/2 primaries\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n\n        // tertiary lookup & spillovers best to offline\n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2)\n    {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3)\n    {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen)\n    {\n        /* This version differs significantly, because longer names do not fit within cell.\n         * Rather, they contain hash in main slot, and offset+length to extension area\n         * that contains actual quads.\n         */\n        if (qlen < 4) { // another sanity check\n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            // probable but not guaranteed: verify\n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access from spill-over areas\n    /**********************************************************\n     */\n\n    private String _findSecondary(int origOffset, int q1)\n    {\n        // tertiary area division is dynamic. First; its size is N/4 compared to\n        // primary hash size; and offsets are for 4 int slots. So to get to logical\n        // index would shift by 4. But! Tertiary area is further split into buckets,\n        // determined by shift value. And finally, from bucket back into physical offsets\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        // but if tertiary full, check out spill-over area as last resort\n        // shared spillover starts at 7/8 of the main hash area\n        // (which is sized at 2 * _hashSize), so:\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n    {\n        final int[] hashArea = _hashArea;\n        // spillOffset assumed to be physical index right into quad string\n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: // always at least 4\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n    {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* API, mutators\n    /**********************************************************\n     */\n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen)\n    {\n        int start = _longNameOffset;\n        \n        // note: at this point we must already be shared. But may not have enough space\n        if ((start + qlen) > _hashArea.length) {\n            // try to increment in reasonable chunks; at least space that we need\n            int toAdd = (start + qlen) - _hashArea.length;\n            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    /*\n    /**********************************************************\n    /* Hash calculation\n    /**********************************************************\n     */\n\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n        hash ^= (hash << 3); // shuffle back a bit\n        hash += (hash >>> 12); // and bit more\n        return hash;\n    }\n\n    public int calcHash(int q1, int q2)\n    {\n        // For two quads, let's change algorithm a bit, to spice\n        // things up (can do bit more processing anyway)\n        int hash = q1;\n\n        hash += (hash >>> 15); // try mixing first and second byte pairs first\n        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n        hash += (q2 * MULT); // then add second quad\n        hash ^= _seed;\n        hash += (hash >>> 16); // and shuffle some more\n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3)\n    { // use same algorithm as multi-byte, tested to work well\n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen)\n    {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        // and finally shuffle some more once done\n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    /*\n    /**********************************************************\n    /* Rehashing\n    /**********************************************************\n     */\n\n    private void rehash()\n    {\n        _needRehash = false;\n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _hashShared = false;\n\n        // And then we can first deal with the main hash area. Since we are expanding\n        // linearly (double up), we know there'll be no collisions during this phase.\n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        // double up main hash area, but do not expand long-name area:\n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); // 4 ints per entry\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        // and simply double up name array\n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        // Plus we can scan only through the primary hash area, looking for non-empty\n        // slots, without worrying about ordering. This should never reduce priority\n        // of existing entries: primaries remain primaries; however, due to increased\n        // space, secondaries may become primaries etc\n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { // empty slot, skip\n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                // #0 is hash, #1 offset\n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        // Sanity checks: since corruption difficult to detect, assert explicitly\n        // with production code\n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    /**\n     * Helper method called to empty all shared symbols, but to leave\n     * arrays allocated\n     */\n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        // reset spill-over to empty (starting at 7/8 of hash area)\n        _spilloverEnd = _spilloverStart();\n        // and long name area to empty, starting immediately after hash area\n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that calculates start of the spillover area\n     */\n    private final int _spilloverStart() {\n        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n        // So basically multiply by 7\n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions()\n    {\n        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots)\n    {\n        // first: we only get 1/4 of slots of primary, to divide\n        int tertSlots = (primarySlots) >> 2;\n        \n        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n            return 5;\n        }\n        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n            return 6;\n        }\n        // and biggest buckets have 32 slots\n        return 7;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Immutable value class used for sharing information as efficiently\n     * as possible, by only require synchronization of reference manipulation\n     * but not access to contents.\n     * \n     * @since 2.1\n     */\n    private final static class TableInfo\n    {\n        public final int size;\n        public final int count;\n        public final int tertiaryShift;\n        public final int[] mainHash;\n        public final String[] names;\n        public final int spilloverEnd;\n        public final int longNameOffset;\n\n        public TableInfo(int size, int count, int tertiaryShift, \n                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n        {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src)\n        {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, // hashSize\n                    0, // count\n                    tertShift,\n                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n                    new String[sz << 1], // names == 2x slots\n                    hashAreaSize - sz, // at 7/8 of the total area\n                    hashAreaSize // longNameOffset, immediately after main hashes\n            );\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.sym;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport com.fasterxml.jackson.core.JsonFactory;\nimport com.fasterxml.jackson.core.util.InternCache;\n\n/**\n * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n * memory access due to flattening of name quad data.\n * Performance improvement modest for simple JSON document data binding (maybe 3%),\n * but should help more for larger symbol tables, or for binary formats like Smile.\n *\n * @since 2.6\n */\npublic final class ByteQuadsCanonicalizer\n{\n    /**\n     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n     * themselves).\n     */\n    private static final int DEFAULT_T_SIZE = 64;\n//    private static final int DEFAULT_T_SIZE = 256;\n\n    /**\n     * Let's not expand symbol tables past some maximum size;\n     * this should protected against OOMEs caused by large documents\n     * with unique (~= random) names.\n     * Size is in \n     */\n    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n\n    /**\n     * No point in trying to construct tiny tables, just need to resize soon.\n     */\n    final static int MIN_HASH_SIZE = 16;\n    \n    /**\n     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n     * this corresponds to 256k main hash index. This should allow for enough distinct\n     * names for almost any case, while preventing ballooning for cases where names\n     * are unique (or close thereof).\n     */\n    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n\n    /*\n    /**********************************************************\n    /* Linkage, needed for merging symbol tables\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the root symbol table, for child tables, so\n     * that they can merge table information back as necessary.\n     */\n    final protected ByteQuadsCanonicalizer _parent;\n\n    /**\n     * Member that is only used by the root table instance: root\n     * passes immutable state into child instances, and children\n     * may return new state if they add entries to the table.\n     * Child tables do NOT use the reference.\n     */\n    final protected AtomicReference<TableInfo> _tableInfo;\n    \n    /**\n     * Seed value we use as the base to make hash codes non-static between\n     * different runs, but still stable for lifetime of a single symbol table\n     * instance.\n     * This is done for security reasons, to avoid potential DoS attack via\n     * hash collisions.\n     */\n    final private int _seed;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Whether canonical symbol Strings are to be intern()ed before added\n     * to the table or not.\n     *<p>\n     * NOTE: non-final to allow disabling intern()ing in case of excessive\n     * collisions.\n     */\n    protected boolean _intern;\n\n    /**\n     * Flag that indicates whether we should throw an exception if enough \n     * hash collisions are detected (true); or just worked around (false).\n     * \n     * @since 2.4\n     */\n    protected final boolean _failOnDoS;\n    \n    /*\n    /**********************************************************\n    /* First, main hash area info\n    /**********************************************************\n     */\n\n    /**\n     * Primary hash information area: consists of <code>2 * _hashSize</code>\n     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n     * structure (details of which may be tweaked depending on expected rates\n     * of collisions).\n     */\n    protected int[] _hashArea;\n\n    /**\n     * Number of slots for primary entries within {@link #_hashArea}; which is\n     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n     * primary covers only half of the area; plus, additional area for longer\n     * symbols after hash area).\n     */\n    protected int _hashSize;\n\n    /**\n     * Offset within {@link #_hashArea} where secondary entries start\n     */\n    protected int _secondaryStart;\n\n    /**\n     * Offset within {@link #_hashArea} where tertiary entries start\n     */\n    protected int _tertiaryStart;\n    \n    /**\n     * Constant that determines size of buckets for tertiary entries:\n     * <code>1 &lt;&lt; _tertiaryShift</code> is the size, and shift value\n     * is also used for translating from primary offset into\n     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n     *<p>\n     * Default value is 2, for buckets of 4 slots; grows bigger with\n     * bigger table sizes.\n     */\n    protected int _tertiaryShift;\n\n    /**\n     * Total number of Strings in the symbol table; only used for child tables.\n     */\n    protected int _count;\n\n    /**\n     * Array that contains <code>String</code> instances matching\n     * entries in {@link #_hashArea}.\n     * Contains nulls for unused entries. Note that this size is twice\n     * that of {@link #_hashArea}\n     */\n    protected String[] _names;\n\n    /*\n    /**********************************************************\n    /* Then information on collisions etc\n    /**********************************************************\n     */\n\n    /**\n     * Pointer to the offset within spill-over area where there is room\n     * for more spilled over entries (if any).\n     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n     */\n    protected int _spilloverEnd;\n\n    /**\n     * Offset within {@link #_hashArea} that follows main slots and contains\n     * quads for longer names (13 bytes or longers), and points to the\n     * first available int that may be used for appending quads of the next\n     * long name.\n     * Note that long name area follows immediately after the fixed-size\n     * main hash area ({@link #_hashArea}).\n     */\n    protected int _longNameOffset;\n\n    /**\n     * This flag is set if, after adding a new entry, it is deemed\n     * that a rehash is warranted if any more entries are to be added.\n     */\n    private transient boolean _needRehash;\n\n    /*\n    /**********************************************************\n    /* Sharing, versioning\n    /**********************************************************\n     */\n\n    // // // Which of the buffers may be shared (and are copy-on-write)?\n\n    /**\n     * Flag that indicates whether underlying data structures for\n     * the main hash area are shared or not. If they are, then they\n     * need to be handled in copy-on-write way, i.e. if they need\n     * to be modified, a copy needs to be made first; at this point\n     * it will not be shared any more, and can be modified.\n     *<p>\n     * This flag needs to be checked both when adding new main entries,\n     * and when adding new collision list queues (i.e. creating a new\n     * collision list head entry)\n     */\n    private boolean _hashShared;\n\n    /*\n    /**********************************************************\n    /* Life-cycle: constructors\n    /**********************************************************\n     */\n\n    /**\n     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n     * symbol tables: ones used for merging and sharing common symbols\n     * \n     * @param sz Initial primary hash area size\n     * @param intern Whether Strings contained should be {@link String#intern}ed\n     * @param seed Random seed valued used to make it more difficult to cause\n     *   collisions (used for collision-based DoS attacks).\n     */\n    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n        _parent = null;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        // Sanity check: let's now allow hash sizes below certain minimum value\n        if (sz < MIN_HASH_SIZE) {\n            sz = MIN_HASH_SIZE;\n        } else {\n            // Also; size must be 2^N; otherwise hash algorithm won't\n            // work... so let's just pad it up, if so\n            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n                int curr = MIN_HASH_SIZE;\n                while (curr < sz) {\n                    curr += curr;\n                }\n                sz = curr;\n            }\n        }\n        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n    }\n\n    /**\n     * Constructor used when creating a child instance\n     */\n    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n            int seed, boolean failOnDoS, TableInfo state)\n    {\n        _parent = parent;\n        _seed = seed;\n        _intern = intern;\n        _failOnDoS = failOnDoS;\n        _tableInfo = null; // not used by child tables\n\n        // Then copy shared state\n        _count = state.count;\n        _hashSize = state.size;\n        _secondaryStart = _hashSize << 2; // right after primary area\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = state.tertiaryShift;\n        \n        _hashArea = state.mainHash;\n        _names = state.names;\n\n        _spilloverEnd = state.spilloverEnd;\n        _longNameOffset = state.longNameOffset;\n\n        // and then set other state to reflect sharing status\n        _needRehash = false;\n        _hashShared = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Life-cycle: factory methods, merging\n    /**********************************************************\n     */\n    \n    /**\n     * Factory method to call to create a symbol table instance with a\n     * randomized seed value.\n     */\n    public static ByteQuadsCanonicalizer createRoot() {\n        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n         * based attacks.\n         */\n        long now = System.currentTimeMillis();\n        // ensure it's not 0; and might as well require to be odd so:\n        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n        return createRoot(seed);\n    }\n\n    /**\n     * Factory method that should only be called from unit tests, where seed\n     * value should remain the same.\n     */\n    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n    }\n    \n    /**\n     * Factory method used to create actual symbol table instance to\n     * use for parsing.\n     */\n    public ByteQuadsCanonicalizer makeChild(int flags) {\n        return new ByteQuadsCanonicalizer(this,\n                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n                _seed,\n                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                _tableInfo.get());\n    }\n\n    /**\n     * Method called by the using code to indicate it is done\n     * with this instance. This lets instance merge accumulated\n     * changes into parent (if need be), safely and efficiently,\n     * and without calling code having to know about parent\n     * information\n     */\n    public void release()\n    {\n        // we will try to merge if child table has new entries\n        if (_parent != null && maybeDirty()) {\n            _parent.mergeChild(new TableInfo(this));\n            /* Let's also mark this instance as dirty, so that just in\n             * case release was too early, there's no corruption of possibly shared data.\n             */\n            _hashShared = true;\n        }\n    }\n\n    private void mergeChild(TableInfo childState)\n    {\n        final int childCount = childState.count;\n        TableInfo currState = _tableInfo.get();\n\n        // Should usually grow; but occasionally could also shrink if (but only if)\n        // collision list overflow ends up clearing some collision lists.\n        if (childCount == currState.count) {\n            return;\n        }\n\n        // One caveat: let's try to avoid problems with degenerate cases of documents with\n        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n        // One way to do this is to just purge tables if they grow\n        // too large, and that's what we'll do here.\n        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n            // At any rate, need to clean up the tables\n            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n        }\n        _tableInfo.compareAndSet(currState, childState);\n    }\n\n    /*\n    /**********************************************************\n    /* API, accessors\n    /**********************************************************\n     */\n\n    public int size()\n    {\n        if (_tableInfo != null) { // root table\n            return _tableInfo.get().count;\n        }\n        // nope, child table\n        return _count;\n    }\n\n    /**\n     * Returns number of primary slots table has currently\n     */\n    public int bucketCount() { return _hashSize; }\n\n    /**\n     * Method called to check to quickly see if a child symbol table\n     * may have gotten additional entries. Used for checking to see\n     * if a child table should be merged into shared table.\n     */\n    public boolean maybeDirty() { return !_hashShared; }\n\n    public int hashSeed() { return _seed; }\n    \n    /**\n     * Method mostly needed by unit tests; calculates number of\n     * entries that are in the primary slot set. These are\n     * \"perfect\" entries, accessible with a single lookup\n     */\n    public int primaryCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in secondary buckets\n     */\n    public int secondaryCount() {\n        int count = 0;\n        int offset = _secondaryStart + 3;\n        for (int end = _tertiaryStart; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in tertiary buckets\n     */\n    public int tertiaryCount() {\n        int count = 0;\n        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n        for (int end = offset + _hashSize; offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Method mostly needed by unit tests; calculates number of entries\n     * in shared spillover area\n     */\n    public int spilloverCount() {\n        // difference between spillover end, start, divided by 4 (four ints per slot)\n        return (_spilloverEnd - _spilloverStart()) >> 2;\n    }\n\n    public int totalCount()\n    {\n        int count = 0;\n        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n            if (_hashArea[offset] != 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public String toString() {\n        int pri = primaryCount();\n        int sec = secondaryCount();\n        int tert = tertiaryCount();\n        int spill = spilloverCount();\n        int total = totalCount();\n        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n                getClass().getName(), _count, _hashSize,\n                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, accessing symbols\n    /**********************************************************\n     */\n\n    public String findName(int q1)\n    {\n        int offset = _calcOffset(calcHash(q1));\n        // first: primary match?\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 1) {\n            if (hashArea[offset] == q1) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary? single slot shared by N/2 primaries\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 1) {\n            if (hashArea[offset2] == q1) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n\n        // tertiary lookup & spillovers best to offline\n        return _findSecondary(offset, q1);\n    }\n\n    public String findName(int q1, int q2)\n    {\n        int offset = _calcOffset(calcHash(q1, q2));\n\n        final int[] hashArea = _hashArea;\n\n        int len = hashArea[offset+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 2) {\n            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2);\n    }\n\n    public String findName(int q1, int q2, int q3)\n    {\n        int offset = _calcOffset(calcHash(q1, q2, q3));\n        final int[] hashArea = _hashArea;\n        int len = hashArea[offset+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n                return _names[offset >> 2];\n            }\n        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        len = hashArea[offset2+3];\n\n        if (len == 3) {\n            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n                return _names[offset2 >> 2];\n            }\n        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, q1, q2, q3);\n    }\n\n    public String findName(int[] q, int qlen)\n    {\n        /* This version differs significantly, because longer names do not fit within cell.\n         * Rather, they contain hash in main slot, and offset+length to extension area\n         * that contains actual quads.\n         */\n        if (qlen < 4) { // another sanity check\n            if (qlen == 3) {\n                return findName(q[0], q[1], q[2]);\n            }\n            if (qlen == 2) {\n                return findName(q[0], q[1]);\n            }\n            return findName(q[0]);\n        }\n        final int hash = calcHash(q, qlen);\n        int offset = _calcOffset(hash);\n\n        final int[] hashArea = _hashArea;\n\n        final int len = hashArea[offset+3];\n        \n        if ((hash == hashArea[offset]) && (len == qlen)) {\n            // probable but not guaranteed: verify\n            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                return _names[offset >> 2];\n            }\n        }\n        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n            return null;\n        }\n        // secondary?\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n\n        final int len2 = hashArea[offset2+3];\n        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n                return _names[offset2 >> 2];\n            }\n        }\n        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n            return null;\n        }\n        return _findSecondary(offset, hash, q, qlen);\n    }\n    \n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n    /*\n    /**********************************************************\n    /* Access from spill-over areas\n    /**********************************************************\n     */\n\n    private String _findSecondary(int origOffset, int q1)\n    {\n        // tertiary area division is dynamic. First; its size is N/4 compared to\n        // primary hash size; and offsets are for 4 int slots. So to get to logical\n        // index would shift by 4. But! Tertiary area is further split into buckets,\n        // determined by shift value. And finally, from bucket back into physical offsets\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (1 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        // but if tertiary full, check out spill-over area as last resort\n        // shared spillover starts at 7/8 of the main hash area\n        // (which is sized at 2 * _hashSize), so:\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n                return _names[offset >> 2];\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                    && (3 == hashArea[offset+3])) {\n                return _names[offset >> 2];\n            }\n        }\n        return null;\n    }\n\n    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n    {\n        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int[] hashArea = _hashArea;\n\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset + bucketSize; offset < end; offset += 4) {\n            int len = hashArea[offset+3];\n            if ((hash == hashArea[offset]) && (qlen == len)) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n            if (len == 0) {\n                return null;\n            }\n        }\n        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                    return _names[offset >> 2];\n                }\n            }\n        }\n        return null;\n    }\n    \n    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n    {\n        final int[] hashArea = _hashArea;\n        // spillOffset assumed to be physical index right into quad string\n        int ix = 0;\n\n        switch (qlen) {\n        default:\n            return _verifyLongName2(q, qlen, spillOffset);\n        case 8:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 7:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 6:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 5:\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        case 4: // always at least 4\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n            if (q[ix++] != hashArea[spillOffset++]) return false;\n        }\n        return true;\n    }\n\n    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n    {\n        int ix = 0;\n        do {\n            if (q[ix++] != _hashArea[spillOffset++]) {\n                return false;\n            }\n        } while (ix < qlen);\n        return true;\n    }\n\n    /*\n    /**********************************************************\n    /* API, mutators\n    /**********************************************************\n     */\n\n    public String addName(String name, int q1) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1));\n        _hashArea[offset] = q1;\n        _hashArea[offset+3] = 1;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n        int offset = _findOffsetForAdd(hash);\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+3] = 2;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int q1, int q2, int q3) {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n        _hashArea[offset] = q1;\n        _hashArea[offset+1] = q2;\n        _hashArea[offset+2] = q3;\n        _hashArea[offset+3] = 3;\n        _names[offset >> 2] = name;\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n            _verifyNeedForRehash();\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n    private int _appendLongName(int[] quads, int qlen)\n    {\n        int start = _longNameOffset;\n        \n        // note: at this point we must already be shared. But may not have enough space\n        if ((start + qlen) > _hashArea.length) {\n            // try to increment in reasonable chunks; at least space that we need\n            int toAdd = (start + qlen) - _hashArea.length;\n            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n            int minAdd = Math.min(4096, _hashSize);\n\n            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n            _hashArea = Arrays.copyOf(_hashArea, newSize);\n        }\n        System.arraycopy(quads, 0, _hashArea, start, qlen);\n        _longNameOffset += qlen;\n        return start;\n    }\n\n    /*\n    /**********************************************************\n    /* Hash calculation\n    /**********************************************************\n     */\n\n    /* Note on hash calculation: we try to make it more difficult to\n     * generate collisions automatically; part of this is to avoid\n     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n     * and add bit of shifting. And other part is to make this\n     * non-linear, at least for shorter symbols.\n     */\n    \n    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n    // as it seems to give fewest collisions for us\n    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n    private final static int MULT = 33;\n    private final static int MULT2 = 65599;\n    private final static int MULT3 = 31;\n    \n    public int calcHash(int q1)\n    {\n        int hash = q1 ^ _seed;\n        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n         *    except for one specific problem case: numbers. So needed to make sure\n         *    that all 4 least-significant bits participate in hash. Couple of ways\n         *    to work it out, but this is the simplest, fast and seems to do ok.\n         */\n        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n        hash ^= (hash << 3); // shuffle back a bit\n        hash += (hash >>> 12); // and bit more\n        return hash;\n    }\n\n    public int calcHash(int q1, int q2)\n    {\n        // For two quads, let's change algorithm a bit, to spice\n        // things up (can do bit more processing anyway)\n        int hash = q1;\n\n        hash += (hash >>> 15); // try mixing first and second byte pairs first\n        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n        hash += (q2 * MULT); // then add second quad\n        hash ^= _seed;\n        hash += (hash >>> 16); // and shuffle some more\n        hash ^= (hash >>> 4);\n        hash += (hash << 3);\n        \n        return hash;\n    }\n\n    public int calcHash(int q1, int q2, int q3)\n    { // use same algorithm as multi-byte, tested to work well\n        int hash = q1 ^ _seed;\n        hash += (hash >>> 9);\n        hash *= MULT3;\n        hash += q2;\n        hash *= MULT;\n        hash += (hash >>> 15);\n        hash ^= q3;\n        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n        hash += (hash >>> 4);\n\n        hash += (hash >>> 15);\n        hash ^= (hash << 9);\n\n        return hash;\n    }\n\n    public int calcHash(int[] q, int qlen)\n    {\n        if (qlen < 4) {\n            throw new IllegalArgumentException();\n        }\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = q[0] ^ _seed;\n        hash += (hash >>> 9);\n        hash += q[1];\n        hash += (hash >>> 15);\n        hash *= MULT;\n        hash ^= q[2];\n        hash += (hash >>> 4);\n\n        for (int i = 3; i < qlen; ++i) {\n            int next = q[i];\n            next = next ^ (next >> 21);\n            hash += next;\n        }\n        hash *= MULT2;\n        \n        // and finally shuffle some more once done\n        hash += (hash >>> 19);\n        hash ^= (hash << 5);\n        return hash;\n    }\n\n    /*\n    /**********************************************************\n    /* Rehashing\n    /**********************************************************\n     */\n\n    private void rehash()\n    {\n        _needRehash = false;\n        // Note: since we'll make copies, no need to unshare, can just mark as such:\n        _hashShared = false;\n\n        // And then we can first deal with the main hash area. Since we are expanding\n        // linearly (double up), we know there'll be no collisions during this phase.\n        final int[] oldHashArea = _hashArea;\n        final String[] oldNames = _names;\n        final int oldSize = _hashSize;\n        final int oldCount = _count;\n        final int newSize = oldSize + oldSize;\n        final int oldEnd = _spilloverEnd;\n\n        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n         *    large documents with unique (or mostly so) names\n         */\n        if (newSize > MAX_T_SIZE) {\n            nukeSymbols(true);\n            return;\n        }\n        // double up main hash area, but do not expand long-name area:\n        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n        _hashSize = newSize;\n        _secondaryStart = (newSize << 2); // 4 ints per entry\n        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n        _tertiaryShift = _calcTertiaryShift(newSize);\n        \n        // and simply double up name array\n        _names = new String[oldNames.length << 1];\n        nukeSymbols(false);\n\n        // Plus we can scan only through the primary hash area, looking for non-empty\n        // slots, without worrying about ordering. This should never reduce priority\n        // of existing entries: primaries remain primaries; however, due to increased\n        // space, secondaries may become primaries etc\n\n        int copyCount = 0;\n        int[] q = new int[16];\n        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n            int len = oldHashArea[offset+3];\n            if (len == 0) { // empty slot, skip\n                continue;\n            }\n            ++copyCount;\n            String name = oldNames[offset>>2];\n            switch (len) {\n            case 1:\n                q[0] = oldHashArea[offset];\n                addName(name, q, 1);\n                break;\n            case 2:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                addName(name, q, 2);\n                break;\n            case 3:\n                q[0] = oldHashArea[offset];\n                q[1] = oldHashArea[offset+1];\n                q[2] = oldHashArea[offset+2];\n                addName(name, q, 3);\n                break;\n            default:\n                if (len > q.length) {\n                    q = new int[len];\n                }\n                // #0 is hash, #1 offset\n                int qoff = oldHashArea[offset+1];\n                System.arraycopy(oldHashArea, qoff, q, 0, len);\n                addName(name, q, len);\n                break;\n            }\n        }\n\n        // Sanity checks: since corruption difficult to detect, assert explicitly\n        // with production code\n        if (copyCount != oldCount) {\n            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n        }\n    }\n\n    /**\n     * Helper method called to empty all shared symbols, but to leave\n     * arrays allocated\n     */\n    private void nukeSymbols(boolean fill) {\n        _count = 0;\n        // reset spill-over to empty (starting at 7/8 of hash area)\n        _spilloverEnd = _spilloverStart();\n        // and long name area to empty, starting immediately after hash area\n        _longNameOffset = _hashSize << 3;\n        if (fill) {\n            Arrays.fill(_hashArea, 0);\n            Arrays.fill(_names, null);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that calculates start of the spillover area\n     */\n    private final int _spilloverStart() {\n        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n        // So basically multiply by 7\n        int offset = _hashSize;\n        return (offset << 3) - offset;\n    }\n\n    protected void _reportTooManyCollisions()\n    {\n        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n            return;\n        }\n        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n    }\n\n    static int _calcTertiaryShift(int primarySlots)\n    {\n        // first: we only get 1/4 of slots of primary, to divide\n        int tertSlots = (primarySlots) >> 2;\n        \n        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n        if (tertSlots < 64) {\n            return 4;\n        }\n        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n            return 5;\n        }\n        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n            return 6;\n        }\n        // and biggest buckets have 32 slots\n        return 7;\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Immutable value class used for sharing information as efficiently\n     * as possible, by only require synchronization of reference manipulation\n     * but not access to contents.\n     * \n     * @since 2.1\n     */\n    private final static class TableInfo\n    {\n        public final int size;\n        public final int count;\n        public final int tertiaryShift;\n        public final int[] mainHash;\n        public final String[] names;\n        public final int spilloverEnd;\n        public final int longNameOffset;\n\n        public TableInfo(int size, int count, int tertiaryShift, \n                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n        {\n            this.size = size;\n            this.count = count;\n            this.tertiaryShift = tertiaryShift;\n            this.mainHash = mainHash;\n            this.names = names;\n            this.spilloverEnd = spilloverEnd;\n            this.longNameOffset = longNameOffset;\n        }\n\n        public TableInfo(ByteQuadsCanonicalizer src)\n        {\n            size = src._hashSize;\n            count = src._count;\n            tertiaryShift = src._tertiaryShift;\n            mainHash = src._hashArea;\n            names = src._names;\n            spilloverEnd = src._spilloverEnd;\n            longNameOffset = src._longNameOffset;\n        }\n\n        public static TableInfo createInitial(int sz) {\n            int hashAreaSize = sz << 3;\n            int tertShift = _calcTertiaryShift(sz);\n\n            return new TableInfo(sz, // hashSize\n                    0, // count\n                    tertShift,\n                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n                    new String[sz << 1], // names == 2x slots\n                    hashAreaSize - sz, // at 7/8 of the total area\n                    hashAreaSize // longNameOffset, immediately after main hashes\n            );\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 12, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * @since 2.7\n     */\n    protected long _nameInputTotal; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n    \n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameInputTotal = _currInputProcessed + _inputPtr - 1;\n        _nameInputRow = _currInputRow;\n        _nameInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * @since 2.7\n     */\n    protected long _nameInputTotal; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    _inputPtr = inPtr;\n                    c = _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    -1L, _nameInputTotal, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                -1L, _tokenInputTotal, _tokenInputRow,\n                getTokenColumnNr());\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n    \n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameInputTotal = _currInputProcessed + _inputPtr - 1;\n        _nameInputRow = _currInputRow;\n        _nameInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n\n    /**\n     * @since 2.7\n     */\n    protected long _nameInputTotal; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputCol;\n\n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n\n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        _updateNameLocation();\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            i = _skipColonFast(ptr+1);\n                            _isNextTokenNameYes(i);\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true);\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n\n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        JsonToken t = nextToken();\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consecutively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Improved location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                getTokenCharacterOffset(), -1L, getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameInputTotal = _currInputProcessed + _inputPtr - 1;\n        _nameInputRow = _currInputRow;\n        _nameInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete = false;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n\n    /**\n     * @since 2.7\n     */\n    protected long _nameInputTotal; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameInputCol;\n\n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n\n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n        \n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            _currInputProcessed += _inputPtr;\n            _currInputRowStart -= _inputPtr;\n            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        _updateNameLocation();\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            i = _skipColonFast(ptr+1);\n                            _isNextTokenNameYes(i);\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true);\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n\n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        JsonToken t = nextToken();\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per #105, need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consecutively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3(c);\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                if (c != '\\'') { // marked as special, isn't here\n                    c = _decodeEscaped();\n                }\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    if (i < INT_SPACE) {\n                        _throwInvalidSpace(i);\n                    }\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2(i);\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3(i);\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Improved location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                _tokenInputTotal, -1L, _tokenInputRow,\n                getTokenColumnNr());\n    }\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameInputTotal = _currInputProcessed + _inputPtr - 1;\n        _nameInputRow = _currInputRow;\n        _nameInputCol = _inputPtr - _currInputRowStart - 1;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 13, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.JsonGeneratorImpl", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.GeneratorBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * Intermediate base class shared by JSON-backed generators\n * like {@link UTF8JsonGenerator} and {@link WriterBasedJsonGenerator}.\n * \n * @since 2.1\n */\npublic abstract class JsonGeneratorImpl extends GeneratorBase\n{\n    /*\n    /**********************************************************\n    /* Constants\n    /**********************************************************\n     */\n\n    /**\n     * This is the default set of escape codes, over 7-bit ASCII range\n     * (first 128 character codes), used for single-byte UTF-8 characters.\n     */\n    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n    \n    /*\n    /**********************************************************\n    /* Configuration, basic I/O\n    /**********************************************************\n     */\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Configuration, output escaping\n    /**********************************************************\n     */\n\n    /**\n     * Currently active set of output escape code definitions (whether\n     * and how to escape or not) for 7-bit ASCII range (first 128\n     * character codes). Defined separately to make potentially\n     * customizable\n     */\n    protected int[] _outputEscapes = sOutputEscapes;\n\n    /**\n     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n     * Unicode code point that will not need escaping; or 0 to indicate\n     * that all characters can be represented without escaping.\n     * Typically used to force escaping of some portion of character set;\n     * for example to always escape non-ASCII characters (if value was 127).\n     *<p>\n     * NOTE: not all sub-classes make use of this setting.\n     */\n    protected int _maximumNonEscapedChar;\n\n    /**\n     * Definition of custom character escapes to use for generators created\n     * by this factory, if any. If null, standard data format specific\n     * escapes are used.\n     */\n    protected CharacterEscapes _characterEscapes;\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Separator to use, if any, between root-level values.\n     * \n     * @since 2.1\n     */\n    protected SerializableString _rootValueSeparator\n        = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n\n    /**\n     * Flag that is set if quoting is not to be added around\n     * JSON Object property names.\n     *\n     * @since 2.7\n     */\n    protected boolean _cfgUnqNames;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec)\n    {\n        super(features, codec);\n        _ioContext = ctxt;\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(features)) {\n            // inlined `setHighestNonEscapedChar()`\n            _maximumNonEscapedChar = 127;\n        }\n        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        super.enable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = false;\n        }\n        return this;\n    }\n\n\n    @Override\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        super._checkStdFeatureChanges(newFeatureFlags, changedFeatures);\n        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags);\n    }\n\n    @Override\n    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n        return this;\n    }\n\n    @Override\n    public int getHighestEscapedChar() {\n        return _maximumNonEscapedChar;\n    }\n\n    @Override\n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n    {\n        _characterEscapes = esc;\n        if (esc == null) { // revert to standard escapes\n            _outputEscapes = sOutputEscapes;\n        } else {\n            _outputEscapes = esc.getEscapeCodesForAscii();\n        }\n        return this;\n    }\n\n    /**\n     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     */\n    @Override\n    public CharacterEscapes getCharacterEscapes() {\n        return _characterEscapes;\n    }\n    \n    @Override\n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        _rootValueSeparator = sep;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Versioned\n    /**********************************************************\n     */\n\n    @Override\n    public Version version() {\n        return VersionUtil.versionFor(getClass());\n    }\n\n    /*\n    /**********************************************************\n    /* Partial API\n    /**********************************************************\n     */\n\n    // // Overrides just to make things final, to possibly help with inlining\n    \n    @Override\n    public final void writeStringField(String fieldName, String value) throws IOException\n    {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.GeneratorBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * Intermediate base class shared by JSON-backed generators\n * like {@link UTF8JsonGenerator} and {@link WriterBasedJsonGenerator}.\n * \n * @since 2.1\n */\npublic abstract class JsonGeneratorImpl extends GeneratorBase\n{\n    /*\n    /**********************************************************\n    /* Constants\n    /**********************************************************\n     */\n\n    /**\n     * This is the default set of escape codes, over 7-bit ASCII range\n     * (first 128 character codes), used for single-byte UTF-8 characters.\n     */\n    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n    \n    /*\n    /**********************************************************\n    /* Configuration, basic I/O\n    /**********************************************************\n     */\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Configuration, output escaping\n    /**********************************************************\n     */\n\n    /**\n     * Currently active set of output escape code definitions (whether\n     * and how to escape or not) for 7-bit ASCII range (first 128\n     * character codes). Defined separately to make potentially\n     * customizable\n     */\n    protected int[] _outputEscapes = sOutputEscapes;\n\n    /**\n     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n     * Unicode code point that will not need escaping; or 0 to indicate\n     * that all characters can be represented without escaping.\n     * Typically used to force escaping of some portion of character set;\n     * for example to always escape non-ASCII characters (if value was 127).\n     *<p>\n     * NOTE: not all sub-classes make use of this setting.\n     */\n    protected int _maximumNonEscapedChar;\n\n    /**\n     * Definition of custom character escapes to use for generators created\n     * by this factory, if any. If null, standard data format specific\n     * escapes are used.\n     */\n    protected CharacterEscapes _characterEscapes;\n    \n    /*\n    /**********************************************************\n    /* Configuration, other\n    /**********************************************************\n     */\n\n    /**\n     * Separator to use, if any, between root-level values.\n     * \n     * @since 2.1\n     */\n    protected SerializableString _rootValueSeparator\n        = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n\n    /**\n     * Flag that is set if quoting is not to be added around\n     * JSON Object property names.\n     *\n     * @since 2.7\n     */\n    protected boolean _cfgUnqNames;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec)\n    {\n        super(features, codec);\n        _ioContext = ctxt;\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(features)) {\n            // inlined `setHighestNonEscapedChar()`\n            _maximumNonEscapedChar = 127;\n        }\n        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        super.enable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = false;\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        super.disable(f);\n        if (f == Feature.QUOTE_FIELD_NAMES) {\n            _cfgUnqNames = true;\n        }\n        return this;\n    }\n\n    @Override\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n        super._checkStdFeatureChanges(newFeatureFlags, changedFeatures);\n        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags);\n    }\n\n    @Override\n    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n        return this;\n    }\n\n    @Override\n    public int getHighestEscapedChar() {\n        return _maximumNonEscapedChar;\n    }\n\n    @Override\n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n    {\n        _characterEscapes = esc;\n        if (esc == null) { // revert to standard escapes\n            _outputEscapes = sOutputEscapes;\n        } else {\n            _outputEscapes = esc.getEscapeCodesForAscii();\n        }\n        return this;\n    }\n\n    /**\n     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     */\n    @Override\n    public CharacterEscapes getCharacterEscapes() {\n        return _characterEscapes;\n    }\n    \n    @Override\n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        _rootValueSeparator = sep;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Versioned\n    /**********************************************************\n     */\n\n    @Override\n    public Version version() {\n        return VersionUtil.versionFor(getClass());\n    }\n\n    /*\n    /**********************************************************\n    /* Partial API\n    /**********************************************************\n     */\n\n    // // Overrides just to make things final, to possibly help with inlining\n    \n    @Override\n    public final void writeStringField(String fieldName, String value) throws IOException\n    {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 14, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.io.IOContext", "buggy_version": "package com.fasterxml.jackson.core.io;\n\nimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.util.BufferRecycler;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n/**\n * To limit number of configuration and state objects to pass, all\n * contextual objects that need to be passed by the factory to\n * readers and writers are combined under this object. One instance\n * is created for each reader and writer.\n *<p>\n * NOTE: non-final since 2.4, to allow sub-classing.\n */\npublic class IOContext\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the source object, which can be used for displaying\n     * location information\n     */\n    protected final Object _sourceRef;\n\n    /**\n     * Encoding used by the underlying stream, if known.\n     */\n    protected JsonEncoding _encoding;\n\n    /**\n     * Flag that indicates whether underlying input/output source/target\n     * object is fully managed by the owner of this context (parser or\n     * generator). If true, it is, and is to be closed by parser/generator;\n     * if false, calling application has to do closing (unless auto-closing\n     * feature is enabled for the parser/generator in question; in which\n     * case it acts like the owner).\n     */\n    protected final boolean _managedResource;\n\n    /*\n    /**********************************************************\n    /* Buffer handling, recycling\n    /**********************************************************\n     */\n\n    /**\n     * Recycler used for actual allocation/deallocation/reuse\n     */\n    protected final BufferRecycler _bufferRecycler;\n\n    /**\n     * Reference to the allocated I/O buffer for low-level input reading,\n     * if any allocated.\n     */\n    protected byte[] _readIOBuffer;\n\n    /**\n     * Reference to the allocated I/O buffer used for low-level\n     * encoding-related buffering.\n     */\n    protected byte[] _writeEncodingBuffer;\n    \n    /**\n     * Reference to the buffer allocated for temporary use with\n     * base64 encoding or decoding.\n     */\n    protected byte[] _base64Buffer;\n\n    /**\n     * Reference to the buffer allocated for tokenization purposes,\n     * in which character input is read, and from which it can be\n     * further returned.\n     */\n    protected char[] _tokenCBuffer;\n\n    /**\n     * Reference to the buffer allocated for buffering it for\n     * output, before being encoded: generally this means concatenating\n     * output, then encoding when buffer fills up.\n     */\n    protected char[] _concatCBuffer;\n\n    /**\n     * Reference temporary buffer Parser instances need if calling\n     * app decides it wants to access name via 'getTextCharacters' method.\n     * Regular text buffer can not be used as it may contain textual\n     * representation of the value token.\n     */\n    protected char[] _nameCopyBuffer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource)\n    {\n        _bufferRecycler = br;\n        _sourceRef = sourceRef;\n        _managedResource = managedResource;\n    }\n\n    public void setEncoding(JsonEncoding enc) {\n        _encoding = enc;\n    }\n\n    /**\n     * @since 1.6\n     */\n    public IOContext withEncoding(JsonEncoding enc) {\n        _encoding = enc;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, accessors\n    /**********************************************************\n     */\n\n    public Object getSourceReference() { return _sourceRef; }\n    public JsonEncoding getEncoding() { return _encoding; }\n    public boolean isResourceManaged() { return _managedResource; }\n\n    /*\n    /**********************************************************\n    /* Public API, buffer management\n    /**********************************************************\n     */\n\n    public TextBuffer constructTextBuffer() {\n        return new TextBuffer(_bufferRecycler);\n    }\n\n    /**\n     *<p>\n     * Note: the method can only be called once during its life cycle.\n     * This is to protect against accidental sharing.\n     */\n    public byte[] allocReadIOBuffer() {\n        _verifyAlloc(_readIOBuffer);\n        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public byte[] allocReadIOBuffer(int minSize) {\n        _verifyAlloc(_readIOBuffer);\n        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, minSize));\n    }\n    \n    public byte[] allocWriteEncodingBuffer() {\n        _verifyAlloc(_writeEncodingBuffer);\n        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public byte[] allocWriteEncodingBuffer(int minSize) {\n        _verifyAlloc(_writeEncodingBuffer);\n        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, minSize));\n    }\n    \n    /**\n     * @since 2.1\n     */\n    public byte[] allocBase64Buffer() {\n        _verifyAlloc(_base64Buffer);\n        return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER));\n    }\n    \n    public char[] allocTokenBuffer() {\n        _verifyAlloc(_tokenCBuffer);\n        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public char[] allocTokenBuffer(int minSize) {\n        _verifyAlloc(_tokenCBuffer);\n        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, minSize));\n    }\n    \n    public char[] allocConcatBuffer() {\n        _verifyAlloc(_concatCBuffer);\n        return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER));\n    }\n\n    public char[] allocNameCopyBuffer(int minSize) {\n        _verifyAlloc(_nameCopyBuffer);\n        return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, minSize));\n    }\n\n    /**\n     * Method to call when all the processing buffers can be safely\n     * recycled.\n     */\n    public void releaseReadIOBuffer(byte[] buf) {\n        if (buf != null) {\n            /* Let's do sanity checks to ensure once-and-only-once release,\n             * as well as avoiding trying to release buffers not owned\n             */\n            _verifyRelease(buf, _readIOBuffer);\n            _readIOBuffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, buf);\n        }\n    }\n\n    public void releaseWriteEncodingBuffer(byte[] buf) {\n        if (buf != null) {\n            /* Let's do sanity checks to ensure once-and-only-once release,\n             * as well as avoiding trying to release buffers not owned\n             */\n            _verifyRelease(buf, _writeEncodingBuffer);\n            _writeEncodingBuffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, buf);\n        }\n    }\n\n    public void releaseBase64Buffer(byte[] buf) {\n        if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n            _verifyRelease(buf, _base64Buffer);\n            _base64Buffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER, buf);\n        }\n    }\n    \n    public void releaseTokenBuffer(char[] buf) {\n        if (buf != null) {\n            _verifyRelease(buf, _tokenCBuffer);\n            _tokenCBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, buf);\n        }\n    }\n\n    public void releaseConcatBuffer(char[] buf) {\n        if (buf != null) {\n            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n            _verifyRelease(buf, _concatCBuffer);\n            _concatCBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\n        }\n    }\n\n    public void releaseNameCopyBuffer(char[] buf) {\n        if (buf != null) {\n            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n            _verifyRelease(buf, _nameCopyBuffer);\n            _nameCopyBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, buf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal helpers\n    /**********************************************************\n     */\n\n    protected final void _verifyAlloc(Object buffer) {\n        if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n    }\n\n    protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n    }\n\n    protected final void _verifyRelease(char[] toRelease, char[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n    }\n\n    private IllegalArgumentException wrongBuf() {\n        // sanity check failed; trying to return different, smaller buffer.\nreturn new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.io;\n\nimport com.fasterxml.jackson.core.JsonEncoding;\nimport com.fasterxml.jackson.core.util.BufferRecycler;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n/**\n * To limit number of configuration and state objects to pass, all\n * contextual objects that need to be passed by the factory to\n * readers and writers are combined under this object. One instance\n * is created for each reader and writer.\n *<p>\n * NOTE: non-final since 2.4, to allow sub-classing.\n */\npublic class IOContext\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reference to the source object, which can be used for displaying\n     * location information\n     */\n    protected final Object _sourceRef;\n\n    /**\n     * Encoding used by the underlying stream, if known.\n     */\n    protected JsonEncoding _encoding;\n\n    /**\n     * Flag that indicates whether underlying input/output source/target\n     * object is fully managed by the owner of this context (parser or\n     * generator). If true, it is, and is to be closed by parser/generator;\n     * if false, calling application has to do closing (unless auto-closing\n     * feature is enabled for the parser/generator in question; in which\n     * case it acts like the owner).\n     */\n    protected final boolean _managedResource;\n\n    /*\n    /**********************************************************\n    /* Buffer handling, recycling\n    /**********************************************************\n     */\n\n    /**\n     * Recycler used for actual allocation/deallocation/reuse\n     */\n    protected final BufferRecycler _bufferRecycler;\n\n    /**\n     * Reference to the allocated I/O buffer for low-level input reading,\n     * if any allocated.\n     */\n    protected byte[] _readIOBuffer;\n\n    /**\n     * Reference to the allocated I/O buffer used for low-level\n     * encoding-related buffering.\n     */\n    protected byte[] _writeEncodingBuffer;\n    \n    /**\n     * Reference to the buffer allocated for temporary use with\n     * base64 encoding or decoding.\n     */\n    protected byte[] _base64Buffer;\n\n    /**\n     * Reference to the buffer allocated for tokenization purposes,\n     * in which character input is read, and from which it can be\n     * further returned.\n     */\n    protected char[] _tokenCBuffer;\n\n    /**\n     * Reference to the buffer allocated for buffering it for\n     * output, before being encoded: generally this means concatenating\n     * output, then encoding when buffer fills up.\n     */\n    protected char[] _concatCBuffer;\n\n    /**\n     * Reference temporary buffer Parser instances need if calling\n     * app decides it wants to access name via 'getTextCharacters' method.\n     * Regular text buffer can not be used as it may contain textual\n     * representation of the value token.\n     */\n    protected char[] _nameCopyBuffer;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource)\n    {\n        _bufferRecycler = br;\n        _sourceRef = sourceRef;\n        _managedResource = managedResource;\n    }\n\n    public void setEncoding(JsonEncoding enc) {\n        _encoding = enc;\n    }\n\n    /**\n     * @since 1.6\n     */\n    public IOContext withEncoding(JsonEncoding enc) {\n        _encoding = enc;\n        return this;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, accessors\n    /**********************************************************\n     */\n\n    public Object getSourceReference() { return _sourceRef; }\n    public JsonEncoding getEncoding() { return _encoding; }\n    public boolean isResourceManaged() { return _managedResource; }\n\n    /*\n    /**********************************************************\n    /* Public API, buffer management\n    /**********************************************************\n     */\n\n    public TextBuffer constructTextBuffer() {\n        return new TextBuffer(_bufferRecycler);\n    }\n\n    /**\n     *<p>\n     * Note: the method can only be called once during its life cycle.\n     * This is to protect against accidental sharing.\n     */\n    public byte[] allocReadIOBuffer() {\n        _verifyAlloc(_readIOBuffer);\n        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public byte[] allocReadIOBuffer(int minSize) {\n        _verifyAlloc(_readIOBuffer);\n        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, minSize));\n    }\n    \n    public byte[] allocWriteEncodingBuffer() {\n        _verifyAlloc(_writeEncodingBuffer);\n        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public byte[] allocWriteEncodingBuffer(int minSize) {\n        _verifyAlloc(_writeEncodingBuffer);\n        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, minSize));\n    }\n    \n    /**\n     * @since 2.1\n     */\n    public byte[] allocBase64Buffer() {\n        _verifyAlloc(_base64Buffer);\n        return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER));\n    }\n    \n    public char[] allocTokenBuffer() {\n        _verifyAlloc(_tokenCBuffer);\n        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));\n    }\n\n    /**\n     * @since 2.4\n     */\n    public char[] allocTokenBuffer(int minSize) {\n        _verifyAlloc(_tokenCBuffer);\n        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, minSize));\n    }\n    \n    public char[] allocConcatBuffer() {\n        _verifyAlloc(_concatCBuffer);\n        return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER));\n    }\n\n    public char[] allocNameCopyBuffer(int minSize) {\n        _verifyAlloc(_nameCopyBuffer);\n        return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, minSize));\n    }\n\n    /**\n     * Method to call when all the processing buffers can be safely\n     * recycled.\n     */\n    public void releaseReadIOBuffer(byte[] buf) {\n        if (buf != null) {\n            /* Let's do sanity checks to ensure once-and-only-once release,\n             * as well as avoiding trying to release buffers not owned\n             */\n            _verifyRelease(buf, _readIOBuffer);\n            _readIOBuffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, buf);\n        }\n    }\n\n    public void releaseWriteEncodingBuffer(byte[] buf) {\n        if (buf != null) {\n            /* Let's do sanity checks to ensure once-and-only-once release,\n             * as well as avoiding trying to release buffers not owned\n             */\n            _verifyRelease(buf, _writeEncodingBuffer);\n            _writeEncodingBuffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, buf);\n        }\n    }\n\n    public void releaseBase64Buffer(byte[] buf) {\n        if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n            _verifyRelease(buf, _base64Buffer);\n            _base64Buffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER, buf);\n        }\n    }\n    \n    public void releaseTokenBuffer(char[] buf) {\n        if (buf != null) {\n            _verifyRelease(buf, _tokenCBuffer);\n            _tokenCBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, buf);\n        }\n    }\n\n    public void releaseConcatBuffer(char[] buf) {\n        if (buf != null) {\n            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n            _verifyRelease(buf, _concatCBuffer);\n            _concatCBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\n        }\n    }\n\n    public void releaseNameCopyBuffer(char[] buf) {\n        if (buf != null) {\n            // 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n            _verifyRelease(buf, _nameCopyBuffer);\n            _nameCopyBuffer = null;\n            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, buf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal helpers\n    /**********************************************************\n     */\n\n    protected final void _verifyAlloc(Object buffer) {\n        if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n    }\n\n    protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n    }\n\n    protected final void _verifyRelease(char[] toRelease, char[] src) {\n        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n        if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); }\n    }\n\n    private IllegalArgumentException wrongBuf() {\n        // sanity check failed; trying to return different, smaller buffer.\n        return new IllegalArgumentException(\"Trying to release buffer smaller than original\");\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 15, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate", "buggy_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return (_currToken = t);\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n", "fixed_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \tif(!_allowMultipleMatches && _currToken != null && _exposedContext == null){\n    \t\t//if not scalar and ended successfully, then return null\n    \t\tif((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n    \t\telse if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath \n    \t\t\t\t&& _itemFilter == TokenFilter.INCLUDE_ALL) {\n    \t\t\treturn (_currToken = null);\n    \t\t}\n    \t}\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return (_currToken = t);\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}]}
{"project": "JacksonCore", "bug_id": 16, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.util.JsonParserSequence", "buggy_version": "package com.fasterxml.jackson.core.util;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Helper class that can be used to sequence multiple physical\n * {@link JsonParser}s to create a single logical sequence of\n * tokens, as a single {@link JsonParser}.\n *<p>\n * Fairly simple use of {@link JsonParserDelegate}: only need\n * to override {@link #nextToken} to handle transition\n */\npublic class JsonParserSequence extends JsonParserDelegate\n{\n    /**\n     * Parsers other than the first one (which is initially assigned\n     * as delegate)\n     */\n    protected final JsonParser[] _parsers;\n    \n    /**\n     * Index of the next parser in {@link #_parsers}.\n     */\n    protected int _nextParser;\n\n    /**\n     * Flag used to indicate that `JsonParser.nextToken()` should not be called,\n     * due to parser already pointing to a token.\n     *\n     * @since 2.8\n     */\n    \n    /*\n     *******************************************************\n     * Construction\n     *******************************************************\n     */\n\n    protected JsonParserSequence(JsonParser[] parsers)\n    {\n        super(parsers[0]);\n        _parsers = parsers;\n        _nextParser = 1;\n    }\n\n    /**\n     * Method that will construct a parser (possibly a sequence) that\n     * contains all given sub-parsers.\n     * All parsers given are checked to see if they are sequences: and\n     * if so, they will be \"flattened\", that is, contained parsers are\n     * directly added in a new sequence instead of adding sequences\n     * within sequences. This is done to minimize delegation depth,\n     * ideally only having just a single level of delegation.\n     */\n    public static JsonParserSequence createFlattened(JsonParser first, JsonParser second)\n    {\n        if (!(first instanceof JsonParserSequence || second instanceof JsonParserSequence)) {\n            // simple:\n            return new JsonParserSequence(new JsonParser[] { first, second });\n        }\n        ArrayList<JsonParser> p = new ArrayList<JsonParser>();\n        if (first instanceof JsonParserSequence) {\n            ((JsonParserSequence) first).addFlattenedActiveParsers(p);\n        } else {\n            p.add(first);\n        }\n        if (second instanceof JsonParserSequence) {\n            ((JsonParserSequence) second).addFlattenedActiveParsers(p);\n        } else {\n            p.add(second);\n        }\n        return new JsonParserSequence(p.toArray(new JsonParser[p.size()]));\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected void addFlattenedActiveParsers(List<JsonParser> result)\n    {\n        for (int i = _nextParser-1, len = _parsers.length; i < len; ++i) {\n            JsonParser p = _parsers[i];\n            if (p instanceof JsonParserSequence) {\n                ((JsonParserSequence) p).addFlattenedActiveParsers(result);\n            } else {\n                result.add(p);\n            }\n        }\n    }\n    \n    /*\n     *******************************************************\n     * Overridden methods, needed: cases where default\n     * delegation does not work\n     *******************************************************\n     */\n    \n    @Override\n    public void close() throws IOException {\n        do { delegate.close(); } while (switchToNext());\n    }\n\n    @Override\n    public JsonToken nextToken() throws IOException, JsonParseException\n    {\n        JsonToken t = delegate.nextToken();\n        if (t != null) return t;\n        while (switchToNext()) {\n            t = delegate.nextToken();\n            if (t != null) return t;\n        }\n        return null;\n    }\n\n    /*\n    /*******************************************************\n    /* Additional extended API\n    /*******************************************************\n     */\n\n    /**\n     * Method that is most useful for debugging or testing;\n     * returns actual number of underlying parsers sequence\n     * was constructed with (nor just ones remaining active)\n     */\n    public int containedParsersCount() {\n        return _parsers.length;\n    }\n    \n    /*\n    /*******************************************************\n    /* Helper methods\n    /*******************************************************\n     */\n\n    /**\n     * Method that will switch active parser from the current one\n     * to next parser in sequence, if there is another parser left,\n     * making this the new delegate. Old delegate is returned if\n     * switch succeeds.\n     * \n     * @return True if switch succeeded; false otherwise\n     */\n    protected boolean switchToNext()\n    {\n        if (_nextParser >= _parsers.length) {\n            return false;\n        }\n        delegate = _parsers[_nextParser++];\n        return true;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.util;\n\nimport java.io.IOException;\nimport java.util.*;\n\nimport com.fasterxml.jackson.core.*;\n\n/**\n * Helper class that can be used to sequence multiple physical\n * {@link JsonParser}s to create a single logical sequence of\n * tokens, as a single {@link JsonParser}.\n *<p>\n * Fairly simple use of {@link JsonParserDelegate}: only need\n * to override {@link #nextToken} to handle transition\n */\npublic class JsonParserSequence extends JsonParserDelegate\n{\n    /**\n     * Parsers other than the first one (which is initially assigned\n     * as delegate)\n     */\n    protected final JsonParser[] _parsers;\n    \n    /**\n     * Index of the next parser in {@link #_parsers}.\n     */\n    protected int _nextParser;\n\n    /**\n     * Flag used to indicate that `JsonParser.nextToken()` should not be called,\n     * due to parser already pointing to a token.\n     *\n     * @since 2.8\n     */\n    protected boolean _suppressNextToken;\n    \n    /*\n     *******************************************************\n     * Construction\n     *******************************************************\n     */\n\n    protected JsonParserSequence(JsonParser[] parsers)\n    {\n        super(parsers[0]);\n        _suppressNextToken = delegate.hasCurrentToken();\n        _parsers = parsers;\n        _nextParser = 1;\n    }\n\n    /**\n     * Method that will construct a parser (possibly a sequence) that\n     * contains all given sub-parsers.\n     * All parsers given are checked to see if they are sequences: and\n     * if so, they will be \"flattened\", that is, contained parsers are\n     * directly added in a new sequence instead of adding sequences\n     * within sequences. This is done to minimize delegation depth,\n     * ideally only having just a single level of delegation.\n     */\n    public static JsonParserSequence createFlattened(JsonParser first, JsonParser second)\n    {\n        if (!(first instanceof JsonParserSequence || second instanceof JsonParserSequence)) {\n            // simple:\n            return new JsonParserSequence(new JsonParser[] { first, second });\n        }\n        ArrayList<JsonParser> p = new ArrayList<JsonParser>();\n        if (first instanceof JsonParserSequence) {\n            ((JsonParserSequence) first).addFlattenedActiveParsers(p);\n        } else {\n            p.add(first);\n        }\n        if (second instanceof JsonParserSequence) {\n            ((JsonParserSequence) second).addFlattenedActiveParsers(p);\n        } else {\n            p.add(second);\n        }\n        return new JsonParserSequence(p.toArray(new JsonParser[p.size()]));\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected void addFlattenedActiveParsers(List<JsonParser> result)\n    {\n        for (int i = _nextParser-1, len = _parsers.length; i < len; ++i) {\n            JsonParser p = _parsers[i];\n            if (p instanceof JsonParserSequence) {\n                ((JsonParserSequence) p).addFlattenedActiveParsers(result);\n            } else {\n                result.add(p);\n            }\n        }\n    }\n    \n    /*\n     *******************************************************\n     * Overridden methods, needed: cases where default\n     * delegation does not work\n     *******************************************************\n     */\n    \n    @Override\n    public void close() throws IOException {\n        do { delegate.close(); } while (switchToNext());\n    }\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        if (delegate == null) {\n            return null;\n        }\n        if (_suppressNextToken) {\n            _suppressNextToken = false;\n            return delegate.currentToken();\n        }\n        JsonToken t = delegate.nextToken();\n        while ((t == null) && switchToNext()) {\n            t = delegate.hasCurrentToken()\n                    ? delegate.currentToken() : delegate.nextToken();\n        }\n        return t;\n    }\n\n    /*\n    /*******************************************************\n    /* Additional extended API\n    /*******************************************************\n     */\n\n    /**\n     * Method that is most useful for debugging or testing;\n     * returns actual number of underlying parsers sequence\n     * was constructed with (nor just ones remaining active)\n     */\n    public int containedParsersCount() {\n        return _parsers.length;\n    }\n    \n    /*\n    /*******************************************************\n    /* Helper methods\n    /*******************************************************\n     */\n\n    /**\n     * Method that will switch active parser from the current one\n     * to next parser in sequence, if there is another parser left,\n     * making this the new delegate. Old delegate is returned if\n     * switch succeeds.\n     * \n     * @return True if switch succeeded; false otherwise\n     */\n    protected boolean switchToNext()\n    {\n        if (_nextParser >= _parsers.length) {\n            return false;\n        }\n        delegate = _parsers[_nextParser++];\n        return true;\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 17, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.UTF8JsonGenerator", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n\n        while (len > 0) {\n            int len2 = Math.min(buf.length, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            writeRaw(buf, 0, len2);\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(\"Split surrogate on writeRaw() input (last character)\");\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        writeRaw(text, 0, text.length());\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            _writeRawSegment(buf, 0, len);\n            return;\n        }\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n    {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n                    ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 18, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.base.GeneratorBase", "buggy_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * This base class implements part of API that a JSON generator exposes\n * to applications, adds shared internal methods that sub-classes\n * can use and adds some abstract methods sub-classes must implement.\n */\npublic abstract class GeneratorBase extends JsonGenerator\n{\n    public final static int SURR1_FIRST = 0xD800;\n    public final static int SURR1_LAST = 0xDBFF;\n    public final static int SURR2_FIRST = 0xDC00;\n    public final static int SURR2_LAST = 0xDFFF;\n\n    /**\n     * Set of feature masks related to features that need updates of other\n     * local configuration or state.\n     * \n     * @since 2.5\n     */\n    protected final static int DERIVED_FEATURES_MASK =\n            Feature.WRITE_NUMBERS_AS_STRINGS.getMask()\n            | Feature.ESCAPE_NON_ASCII.getMask()\n            | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n            ;\n\n    // // // Constants for validation messages (since 2.6)\n\n    protected final static String WRITE_BINARY = \"write a binary value\";\n    protected final static String WRITE_BOOLEAN = \"write a boolean value\";\n    protected final static String WRITE_NULL = \"write a null\";\n    protected final static String WRITE_NUMBER = \"write a number\";\n    protected final static String WRITE_RAW = \"write a raw (unencoded) value\";\n    protected final static String WRITE_STRING = \"write a string\";\n\n    /**\n     * This value is the limit of scale allowed for serializing {@link BigDecimal}\n     * in \"plain\" (non-engineering) notation; intent is to prevent asymmetric\n     * attack whereupon simple eng-notation with big scale is used to generate\n     * huge \"plain\" serialization. See [core#315] for details.\n     * \n     * @since 2.7.7\n     */\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     */\n    protected int _features;\n\n    /**\n     * Flag set to indicate that implicit conversion from number\n     * to JSON String is needed (as per\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_NUMBERS_AS_STRINGS}).\n     */\n    protected boolean _cfgNumbersAsStrings;\n\n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Object that keeps track of the current contextual state\n     * of the generator.\n     */\n    protected JsonWriteContext _writeContext;\n\n    /**\n     * Flag that indicates whether generator is closed or not. Gets\n     * set when it is closed by an explicit call\n     * ({@link #close}).\n     */\n    protected boolean _closed;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected GeneratorBase(int features, ObjectCodec codec) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _writeContext = JsonWriteContext.createRootContext(dups);\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        _writeContext = ctxt;\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    /**\n     * Implemented with standard version number detection algorithm, typically using\n     * a simple generated class, with information extracted from Maven project file\n     * during build.\n     */\n    @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n\n    @Override\n    public Object getCurrentValue() {\n        return _writeContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _writeContext.setCurrentValue(v);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n\n    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n    @Override public int getFeatureMask() { return _features; }\n\n    //public JsonGenerator configure(Feature f, boolean state) { }\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        final int mask = f.getMask();\n        _features |= mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            // why not switch? Requires addition of a generated class, alas\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = true;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(127);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        final int mask = f.getMask();\n        _features &= ~mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = false;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(0);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonGenerator setFeatureMask(int newMask) {\n        int changed = newMask ^ _features;\n        _features = newMask;\n        if (changed != 0) {\n            _checkStdFeatureChanges(newMask, changed);\n        }\n        return this;\n    }\n\n    @Override // since 2.7\n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    /**\n     * Helper method called to verify changes to standard features.\n     *\n     * @param newFeatureFlags Bitflag of standard features after they were changed\n     * @param changedFeatures Bitflag of standard features for which setting\n     *    did change\n     *\n     * @since 2.7\n     */\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n    {\n        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n            return;\n        }\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n                setHighestNonEscapedChar(127);\n            } else {\n                setHighestNonEscapedChar(0);\n            }\n        }\n        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling\n                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            } else { // disabling\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n    }\n\n    @Override public JsonGenerator useDefaultPrettyPrinter() {\n        // Should not override a pretty printer if one already assigned.\n        if (getPrettyPrinter() != null) {\n            return this;\n        }\n        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n    }\n    \n    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n\n    /*\n    /**********************************************************\n    /* Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Note: co-variant return type.\n     */\n    @Override public JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, structural\n    /**********************************************************\n     */\n\n    //public void writeStartArray() throws IOException\n    //public void writeEndArray() throws IOException\n    //public void writeStartObject() throws IOException\n    //public void writeEndObject() throws IOException\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, textual\n    /**********************************************************\n     */\n\n    @Override public void writeFieldName(SerializableString name) throws IOException {\n        writeFieldName(name.getValue());\n    }\n    \n    //public abstract void writeString(String text) throws IOException;\n\n    //public abstract void writeString(char[] text, int offset, int len) throws IOException;\n\n    //public abstract void writeRaw(String text) throws IOException,;\n\n    //public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n\n    @Override public void writeRawValue(String text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override public void writeRawValue(String text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n        // Let's implement this as \"unsupported\" to make it easier to add new parser impls\n        _reportUnsupportedOperation();\n        return 0;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, write methods, primitive\n   /**********************************************************\n    */\n\n    // Not implemented at this level, added as placeholders\n\n     /*\n    public abstract void writeNumber(int i)\n    public abstract void writeNumber(long l)\n    public abstract void writeNumber(double d)\n    public abstract void writeNumber(float f)\n    public abstract void writeNumber(BigDecimal dec)\n    public abstract void writeBoolean(boolean state)\n    public abstract void writeNull()\n    */\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, POJOs, trees\n    /**********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            // important: call method that does check value write:\n            writeNull();\n        } else {\n            /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n             *   because that will be done when codec actually serializes\n             *   contained POJO. If we did call it it would advance state\n             *   causing exception later on\n             */\n            if (_objectCodec != null) {\n                _objectCodec.writeValue(this, value);\n                return;\n            }\n            _writeSimpleObject(value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode rootNode) throws IOException {\n        // As with 'writeObject()', we are not check if write would work\n        if (rootNode == null) {\n            writeNull();\n        } else {\n            if (_objectCodec == null) {\n                throw new IllegalStateException(\"No ObjectCodec defined\");\n            }\n            _objectCodec.writeValue(this, rootNode);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, low-level output handling\n    /**********************************************************\n     */\n\n    @Override public abstract void flush() throws IOException;\n    @Override public void close() throws IOException { _closed = true; }\n    @Override public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* Package methods for this, sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release any buffers generator may be holding,\n     * once generator is being closed.\n     */\n    protected abstract void _releaseBuffers();\n\n    /**\n     * Method called before trying to write a value (scalar or structured),\n     * to verify that this is legal in current output state, as well as to\n     * output separators if and as necessary.\n     * \n     * @param typeMsg Additional message used for generating exception message\n     *   if value output is NOT legal in current generator output state.\n     */\n    protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n\n    /**\n     * Overridable factory method called to instantiate an appropriate {@link PrettyPrinter}\n     * for case of \"just use the default one\", when {@link #useDefaultPrettyPrinter()} is called.\n     *\n     * @since 2.6\n     */\n    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultPrettyPrinter();\n    }\n\n    /**\n     * Helper method used to serialize a {@link java.math.BigDecimal} as a String,\n     * for serialization, taking into account configuration settings\n     *\n     * @since 2.7.7\n     */\n    protected String _asString(BigDecimal value) throws IOException {\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n        return value.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* UTF-8 related helper method(s)\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.5\n     */\n    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException\n    {\n        // First is known to be valid, but how about the other?\n        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n            _reportError(msg);\n        }\n        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n        return c;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * This base class implements part of API that a JSON generator exposes\n * to applications, adds shared internal methods that sub-classes\n * can use and adds some abstract methods sub-classes must implement.\n */\npublic abstract class GeneratorBase extends JsonGenerator\n{\n    public final static int SURR1_FIRST = 0xD800;\n    public final static int SURR1_LAST = 0xDBFF;\n    public final static int SURR2_FIRST = 0xDC00;\n    public final static int SURR2_LAST = 0xDFFF;\n\n    /**\n     * Set of feature masks related to features that need updates of other\n     * local configuration or state.\n     * \n     * @since 2.5\n     */\n    protected final static int DERIVED_FEATURES_MASK =\n            Feature.WRITE_NUMBERS_AS_STRINGS.getMask()\n            | Feature.ESCAPE_NON_ASCII.getMask()\n            | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n            ;\n\n    // // // Constants for validation messages (since 2.6)\n\n    protected final static String WRITE_BINARY = \"write a binary value\";\n    protected final static String WRITE_BOOLEAN = \"write a boolean value\";\n    protected final static String WRITE_NULL = \"write a null\";\n    protected final static String WRITE_NUMBER = \"write a number\";\n    protected final static String WRITE_RAW = \"write a raw (unencoded) value\";\n    protected final static String WRITE_STRING = \"write a string\";\n\n    /**\n     * This value is the limit of scale allowed for serializing {@link BigDecimal}\n     * in \"plain\" (non-engineering) notation; intent is to prevent asymmetric\n     * attack whereupon simple eng-notation with big scale is used to generate\n     * huge \"plain\" serialization. See [core#315] for details.\n     * \n     * @since 2.7.7\n     */\n    protected final static int MAX_BIG_DECIMAL_SCALE = 9999;\n    \n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n     * are enabled.\n     */\n    protected int _features;\n\n    /**\n     * Flag set to indicate that implicit conversion from number\n     * to JSON String is needed (as per\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_NUMBERS_AS_STRINGS}).\n     */\n    protected boolean _cfgNumbersAsStrings;\n\n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Object that keeps track of the current contextual state\n     * of the generator.\n     */\n    protected JsonWriteContext _writeContext;\n\n    /**\n     * Flag that indicates whether generator is closed or not. Gets\n     * set when it is closed by an explicit call\n     * ({@link #close}).\n     */\n    protected boolean _closed;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected GeneratorBase(int features, ObjectCodec codec) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _writeContext = JsonWriteContext.createRootContext(dups);\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    /**\n     * @since 2.5\n     */\n    protected GeneratorBase(int features, ObjectCodec codec, JsonWriteContext ctxt) {\n        super();\n        _features = features;\n        _objectCodec = codec;\n        _writeContext = ctxt;\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n    }\n\n    /**\n     * Implemented with standard version number detection algorithm, typically using\n     * a simple generated class, with information extracted from Maven project file\n     * during build.\n     */\n    @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n\n    @Override\n    public Object getCurrentValue() {\n        return _writeContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _writeContext.setCurrentValue(v);\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n\n    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n    @Override public int getFeatureMask() { return _features; }\n\n    //public JsonGenerator configure(Feature f, boolean state) { }\n\n    @Override\n    public JsonGenerator enable(Feature f) {\n        final int mask = f.getMask();\n        _features |= mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            // why not switch? Requires addition of a generated class, alas\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = true;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(127);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonGenerator disable(Feature f) {\n        final int mask = f.getMask();\n        _features &= ~mask;\n        if ((mask & DERIVED_FEATURES_MASK) != 0) {\n            if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                _cfgNumbersAsStrings = false;\n            } else if (f == Feature.ESCAPE_NON_ASCII) {\n                setHighestNonEscapedChar(0);\n            } else if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonGenerator setFeatureMask(int newMask) {\n        int changed = newMask ^ _features;\n        _features = newMask;\n        if (changed != 0) {\n            _checkStdFeatureChanges(newMask, changed);\n        }\n        return this;\n    }\n\n    @Override // since 2.7\n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    /**\n     * Helper method called to verify changes to standard features.\n     *\n     * @param newFeatureFlags Bitflag of standard features after they were changed\n     * @param changedFeatures Bitflag of standard features for which setting\n     *    did change\n     *\n     * @since 2.7\n     */\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n    {\n        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n            return;\n        }\n        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n                setHighestNonEscapedChar(127);\n            } else {\n                setHighestNonEscapedChar(0);\n            }\n        }\n        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling\n                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                }\n            } else { // disabling\n                _writeContext = _writeContext.withDupDetector(null);\n            }\n        }\n    }\n\n    @Override public JsonGenerator useDefaultPrettyPrinter() {\n        // Should not override a pretty printer if one already assigned.\n        if (getPrettyPrinter() != null) {\n            return this;\n        }\n        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n    }\n    \n    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n        _objectCodec = oc;\n        return this;\n    }\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n\n    /*\n    /**********************************************************\n    /* Public API, accessors\n    /**********************************************************\n     */\n\n    /**\n     * Note: co-variant return type.\n     */\n    @Override public JsonWriteContext getOutputContext() { return _writeContext; }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, structural\n    /**********************************************************\n     */\n\n    //public void writeStartArray() throws IOException\n    //public void writeEndArray() throws IOException\n    //public void writeStartObject() throws IOException\n    //public void writeEndObject() throws IOException\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, textual\n    /**********************************************************\n     */\n\n    @Override public void writeFieldName(SerializableString name) throws IOException {\n        writeFieldName(name.getValue());\n    }\n    \n    //public abstract void writeString(String text) throws IOException;\n\n    //public abstract void writeString(char[] text, int offset, int len) throws IOException;\n\n    //public abstract void writeRaw(String text) throws IOException,;\n\n    //public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n\n    @Override public void writeRawValue(String text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override public void writeRawValue(String text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text, offset, len);\n    }\n\n    @Override public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(\"write raw value\");\n        writeRaw(text);\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n        // Let's implement this as \"unsupported\" to make it easier to add new parser impls\n        _reportUnsupportedOperation();\n        return 0;\n    }\n\n    /*\n   /**********************************************************\n   /* Public API, write methods, primitive\n   /**********************************************************\n    */\n\n    // Not implemented at this level, added as placeholders\n\n     /*\n    public abstract void writeNumber(int i)\n    public abstract void writeNumber(long l)\n    public abstract void writeNumber(double d)\n    public abstract void writeNumber(float f)\n    public abstract void writeNumber(BigDecimal dec)\n    public abstract void writeBoolean(boolean state)\n    public abstract void writeNull()\n    */\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, POJOs, trees\n    /**********************************************************\n     */\n\n    @Override\n    public void writeObject(Object value) throws IOException {\n        if (value == null) {\n            // important: call method that does check value write:\n            writeNull();\n        } else {\n            /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n             *   because that will be done when codec actually serializes\n             *   contained POJO. If we did call it it would advance state\n             *   causing exception later on\n             */\n            if (_objectCodec != null) {\n                _objectCodec.writeValue(this, value);\n                return;\n            }\n            _writeSimpleObject(value);\n        }\n    }\n\n    @Override\n    public void writeTree(TreeNode rootNode) throws IOException {\n        // As with 'writeObject()', we are not check if write would work\n        if (rootNode == null) {\n            writeNull();\n        } else {\n            if (_objectCodec == null) {\n                throw new IllegalStateException(\"No ObjectCodec defined\");\n            }\n            _objectCodec.writeValue(this, rootNode);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, low-level output handling\n    /**********************************************************\n     */\n\n    @Override public abstract void flush() throws IOException;\n    @Override public void close() throws IOException { _closed = true; }\n    @Override public boolean isClosed() { return _closed; }\n\n    /*\n    /**********************************************************\n    /* Package methods for this, sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release any buffers generator may be holding,\n     * once generator is being closed.\n     */\n    protected abstract void _releaseBuffers();\n\n    /**\n     * Method called before trying to write a value (scalar or structured),\n     * to verify that this is legal in current output state, as well as to\n     * output separators if and as necessary.\n     * \n     * @param typeMsg Additional message used for generating exception message\n     *   if value output is NOT legal in current generator output state.\n     */\n    protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n\n    /**\n     * Overridable factory method called to instantiate an appropriate {@link PrettyPrinter}\n     * for case of \"just use the default one\", when {@link #useDefaultPrettyPrinter()} is called.\n     *\n     * @since 2.6\n     */\n    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultPrettyPrinter();\n    }\n\n    /**\n     * Helper method used to serialize a {@link java.math.BigDecimal} as a String,\n     * for serialization, taking into account configuration settings\n     *\n     * @since 2.7.7\n     */\n    protected String _asString(BigDecimal value) throws IOException {\n        if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n            int scale = value.scale();\n            if ((scale < -MAX_BIG_DECIMAL_SCALE) || (scale > MAX_BIG_DECIMAL_SCALE)) {\n                _reportError(String.format(\n\"Attempt to write plain `java.math.BigDecimal` (see JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN) with illegal scale (%d): needs to be between [-%d, %d]\",\nscale, MAX_BIG_DECIMAL_SCALE, MAX_BIG_DECIMAL_SCALE));\n            }\n            return value.toPlainString();\n        }\n        return value.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* UTF-8 related helper method(s)\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.5\n     */\n    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException\n    {\n        // First is known to be valid, but how about the other?\n        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n            _reportError(msg);\n        }\n        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n        return c;\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.UTF8JsonGenerator", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        final int len = text.length();\n        final char[] buf = _charBuffer;\n        if (len <= buf.length) {\n            text.getChars(0, len, buf, 0);\n            writeRaw(buf, 0, len);\n        } else {\n            writeRaw(text, 0, len);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            writeRaw(buf, 0, len);\n            return;\n        }\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n    {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\npublic class UTF8JsonGenerator\n    extends JsonGeneratorImpl\n{\n    private final static byte BYTE_u = (byte) 'u';\n\n    private final static byte BYTE_0 = (byte) '0';\n\n    private final static byte BYTE_LBRACKET = (byte) '[';\n    private final static byte BYTE_RBRACKET = (byte) ']';\n    private final static byte BYTE_LCURLY = (byte) '{';\n    private final static byte BYTE_RCURLY = (byte) '}';\n\n    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n    private final static byte BYTE_COMMA = (byte) ',';\n    private final static byte BYTE_COLON = (byte) ':';\n    private final static byte BYTE_QUOTE = (byte) '\"';\n\n    // intermediate copies only made up to certain length...\n    private final static int MAX_BYTES_TO_BUFFER = 512;\n\n    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n\n    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    /**\n     * Underlying output stream used for writing JSON content.\n     */\n    final protected OutputStream _outputStream;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_outputStream}.\n     */\n    protected byte[] _outputBuffer;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may be past the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected final int _outputEnd;\n\n    /**\n     * Maximum number of <code>char</code>s that we know will always fit\n     * in the output buffer after escaping\n     */\n    protected final int _outputMaxContiguous;\n\n    /**\n     * Intermediate buffer in which characters of a String are copied\n     * before being encoded.\n     */\n    protected char[] _charBuffer;\n\n    /**\n     * Length of <code>_charBuffer</code>\n     */\n    protected final int _charBufferLength;\n\n    /**\n     * 6 character temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected byte[] _entityBuffer;\n\n    /**\n     * Flag that indicates whether the output buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out)\n    {\n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = true;\n        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n        _outputEnd = _outputBuffer.length;\n\n        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n         * we will actually round down to only do up to 1/8 number of chars\n         */\n        _outputMaxContiguous = _outputEnd >> 3;\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n\n        // By default we use this feature to determine additional quoting\n        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n            setHighestNonEscapedChar(127);\n        }\n    }\n    \n    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n            OutputStream out,\n            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n    {\n        \n        super(ctxt, features, codec);\n        _outputStream = out;\n        _bufferRecyclable = bufferRecyclable;\n        _outputTail = outputOffset;\n        _outputBuffer = outputBuffer;\n        _outputEnd = _outputBuffer.length;\n        // up to 6 bytes per char (see above), rounded up to 1/8\n        _outputMaxContiguous = (_outputEnd >> 3);\n        _charBuffer = ctxt.allocConcatBuffer();\n        _charBufferLength = _charBuffer.length;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _outputStream;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail is always valid, set to 0 on close\n        return _outputTail;\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        /* To support [JACKSON-46], we'll do this:\n         * (Question: should quoting of spaces (etc) still be enabled?)\n         */\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        // Does it fit in buffer?\n        if (len > _charBufferLength) { // no, offline\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(name, 0, len);\n        } else {\n            _writeStringSegments(name, 0, len);\n        }\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name);\n            return;\n        }\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_COMMA;\n        }\n        if (_cfgUnqNames) {\n            _writeUnq(name);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) { // couldn't append, bit longer processing\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    private final void _writeUnq(SerializableString name) throws IOException {\n        int len = name.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(name.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n        }\n    }\n\n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected final void _writePPFieldName(String name) throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n        if (_cfgUnqNames) {\n            _writeStringSegments(name, false);\n            return;\n        }\n        final int len = name.length();\n        if (len > _charBufferLength) {\n            _writeStringSegments(name, true);\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        name.getChars(0, len, _charBuffer, 0);\n        // But as one segment, or multiple?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(_charBuffer, 0, len);\n        } else {\n            _writeStringSegments(_charBuffer, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    protected final void _writePPFieldName(SerializableString name) throws IOException\n    {\n        final int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        final boolean addQuotes = !_cfgUnqNames; // standard\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n        _writeBytes(name.asQuotedUTF8());\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        // First: if we can't guarantee it all fits, quoted, within output, offline\n        final int len = text.length();\n        if (len > _outputMaxContiguous) { // nope: off-line handling\n            _writeStringSegments(text, true);\n            return;\n        }\n        if ((_outputTail + len) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeStringSegment(text, 0, len); // we checked space already above\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n        } else {\n            _writeStringSegments(text, offset, len);\n        }\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public final void writeString(SerializableString text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        int len = text.appendQuotedUTF8(_outputBuffer, _outputTail);\n        if (len < 0) {\n            _writeBytes(text.asQuotedUTF8());\n        } else {\n            _outputTail += len;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBytes(text, offset, length);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        // One or multiple segments?\n        if (len <= _outputMaxContiguous) {\n            _writeUTF8Segment(text, offset, len);\n        } else {\n            _writeUTF8Segments(text, offset, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n        final int len = text.length();\n        final char[] buf = _charBuffer;\n        if (len <= buf.length) {\n            text.getChars(0, len, buf, 0);\n            writeRaw(buf, 0, len);\n        } else {\n            writeRaw(text, 0, len);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        final char[] buf = _charBuffer;\n\n        // minor optimization: see if we can just get and copy\n        if (len <= buf.length) {\n            text.getChars(offset, offset+len, buf, 0);\n            writeRaw(buf, 0, len);\n            return;\n        }\n\n        // If not, need segmented approach. For speed, let's also use input buffer\n        // size that is guaranteed to fit in output buffer; each char can expand to\n        // at most 3 bytes, so at most 1/3 of buffer size.\n        final int maxChunk = (_outputEnd >> 2) + (_outputEnd >> 4); // == (1/4 + 1/16) == 5/16\n        final int maxBytes = maxChunk * 3;\n\n        while (len > 0) {\n            int len2 = Math.min(maxChunk, len);\n            text.getChars(offset, offset+len2, buf, 0);\n            if ((_outputTail + maxBytes) > _outputEnd) {\n                _flushBuffer();\n            }\n            // If this is NOT the last segment and if the last character looks like\n            // split surrogate second half, drop it\n            if (len > 0) {\n                char ch = buf[len2-1];\n                if ((ch >= SURR1_FIRST) && (ch <= SURR1_LAST)) {\n                    --len2;\n                }\n            }\n            _writeRawSegment(buf, 0, len2);\n            offset += len2;\n            len -= len2;\n        }\n    }\n\n    @Override\n    public void writeRaw(SerializableString text) throws IOException\n    {\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // since 2.5\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _verifyValueWrite(WRITE_RAW);\n        byte[] raw = text.asUnquotedUTF8();\n        if (raw.length > 0) {\n            _writeBytes(raw);\n        }\n    }\n\n    // @TODO: rewrite for speed...\n    @Override\n    public final void writeRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n        {\n            int len3 = len+len+len;\n            if ((_outputTail + len3) > _outputEnd) {\n                // maybe we could flush?\n                if (_outputEnd < len3) { // wouldn't be enough...\n                    _writeSegmentedRaw(cbuf, offset, len);\n                    return;\n                }\n                // yes, flushing brings enough space\n                _flushBuffer();\n            }\n        }\n        len += offset; // now marks the end\n\n        // Note: here we know there is enough room, hence no output boundary checks\n        main_loop:\n        while (offset < len) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= len) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, len);\n            }\n        }\n    }\n\n    @Override\n    public void writeRaw(char ch) throws IOException\n    {\n        if ((_outputTail + 3) >= _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        if (ch <= 0x7F) {\n            bbuf[_outputTail++] = (byte) ch;\n        } else  if (ch < 0x800) { // 2-byte?\n            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        } else {\n            /*offset =*/ _outputRawMultiByteChar(ch, null, 0, 0);\n        }\n    }\n\n    /**\n     * Helper method called when it is possible that output of raw section\n     * to output may cross buffer boundary\n     */\n    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException\n    {\n        final int end = _outputEnd;\n        final byte[] bbuf = _outputBuffer;\n        final int inputEnd = offset + len;\n        \n        main_loop:\n        while (offset < inputEnd) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch >= 0x80) {\n                    break inner_loop;\n                }\n                // !!! TODO: fast(er) writes (roll input, output checks in one)\n                if (_outputTail >= end) {\n                    _flushBuffer();\n                }\n                bbuf[_outputTail++] = (byte) ch;\n                if (++offset >= inputEnd) {\n                    break main_loop;\n                }\n            }\n            if ((_outputTail + 3) >= _outputEnd) {\n                _flushBuffer();\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, inputEnd);\n            }\n        }\n    }\n\n    /**\n     * Helper method that is called for segmented write of raw content\n     * when explicitly outputting a segment of longer thing.\n     * Caller has to take care of ensuring there's no split surrogate\n     * pair at the end (that is, last char can not be first part of a\n     * surrogate char pair).\n     *\n     * @since 2.8.2\n     */\n    private void _writeRawSegment(char[] cbuf, int offset, int end) throws IOException\n    {\n        main_loop:\n        while (offset < end) {\n            inner_loop:\n            while (true) {\n                int ch = (int) cbuf[offset];\n                if (ch > 0x7F) {\n                    break inner_loop;\n                }\n                _outputBuffer[_outputTail++] = (byte) ch;\n                if (++offset >= end) {\n                    break main_loop;\n                }\n            }\n            char ch = cbuf[offset++];\n            if (ch < 0x800) { // 2-byte?\n                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                offset = _outputRawMultiByteChar(ch, cbuf, offset, end);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n            byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n    \n    private final void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    } \n    \n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedInt(int i) throws IOException\n    {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private final void _writeQuotedLong(long l) throws IOException\n    {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            (((Double.isNaN(d) || Double.isInfinite(d))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n            (((Float.isNaN(f) || Float.isInfinite(f))\n                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);            \n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private final void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n        int len = keyword.length;\n        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        if (_cfgPrettyPrinter == null) {\n            byte b;\n            switch (status) {\n            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n                b = BYTE_COMMA;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                b = BYTE_COLON;\n                break;\n            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n                if (_rootValueSeparator != null) {\n                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n                    if (raw.length > 0) {\n                        _writeBytes(raw);\n                    }\n                }\n                return;\n            case JsonWriteContext.STATUS_OK_AS_IS:\n            default:\n                return;\n            }\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail] = b;\n            ++_outputTail;\n            return;\n        }\n        // Otherwise, pretty printer knows what to do...\n        _verifyPrettyValueWrite(typeMsg, status);\n    }\n\n    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n    {\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_outputStream != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _outputStream.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if ((_outputBuffer != null)\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputTail = 0; // just to ensure we don't think there's anything buffered\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_outputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _outputStream.close();\n            } else if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _outputStream.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        byte[] buf = _outputBuffer;\n        if (buf != null && _bufferRecyclable) {\n            _outputBuffer = null;\n            _ioContext.releaseWriteEncodingBuffer(buf);\n        }\n        char[] cbuf = _charBuffer;\n        if (cbuf != null) {\n            _charBuffer = null;\n            _ioContext.releaseConcatBuffer(cbuf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, raw bytes\n    /**********************************************************\n     */\n\n    private final void _writeBytes(byte[] bytes) throws IOException\n    {\n        final int len = bytes.length;\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, 0, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n    {\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            // still not enough?\n            if (len > MAX_BYTES_TO_BUFFER) {\n                _outputStream.write(bytes, offset, len);\n                return;\n            }\n        }\n        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, mid-level writing, String segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when String to write is long enough not to fit\n     * completely in temporary copy buffer. If so, we will actually\n     * copy it in small enough chunks so it can be directly fed\n     * to single-segment writes (instead of maximum slices that\n     * would fit in copy buffer)\n     */\n    private final void _writeStringSegments(String text, boolean addQuotes) throws IOException\n    {\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;        \n        }\n\n        int left = text.length();\n        int offset = 0;\n\n        while (left > 0) {\n            int len = Math.min(_outputMaxContiguous, left);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            left -= len;\n        }\n\n        if (addQuotes) {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n        }\n    }\n\n    /**\n     * Method called when character sequence to write is long enough that\n     * its maximum encoded and escaped form is not guaranteed to fit in\n     * the output buffer. If so, we will need to choose smaller output\n     * chunks to write at a time.\n     */\n    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(cbuf, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                _flushBuffer();\n            }\n            _writeStringSegment(text, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segments\n    /**********************************************************\n     */\n\n    /**\n     * This method called when the string content is already in\n     * a char buffer, and its maximum total encoded and escaped length\n     * can not exceed size of the output buffer.\n     * Caller must ensure that there is enough space in output buffer,\n     * assuming case of all non-escaped ASCII characters, as well as\n     * potentially enough space for other cases (but not necessarily flushed)\n     */\n    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n        throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        \n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = cbuf[offset];\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            // [JACKSON-106]\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(cbuf, offset, len);\n            // [JACKSON-102]\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(cbuf, offset, len);\n            } else {\n                _writeStringSegmentASCII2(cbuf, offset, len);\n            }\n\n        }\n    }\n\n    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n    {\n        // note: caller MUST ensure (via flushing) there's room for ASCII only\n        // Fast+tight loop for ASCII-only, no-escaping-needed output\n        len += offset; // becomes end marker, then\n\n        int outputPtr = _outputTail;\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n\n        while (offset < len) {\n            int ch = text.charAt(offset);\n            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n            if (ch > 0x7F || escCodes[ch] != 0) {\n                break;\n            }\n            outputBuffer[outputPtr++] = (byte) ch;\n            ++offset;\n        }\n        _outputTail = outputPtr;\n        if (offset < len) {\n            if (_characterEscapes != null) {\n                _writeCustomStringSegment2(text, offset, len);\n            } else if (_maximumNonEscapedChar == 0) {\n                _writeStringSegment2(text, offset, len);\n            } else {\n                _writeStringSegmentASCII2(text, offset, len);\n            }\n        }\n    }\n\n    /**\n     * Secondary method called when content contains characters to escape,\n     * and/or multi-byte UTF-8 characters.\n     */\n    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n\n        int outputPtr = _outputTail;\n\n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                }\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n     * additional escaping for high-range code points\n     */\n    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n    \n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        final int maxUnescaped = _maximumNonEscapedChar;\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with fully custom escaping (and possibly escaping of non-ASCII\n    /**********************************************************\n     */\n\n    /**\n     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n     * additional checking for completely custom escapes\n     */\n    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = cbuf[offset++];\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n    {\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n            _flushBuffer();\n        }\n        int outputPtr = _outputTail;\n    \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        // may or may not have this limit\n        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n        \n        while (offset < end) {\n            int ch = text.charAt(offset++);\n            if (ch <= 0x7F) {\n                 if (escCodes[ch] == 0) {\n                     outputBuffer[outputPtr++] = (byte) ch;\n                     continue;\n                 }\n                 int escape = escCodes[ch];\n                 if (escape > 0) { // 2-char escape, fine\n                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                     outputBuffer[outputPtr++] = (byte) escape;\n                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n                     if (esc == null) {\n                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n                     }\n                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                 } else {\n                     // ctrl-char, 6-byte escape...\n                     outputPtr = _writeGenericEscape(ch, outputPtr);\n                 }\n                 continue;\n            }\n            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n                continue;\n            }\n            SerializableString esc = customEscapes.getEscapeSequence(ch);\n            if (esc != null) {\n                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n                continue;\n            }\n            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n            } else {\n                outputPtr = _outputMultiByteChar(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n\n    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n        int len = raw.length;\n        if (len > 6) { // may violate constraints we have, do offline\n            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n        }\n        // otherwise will fit without issues, so:\n        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n        return (outputPtr + len);\n    }\n    \n    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n            int remainingChars)\n        throws IOException, JsonGenerationException\n    {\n        int len = raw.length;\n        if ((outputPtr + len) > outputEnd) {\n            _outputTail = outputPtr;\n            _flushBuffer();\n            outputPtr = _outputTail;\n            if (len > outputBuffer.length) { // very unlikely, but possible...\n                _outputStream.write(raw, 0, len);\n                return outputPtr;\n            }\n            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n            outputPtr += len;\n        }\n        // but is the invariant still obeyed? If not, flush once more\n        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n            _flushBuffer();\n            return _outputTail;\n        }\n        return outputPtr;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n    /**********************************************************\n     */\n    \n    /**\n     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n     * to fit in the output buffer after escaping; as such, we just need to\n     * chunk writes.\n     */\n    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n        throws IOException, JsonGenerationException\n    {\n        do {\n            int len = Math.min(_outputMaxContiguous, totalLen);\n            _writeUTF8Segment(utf8, offset, len);\n            offset += len;\n            totalLen -= len;\n        } while (totalLen > 0);\n    }\n    \n    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n        throws IOException, JsonGenerationException\n    {\n        // fast loop to see if escaping is needed; don't copy, just look\n        final int[] escCodes = _outputEscapes;\n\n        for (int ptr = offset, end = offset + len; ptr < end; ) {\n            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n            int ch = utf8[ptr++];\n            if ((ch >= 0) && escCodes[ch] != 0) {\n                _writeUTF8Segment2(utf8, offset, len);\n                return;\n            }\n        }\n        \n        // yes, fine, just copy the sucker\n        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n        }\n        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n        _outputTail += len;\n    }\n\n    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        int outputPtr = _outputTail;\n\n        // Ok: caller guarantees buffer can have room; but that may require flushing:\n        if ((outputPtr + (len * 6)) > _outputEnd) {\n            _flushBuffer();\n            outputPtr = _outputTail;\n        }\n        \n        final byte[] outputBuffer = _outputBuffer;\n        final int[] escCodes = _outputEscapes;\n        len += offset; // so 'len' becomes 'end'\n        \n        while (offset < len) {\n            byte b = utf8[offset++];\n            int ch = b;\n            if (ch < 0 || escCodes[ch] == 0) {\n                outputBuffer[outputPtr++] = b;\n                continue;\n            }\n            int escape = escCodes[ch];\n            if (escape > 0) { // 2-char escape, fine\n                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n                outputBuffer[outputPtr++] = (byte) escape;\n            } else {\n                // ctrl-char, 6-byte escape...\n                outputPtr = _writeGenericEscape(ch, outputPtr);\n            }\n        }\n        _outputTail = outputPtr;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, base64 encoded\n    /**********************************************************\n     */\n    \n    protected final void _writeBinary(Base64Variant b64variant,\n            byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n\n    // write method when length is unknown\n    protected final int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private final int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, character escapes/encoding\n    /**********************************************************\n     */\n    \n    /**\n     * Method called to output a character that is beyond range of\n     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n     * text (meaning it is not to be escaped or quoted)\n     */\n    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)\n        throws IOException\n    {\n        // Let's handle surrogates gracefully (as 4 byte output):\n        if (ch >= SURR1_FIRST) {\n            if (ch <= SURR2_LAST) { // yes, outside of BMP\n                // Do we have second part?\n                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down\n                    _reportError(String.format(\n\"Split surrogate on writeRaw() input (last character): first character 0x%4x\", ch));\n                }\n                _outputSurrogates(ch, cbuf[inputOffset]);\n                return inputOffset+1;\n            }\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n        return inputOffset;\n    }\n\n    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n    {\n        int c = _decodeSurrogate(surr1, surr2);\n        if ((_outputTail + 4) > _outputEnd) {\n            _flushBuffer();\n        }\n        final byte[] bbuf = _outputBuffer;\n        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n    }\n    \n    /**\n     * \n     * @param ch\n     * @param outputPtr Position within output buffer to append multi-byte in\n     * \n     * @return New output position after appending\n     * \n     * @throws IOException\n     */\n    private final int _outputMultiByteChar(int ch, int outputPtr) throws IOException\n    {\n        byte[] bbuf = _outputBuffer;\n        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n            //   it would be added here... but as things are, we do not have proper\n            //   access yet...\n//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n                bbuf[outputPtr++] = BYTE_BACKSLASH;\n                bbuf[outputPtr++] = BYTE_u;\n                \n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n//            } else { ... }\n        } else {\n            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n        }\n        return outputPtr;\n    }\n\n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n        _outputTail += 4;\n    }\n        \n    /**\n     * Method called to write a generic Unicode escape for given character.\n     * \n     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n     */\n    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n    {\n        final byte[] bbuf = _outputBuffer;\n        bbuf[outputPtr++] = BYTE_BACKSLASH;\n        bbuf[outputPtr++] = BYTE_u;\n        if (charToEscape > 0xFF) {\n            int hi = (charToEscape >> 8) & 0xFF;\n            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n            charToEscape &= 0xFF;\n        } else {\n            bbuf[outputPtr++] = BYTE_0;\n            bbuf[outputPtr++] = BYTE_0;\n        }\n        // We know it's a control char, so only the last 2 chars are non-0\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n        return outputPtr;\n    }\n\n    protected final void _flushBuffer() throws IOException\n    {\n        int len = _outputTail;\n        if (len > 0) {\n            _outputTail = 0;\n            _outputStream.write(_outputBuffer, 0, len);\n        }\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\n/**\n * {@link JsonGenerator} that outputs JSON content using a {@link java.io.Writer}\n * which handles character encoding.\n */\npublic final class WriterBasedJsonGenerator\n    extends JsonGeneratorImpl\n{\n    final protected static int SHORT_WRITE = 32;\n\n    final protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    final protected Writer _writer;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_writer}.\n     */\n    protected char[] _outputBuffer;\n\n    /**\n     * Pointer to the first buffered character to output\n     */\n    protected int _outputHead;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may point to position right beyond the end of the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected int _outputEnd;\n\n    /**\n     * Short (14 char) temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected char[] _entityBuffer;\n\n    /**\n     * When custom escapes are used, this member variable is used\n     * internally to hold a reference to currently used escape\n     */\n    protected SerializableString _currentEscape;\n    \n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public WriterBasedJsonGenerator(IOContext ctxt, int features,\n            ObjectCodec codec, Writer w)\n    {\n        super(ctxt, features, codec);\n        _writer = w;\n        _outputBuffer = ctxt.allocConcatBuffer();\n        _outputEnd = _outputBuffer.length;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _writer;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail and head are kept but... trust and verify:\n        int len = _outputTail - _outputHead;\n        return Math.max(0, len);\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        // Object is a value, need to verify it's allowed\n        int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    protected void _writeFieldName(String name, boolean commaBefore) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        // for fast+std case, need to output up to 2 chars, comma, dquote\n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        // Alternate mode, in which quoting of field names disabled?\n        if (_cfgUnqNames) {\n            _writeString(name);\n            return;\n        }\n        // we know there's room for at least one more char\n        _outputBuffer[_outputTail++] = '\"';\n        // The beef:\n        _writeString(name);\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        // for fast+std case, need to output up to 2 chars, comma, dquote\n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        // Alternate mode, in which quoting of field names disabled?\n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n            return;\n        }\n        // we know there's room for at least one more char\n        _outputBuffer[_outputTail++] = '\"';\n        // The beef:\n        final int qlen = quoted.length;\n        if ((_outputTail + qlen + 1) >= _outputEnd) {\n            writeRaw(quoted, 0, qlen);\n            // and closing quotes; need room for one more char:\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        } else {\n            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n            _outputTail += qlen;\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public void writeStartArray() throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '[';\n        }\n    }\n\n    @Override\n    public void writeEndArray() throws IOException, JsonGenerationException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = ']';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public void writeStartObject() throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '{';\n        }\n    }\n\n    @Override\n    public void writeEndObject() throws IOException, JsonGenerationException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '}';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected void _writePPFieldName(String name, boolean commaBefore) throws IOException\n    {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        if (_cfgUnqNames) {// non-standard, omit quotes\n            _writeString(name);\n        } else { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            _writeString(name);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException\n    {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n    \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {// non-standard, omit quotes\n            writeRaw(quoted, 0, quoted.length);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            writeRaw(quoted, 0, quoted.length);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text);\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text, offset, len);\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(SerializableString sstr) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        // Note: copied from writeRaw:\n        char[] text = sstr.asQuotedChars();\n        final int len = text.length;\n        // Only worth buffering if it's a short write?\n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n        } else {\n            // Otherwise, better just pass through:\n            _flushBuffer();\n            _writer.write(text, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException\n    {\n        // Nothing to check, can just output as is\n        int len = text.length();\n        int room = _outputEnd - _outputTail;\n\n        if (room == 0) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        // But would it nicely fit in? If yes, it's easy\n        if (room >= len) {\n            text.getChars(0, len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {\n            writeRawLong(text);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int start, int len) throws IOException\n    {\n        // Nothing to check, can just output as is\n        int room = _outputEnd - _outputTail;\n\n        if (room < len) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        // But would it nicely fit in? If yes, it's easy\n        if (room >= len) {\n            text.getChars(start, start+len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {            \t\n            writeRawLong(text.substring(start, start+len));\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        writeRaw(text.getValue());\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException\n    {\n        // Only worth buffering if it's a short write?\n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, offset, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n            return;\n        }\n        // Otherwise, better just pass through:\n        _flushBuffer();\n        _writer.write(text, offset, len);\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = c;\n    }\n\n    private void writeRawLong(String text) throws IOException\n    {\n        int room = _outputEnd - _outputTail;\n        // If not, need to do it by looping\n        text.getChars(0, room, _outputBuffer, _outputTail);\n        _outputTail += room;\n        _flushBuffer();\n        int offset = room;\n        int len = text.length() - room;\n\n        while (len > _outputEnd) {\n            int amount = _outputEnd;\n            text.getChars(offset, offset+amount, _outputBuffer, 0);\n            _outputHead = 0;\n            _outputTail = amount;\n            _flushBuffer();\n            offset += amount;\n            len -= amount;\n        }\n        // And last piece (at most length of buffer)\n        text.getChars(offset, offset+len, _outputBuffer, 0);\n        _outputHead = 0;\n        _outputTail = len;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    // !!! 05-Aug-2008, tatus: Any ways to optimize these?\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n            _writeQuotedRaw(raw);\n        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n            writeRaw(value.toPlainString());\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);\n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        if (state) {\n            buf[ptr] = 't';\n            buf[++ptr] = 'r';\n            buf[++ptr] = 'u';\n            buf[++ptr] = 'e';\n        } else {\n            buf[ptr] = 'f';\n            buf[++ptr] = 'a';\n            buf[++ptr] = 'l';\n            buf[++ptr] = 's';\n            buf[++ptr] = 'e';\n        }\n        _outputTail = ptr+1;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            // Otherwise, pretty printer knows what to do...\n            _verifyPrettyValueWrite(typeMsg);\n            return;\n        }\n        char c;\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n            c = ',';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            c = ':';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n            if (_rootValueSeparator != null) {\n                writeRaw(_rootValueSeparator.getValue());\n            }\n            return;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n        default:\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail] = c;\n        ++_outputTail;\n    }\n\n    protected void _verifyPrettyValueWrite(String typeMsg) throws IOException\n    {\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_writer != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _writer.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if (_outputBuffer != null\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputHead = 0;\n        _outputTail = 0;\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_writer != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _writer.close();\n            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _writer.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        char[] buf = _outputBuffer;\n        if (buf != null) {\n            _outputBuffer = null;\n            _ioContext.releaseConcatBuffer(buf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing; text, default\n    /**********************************************************\n     */\n\n    private void _writeString(String text) throws IOException\n    {\n        /* One check first: if String won't fit in the buffer, let's\n         * segment writes. No point in extending buffer to huge sizes\n         * (like if someone wants to include multi-megabyte base64\n         * encoded stuff or such)\n         */\n        final int len = text.length();\n        if (len > _outputEnd) { // Let's reserve space for entity at begin/end\n            _writeLongString(text);\n            return;\n        }\n\n        // Ok: we know String will fit in buffer ok\n        // But do we need to flush first?\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n        }\n        text.getChars(0, len, _outputBuffer, _outputTail);\n\n        if (_characterEscapes != null) {\n            _writeStringCustom(len);\n        } else if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(len, _maximumNonEscapedChar);\n        } else {\n            _writeString2(len);\n        }\n    }\n\n    private void _writeString2(final int len) throws IOException\n    {\n        // And then we'll need to verify need for escaping etc:\n        final int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n\n        output_loop:\n        while (_outputTail < end) {\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                char c = _outputBuffer[_outputTail];\n                if (c < escLen && escCodes[c] != 0) {\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n\n            // Ok, bumped into something that needs escaping.\n            /* First things first: need to flush the buffer.\n             * Inlined, as we don't want to lose tail pointer\n             */\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            /* In any case, tail will be the new start, so hopefully\n             * we have room now.\n             */\n            char c = _outputBuffer[_outputTail++];\n            _prependOrWriteCharacterEscape(c, escCodes[c]);\n        }\n    }\n\n    /**\n     * Method called to write \"long strings\", strings whose length exceeds\n     * output buffer length.\n     */\n    private void _writeLongString(String text) throws IOException\n    {\n        // First things first: let's flush the buffer to get some more room\n        _flushBuffer();\n\n        // Then we can write \n        final int textLen = text.length();\n        int offset = 0;\n        do {\n            int max = _outputEnd;\n            int segmentLen = ((offset + max) > textLen)\n                ? (textLen - offset) : max;\n            text.getChars(offset, offset+segmentLen, _outputBuffer, 0);\n            if (_characterEscapes != null) {\n                _writeSegmentCustom(segmentLen);\n            } else if (_maximumNonEscapedChar != 0) {\n                _writeSegmentASCII(segmentLen, _maximumNonEscapedChar);\n            } else {\n                _writeSegment(segmentLen);\n            }\n            offset += segmentLen;\n        } while (offset < textLen);\n    }\n\n    /**\n     * Method called to output textual context which has been copied\n     * to the output buffer prior to call. If any escaping is needed,\n     * it will also be handled by the method.\n     *<p>\n     * Note: when called, textual content to write is within output\n     * buffer, right after buffered content (if any). That's why only\n     * length of that text is passed, as buffer and offset are implied.\n     */\n    private void _writeSegment(int end) throws IOException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n    \n        int ptr = 0;\n        int start = ptr;\n\n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n\n            // Ok, bumped into something that needs escaping.\n            /* First things first: need to flush the buffer.\n             * Inlined, as we don't want to lose tail pointer\n             */\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            // So; either try to prepend (most likely), or write directly:\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);\n        }\n    }\n    \n    /**\n     * This method called when the string content is already in\n     * a char buffer, and need not be copied for processing.\n     */\n    private void _writeString(char[] text, int offset, int len) throws IOException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /* Same as \"_writeString2()\", except needs additional escaping\n     * for subset of characters\n     */\n    private void _writeStringASCII(final int len, final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        // And then we'll need to verify need for escaping etc:\n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        \n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentASCII(int end, final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringASCII(char[] text, int offset, int len,\n            final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with custom escaping (possibly coupling with ASCII limits)\n    /**********************************************************\n     */\n\n    /* Same as \"_writeString2()\", except needs additional escaping\n     * for subset of characters\n     */\n    private void _writeStringCustom(final int len)\n        throws IOException, JsonGenerationException\n    {\n        // And then we'll need to verify need for escaping etc:\n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break escape_loop;\n                    }\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentCustom(int end)\n        throws IOException, JsonGenerationException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringCustom(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n    \n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing; binary\n    /**********************************************************\n     */\n    \n    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n    \n    // write method when length is unknown\n    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, other\n    /**********************************************************\n     */\n    \n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        buf[ptr] = 'n';\n        buf[++ptr] = 'u';\n        buf[++ptr] = 'l';\n        buf[++ptr] = 'l';\n        _outputTail = ptr+1;\n    }\n        \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, escapes\n    /**********************************************************\n     */\n\n    /**\n     * Method called to try to either prepend character escape at front of\n     * given buffer; or if not possible, to write it out directly.\n     * Uses head and tail pointers (and updates as necessary)\n     */\n    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    buf[++ptr] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }\n\n    /**\n     * Method called to try to either prepend character escape at front of\n     * given buffer; or if not possible, to write it out directly.\n     * \n     * @return Pointer to start of prepended entity (if prepended); or 'ptr'\n     *   if not.\n     */\n    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }\n\n    /**\n     * Method called to append escape sequence for given character, at the\n     * end of standard output buffer; or if not possible, write out directly.\n     */\n    private void _appendCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if ((_outputTail + 2) > _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\\\\';\n            _outputBuffer[_outputTail++] = (char) escCode;\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if ((_outputTail + 5) >= _outputEnd) {\n                _flushBuffer();\n            }\n            int ptr = _outputTail;\n            char[] buf = _outputBuffer;\n            buf[ptr++] = '\\\\';\n            buf[ptr++] = 'u';\n            // We know it's a control char, so only the last 2 chars are non-0\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                buf[ptr++] = HEX_CHARS[hi >> 4];\n                buf[ptr++] = HEX_CHARS[hi & 0xF];\n                ch &= 0xFF;\n            } else {\n                buf[ptr++] = '0';\n                buf[ptr++] = '0';\n            }\n            buf[ptr++] = HEX_CHARS[ch >> 4];\n            buf[ptr++] = HEX_CHARS[ch & 0xF];\n            _outputTail = ptr;\n            return;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            if (len > _outputEnd) { // very very long escape; unlikely but theoretically possible\n                _writer.write(escape);\n                return;\n            }\n        }\n        escape.getChars(0, len, _outputBuffer, _outputTail);\n        _outputTail += len;\n    }\n    \n    private char[] _allocateEntityBuffer()\n    {\n        char[] buf = new char[14];\n        // first 2 chars, non-numeric escapes (like \\n)\n        buf[0] = '\\\\';\n        // next 6; 8-bit escapes (control chars mostly)\n        buf[2] = '\\\\';\n        buf[3] = 'u';\n        buf[4] = '0';\n        buf[5] = '0';\n        // last 6, beyond 8 bits\n        buf[8] = '\\\\';\n        buf[9] = 'u';\n        _entityBuffer = buf;\n        return buf;\n    }\n    \n    protected void _flushBuffer() throws IOException\n    {\n        int len = _outputTail - _outputHead;\n        if (len > 0) {\n            int offset = _outputHead;\n            _outputTail = _outputHead = 0;\n            _writer.write(_outputBuffer, offset, len);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.*;\n\n/**\n * {@link JsonGenerator} that outputs JSON content using a {@link java.io.Writer}\n * which handles character encoding.\n */\npublic final class WriterBasedJsonGenerator\n    extends JsonGeneratorImpl\n{\n    final protected static int SHORT_WRITE = 32;\n\n    final protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n\n    /*\n    /**********************************************************\n    /* Output buffering\n    /**********************************************************\n     */\n\n    final protected Writer _writer;\n\n    /**\n     * Intermediate buffer in which contents are buffered before\n     * being written using {@link #_writer}.\n     */\n    protected char[] _outputBuffer;\n\n    /**\n     * Pointer to the first buffered character to output\n     */\n    protected int _outputHead;\n\n    /**\n     * Pointer to the position right beyond the last character to output\n     * (end marker; may point to position right beyond the end of the buffer)\n     */\n    protected int _outputTail;\n\n    /**\n     * End marker of the output buffer; one past the last valid position\n     * within the buffer.\n     */\n    protected int _outputEnd;\n\n    /**\n     * Short (14 char) temporary buffer allocated if needed, for constructing\n     * escape sequences\n     */\n    protected char[] _entityBuffer;\n\n    /**\n     * When custom escapes are used, this member variable is used\n     * internally to hold a reference to currently used escape\n     */\n    protected SerializableString _currentEscape;\n    \n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public WriterBasedJsonGenerator(IOContext ctxt, int features,\n            ObjectCodec codec, Writer w)\n    {\n        super(ctxt, features, codec);\n        _writer = w;\n        _outputBuffer = ctxt.allocConcatBuffer();\n        _outputEnd = _outputBuffer.length;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overridden configuration methods\n    /**********************************************************\n     */\n    \n    @Override\n    public Object getOutputTarget() {\n        return _writer;\n    }\n\n    @Override\n    public int getOutputBuffered() {\n        // Assuming tail and head are kept but... trust and verify:\n        int len = _outputTail - _outputHead;\n        return Math.max(0, len);\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(String name)  throws IOException\n    {\n        int status = _writeContext.writeFieldName(name);\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        // Object is a value, need to verify it's allowed\n        int status = _writeContext.writeFieldName(name.getValue());\n        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n    }\n\n    protected void _writeFieldName(String name, boolean commaBefore) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        // for fast+std case, need to output up to 2 chars, comma, dquote\n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        // Alternate mode, in which quoting of field names disabled?\n        if (_cfgUnqNames) {\n            _writeString(name);\n            return;\n        }\n        // we know there's room for at least one more char\n        _outputBuffer[_outputTail++] = '\"';\n        // The beef:\n        _writeString(name);\n        // and closing quotes; need room for one more char:\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            _writePPFieldName(name, commaBefore);\n            return;\n        }\n        // for fast+std case, need to output up to 2 chars, comma, dquote\n        if ((_outputTail + 1) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (commaBefore) {\n            _outputBuffer[_outputTail++] = ',';\n        }\n        // Alternate mode, in which quoting of field names disabled?\n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {\n            writeRaw(quoted, 0, quoted.length);\n            return;\n        }\n        // we know there's room for at least one more char\n        _outputBuffer[_outputTail++] = '\"';\n        // The beef:\n        final int qlen = quoted.length;\n        if ((_outputTail + qlen + 1) >= _outputEnd) {\n            writeRaw(quoted, 0, qlen);\n            // and closing quotes; need room for one more char:\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        } else {\n            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n            _outputTail += qlen;\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public void writeStartArray() throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '[';\n        }\n    }\n\n    @Override\n    public void writeEndArray() throws IOException, JsonGenerationException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = ']';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    @Override\n    public void writeStartObject() throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '{';\n        }\n    }\n\n    @Override\n    public void writeEndObject() throws IOException, JsonGenerationException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '}';\n        }\n        _writeContext = _writeContext.clearAndGetParent();\n    }\n\n    /**\n     * Specialized version of <code>_writeFieldName</code>, off-lined\n     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n     */\n    protected void _writePPFieldName(String name, boolean commaBefore) throws IOException\n    {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n\n        if (_cfgUnqNames) {// non-standard, omit quotes\n            _writeString(name);\n        } else { \n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            _writeString(name);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException\n    {\n        if (commaBefore) {\n            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n        } else {\n            _cfgPrettyPrinter.beforeObjectEntries(this);\n        }\n    \n        final char[] quoted = name.asQuotedChars();\n        if (_cfgUnqNames) {// non-standard, omit quotes\n            writeRaw(quoted, 0, quoted.length);\n        } else {\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n            writeRaw(quoted, 0, quoted.length);\n            if (_outputTail >= _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\"';\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (text == null) {\n            _writeNull();\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text);\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeString(text, offset, len);\n        // And finally, closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeString(SerializableString sstr) throws IOException\n    {\n        _verifyValueWrite(WRITE_STRING);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        // Note: copied from writeRaw:\n        char[] text = sstr.asQuotedChars();\n        final int len = text.length;\n        // Only worth buffering if it's a short write?\n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n        } else {\n            // Otherwise, better just pass through:\n            _flushBuffer();\n            _writer.write(text, 0, len);\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n        // could add support for buffering if we really want it...\n        _reportUnsupportedOperation();\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRaw(String text) throws IOException\n    {\n        // Nothing to check, can just output as is\n        int len = text.length();\n        int room = _outputEnd - _outputTail;\n\n        if (room == 0) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        // But would it nicely fit in? If yes, it's easy\n        if (room >= len) {\n            text.getChars(0, len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {\n            writeRawLong(text);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int start, int len) throws IOException\n    {\n        // Nothing to check, can just output as is\n        int room = _outputEnd - _outputTail;\n\n        if (room < len) {\n            _flushBuffer();\n            room = _outputEnd - _outputTail;\n        }\n        // But would it nicely fit in? If yes, it's easy\n        if (room >= len) {\n            text.getChars(start, start+len, _outputBuffer, _outputTail);\n            _outputTail += len;\n        } else {            \t\n            writeRawLong(text.substring(start, start+len));\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public void writeRaw(SerializableString text) throws IOException {\n        writeRaw(text.getValue());\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException\n    {\n        // Only worth buffering if it's a short write?\n        if (len < SHORT_WRITE) {\n            int room = _outputEnd - _outputTail;\n            if (len > room) {\n                _flushBuffer();\n            }\n            System.arraycopy(text, offset, _outputBuffer, _outputTail, len);\n            _outputTail += len;\n            return;\n        }\n        // Otherwise, better just pass through:\n        _flushBuffer();\n        _writer.write(text, offset, len);\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = c;\n    }\n\n    private void writeRawLong(String text) throws IOException\n    {\n        int room = _outputEnd - _outputTail;\n        // If not, need to do it by looping\n        text.getChars(0, room, _outputBuffer, _outputTail);\n        _outputTail += room;\n        _flushBuffer();\n        int offset = room;\n        int len = text.length() - room;\n\n        while (len > _outputEnd) {\n            int amount = _outputEnd;\n            text.getChars(offset, offset+amount, _outputBuffer, 0);\n            _outputHead = 0;\n            _outputTail = amount;\n            _flushBuffer();\n            offset += amount;\n            len -= amount;\n        }\n        // And last piece (at most length of buffer)\n        text.getChars(offset, offset+len, _outputBuffer, 0);\n        _outputHead = 0;\n        _outputTail = len;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _writeBinary(b64variant, data, offset, offset+len);\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant,\n            InputStream data, int dataLength)\n        throws IOException, JsonGenerationException\n    {\n        _verifyValueWrite(WRITE_BINARY);\n        // Starting quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n        int bytes;\n        try {\n            if (dataLength < 0) { // length unknown\n                bytes = _writeBinary(b64variant, data, encodingBuffer);\n            } else {\n                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n                if (missing > 0) {\n                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n                }\n                bytes = dataLength;\n            }\n        } finally {\n            _ioContext.releaseBase64Buffer(encodingBuffer);\n        }\n        // and closing quotes\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        return bytes;\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedShort(short s) throws IOException {\n        if ((_outputTail + 8) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedInt(i);\n            return;\n        }\n        // up to 10 digits and possible minus sign\n        if ((_outputTail + 11) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedInt(int i) throws IOException {\n        if ((_outputTail + 13) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }    \n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedLong(l);\n            return;\n        }\n        if ((_outputTail + 21) >= _outputEnd) {\n            // up to 20 digits, minus sign\n            _flushBuffer();\n        }\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n    }\n\n    private void _writeQuotedLong(long l) throws IOException {\n        if ((_outputTail + 23) >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n        _outputBuffer[_outputTail++] = '\"';\n    }\n\n    // !!! 05-Aug-2008, tatus: Any ways to optimize these?\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(value.toString());\n        } else {\n            writeRaw(value.toString());\n        }\n    }\n\n    \n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Double.isNaN(d) || Double.isInfinite(d))))) {\n            writeString(String.valueOf(d));\n            return;\n        }\n        // What is the max length for doubles? 40 chars?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(d));\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        if (_cfgNumbersAsStrings ||\n            // [JACKSON-139]\n                (isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS) && ((Float.isNaN(f) || Float.isInfinite(f))))) {\n            writeString(String.valueOf(f));\n            return;\n        }\n        // What is the max length for floats?\n        _verifyValueWrite(WRITE_NUMBER);\n        writeRaw(String.valueOf(f));\n    }\n\n    @Override\n    public void writeNumber(BigDecimal value) throws IOException\n    {\n        // Don't really know max length for big decimal, no point checking\n        _verifyValueWrite(WRITE_NUMBER);\n        if (value == null) {\n            _writeNull();\n        } else  if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(_asString(value));\n        } else {\n            writeRaw(_asString(value));\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedRaw(encodedValue);\n        } else {\n            writeRaw(encodedValue);\n        }\n    }\n\n    private void _writeQuotedRaw(String value) throws IOException\n    {\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n        writeRaw(value);\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail++] = '\"';\n    }\n    \n    @Override\n    public void writeBoolean(boolean state) throws IOException\n    {\n        _verifyValueWrite(WRITE_BOOLEAN);\n        if ((_outputTail + 5) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        if (state) {\n            buf[ptr] = 't';\n            buf[++ptr] = 'r';\n            buf[++ptr] = 'u';\n            buf[++ptr] = 'e';\n        } else {\n            buf[ptr] = 'f';\n            buf[++ptr] = 'a';\n            buf[++ptr] = 'l';\n            buf[++ptr] = 's';\n            buf[++ptr] = 'e';\n        }\n        _outputTail = ptr+1;\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n        _verifyValueWrite(WRITE_NULL);\n        _writeNull();\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        if (_cfgPrettyPrinter != null) {\n            // Otherwise, pretty printer knows what to do...\n            _verifyPrettyValueWrite(typeMsg);\n            return;\n        }\n        char c;\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n            c = ',';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            c = ':';\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n            if (_rootValueSeparator != null) {\n                writeRaw(_rootValueSeparator.getValue());\n            }\n            return;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n        default:\n            return;\n        }\n        if (_outputTail >= _outputEnd) {\n            _flushBuffer();\n        }\n        _outputBuffer[_outputTail] = c;\n        ++_outputTail;\n    }\n\n    protected void _verifyPrettyValueWrite(String typeMsg) throws IOException\n    {\n        final int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n\n        // If we have a pretty printer, it knows what to do:\n        switch (status) {\n        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n            _cfgPrettyPrinter.writeRootValueSeparator(this);\n            break;\n        case JsonWriteContext.STATUS_OK_AS_IS:\n            // First entry, but of which context?\n            if (_writeContext.inArray()) {\n                _cfgPrettyPrinter.beforeArrayValues(this);\n            } else if (_writeContext.inObject()) {\n                _cfgPrettyPrinter.beforeObjectEntries(this);\n            }\n            break;\n        default:\n            _throwInternal();\n            break;\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        _flushBuffer();\n        if (_writer != null) {\n            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                _writer.flush();\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n        super.close();\n\n        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n         *   scopes.\n         */\n        // First: let's see that we still have buffers...\n        if (_outputBuffer != null\n            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            while (true) {\n                JsonStreamContext ctxt = getOutputContext();\n                if (ctxt.inArray()) {\n                    writeEndArray();\n                } else if (ctxt.inObject()) {\n                    writeEndObject();\n                } else {\n                    break;\n                }\n            }\n        }\n        _flushBuffer();\n        _outputHead = 0;\n        _outputTail = 0;\n\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside: when using UTF8Writer, underlying buffer(s)\n         *   may not be properly recycled if we don't close the writer.\n         */\n        if (_writer != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n                _writer.close();\n            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n                // If we can't close it, we should at least flush\n                _writer.flush();\n            }\n        }\n        // Internal buffer(s) generator has can now be released as well\n        _releaseBuffers();\n    }\n\n    @Override\n    protected void _releaseBuffers()\n    {\n        char[] buf = _outputBuffer;\n        if (buf != null) {\n            _outputBuffer = null;\n            _ioContext.releaseConcatBuffer(buf);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing; text, default\n    /**********************************************************\n     */\n\n    private void _writeString(String text) throws IOException\n    {\n        /* One check first: if String won't fit in the buffer, let's\n         * segment writes. No point in extending buffer to huge sizes\n         * (like if someone wants to include multi-megabyte base64\n         * encoded stuff or such)\n         */\n        final int len = text.length();\n        if (len > _outputEnd) { // Let's reserve space for entity at begin/end\n            _writeLongString(text);\n            return;\n        }\n\n        // Ok: we know String will fit in buffer ok\n        // But do we need to flush first?\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n        }\n        text.getChars(0, len, _outputBuffer, _outputTail);\n\n        if (_characterEscapes != null) {\n            _writeStringCustom(len);\n        } else if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(len, _maximumNonEscapedChar);\n        } else {\n            _writeString2(len);\n        }\n    }\n\n    private void _writeString2(final int len) throws IOException\n    {\n        // And then we'll need to verify need for escaping etc:\n        final int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n\n        output_loop:\n        while (_outputTail < end) {\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                char c = _outputBuffer[_outputTail];\n                if (c < escLen && escCodes[c] != 0) {\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n\n            // Ok, bumped into something that needs escaping.\n            /* First things first: need to flush the buffer.\n             * Inlined, as we don't want to lose tail pointer\n             */\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            /* In any case, tail will be the new start, so hopefully\n             * we have room now.\n             */\n            char c = _outputBuffer[_outputTail++];\n            _prependOrWriteCharacterEscape(c, escCodes[c]);\n        }\n    }\n\n    /**\n     * Method called to write \"long strings\", strings whose length exceeds\n     * output buffer length.\n     */\n    private void _writeLongString(String text) throws IOException\n    {\n        // First things first: let's flush the buffer to get some more room\n        _flushBuffer();\n\n        // Then we can write \n        final int textLen = text.length();\n        int offset = 0;\n        do {\n            int max = _outputEnd;\n            int segmentLen = ((offset + max) > textLen)\n                ? (textLen - offset) : max;\n            text.getChars(offset, offset+segmentLen, _outputBuffer, 0);\n            if (_characterEscapes != null) {\n                _writeSegmentCustom(segmentLen);\n            } else if (_maximumNonEscapedChar != 0) {\n                _writeSegmentASCII(segmentLen, _maximumNonEscapedChar);\n            } else {\n                _writeSegment(segmentLen);\n            }\n            offset += segmentLen;\n        } while (offset < textLen);\n    }\n\n    /**\n     * Method called to output textual context which has been copied\n     * to the output buffer prior to call. If any escaping is needed,\n     * it will also be handled by the method.\n     *<p>\n     * Note: when called, textual content to write is within output\n     * buffer, right after buffered content (if any). That's why only\n     * length of that text is passed, as buffer and offset are implied.\n     */\n    private void _writeSegment(int end) throws IOException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n    \n        int ptr = 0;\n        int start = ptr;\n\n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n\n            // Ok, bumped into something that needs escaping.\n            /* First things first: need to flush the buffer.\n             * Inlined, as we don't want to lose tail pointer\n             */\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            // So; either try to prepend (most likely), or write directly:\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);\n        }\n    }\n    \n    /**\n     * This method called when the string content is already in\n     * a char buffer, and need not be copied for processing.\n     */\n    private void _writeString(char[] text, int offset, int len) throws IOException\n    {\n        if (_characterEscapes != null) {\n            _writeStringCustom(text, offset, len);\n            return;\n        }\n        if (_maximumNonEscapedChar != 0) {\n            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n            return;\n        }\n        \n        /* Let's just find longest spans of non-escapable\n         * content, and for each see if it makes sense\n         * to copy them, or write through\n         */\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLen = escCodes.length;\n        while (offset < len) {\n            int start = offset;\n\n            while (true) {\n                char c = text[offset];\n                if (c < escLen && escCodes[c] != 0) {\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            char c = text[offset++];\n            _appendCharacterEscape(c, escCodes[c]);          \n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with additional escaping (ASCII or such)\n    /**********************************************************\n     */\n\n    /* Same as \"_writeString2()\", except needs additional escaping\n     * for subset of characters\n     */\n    private void _writeStringASCII(final int len, final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        // And then we'll need to verify need for escaping etc:\n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        \n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentASCII(int end, final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringASCII(char[] text, int offset, int len,\n            final int maxNonEscaped)\n        throws IOException, JsonGenerationException\n    {\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n\n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, text segment\n    /* with custom escaping (possibly coupling with ASCII limits)\n    /**********************************************************\n     */\n\n    /* Same as \"_writeString2()\", except needs additional escaping\n     * for subset of characters\n     */\n    private void _writeStringCustom(final int len)\n        throws IOException, JsonGenerationException\n    {\n        // And then we'll need to verify need for escaping etc:\n        int end = _outputTail + len;\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        int escCode = 0;\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        output_loop:\n        while (_outputTail < end) {\n            char c;\n            // Fast loop for chars not needing escaping\n            escape_loop:\n            while (true) {\n                c = _outputBuffer[_outputTail];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break escape_loop;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break escape_loop;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break escape_loop;\n                    }\n                }\n                if (++_outputTail >= end) {\n                    break output_loop;\n                }\n            }\n            int flushLen = (_outputTail - _outputHead);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, _outputHead, flushLen);\n            }\n            ++_outputTail;\n            _prependOrWriteCharacterEscape(c, escCode);\n        }\n    }\n\n    private void _writeSegmentCustom(int end)\n        throws IOException, JsonGenerationException\n    {\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n    \n        int ptr = 0;\n        int escCode = 0;\n        int start = ptr;\n    \n        output_loop:\n        while (ptr < end) {\n            // Fast loop for chars not needing escaping\n            char c;\n            while (true) {\n                c = _outputBuffer[ptr];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++ptr >= end) {\n                    break;\n                }\n            }\n            int flushLen = (ptr - start);\n            if (flushLen > 0) {\n                _writer.write(_outputBuffer, start, flushLen);\n                if (ptr >= end) {\n                    break output_loop;\n                }\n            }\n            ++ptr;\n            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n        }\n    }\n\n    private void _writeStringCustom(char[] text, int offset, int len)\n        throws IOException, JsonGenerationException\n    {\n        len += offset; // -> len marks the end from now on\n        final int[] escCodes = _outputEscapes;\n        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n        final CharacterEscapes customEscapes = _characterEscapes;\n\n        int escCode = 0;\n        \n        while (offset < len) {\n            int start = offset;\n            char c;\n            \n            while (true) {\n                c = text[offset];\n                if (c < escLimit) {\n                    escCode = escCodes[c];\n                    if (escCode != 0) {\n                        break;\n                    }\n                } else if (c > maxNonEscaped) {\n                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n                    break;\n                } else {\n                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n                        break;\n                    }\n                }\n                if (++offset >= len) {\n                    break;\n                }\n            }\n    \n            // Short span? Better just copy it to buffer first:\n            int newAmount = offset - start;\n            if (newAmount < SHORT_WRITE) {\n                // Note: let's reserve room for escaped char (up to 6 chars)\n                if ((_outputTail + newAmount) > _outputEnd) {\n                    _flushBuffer();\n                }\n                if (newAmount > 0) {\n                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n                    _outputTail += newAmount;\n                }\n            } else { // Nope: better just write through\n                _flushBuffer();\n                _writer.write(text, start, newAmount);\n            }\n            // Was this the end?\n            if (offset >= len) { // yup\n                break;\n            }\n            // Nope, need to escape the char.\n            ++offset;\n            _appendCharacterEscape(c, escCode);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing; binary\n    /**********************************************************\n     */\n    \n    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd)\n        throws IOException, JsonGenerationException\n    {\n        // Encoding is by chunks of 3 input, 4 output chars, so:\n        int safeInputEnd = inputEnd - 3;\n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (inputPtr <= safeInputEnd) {\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) input[inputPtr++]) << 8;\n            b24 |= ((int) input[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                // note: must quote in JSON value\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n        if (inputLeft > 0) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) input[inputPtr++]) << 16;\n            if (inputLeft == 2) {\n                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n            }\n            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n        }\n    }\n\n    // write-method called when length is definitely known\n    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer, int bytesLeft)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;       \n        \n        // Let's also reserve room for possible (and quoted) lf char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        while (bytesLeft > 2) { // main loop for full triplets\n            if (inputPtr > lastFullOffset) {\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesLeft -= 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n        \n        // And then we may have 1 or 2 leftover bytes to encode\n        if (bytesLeft > 0) {\n            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n            inputPtr = 0;\n            if (inputEnd > 0) { // yes, but do we have room for output?\n                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                    _flushBuffer();\n                }\n                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n                int amount;\n                if (inputPtr < inputEnd) {\n                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                    amount = 2;\n                } else {\n                    amount = 1;\n                }\n                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n                bytesLeft -= amount;\n            }\n        }\n        return bytesLeft;\n    }\n    \n    // write method when length is unknown\n    protected int _writeBinary(Base64Variant b64variant,\n            InputStream data, byte[] readBuffer)\n        throws IOException, JsonGenerationException\n    {\n        int inputPtr = 0;\n        int inputEnd = 0;\n        int lastFullOffset = -3;\n        int bytesDone = 0;\n        \n        // Let's also reserve room for possible (and quoted) LF char each round\n        int safeOutputEnd = _outputEnd - 6;\n        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n\n        // Ok, first we loop through all full triplets of data:\n        while (true) {\n            if (inputPtr > lastFullOffset) { // need to load more\n                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n                inputPtr = 0;\n                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n                    break;\n                }\n                lastFullOffset = inputEnd-3;\n            }\n            if (_outputTail > safeOutputEnd) { // need to flush\n                _flushBuffer();\n            }\n            // First, mash 3 bytes into lsb of 32-bit int\n            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n            bytesDone += 3;\n            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n            if (--chunksBeforeLF <= 0) {\n                _outputBuffer[_outputTail++] = '\\\\';\n                _outputBuffer[_outputTail++] = 'n';\n                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n            }\n        }\n\n        // And then we may have 1 or 2 leftover bytes to encode\n        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                _flushBuffer();\n            }\n            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n            int amount = 1;\n            if (inputPtr < inputEnd) {\n                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n                amount = 2;\n            }\n            bytesDone += amount;\n            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n        }\n        return bytesDone;\n    }\n    \n    private int _readMore(InputStream in,\n            byte[] readBuffer, int inputPtr, int inputEnd,\n            int maxRead) throws IOException\n    {\n        // anything to shift to front?\n        int i = 0;\n        while (inputPtr < inputEnd) {\n            readBuffer[i++]  = readBuffer[inputPtr++];\n        }\n        inputPtr = 0;\n        inputEnd = i;\n        maxRead = Math.min(maxRead, readBuffer.length);\n        \n        do {\n            int length = maxRead - inputEnd;\n            if (length == 0) {\n                break;\n            }\n            int count = in.read(readBuffer, inputEnd, length);            \n            if (count < 0) {\n                return inputEnd;\n            }\n            inputEnd += count;\n        } while (inputEnd < 3);\n        return inputEnd;\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, other\n    /**********************************************************\n     */\n    \n    private final void _writeNull() throws IOException\n    {\n        if ((_outputTail + 4) >= _outputEnd) {\n            _flushBuffer();\n        }\n        int ptr = _outputTail;\n        char[] buf = _outputBuffer;\n        buf[ptr] = 'n';\n        buf[++ptr] = 'u';\n        buf[++ptr] = 'l';\n        buf[++ptr] = 'l';\n        _outputTail = ptr+1;\n    }\n        \n    /*\n    /**********************************************************\n    /* Internal methods, low-level writing, escapes\n    /**********************************************************\n     */\n\n    /**\n     * Method called to try to either prepend character escape at front of\n     * given buffer; or if not possible, to write it out directly.\n     * Uses head and tail pointers (and updates as necessary)\n     */\n    private void _prependOrWriteCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (_outputTail >= 2) { // fits, just prepend\n                int ptr = _outputTail - 2;\n                _outputHead = ptr;\n                _outputBuffer[ptr++] = '\\\\';\n                _outputBuffer[ptr] = (char) escCode;\n                return;\n            }\n            // won't fit, write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            buf[1] = (char) escCode;\n            _writer.write(buf, 0, 2);\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (_outputTail >= 6) { // fits, prepend to buffer\n                char[] buf = _outputBuffer;\n                int ptr = _outputTail - 6;\n                _outputHead = ptr;\n                buf[ptr] = '\\\\';\n                buf[++ptr] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buf[++ptr] = HEX_CHARS[hi >> 4];\n                    buf[++ptr] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buf[++ptr] = '0';\n                    buf[++ptr] = '0';\n                }\n                buf[++ptr] = HEX_CHARS[ch >> 4];\n                buf[++ptr] = HEX_CHARS[ch & 0xF];\n                return;\n            }\n            // won't fit, flush and write\n            char[] buf = _entityBuffer;\n            if (buf == null) {\n                buf = _allocateEntityBuffer();\n            }\n            _outputHead = _outputTail;\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                int lo = ch & 0xFF;\n                buf[10] = HEX_CHARS[hi >> 4];\n                buf[11] = HEX_CHARS[hi & 0xF];\n                buf[12] = HEX_CHARS[lo >> 4];\n                buf[13] = HEX_CHARS[lo & 0xF];\n                _writer.write(buf, 8, 6);\n            } else { // We know it's a control char, so only the last 2 chars are non-0\n                buf[6] = HEX_CHARS[ch >> 4];\n                buf[7] = HEX_CHARS[ch & 0xF];\n                _writer.write(buf, 2, 6);\n            }\n            return;\n        }\n        String escape;\n\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (_outputTail >= len) { // fits in, prepend\n            int ptr = _outputTail - len;\n            _outputHead = ptr;\n            escape.getChars(0, len, _outputBuffer, ptr);\n            return;\n        }\n        // won't fit, write separately\n        _outputHead = _outputTail;\n        _writer.write(escape);\n    }\n\n    /**\n     * Method called to try to either prepend character escape at front of\n     * given buffer; or if not possible, to write it out directly.\n     * \n     * @return Pointer to start of prepended entity (if prepended); or 'ptr'\n     *   if not.\n     */\n    private int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n            char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if (ptr > 1 && ptr < end) { // fits, just prepend\n                ptr -= 2;\n                buffer[ptr] = '\\\\';\n                buffer[ptr+1] = (char) escCode;\n            } else { // won't fit, write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                ent[1] = (char) escCode;\n                _writer.write(ent, 0, 2);\n            }\n            return ptr;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n                ptr -= 6;\n                buffer[ptr++] = '\\\\';\n                buffer[ptr++] = 'u';\n                // We know it's a control char, so only the last 2 chars are non-0\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n                    ch &= 0xFF;\n                } else {\n                    buffer[ptr++] = '0';\n                    buffer[ptr++] = '0';\n                }\n                buffer[ptr++] = HEX_CHARS[ch >> 4];\n                buffer[ptr] = HEX_CHARS[ch & 0xF];\n                ptr -= 5;\n            } else {\n                // won't fit, flush and write\n                char[] ent = _entityBuffer;\n                if (ent == null) {\n                    ent = _allocateEntityBuffer();\n                }\n                _outputHead = _outputTail;\n                if (ch > 0xFF) { // beyond 8 bytes\n                    int hi = (ch >> 8) & 0xFF;\n                    int lo = ch & 0xFF;\n                    ent[10] = HEX_CHARS[hi >> 4];\n                    ent[11] = HEX_CHARS[hi & 0xF];\n                    ent[12] = HEX_CHARS[lo >> 4];\n                    ent[13] = HEX_CHARS[lo & 0xF];\n                    _writer.write(ent, 8, 6);\n                } else { // We know it's a control char, so only the last 2 chars are non-0\n                    ent[6] = HEX_CHARS[ch >> 4];\n                    ent[7] = HEX_CHARS[ch & 0xF];\n                    _writer.write(ent, 2, 6);\n                }\n            }\n            return ptr;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if (ptr >= len && ptr < end) { // fits in, prepend\n            ptr -= len;\n            escape.getChars(0, len, buffer, ptr);\n        } else { // won't fit, write separately\n            _writer.write(escape);\n        }\n        return ptr;\n    }\n\n    /**\n     * Method called to append escape sequence for given character, at the\n     * end of standard output buffer; or if not possible, write out directly.\n     */\n    private void _appendCharacterEscape(char ch, int escCode)\n        throws IOException, JsonGenerationException\n    {\n        if (escCode >= 0) { // \\\\N (2 char)\n            if ((_outputTail + 2) > _outputEnd) {\n                _flushBuffer();\n            }\n            _outputBuffer[_outputTail++] = '\\\\';\n            _outputBuffer[_outputTail++] = (char) escCode;\n            return;\n        }\n        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n            if ((_outputTail + 5) >= _outputEnd) {\n                _flushBuffer();\n            }\n            int ptr = _outputTail;\n            char[] buf = _outputBuffer;\n            buf[ptr++] = '\\\\';\n            buf[ptr++] = 'u';\n            // We know it's a control char, so only the last 2 chars are non-0\n            if (ch > 0xFF) { // beyond 8 bytes\n                int hi = (ch >> 8) & 0xFF;\n                buf[ptr++] = HEX_CHARS[hi >> 4];\n                buf[ptr++] = HEX_CHARS[hi & 0xF];\n                ch &= 0xFF;\n            } else {\n                buf[ptr++] = '0';\n                buf[ptr++] = '0';\n            }\n            buf[ptr++] = HEX_CHARS[ch >> 4];\n            buf[ptr++] = HEX_CHARS[ch & 0xF];\n            _outputTail = ptr;\n            return;\n        }\n        String escape;\n        if (_currentEscape == null) {\n            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n        } else {\n            escape = _currentEscape.getValue();\n            _currentEscape = null;\n        }\n        int len = escape.length();\n        if ((_outputTail + len) > _outputEnd) {\n            _flushBuffer();\n            if (len > _outputEnd) { // very very long escape; unlikely but theoretically possible\n                _writer.write(escape);\n                return;\n            }\n        }\n        escape.getChars(0, len, _outputBuffer, _outputTail);\n        _outputTail += len;\n    }\n    \n    private char[] _allocateEntityBuffer()\n    {\n        char[] buf = new char[14];\n        // first 2 chars, non-numeric escapes (like \\n)\n        buf[0] = '\\\\';\n        // next 6; 8-bit escapes (control chars mostly)\n        buf[2] = '\\\\';\n        buf[3] = 'u';\n        buf[4] = '0';\n        buf[5] = '0';\n        // last 6, beyond 8 bits\n        buf[8] = '\\\\';\n        buf[9] = 'u';\n        _entityBuffer = buf;\n        return buf;\n    }\n    \n    protected void _flushBuffer() throws IOException\n    {\n        int len = _outputTail - _outputHead;\n        if (len > 0) {\n            int offset = _outputHead;\n            _outputTail = _outputHead = 0;\n            _writer.write(_outputBuffer, offset, len);\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 19, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(src,\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(src,\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Override\n    protected boolean loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    protected char getNextChar(String eofMsg) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { _reportInvalidEOF(eofMsg); }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { _reportInvalidEOFInValue(); }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* [JACKSON-173]: allow single quotes. Unlike with regular\n             * Strings, we'll eagerly parse contents; this so that there's\n             * no need to store information on quote char used.\n             *\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        /* Either ran out of input, or bumped into an escape\n         * sequence...\n         */\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n\n        do {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidToken(matchStr.substring(0, i));\n                }\n            }\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n\n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n            return;\n        }\n        // if Java letter, it's a problem tho\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n        return;\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(src,\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(src,\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        StringBuilder sb = new StringBuilder(matchedPart);\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n        }\n        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n    }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected int _nameStartOffset; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n\n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            final int ptr = _inputPtr;\n\n            _currInputProcessed += ptr;\n            _currInputRowStart -= ptr;\n            // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n            //  (note: probably has little effect here but just in case)\n            _nameStartOffset -= ptr;\n\n            System.arraycopy(_inputBuffer, ptr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        _updateNameLocation();\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            i = _skipColonFast(ptr+1);\n                            _isNextTokenNameYes(i);\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true);\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n\n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        JsonToken t = nextToken();\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per [core#105], need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consecutively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2();\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3();\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2();\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3();\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2();\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3();\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        int c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Improved location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(src,\n                    total, -1L, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(src,\n                _tokenInputTotal-1, -1L, _tokenInputRow, _tokenInputCol);\n    }\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputRow = _currInputRow;\n        final int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameStartRow = _currInputRow;\n        final int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.InputStream} as the input source.\n *<p>\n * Note: non-final since version 2.3.\n */\npublic class UTF8StreamJsonParser\n    extends ParserBase\n{\n    final static byte BYTE_LF = (byte) '\\n';\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Codec used for data binding when (if) requested; typically full\n     * <code>ObjectMapper</code>, but that abstract is not part of core\n     * package.\n     */\n    protected ObjectCodec _objectCodec;\n\n    /**\n     * Symbol table that contains field names encountered so far\n     */\n    final protected ByteQuadsCanonicalizer _symbols;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Temporary buffer used for name parsing.\n     */\n    protected int[] _quadBuffer = new int[16];\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Temporary storage for partially parsed name bytes.\n     */\n    private int _quad1;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected int _nameStartOffset; \n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Input buffering (from former 'StreamBasedParserBase')\n    /**********************************************************\n     */\n\n    protected InputStream _inputStream;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected byte[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n            byte[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _inputStream = in;\n        _objectCodec = codec;\n        _symbols = sym;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _currInputRowStart = start;\n        // If we have offset, need to omit that from byte offset, so:\n        _currInputProcessed = -start;\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for life-cycle\n    /**********************************************************\n     */\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException\n    {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) {\n            return 0;\n        }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        out.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override\n    public Object getInputSource() {\n        return _inputStream;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides, low-level reading\n    /**********************************************************\n     */\n\n    @Override\n    protected final boolean loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += _inputEnd;\n        _currInputRowStart -= _inputEnd;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_inputStream != null) {\n            int space = _inputBuffer.length;\n            if (space == 0) { // only occurs when we've been closed\n                return false;\n            }\n            \n            int count = _inputStream.read(_inputBuffer, 0, space);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method that will try to load at least specified number bytes in\n     * input buffer, possible moving existing data around if necessary\n     */\n    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n    {\n        // No input stream, no leading (either we are closed, or have non-stream input source)\n        if (_inputStream == null) {\n            return false;\n        }\n        // Need to move remaining data in front?\n        int amount = _inputEnd - _inputPtr;\n        if (amount > 0 && _inputPtr > 0) {\n            final int ptr = _inputPtr;\n\n            _currInputProcessed += ptr;\n            _currInputRowStart -= ptr;\n            // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n            //  (note: probably has little effect here but just in case)\n            _nameStartOffset -= ptr;\n\n            System.arraycopy(_inputBuffer, ptr, _inputBuffer, 0, amount);\n            _inputEnd = amount;\n        } else {\n            _inputEnd = 0;\n        }\n        _inputPtr = 0;\n        while (_inputEnd < minAvailable) {\n            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n            if (count < 1) {\n                // End of input\n                _closeInput();\n                // Should never return 0, so let's fail\n                if (count == 0) {\n                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n                }\n                return false;\n            }\n            _inputEnd += count;\n        }\n        return true;\n    }\n    \n    @Override\n    protected void _closeInput() throws IOException\n    {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         */\n        if (_inputStream != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _inputStream.close();\n            }\n            _inputStream = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException\n    {\n        super._releaseBuffers();\n        // Merge found symbols, if any:\n        _symbols.release();\n        if (_bufferRecyclable) {\n            byte[] buf = _inputBuffer;\n            if (buf != null) {\n                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n                 *   get slightly more meaningful error messages in case someone\n                 *   closes parser indirectly, without realizing.\n                 */\n                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                _ioContext.releaseReadIOBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(_currToken);\n    }\n\n    // // // Let's override default impls for improved performance\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n    \n    // @since 2.1\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                return _finishAndReturnString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(0);\n    }\n\n    // since 2.6\n    @Override\n    public int getValueAsInt(int defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            // inlined 'getIntValue()'\n            if ((_numTypesValid & NR_INT) == 0) {\n                if (_numTypesValid == NR_UNKNOWN) {\n                    return _parseIntValue();\n                }\n                if ((_numTypesValid & NR_INT) == 0) {\n                    convertNumberToInt();\n                }\n            }\n            return _numberInt;\n        }\n        return super.getValueAsInt(defValue);\n    }\n    \n    protected final String _getText2(JsonToken t)\n    {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n        \treturn t.asString();\n        }\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n    \n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n                \n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n                \n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n                \n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n    \n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n                              byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal, basic\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Close/release things like input source, symbol table and recyclable buffers\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            return _nextTokenNotInObject(i);\n        }\n        // So first parse the field name itself:\n        _updateNameLocation();\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return _currToken;\n        }        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return _currToken;\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        }\n        return (_currToken = _handleUnexpectedValue(i));\n    }\n    \n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, traversal, nextXxxValue/nextFieldName\n    /**********************************************************\n     */\n\n    @Override\n    public boolean nextFieldName(SerializableString str) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n        \n        // // // This part differs, name parsing\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            byte[] nameBytes = str.asQuotedUTF8();\n            final int len = nameBytes.length;\n            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n            //    of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == INT_QUOTE) {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(str.getValue());\n                            i = _skipColonFast(ptr+1);\n                            _isNextTokenNameYes(i);\n                            return true;\n                        }\n                        if (nameBytes[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, str);\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        final String nameStr = _parseName(i);\n        _parsingContext.setCurrentName(nameStr);\n        _currToken = JsonToken.FIELD_NAME;\n\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameStr;\n        }\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return nameStr;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true);\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(false);\n    }\n    \n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleUnexpectedValue(i);\n    }\n\n    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n\n        String n = _parseName(i);\n        _parsingContext.setCurrentName(n);\n        final boolean match = n.equals(str.getValue());\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n\n        // Ok: we must have a value... what is it? Strings are very common, check first:\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return match;\n        }\n        JsonToken t;\n\n        switch (i) {\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleUnexpectedValue(i);\n        }\n        _nextToken = t;\n        return match;\n    }\n\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    return _finishAndReturnString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException\n    {\n        // two distinct cases; either got name and we know next type, or 'other'\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n\n        JsonToken t = nextToken();\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected JsonToken _parsePosNumber(int c) throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        // Ok: we can first just add digit we saw first:\n        outBuf[0] = (char) c;\n        int intLen = 1;\n        int outPtr = 1;\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - 1; // 1 == outPtr\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) { // split across boundary, offline\n                return _parseNumber2(outBuf, outPtr, false, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, false, intLen);\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n        // And there we have it!\n        return resetInt(false, intLen);\n    }\n    \n    protected JsonToken _parseNegNumber() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks\n        // for either input or output\n        int end = _inputPtr + outBuf.length - outPtr;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parseNumber2(outBuf, outPtr, true, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloat(outBuf, outPtr, c, true, intLen);\n        }\n        \n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n\n        // And there we have it!\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to handle parsing when input is split across buffer boundary\n     * (or output is longer than segment used to store it)\n     */\n    private final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\n            int intPartLength) throws IOException\n    {\n        // Ok, parse the rest\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                _textBuffer.setCurrentLength(outPtr);\n                return resetInt(negative, intPartLength);\n            }\n            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c > INT_9 || c < INT_0) {\n                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            ++intPartLength;\n        }\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // And there we have it!\n        return resetInt(negative, intPartLength);\n        \n    }\n    \n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final int _verifyNoLeadingZeroes() throws IOException\n    {\n        // Ok to have plain \"0\"\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return INT_0;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        // if not followed by a number (probably '.'); return zero as is, to be included\n        if (ch < INT_0 || ch > INT_9) {\n            return INT_0;\n        }\n        // [JACKSON-358]: we may want to allow them, after all...\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || loadMore()) {\n                ch = _inputBuffer[_inputPtr] & 0xFF;\n                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n                    return INT_0;\n                }\n                ++_inputPtr; // skip previous zeroes\n                if (ch != INT_0) { // followed by other number; return \n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n    \n    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n            boolean negative, int integerPartLength) throws IOException\n    {\n        int fractLen = 0;\n        boolean eof = false;\n\n        // And then see if we get other parts\n        if (c == INT_PERIOD) { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == INT_e || c == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Not optional, can require that we get one more char\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                // Likewise, non optional:\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = (char) c;\n                if (_inputPtr >= _inputEnd && !loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            // As per [core#105], need separating space between root values; check here\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetFloat(negative, integerPartLength, fractLen, expLen);\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        // TODO? Handle UTF-8 char decoding for error reporting\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n    \n    protected final String _parseName(int i) throws IOException\n    {\n        if (i != INT_QUOTE) {\n            return _handleOddName(i);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            return slowParseName();\n        }\n\n        // If so, can also unroll loops nicely\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n         *   assume that part is ok (if not it will get caught\n         *   later on), and just handle quotes and backslashes here.\n         */\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        int q = input[_inputPtr++] & 0xFF;\n\n        if (codes[q] == 0) {\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] == 0) {\n                q = (q << 8) | i;\n                i = input[_inputPtr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[_inputPtr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[_inputPtr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return parseMediumName(i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            return findName(q, 4);\n                        }\n                        return parseName(q, i, 4);\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        return findName(q, 3);\n                    }\n                    return parseName(q, i, 3);\n                }                \n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    return findName(q, 2);\n                }\n                return parseName(q, i, 2);\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                return findName(q, 1);\n            }\n            return parseName(q, i, 1);\n        }     \n        if (q == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseName(0, q, 0); // quoting or invalid char\n    }\n\n    protected final String parseMediumName(int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 5 bytes\n                return findName(_quad1, q2, 1);\n            }\n            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 6 bytes\n                return findName(_quad1, q2, 2);\n            }\n            return parseName(_quad1, q2, i, 2);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 7 bytes\n                return findName(_quad1, q2, 3);\n            }\n            return parseName(_quad1, q2, i, 3);\n        }\n        q2 = (q2 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 8 bytes\n                return findName(_quad1, q2, 4);\n            }\n            return parseName(_quad1, q2, i, 4);\n        }\n        return parseMediumName2(i, q2);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected final String parseMediumName2(int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                return findName(_quad1, q2, q3, 1);\n            }\n            return parseName(_quad1, q2, q3, i, 1);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                return findName(_quad1, q2, q3, 2);\n            }\n            return parseName(_quad1, q2, q3, i, 2);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                return findName(_quad1, q2, q3, 3);\n            }\n            return parseName(_quad1, q2, q3, i, 3);\n        }\n        q3 = (q3 << 8) | i;\n        i = input[_inputPtr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 12 bytes\n                return findName(_quad1, q2, q3, 4);\n            }\n            return parseName(_quad1, q2, q3, i, 4);\n        }\n        return parseLongName(i, q2, q3);\n    }\n    \n    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n    {\n        _quadBuffer[0] = _quad1;\n        _quadBuffer[1] = q2;\n        _quadBuffer[2] = q3;\n\n        // As explained above, will ignore UTF-8 encoding at this point\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int qlen = 3;\n\n        while ((_inputPtr + 4) <= _inputEnd) {\n            int i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 1);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 2);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 3);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n            }\n\n            q = (q << 8) | i;\n            i = input[_inputPtr++] & 0xFF;\n            if (codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    return findName(_quadBuffer, qlen, q, 4);\n                }\n                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n            }\n\n            // Nope, no end in sight. Need to grow quad array etc\n            if (qlen >= _quadBuffer.length) {\n                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n            }\n            _quadBuffer[qlen++] = q;\n            q = i;\n        }\n\n        /* Let's offline if we hit buffer boundary (otherwise would\n         * need to [try to] align input, which is bit complicated\n         * and may not always be possible)\n         */\n        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n    }\n\n    /**\n     * Method called when not even first 8 bytes are guaranteed\n     * to come consecutively. Happens rarely, so this is offlined;\n     * plus we'll also do full checks for escaping etc.\n     */\n    protected String slowParseName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i == INT_QUOTE) { // special case, \"\"\n            return \"\";\n        }\n        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n    }\n\n    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n    }\n\n    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n    }\n    \n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hance is offlined to a separate method.\n     */\n    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n            int currQuadBytes) throws IOException\n    {\n        /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n         *   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n         *   caught later on), and just handle quotes and backslashes here.\n         */\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (codes[ch] != 0) {\n                if (ch == INT_QUOTE) { // we are done\n                    break;\n                }\n                // Unquoted white space?\n                if (ch != INT_BACKSLASH) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int ch) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            char c = (char) _decodeCharForError(ch);\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        /* Also: note that although we use a different table here,\n         * it does NOT handle UTF-8 decoding. It'll just pass those\n         * high-bit codes as acceptable for later decoding.\n         */\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        /* Ok, now; instead of ultra-optimizing parsing here (as with\n         * regular JSON names), let's just use the generic \"slow\"\n         * variant. Can measure its impact later on if need be\n         */\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        while (true) {\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n     * main reason being to try to avoid slowing down fast path\n     * for valid JSON -- more alternatives, more code, generally\n     * bit slower execution.\n     */\n    protected String _parseAposName() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n            }\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch == '\\'') { // special case, ''\n            return \"\";\n        }\n        int[] quads = _quadBuffer;\n        int qlen = 0;\n        int currQuad = 0;\n        int currQuadBytes = 0;\n\n        // Copied from parseEscapedFieldName, with minor mods:\n\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (ch == '\\'') {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeEscaped();\n                }\n                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n                 * beyond 7-bit ascii. Gets pretty messy.\n                 * If this happens often, may want to use different name\n                 * canonicalization to avoid these hits.\n                 */\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = pad(currQuad, currQuadBytes);\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = addName(quads, qlen, currQuadBytes);\n        }\n        return name;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, symbol (name) handling\n    /**********************************************************\n     */\n\n    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n    {\n        q1 = pad(q1, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        return addName(_quadBuffer, 1, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n    {\n        q2 = pad(q2, lastQuadBytes);\n        // Usually we'll find it from the canonical symbol table already\n        String name = _symbols.findName(q1, q2);\n        if (name != null) {\n            return name;\n        }\n        // If not, more work. We'll need add stuff to buffer\n        _quadBuffer[0] = q1;\n        _quadBuffer[1] = q2;\n        return addName(_quadBuffer, 2, lastQuadBytes);\n    }\n\n    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n    {\n        q3 = pad(q3, lastQuadBytes);\n        String name = _symbols.findName(q1, q2, q3);\n        if (name != null) {\n            return name;\n        }\n        int[] quads = _quadBuffer;\n        quads[0] = q1;\n        quads[1] = q2;\n        quads[2] = pad(q3, lastQuadBytes);\n        return addName(quads, 3, lastQuadBytes);\n    }\n    \n    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n    {\n        if (qlen >= quads.length) {\n            _quadBuffer = quads = growArrayBy(quads, quads.length);\n        }\n        quads[qlen++] = pad(lastQuad, lastQuadBytes);\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            return addName(quads, qlen, lastQuadBytes);\n        }\n        return name;\n    }\n\n    /**\n     * This is the main workhorse method used when we take a symbol\n     * table miss. It needs to demultiplex individual bytes, decode\n     * multi-byte chars (if any), and then construct Name instance\n     * and add it to the symbol table.\n     */\n    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n    {\n        /* Ok: must decode UTF-8 chars. No other validation is\n         * needed, since unescaping has been done earlier as necessary\n         * (as well as error reporting for unescaped control chars)\n         */\n        // 4 bytes per quad, except last one maybe less\n        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n        /* And last one is not correctly aligned (leading zero bytes instead\n         * need to shift a bit, instead of trailing). Only need to shift it\n         * for UTF-8 decoding; need revert for storage (since key will not\n         * be aligned, to optimize lookup speed)\n         */\n        int lastQuad;\n\n        if (lastQuadBytes < 4) {\n            lastQuad = quads[qlen-1];\n            // 8/16/24 bit left shift\n            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n        } else {\n            lastQuad = 0;\n        }\n\n        // Need some working space, TextBuffer works well:\n        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n        int cix = 0;\n\n        for (int ix = 0; ix < byteLen; ) {\n            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n            int byteIx = (ix & 3);\n            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n            ++ix;\n\n            if (ch > 127) { // multi-byte\n                int needed;\n                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                    ch &= 0x1F;\n                    needed = 1;\n                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                    ch &= 0x0F;\n                    needed = 2;\n                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n                    ch &= 0x07;\n                    needed = 3;\n                } else { // 5- and 6-byte chars not valid xml chars\n                    _reportInvalidInitial(ch);\n                    needed = ch = 1; // never really gets this far\n                }\n                if ((ix + needed) > byteLen) {\n                    _reportInvalidEOF(\" in field name\");\n                }\n                \n                // Ok, always need at least one more:\n                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n                byteIx = (ix & 3);\n                ch2 = (ch2 >> ((3 - byteIx) << 3));\n                ++ix;\n                \n                if ((ch2 & 0xC0) != 0x080) {\n                    _reportInvalidOther(ch2);\n                }\n                ch = (ch << 6) | (ch2 & 0x3F);\n                if (needed > 1) {\n                    ch2 = quads[ix >> 2];\n                    byteIx = (ix & 3);\n                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n                    ++ix;\n                    \n                    if ((ch2 & 0xC0) != 0x080) {\n                        _reportInvalidOther(ch2);\n                    }\n                    ch = (ch << 6) | (ch2 & 0x3F);\n                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n                        ch2 = quads[ix >> 2];\n                        byteIx = (ix & 3);\n                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n                        ++ix;\n                        if ((ch2 & 0xC0) != 0x080) {\n                            _reportInvalidOther(ch2 & 0xFF);\n                        }\n                        ch = (ch << 6) | (ch2 & 0x3F);\n                    }\n                }\n                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n                    ch -= 0x10000; // to normalize it starting with 0x0\n                    if (cix >= cbuf.length) {\n                        cbuf = _textBuffer.expandCurrentSegment();\n                    }\n                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n                    ch = 0xDC00 | (ch & 0x03FF);\n                }\n            }\n            if (cix >= cbuf.length) {\n                cbuf = _textBuffer.expandCurrentSegment();\n            }\n            cbuf[cix++] = (char) ch;\n        }\n\n        // Ok. Now we have the character array, and can construct the String\n        String baseName = new String(cbuf, 0, cix);\n        // And finally, un-align if necessary\n        if (lastQuadBytes < 4) {\n            quads[qlen-1] = lastQuad;\n        }\n        return _symbols.addName(baseName, quads, qlen);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, String value parsing\n    /**********************************************************\n     */\n\n    @Override\n    protected void _finishString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return;\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected String _finishAndReturnString() throws IOException\n    {\n        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            loadMoreGuaranteed();\n            ptr = _inputPtr;\n        }\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    return _textBuffer.setCurrentAndReturn(outPtr);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _inputPtr = ptr;\n        _finishString2(outBuf, outPtr);\n        return _textBuffer.contentsAsString();\n    }\n    \n    private final void _finishString2(char[] outBuf, int outPtr)\n        throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                if (ptr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // As per [JACKSON-208], call can now return:\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        // Need to be fully UTF-8 aware here:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            int c;\n\n            ascii_loop:\n            while (true) {\n                int ptr = _inputPtr;\n                int max = _inputEnd;\n                if (ptr >= max) {\n                    loadMoreGuaranteed();\n                    ptr = _inputPtr;\n                    max = _inputEnd;\n                }\n                while (ptr < max) {\n                    c = (int) inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        _inputPtr = ptr;\n                        break ascii_loop;\n                    }\n                }\n                _inputPtr = ptr;\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                break main_loop;\n            }\n            \n            switch (codes[c]) {\n            case 1: // backslash\n                _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                _skipUtf8_2();\n                break;\n            case 3: // 3-byte UTF\n                _skipUtf8_3();\n                break;\n            case 4: // 4-byte UTF\n                _skipUtf8_4(c);\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleUnexpectedValue(int c)\n        throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (c) {\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(c, \"expected a value\");\n        case '\\'':\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n        }\n        // [Issue#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(c)) {\n            _reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos()\n        throws IOException\n    {\n        int c = 0;\n        // Otherwise almost verbatim copy of _finishString()\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        main_loop:\n        while (true) {\n            // Then the tight ascii non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                int max = _inputEnd;\n                {\n                    int max2 = _inputPtr + (outBuf.length - outPtr);\n                    if (max2 < max) {\n                        max = max2;\n                    }\n                }\n                while (_inputPtr < max) {\n                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n                    if (c == '\\'' || codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n\n            // Ok: end marker, escape or multi-byte?\n            if (c == '\\'') {\n                break main_loop;\n            }\n\n            switch (codes[c]) {\n            case 1: // backslash\n                c = _decodeEscaped();\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUtf8_2(c);\n                break;\n            case 3: // 3-byte UTF\n                if ((_inputEnd - _inputPtr) >= 2) {\n                    c = _decodeUtf8_3fast(c);\n                } else {\n                    c = _decodeUtf8_3(c);\n                }\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUtf8_4(c);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    _throwUnquotedSpace(c, \"string value\");\n                }\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n\n        return JsonToken.VALUE_STRING;\n    }\n    \n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n        throws IOException\n    {\n        while (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOFInValue();\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            String match;\n            if (ch == 'N') {\n                match = neg ? \"-INF\" :\"+INF\";\n            } else if (ch == 'n') {\n                match = neg ? \"-Infinity\" :\"+Infinity\";\n            } else {\n                break;\n            }\n            _matchToken(match, 3);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr] & 0xFF;\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n        // but actually only alphanums are problematic\n        char c = (char) _decodeCharForError(ch);\n        if (Character.isJavaIdentifierPart(c)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods, ws skipping, escape/unescape\n    /**********************************************************\n     */\n\n    private final int _skipWS() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWS2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWS2();\n    }\n\n    private final int _skipWS2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }        \n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n    \n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++] & 0xFF;\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n        \n        while (_inputPtr < _inputEnd) {\n            i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private final int _skipWSOrEnd2() throws IOException\n    {\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        // We ran out of input...\n        return _eofAsNextChar();\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        // Fast path: colon with optional single-space/tab before and/or after:\n        int i = _inputBuffer[_inputPtr];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;                    \n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[++_inputPtr];\n        }\n        if (i == INT_COLON) {\n            i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || loadMore()) {\n            int i = _inputBuffer[_inputPtr++] & 0xFF;\n\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n    }\n\n    private final void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _reportInvalidEOF(\" in a comment\");\n        }\n        int c = _inputBuffer[_inputPtr++] & 0xFF;\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private final void _skipCComment() throws IOException\n    {\n        // Need to be UTF-8 aware here to decode content (for skipping)\n        final int[] codes = CharTypes.getInputCodeComment();\n\n        // Ok: need the matching '*/'\n        main_loop:\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case '*':\n                    if (_inputPtr >= _inputEnd && !loadMore()) {\n                        break main_loop;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    break;\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                case INT_CR:\n                    _skipCR();\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2();\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3();\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    // Is this good enough error message?\n                    _reportInvalidChar(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\");\n    }\n\n    private final boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    /**\n     * Method for skipping contents of an input line; usually for CPP\n     * and YAML style comments.\n     */\n    private final void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        final int[] codes = CharTypes.getInputCodeComment();\n        while ((_inputPtr < _inputEnd) || loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            int code = codes[i];\n            if (code != 0) {\n                switch (code) {\n                case INT_LF:\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    return;\n                case INT_CR:\n                    _skipCR();\n                    return;\n                case '*': // nop for these comments\n                    break;\n                case 2: // 2-byte UTF\n                    _skipUtf8_2();\n                    break;\n                case 3: // 3-byte UTF\n                    _skipUtf8_3();\n                    break;\n                case 4: // 4-byte UTF\n                    _skipUtf8_4(i);\n                    break;\n                default: // e.g. -1\n                    if (code < 0) {\n                        // Is this good enough error message?\n                        _reportInvalidChar(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\");\n            }\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\");\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    protected int _decodeCharForError(int firstByte) throws IOException\n    {\n        int c = firstByte & 0xFF;\n        if (c > 0x7F) { // if >= 0, is ascii and fine as is\n            int needed;\n            \n            // Ok; if we end here, we got multi-byte combination\n            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n                c &= 0x1F;\n                needed = 1;\n            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n                c &= 0x0F;\n                needed = 2;\n            } else if ((c & 0xF8) == 0xF0) {\n                // 4 bytes; double-char with surrogates and all...\n                c &= 0x07;\n                needed = 3;\n            } else {\n                _reportInvalidInitial(c & 0xFF);\n                needed = 1; // never gets here\n            }\n\n            int d = nextByte();\n            if ((d & 0xC0) != 0x080) {\n                _reportInvalidOther(d & 0xFF);\n            }\n            c = (c << 6) | (d & 0x3F);\n            \n            if (needed > 1) { // needed == 1 means 2 bytes total\n                d = nextByte(); // 3rd byte\n                if ((d & 0xC0) != 0x080) {\n                    _reportInvalidOther(d & 0xFF);\n                }\n                c = (c << 6) | (d & 0x3F);\n                if (needed > 2) { // 4 bytes? (need surrogates)\n                    d = nextByte();\n                    if ((d & 0xC0) != 0x080) {\n                        _reportInvalidOther(d & 0xFF);\n                    }\n                    c = (c << 6) | (d & 0x3F);\n                }\n            }\n        }\n        return c;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods,UTF8 decoding\n    /**********************************************************\n     */\n\n    private final int _decodeUtf8_2(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUtf8_3(int c1) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    private final int _decodeUtf8_3fast(int c1) throws IOException\n    {\n        c1 &= 0x0F;\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        int c = (c1 << 6) | (d & 0x3F);\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        return c;\n    }\n\n    /**\n     * @return Character value <b>minus 0x10000</c>; this so that caller\n     *    can readily expand it to actual surrogates\n     */\n    private final int _decodeUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n\n        /* note: won't change it to negative here, since caller\n         * already knows it'll need a surrogate\n         */\n        return ((c << 6) | (d & 0x3F)) - 0x10000;\n    }\n\n    private final void _skipUtf8_2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    /* Alas, can't heavily optimize skipping, since we still have to\n     * do validity checks...\n     */\n    private final void _skipUtf8_3() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        //c &= 0x0F;\n        int c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++];\n        if ((c & 0xC0) != 0x080) {\n            _reportInvalidOther(c & 0xFF, _inputPtr);\n        }\n    }\n\n    private final void _skipUtf8_4(int c) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        int d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        d = (int) _inputBuffer[_inputPtr++];\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, input loading\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException\n    {\n        if (_inputPtr < _inputEnd || loadMore()) {\n            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n        private int nextByte() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        return _inputBuffer[_inputPtr++] & 0xFF;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n\n         /* Let's just try to find what appears to be the token, using\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n         while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 break;\n             }\n             int i = (int) _inputBuffer[_inputPtr++];\n             char c = (char) _decodeCharForError(i);\n             if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n             }\n             sb.append(c);\n         }\n         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n        \n    protected void _reportInvalidChar(int c)\n        throws JsonParseException\n    {\n        // Either invalid WS or illegal UTF-8 start char\n        if (c < INT_SPACE) {\n            _throwInvalidSpace(c);\n        }\n        _reportInvalidInitial(c);\n    }\n\n    protected void _reportInvalidInitial(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask)\n        throws JsonParseException\n    {\n        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n    }\n\n    protected void _reportInvalidOther(int mask, int ptr)\n        throws JsonParseException\n    {\n        _inputPtr = ptr;\n        _reportInvalidOther(mask);\n    }\n\n    public static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            int ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    loadMoreGuaranteed();\n                }\n                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == INT_QUOTE) {\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n            \n            // then second base64 char; can't get padding yet, nor ws\n            \n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n            \n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"' && !b64variant.usesPadding()) {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Improved location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(src,\n                    total, -1L, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(src,\n                _tokenInputTotal-1, -1L, _tokenInputRow, _tokenInputCol);\n    }\n\n    // As per [core#108], must ensure we call the right method\n    @Override\n    public JsonLocation getCurrentLocation()\n    {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_ioContext.getSourceReference(),\n                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        _tokenInputRow = _currInputRow;\n        final int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        _nameStartRow = _currInputRow;\n        final int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method needed to fix [Issue#148], masking of 0x00 character\n     */\n    private final static int pad(int q, int bytes) {\n        return (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 20, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.JsonGenerator", "buggy_version": "/* Jackson JSON-processor.\n *\n * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n */\npackage com.fasterxml.jackson.core;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.fasterxml.jackson.core.JsonParser.NumberType;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * Base class that defines public API for writing JSON content.\n * Instances are created using factory methods of\n * a {@link JsonFactory} instance.\n *\n * @author Tatu Saloranta\n */\npublic abstract class JsonGenerator\n    implements Closeable, Flushable, Versioned\n{\n    /**\n     * Enumeration that defines all togglable features for generators.\n     */\n    public enum Feature {\n        // // Low-level I/O / content features\n        \n        /**\n         * Feature that determines whether generator will automatically\n         * close underlying output target that is NOT owned by the\n         * generator.\n         * If disabled, calling application has to separately\n         * close the underlying {@link OutputStream} and {@link Writer}\n         * instances used to create the generator. If enabled, generator\n         * will handle closing, as long as generator itself gets closed:\n         * this happens when end-of-input is encountered, or generator\n         * is closed by a call to {@link JsonGenerator#close}.\n         *<p>\n         * Feature is enabled by default.\n         */\n        AUTO_CLOSE_TARGET(true),\n\n        /**\n         * Feature that determines what happens when the generator is\n         * closed while there are still unmatched\n         * {@link JsonToken#START_ARRAY} or {@link JsonToken#START_OBJECT}\n         * entries in output content. If enabled, such Array(s) and/or\n         * Object(s) are automatically closed; if disabled, nothing\n         * specific is done.\n         *<p>\n         * Feature is enabled by default.\n         */\n        AUTO_CLOSE_JSON_CONTENT(true),\n\n        /**\n         * Feature that specifies that calls to {@link #flush} will cause\n         * matching <code>flush()</code> to underlying {@link OutputStream}\n         * or {@link Writer}; if disabled this will not be done.\n         * Main reason to disable this feature is to prevent flushing at\n         * generator level, if it is not possible to prevent method being\n         * called by other code (like <code>ObjectMapper</code> or third\n         * party libraries).\n         *<p>\n         * Feature is enabled by default.\n         */\n        FLUSH_PASSED_TO_STREAM(true),\n\n        // // Quoting-related features\n        \n        /**\n         * Feature that determines whether JSON Object field names are\n         * quoted using double-quotes, as specified by JSON specification\n         * or not. Ability to disable quoting was added to support use\n         * cases where they are not usually expected, which most commonly\n         * occurs when used straight from Javascript.\n         *<p>\n         * Feature is enabled by default (since it is required by JSON specification).\n         */\n        QUOTE_FIELD_NAMES(true),\n\n        /**\n         * Feature that determines whether \"exceptional\" (not real number)\n         * float/double values are output as quoted strings.\n         * The values checked are Double.Nan,\n         * Double.POSITIVE_INFINITY and Double.NEGATIVE_INIFINTY (and \n         * associated Float values).\n         * If feature is disabled, these numbers are still output using\n         * associated literal values, resulting in non-conformant\n         * output.\n         *<p>\n         * Feature is enabled by default.\n         */\n        QUOTE_NON_NUMERIC_NUMBERS(true),\n\n        /**\n         * Feature that forces all Java numbers to be written as JSON strings.\n         * Default state is 'false', meaning that Java numbers are to\n         * be serialized using basic numeric serialization (as JSON\n         * numbers, integral or floating point). If enabled, all such\n         * numeric values are instead written out as JSON Strings.\n         *<p>\n         * One use case is to avoid problems with Javascript limitations:\n         * since Javascript standard specifies that all number handling\n         * should be done using 64-bit IEEE 754 floating point values,\n         * result being that some 64-bit integer values can not be\n         * accurately represent (as mantissa is only 51 bit wide).\n         *<p>\n         * Feature is disabled by default.\n         */\n        WRITE_NUMBERS_AS_STRINGS(false),\n\n        /**\n         * Feature that determines whether {@link java.math.BigDecimal} entries are\n         * serialized using {@link java.math.BigDecimal#toPlainString()} to prevent\n         * values to be written using scientific notation.\n         *<p>\n         * Feature is disabled by default, so default output mode is used; this generally\n         * depends on how {@link BigDecimal} has been created.\n         * \n         * @since 2.3\n         */\n        WRITE_BIGDECIMAL_AS_PLAIN(false),\n        \n        /**\n         * Feature that specifies that all characters beyond 7-bit ASCII\n         * range (i.e. code points of 128 and above) need to be output\n         * using format-specific escapes (for JSON, backslash escapes),\n         * if format uses escaping mechanisms (which is generally true\n         * for textual formats but not for binary formats).\n         *<p>\n         * Note that this setting may not necessarily make sense for all\n         * data formats (for example, binary formats typically do not use\n         * any escaping mechanisms; and some textual formats do not have\n         * general-purpose escaping); if so, settings is simply ignored.\n         * Put another way, effects of this feature are data-format specific.\n         *<p>\n         * Feature is disabled by default.\n         */\n        ESCAPE_NON_ASCII(false),\n\n// 23-Nov-2015, tatu: for [core#223], if and when it gets implemented\n        /**\n         * Feature that specifies handling of UTF-8 content that contains\n         * characters beyond BMP (Basic Multilingual Plane), which are\n         * represented in UCS-2 (Java internal character encoding) as two\n         * \"surrogate\" characters. If feature is enabled, these surrogate\n         * pairs are separately escaped using backslash escapes; if disabled,\n         * native output (4-byte UTF-8 sequence, or, with char-backed output\n         * targets, writing of surrogates as is which is typically converted\n         * by {@link java.io.Writer} into 4-byte UTF-8 sequence eventually)\n         * is used.\n         *<p>\n         * Note that the original JSON specification suggests use of escaping;\n         * but that this is not correct from standard UTF-8 handling perspective.\n         * Because of two competing goals, this feature was added to allow either\n         * behavior to be used, but defaulting to UTF-8 specification compliant\n         * mode.\n         *<p>\n         * Feature is disabled by default.\n         *\n         * @since Xxx\n         */\n//        ESCAPE_UTF8_SURROGATES(false),\n        \n        // // Schema/Validity support features\n\n        /**\n         * Feature that determines whether {@link JsonGenerator} will explicitly\n         * check that no duplicate JSON Object field names are written.\n         * If enabled, generator will check all names within context and report\n         * duplicates by throwing a {@link JsonGenerationException}; if disabled,\n         * no such checking will be done. Assumption in latter case is\n         * that caller takes care of not trying to write duplicate names.\n         *<p>\n         * Note that enabling this feature will incur performance overhead\n         * due to having to store and check additional information.\n         *<p>\n         * Feature is disabled by default.\n         * \n         * @since 2.3\n         */\n        STRICT_DUPLICATE_DETECTION(false),\n        \n        /**\n         * Feature that determines what to do if the underlying data format requires knowledge\n         * of all properties to output, and if no definition is found for a property that\n         * caller tries to write. If enabled, such properties will be quietly ignored;\n         * if disabled, a {@link JsonProcessingException} will be thrown to indicate the\n         * problem.\n         * Typically most textual data formats do NOT require schema information (although\n         * some do, such as CSV), whereas many binary data formats do require definitions\n         * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n         *<p>\n         * Note that support for this feature is implemented by individual data format\n         * module, if (and only if) it makes sense for the format in question. For JSON,\n         * for example, this feature has no effect as properties need not be pre-defined.\n         *<p>\n         * Feature is disabled by default, meaning that if the underlying data format\n         * requires knowledge of all properties to output, attempts to write an unknown\n         * property will result in a {@link JsonProcessingException}\n         *\n         * @since 2.5\n         */\n        IGNORE_UNKNOWN(false),\n        ;\n\n        private final boolean _defaultState;\n        private final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        public boolean enabledByDefault() { return _defaultState; }\n\n        /**\n         * @since 2.3\n         */\n        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n\n        public int getMask() { return _mask; }\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object that handles pretty-printing (usually additional\n     * white space to make results more human-readable) during\n     * output. If null, no pretty-printing is done.\n     */\n    protected PrettyPrinter _cfgPrettyPrinter;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n    \n    protected JsonGenerator() { }\n\n    /**\n     * Method that can be called to set or reset the object to\n     * use for writing Java objects as JsonContent\n     * (using method {@link #writeObject}).\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator setCodec(ObjectCodec oc);\n\n    /**\n     * Method for accessing the object used for writing Java\n     * object as JSON content\n     * (using method {@link #writeObject}).\n     */\n    public abstract ObjectCodec getCodec();\n\n    /**\n     * Accessor for finding out version of the bundle that provided this generator instance.\n     */\n    @Override\n    public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Public API, Feature configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling specified parser features:\n     * check {@link Feature} for list of available features.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator enable(Feature f);\n\n    /**\n     * Method for disabling specified  features\n     * (check {@link Feature} for list of features)\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator disable(Feature f);\n\n    /**\n     * Method for enabling or disabling specified feature:\n     * check {@link Feature} for list of available features.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public final JsonGenerator configure(Feature f, boolean state) {\n        if (state) enable(f); else disable(f);\n        return this;\n    }\n\n    /**\n     * Method for checking whether given feature is enabled.\n     * Check {@link Feature} for list of available features.\n     */\n    public abstract boolean isEnabled(Feature f);\n\n    /**\n     * Bulk access method for getting state of all standard (non-dataformat-specific)\n     * {@link JsonGenerator.Feature}s.\n     * \n     * @return Bit mask that defines current states of all standard {@link JsonGenerator.Feature}s.\n     * \n     * @since 2.3\n     */\n    public abstract int getFeatureMask();\n\n    /**\n     * Bulk set method for (re)setting states of all standard {@link Feature}s\n     * \n     * @since 2.3\n     * \n     * @param values Bitmask that defines which {@link Feature}s are enabled\n     *    and which disabled\n     *\n     * @return This parser object, to allow chaining of calls\n     *\n     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead -- remove from 2.9\n     */\n    @Deprecated\n    public abstract JsonGenerator setFeatureMask(int values);\n\n    /**\n     * Bulk set method for (re)setting states of features specified by <code>mask</code>.\n     * Functionally equivalent to\n     *<code>\n     *    int oldState = getFeatureMask();\n     *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n     *    setFeatureMask(newState);\n     *</code>\n     * but preferred as this lets caller more efficiently specify actual changes made.\n     * \n     * @param values Bit mask of set/clear state for features to change\n     * @param mask Bit mask of features to change\n     * \n     * @since 2.6\n     */\n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n    }\n\n    /**\n     * Bulk access method for getting state of all {@link FormatFeature}s, format-specific\n     * on/off configuration settings.\n     * \n     * @return Bit mask that defines current states of all standard {@link FormatFeature}s.\n     * \n     * @since 2.6\n     */\n    public int getFormatFeatures() {\n        return 0;\n    }\n    \n    /**\n     * Bulk set method for (re)setting states of {@link FormatFeature}s,\n     * by specifying values (set / clear) along with a mask, to determine\n     * which features to change, if any.\n     *<p>\n     * Default implementation will simply throw an exception to indicate that\n     * the generator implementation does not support any {@link FormatFeature}s.\n     * \n     * @param values Bit mask of set/clear state for features to change\n     * @param mask Bit mask of features to change\n     * \n     * @since 2.6\n     */\n    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n        throw new IllegalArgumentException(\"No FormatFeatures defined for generator of type \"+getClass().getName());\n        /*\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n        */\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, Schema configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method to call to make this generator use specified schema.\n     * Method must be called before generating any content, right after instance\n     * has been created.\n     * Note that not all generators support schemas; and those that do usually only\n     * accept specific types of schemas: ones defined for data format this generator\n     * produces.\n     *<p>\n     * If generator does not support specified schema, {@link UnsupportedOperationException}\n     * is thrown.\n     * \n     * @param schema Schema to use\n     * \n     * @throws UnsupportedOperationException if generator does not support schema\n     */\n    public void setSchema(FormatSchema schema) {\n        throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                +schema.getSchemaType()+\"'\");\n    }\n\n    /**\n     * Method for accessing Schema that this parser uses, if any.\n     * Default implementation returns null.\n     *\n     * @since 2.1\n     */\n    public FormatSchema getSchema() { return null; }\n\n    /*\n    /**********************************************************\n    /* Public API, other configuration\n    /**********************************************************\n      */\n\n    /**\n     * Method for setting a custom pretty printer, which is usually\n     * used to add indentation for improved human readability.\n     * By default, generator does not do pretty printing.\n     *<p>\n     * To use the default pretty printer that comes with core\n     * Jackson distribution, call {@link #useDefaultPrettyPrinter}\n     * instead.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        return this;\n    }\n\n    /**\n     * Accessor for checking whether this generator has a configured\n     * {@link PrettyPrinter}; returns it if so, null if none configured.\n     * \n     * @since 2.1\n     */\n    public PrettyPrinter getPrettyPrinter() {\n        return _cfgPrettyPrinter;\n    }\n    \n    /**\n     * Convenience method for enabling pretty-printing using\n     * the default pretty printer\n     * ({@link com.fasterxml.jackson.core.util.DefaultPrettyPrinter}).\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator useDefaultPrettyPrinter();\n\n    /**\n     * Method that can be called to request that generator escapes\n     * all character codes above specified code point (if positive value);\n     * or, to not escape any characters except for ones that must be\n     * escaped for the data format (if -1).\n     * To force escaping of all non-ASCII characters, for example,\n     * this method would be called with value of 127.\n     *<p>\n     * Note that generators are NOT required to support setting of value\n     * higher than 127, because there are other ways to affect quoting\n     * (or lack thereof) of character codes between 0 and 127.\n     * Not all generators support concept of escaping, either; if so,\n     * calling this method will have no effect.\n     *<p>\n     * Default implementation does nothing; sub-classes need to redefine\n     * it according to rules of supported data format.\n     * \n     * @param charCode Either -1 to indicate that no additional escaping\n     *   is to be done; or highest code point not to escape (meaning higher\n     *   ones will be), if positive value.\n     */\n    public JsonGenerator setHighestNonEscapedChar(int charCode) { return this; }\n\n    /**\n     * Accessor method for testing what is the highest unescaped character\n     * configured for this generator. This may be either positive value\n     * (when escaping configuration has been set and is in effect), or\n     * 0 to indicate that no additional escaping is in effect.\n     * Some generators may not support additional escaping: for example,\n     * generators for binary formats that do not use escaping should\n     * simply return 0.\n     * \n     * @return Currently active limitation for highest non-escaped character,\n     *   if defined; or -1 to indicate no additional escaping is performed.\n     */\n    public int getHighestEscapedChar() { return 0; }\n\n    /**\n     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     */\n    public CharacterEscapes getCharacterEscapes() { return null; }\n\n    /**\n     * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     *<p>\n     * Default implementation does nothing and simply returns this instance.\n     */\n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n\n    /**\n     * Method that allows overriding String used for separating root-level\n     * JSON values (default is single space character)\n     *<p>\n     * Default implementation throws {@link UnsupportedOperationException}.\n     * \n     * @param sep Separator to use, if any; null means that no separator is\n     *   automatically added\n     * \n     * @since 2.1\n     */\n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, output state access\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be used to get access to object that is used\n     * as target for generated output; this is usually either\n     * {@link OutputStream} or {@link Writer}, depending on what\n     * generator was constructed with.\n     * Note that returned value may be null in some cases; including\n     * case where implementation does not want to exposed raw\n     * source to caller.\n     * In cases where output has been decorated, object returned here\n     * is the decorated version; this allows some level of interaction\n     * between users of generator and decorator object.\n     *<p>\n     * In general use of this accessor should be considered as\n     * \"last effort\", i.e. only used if no other mechanism is applicable.\n     */\n    public Object getOutputTarget() {\n        return null;\n    }\n\n    /**\n     * Method for verifying amount of content that is buffered by generator\n     * but not yet flushed to the underlying target (stream, writer),\n     * in units (byte, char) that the generator implementation uses for buffering;\n     * or -1 if this information is not available.\n     * Unit used is often the same as the unit of underlying target (that is,\n     * `byte` for {@link java.io.OutputStream}, `char` for {@link java.io.Writer}),\n     * but may differ if buffering is done before encoding.\n     * Default JSON-backed implementations do use matching units.\n     *<p>\n     * Note: non-JSON implementations will be retrofitted for 2.6 and beyond;\n     * please report if you see -1 (missing override)\n     *\n     * @return Amount of content buffered in internal units, if amount known and\n     *    accessible; -1 if not accessible.\n     *\n     * @since 2.6\n     */\n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    /**\n     * Helper method, usually equivalent to:\n     *<code>\n     *   getOutputContext().getCurrentValue();\n     *</code>\n     *<p>\n     * Note that \"current value\" is NOT populated (or used) by Streaming parser;\n     * it is only used by higher-level data-binding functionality.\n     * The reason it is included here is that it can be stored and accessed hierarchically,\n     * and gets passed through data-binding.\n     * \n     * @since 2.5\n     */\n    public Object getCurrentValue() {\n        JsonStreamContext ctxt = getOutputContext();\n        return (ctxt == null) ? null : ctxt.getCurrentValue();\n    }\n\n    /**\n     * Helper method, usually equivalent to:\n     *<code>\n     *   getOutputContext().setCurrentValue(v);\n     *</code>\n     * \n     * @since 2.5\n     */\n    public void setCurrentValue(Object v) {\n        JsonStreamContext ctxt = getOutputContext();\n        if (ctxt != null) {\n            ctxt.setCurrentValue(v);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, capability introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to verify that given schema can be used with\n     * this generator (using {@link #setSchema}).\n     * \n     * @param schema Schema to check\n     * \n     * @return True if this generator can use given schema; false if not\n     */\n    public boolean canUseSchema(FormatSchema schema) { return false; }\n    \n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports some kind of Object Ids natively (many do not;\n     * for example, JSON doesn't).\n     * This method <b>must</b> be called prior to calling\n     * {@link #writeObjectId} or {@link #writeObjectRef}.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native Object Ids. Caller is expected to either\n     * use a non-native notation (explicit property or such), or fail,\n     * in case it can not use native object ids.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteObjectId() { return false; }\n\n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports some kind of Type Ids natively (many do not;\n     * for example, JSON doesn't).\n     * This method <b>must</b> be called prior to calling\n     * {@link #writeTypeId}.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native Type Ids. Caller is expected to either\n     * use a non-native notation (explicit property or such), or fail,\n     * in case it can not use native type ids.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteTypeId() { return false; }\n\n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports \"native\" binary data; that is, an efficient\n     * output of binary content without encoding.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native binary content.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteBinaryNatively() { return false; }\n    \n    /**\n     * Introspection method to call to check whether it is ok to omit\n     * writing of Object fields or not. Most formats do allow omission,\n     * but certain positional formats (such as CSV) require output of\n     * placeholders, even if no real values are to be emitted.\n     * \n     * @since 2.3\n     */\n    public boolean canOmitFields() { return true; }\n\n    /**\n     * Introspection method to call to check whether it is possible\n     * to write numbers using {@link #writeNumber(java.lang.String)}\n     * using possible custom format, or not. Typically textual formats\n     * allow this (and JSON specifically does), whereas binary formats\n     * do not allow this (except by writing them as Strings).\n     * Usual reason for calling this method is to check whether custom\n     * formatting of numbers may be applied by higher-level code (databinding)\n     * or not.\n     *\n     * @since 2.8\n     */\n    public boolean canWriteFormattedNumbers() { return false; }\n    \n    /*\n    /**********************************************************\n    /* Public API, write methods, structural\n    /**********************************************************\n     */\n\n    /**\n     * Method for writing starting marker of a Array value\n     * (for JSON this is character '['; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Array values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartArray() throws IOException;\n\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to {@link #writeStartArray()}, but also specifying how many\n     * elements will be written for the array before calling\n     * {@link #writeEndArray()}.\n     *<p>\n     * Default implementation simply calls {@link #writeStartArray()}.\n     * \n     * @param size Number of elements this array will have: actual\n     *   number of values written (before matching call to\n     *   {@link #writeEndArray()} MUST match; generator MAY verify\n     *   this is the case.\n     *   \n     * @since 2.4\n     */\n    public void writeStartArray(int size) throws IOException {\n        writeStartArray();\n    }\n    \n    /**\n     * Method for writing closing marker of a JSON Array value\n     * (character ']'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Array.\n     */\n    public abstract void writeEndArray() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException\n    {\n        writeStartObject();\n        setCurrentValue(forValue);\n    }\n\n    /**\n     * Method for writing closing marker of a JSON Object value\n     * (character '}'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Object, and the last written event was either a\n     * complete value, or START-OBJECT marker (see JSON specification\n     * for more details).\n     */\n    public abstract void writeEndObject() throws IOException;\n\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to {@link #writeFieldName(String)}, main difference\n     * being that it may perform better as some of processing (such as\n     * quoting of certain characters, or encoding into external encoding\n     * if supported by generator) can be done just once and reused for\n     * later calls.\n     *<p>\n     * Default implementation simple uses unprocessed name container in\n     * serialized String; implementations are strongly encouraged to make\n     * use of more efficient methods argument object has.\n     */\n    public abstract void writeFieldName(SerializableString name) throws IOException;\n\n    /**\n     * Alternative to {@link #writeFieldName(String)} that may be used\n     * in cases where property key is of numeric type; either where\n     * underlying format supports such notion (some binary formats do,\n     * unlike JSON), or for convenient conversion into String presentation.\n     * Default implementation will simply convert id into <code>String</code>\n     * and call {@link #writeFieldName(String)}.\n     *\n     * @since 2.8\n     */\n    public void writeFieldId(long id) throws IOException {\n        writeFieldName(Long.toString(id));\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, scalar arrays (2.8)\n    /**********************************************************\n     */\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_INT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(int[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_INT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(long[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_FLOAT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(double[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, text/String values\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting a String value. Depending on context\n     * this means either array element, (object) field value or\n     * a stand alone String; but in all cases, String will be\n     * surrounded in double quotes, and contents will be properly\n     * escaped as required by JSON specification.\n     */\n    public abstract void writeString(String text) throws IOException;\n\n    /**\n     * Method for outputting a String value. Depending on context\n     * this means either array element, (object) field value or\n     * a stand alone String; but in all cases, String will be\n     * surrounded in double quotes, and contents will be properly\n     * escaped as required by JSON specification.\n     */\n    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)}, but that takes\n     * {@link SerializableString} which can make this potentially\n     * more efficient to call as generator may be able to reuse\n     * quoted and/or encoded representation.\n     *<p>\n     * Default implementation just calls {@link #writeString(String)};\n     * sub-classes should override it with more efficient implementation\n     * if possible.\n     */\n    public abstract void writeString(SerializableString text) throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)} but that takes as\n     * its input a UTF-8 encoded String that is to be output as-is, without additional\n     * escaping (type of which depends on data format; backslashes for JSON).\n     * However, quoting that data format requires (like double-quotes for JSON) will be added\n     * around the value if and as necessary.\n     *<p>\n     * Note that some backends may choose not to support this method: for\n     * example, if underlying destination is a {@link java.io.Writer}\n     * using this method would require UTF-8 decoding.\n     * If so, implementation may instead choose to throw a\n     * {@link UnsupportedOperationException} due to ineffectiveness\n     * of having to decode input.\n     */\n    public abstract void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)} but that takes as its input\n     * a UTF-8 encoded String which has <b>not</b> been escaped using whatever\n     * escaping scheme data format requires (for JSON that is backslash-escaping\n     * for control characters and double-quotes; for other formats something else).\n     * This means that textual JSON backends need to check if value needs\n     * JSON escaping, but otherwise can just be copied as is to output.\n     * Also, quoting that data format requires (like double-quotes for JSON) will be added\n     * around the value if and as necessary.\n     *<p>\n     * Note that some backends may choose not to support this method: for\n     * example, if underlying destination is a {@link java.io.Writer}\n     * using this method would require UTF-8 decoding.\n     * In this case\n     * generator implementation may instead choose to throw a\n     * {@link UnsupportedOperationException} due to ineffectiveness\n     * of having to decode input.\n     */\n    public abstract void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, binary/raw content\n    /**********************************************************\n     */\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(String text) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(String text, int offset, int len) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(char c) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     *<p>\n     * The default implementation delegates to {@link #writeRaw(String)};\n     * other backends that support raw inclusion of text are encouraged\n     * to implement it in more efficient manner (especially if they\n     * use UTF-8 encoding).\n     * \n     * @since 2.1\n     */\n    public void writeRaw(SerializableString raw) throws IOException {\n        writeRaw(raw.getValue());\n    }\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim without any modifications, but assuming\n     * it must constitute a single legal JSON value (number, string,\n     * boolean, null, Array or List). Assuming this, proper separators\n     * are added if and as needed (comma or colon), and generator\n     * state updated to reflect this.\n     */\n    public abstract void writeRawValue(String text) throws IOException;\n\n    public abstract void writeRawValue(String text, int offset, int len) throws IOException;\n\n    public abstract void writeRawValue(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method similar to {@link #writeRawValue(String)}, but potentially more\n     * efficient as it may be able to use pre-encoded content (similar to\n     * {@link #writeRaw(SerializableString)}.\n     * \n     * @since 2.5\n     */\n    public void writeRawValue(SerializableString raw) throws IOException {\n        writeRawValue(raw.getValue());\n    }\n\n    /**\n     * Method that will output given chunk of binary data as base64\n     * encoded, as a complete String value (surrounded by double quotes).\n     * This method defaults\n     *<p>\n     * Note: because JSON Strings can not contain unescaped linefeeds,\n     * if linefeeds are included (as per last argument), they must be\n     * escaped. This adds overhead for decoding without improving\n     * readability.\n     * Alternatively if linefeeds are not included,\n     * resulting String value may violate the requirement of base64\n     * RFC which mandates line-length of 76 characters and use of\n     * linefeeds. However, all {@link JsonParser} implementations\n     * are required to accept such \"long line base64\"; as do\n     * typical production-level base64 decoders.\n     *\n     * @param bv Base64 variant to use: defines details such as\n     *   whether padding is used (and if so, using which character);\n     *   what is the maximum line length before adding linefeed,\n     *   and also the underlying alphabet to use.\n     */\n    public abstract void writeBinary(Base64Variant bv,\n            byte[] data, int offset, int len) throws IOException;\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     */\n    public void writeBinary(byte[] data, int offset, int len) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n    }\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n     * assumes that whole byte array is to be output.\n     */\n    public void writeBinary(byte[] data) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n    }\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     * \n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known. Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may\n     */\n    public int writeBinary(InputStream data, int dataLength)\n        throws IOException {\n        return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n    }\n    \n    /**\n     * Method similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but where input is provided through a stream, allowing for incremental\n     * writes without holding the whole input in memory.\n     * \n     * @param bv Base64 variant to use\n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known.\n     *    If a positive length is given, <code>data</code> MUST provide at least\n     *    that many bytes: if not, an exception will be thrown.\n     *    Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may.\n     * \n     * @return Number of bytes read from <code>data</code> and written as binary payload\n     * \n     * @since 2.1\n     */\n    public abstract int writeBinary(Base64Variant bv,\n            InputStream data, int dataLength) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, numeric\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     *\n     * @since 2.2\n     */\n    public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(int v) throws IOException;\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(long v) throws IOException;\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(BigInteger v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(double v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(float v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(BigDecimal v) throws IOException;\n\n    /**\n     * Write method that can be used for custom numeric types that can\n     * not be (easily?) converted to \"standard\" Java number types.\n     * Because numbers are not surrounded by double quotes, regular\n     * {@link #writeString} method can not be used; nor\n     * {@link #writeRaw} because that does not properly handle\n     * value separators needed in Array or Object contexts.\n     *<p>\n     * Note: because of lack of type safety, some generator\n     * implementations may not be able to implement this\n     * method. For example, if a binary JSON format is used,\n     * it may require type information for encoding; similarly\n     * for generator-wrappers around Java objects or JSON nodes.\n     * If implementation does not implement this method,\n     * it needs to throw {@link UnsupportedOperationException}.\n     * \n     * @throws UnsupportedOperationException If underlying data format does not\n     *   support numbers serialized textually AND if generator is not allowed\n     *   to just output a String instead (Schema-based formats may require actual\n     *   number, for example)\n     */\n    public abstract void writeNumber(String encodedValue) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, other value types\n    /**********************************************************\n     */\n    \n    /**\n     * Method for outputting literal JSON boolean value (one of\n     * Strings 'true' and 'false').\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeBoolean(boolean state) throws IOException;\n\n    /**\n     * Method for outputting literal JSON null value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeNull() throws IOException;\n\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                this);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, write methods, Native Ids (type, object)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to output so-called native Object Id.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteObjectId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     * \n     * @since 2.3\n     */\n    public void writeObjectId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }\n\n    /**\n     * Method that can be called to output references to native Object Ids.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteObjectId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     */\n    public void writeObjectRef(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }\n    \n    /**\n     * Method that can be called to output so-called native Type Id.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteTypeId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     * \n     * @since 2.3\n     */\n    public void writeTypeId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n    }\n\n    // 24-May-2016, tatu: Looks like this won't quite make it in 2.8... too\n    //   many open questions on whether return value may be used and such to\n    //   really close the loop. But leaving code sample in, in case we can resolve it\n    //   it for 2.9.\n\n    /*\n     * Replacement method for {@link #writeTypeId(Object)} which is called\n     * regardless of whether format has native type ids. If it does have native\n     * type ids, those are to be used (if configuration allows this), if not,\n     * structural type id inclusion is to be used. For JSON, for example, no\n     * native type ids exist and structural inclusion is always used.\n     *<p>\n     * NOTE: from databind perspective, only \"as-wrapper-array\", \"as-wrapper-object\" and\n     * \"as-property\" inclusion styles call this method; the remaining \"as-external-property\"\n     * mechanism always uses writes type id value as simple property.\n     *\n     * @param inclStyle Kind of inclusion; {@link JsonToken#START_ARRAY} for \"as-wrapper-array\",\n     *     {@link JsonToken#START_OBJECT} for \"as-wrapper-object\" and {@link JsonToken#FIELD_NAME}\n     *     for \"as-property\"\n     * @param forValue Java object for which type is being written; not used by standard mechanism\n     * @param valueShape Expected shape of the value to write, as expressed by the first token (for\n     *    structural type), or any of scalar types for non-structured values (typically\n     *    just {@link JsonToken#VALUE_STRING} -- exact token not required, just the fact it's scalar)\n     * @param typeId Type id to write\n     * @param propertyName Name of property to use, in case of \"as-property\" inclusion style\n     *\n     * @since 2.8\n     */\n    /*\n    public Object writeTypeSuffix(JsonToken inclStyle, Object forValue, JsonToken valueShape,\n            String typeId, String propertyName) throws IOException\n    {\n        if (inclStyle == JsonToken.FIELD_NAME) { // as-property\n            if (typeId == null) { // should not include `null` type id in any form with this style\n                writeStartObject();\n            } else if (valueShape == JsonToken.START_OBJECT) {\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                    writeStartObject();\n                } else {\n                    writeStartObject();\n                    writeStringField(propertyName, typeId);\n                }\n            } else if (valueShape == JsonToken.START_ARRAY) {\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                    writeStartArray();\n                } else {\n                    writeStartArray();\n                    writeString(typeId);\n                }\n            } else { // any scalar\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                }\n            }\n            return JsonToken.END_OBJECT;\n        }\n        if (inclStyle == JsonToken.START_ARRAY) { // as-wrapper-array\n        } else if (inclStyle == JsonToken.START_OBJECT) { // as-wrapper-object\n            \n        } else {\n            throw new JsonGenerationException(\"Unrecognized inclusion style: \"+inclStyle, this);\n        }\n    }\n    */\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, serializing Java objects\n    /**********************************************************\n     */\n\n    /**\n     * Method for writing given Java object (POJO) as Json.\n     * Exactly how the object gets written depends on object\n     * in question (ad on codec, its configuration); for most\n     * beans it will result in JSON Object, but for others JSON\n     * Array, or String or numeric value (and for nulls, JSON\n     * null literal.\n     * <b>NOTE</b>: generator must have its <b>object codec</b>\n     * set to non-null value; for generators created by a mapping\n     * factory this is the case, for others not.\n     */\n    public abstract void writeObject(Object pojo) throws IOException;\n\n    /**\n     * Method for writing given JSON tree (expressed as a tree\n     * where given JsonNode is the root) using this generator.\n     * This will generally just call\n     * {@link #writeObject} with given node, but is added\n     * for convenience and to make code more explicit in cases\n     * where it deals specifically with trees.\n     */\n    public abstract void writeTree(TreeNode rootNode) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, convenience field write methods\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has a String value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeString(value);\n     *</pre>\n     *<p>\n     * Note: many performance-sensitive implementations override this method\n     */\n    public void writeStringField(String fieldName, String value) throws IOException {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has a boolean value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeBoolean(value);\n     *</pre>\n     */\n    public final void writeBooleanField(String fieldName, boolean value) throws IOException {\n        writeFieldName(fieldName);\n        writeBoolean(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has JSON literal value null. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNull();\n     *</pre>\n     */\n    public final void writeNullField(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeNull();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, int value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, long value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, double value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, float value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that contains specified data in base64-encoded form.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeBinary(value);\n     *</pre>\n     */\n    public final void writeBinaryField(String fieldName, byte[] data) throws IOException {\n        writeFieldName(fieldName);\n        writeBinary(data);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * (that will contain a JSON Array value), and the START_ARRAY marker.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeStartArray();\n     *</pre>\n     *<p>\n     * Note: caller still has to take care to close the array\n     * (by calling {#link #writeEndArray}) after writing all values\n     * of the value Array.\n     */\n    public final void writeArrayFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartArray();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * (that will contain a JSON Object value), and the START_OBJECT marker.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeStartObject();\n     *</pre>\n     *<p>\n     * Note: caller still has to take care to close the Object\n     * (by calling {#link #writeEndObject}) after writing all\n     * entries of the value Object.\n     */\n    public final void writeObjectFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartObject();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has contents of specific Java object as its value.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeObject(pojo);\n     *</pre>\n     */\n    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n        writeFieldName(fieldName);\n        writeObject(pojo);\n    }\n\n    /**\n     * Method called to indicate that a property in this position was\n     * skipped. It is usually only called for generators that return\n     * <code>false</code> from {@link #canOmitFields()}.\n     *<p>\n     * Default implementation does nothing.\n     * \n     * @since 2.3\n     */\n    public void writeOmittedField(String fieldName) throws IOException { }\n    \n    /*\n    /**********************************************************\n    /* Public API, copy-through methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for copying contents of the current event that\n     * the given parser instance points to.\n     * Note that the method <b>will not</b> copy any other events,\n     * such as events contained within JSON Array or Object structures.\n     *<p>\n     * Calling this method will not advance the given\n     * parser, although it may cause parser to internally process\n     * more data (if it lazy loads contents of value events, for example)\n     */\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        JsonToken t = p.currentToken();\n        // sanity check; what to do?\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        switch (t.id()) {\n        case ID_NOT_AVAILABLE:\n            _reportError(\"No current event to copy\");\n            break; // never gets here\n        case ID_START_OBJECT:\n            writeStartObject();\n            break;\n        case ID_END_OBJECT:\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            break;\n        case ID_END_ARRAY:\n            writeEndArray();\n            break;\n        case ID_FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case ID_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case ID_NUMBER_INT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.INT) {\n                writeNumber(p.getIntValue());\n            } else if (n == NumberType.BIG_INTEGER) {\n                writeNumber(p.getBigIntegerValue());\n            } else {\n                writeNumber(p.getLongValue());\n            }\n            break;\n        }\n        case ID_NUMBER_FLOAT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.BIG_DECIMAL) {\n                writeNumber(p.getDecimalValue());\n            } else if (n == NumberType.FLOAT) {\n                writeNumber(p.getFloatValue());\n            } else {\n                writeNumber(p.getDoubleValue());\n            }\n            break;\n        }\n        case ID_TRUE:\n            writeBoolean(true);\n            break;\n        case ID_FALSE:\n            writeBoolean(false);\n            break;\n        case ID_NULL:\n            writeNull();\n            break;\n        case ID_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            _throwInternal();\n        }\n    }\n\n    /**\n     * Method for copying contents of the current event\n     * <b>and following events that it encloses</b>\n     * the given parser instance points to.\n     *<p>\n     * So what constitutes enclosing? Here is the list of\n     * events that have associated enclosed events that will\n     * get copied:\n     *<ul>\n     * <li>{@link JsonToken#START_OBJECT}:\n     *   all events up to and including matching (closing)\n     *   {@link JsonToken#END_OBJECT} will be copied\n     *  </li>\n     * <li>{@link JsonToken#START_ARRAY}\n     *   all events up to and including matching (closing)\n     *   {@link JsonToken#END_ARRAY} will be copied\n     *  </li>\n     * <li>{@link JsonToken#FIELD_NAME} the logical value (which\n     *   can consist of a single scalar value; or a sequence of related\n     *   events for structured types (JSON Arrays, Objects)) will\n     *   be copied along with the name itself. So essentially the\n     *   whole <b>field entry</b> (name and value) will be copied.\n     *  </li>\n     *</ul>\n     *<p>\n     * After calling this method, parser will point to the\n     * <b>last event</b> that was copied. This will either be\n     * the event parser already pointed to (if there were no\n     * enclosed events), or the last enclosed event copied.\n     */\n    public void copyCurrentStructure(JsonParser p) throws IOException\n    {\n        JsonToken t = p.currentToken();\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        // Let's handle field-name separately first\n        int id = t.id();\n        if (id == ID_FIELD_NAME) {\n            writeFieldName(p.getCurrentName());\n            t = p.nextToken();\n            id = t.id();\n            // fall-through to copy the associated value\n        }\n        switch (id) {\n        case ID_START_OBJECT:\n            writeStartObject();\n            while (p.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(p);\n            }\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            while (p.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(p);\n            }\n            writeEndArray();\n            break;\n        default:\n            copyCurrentEvent(p);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, context access\n    /**********************************************************\n     */\n\n    /**\n     * @return Context object that can give information about logical\n     *   position within generated json content.\n     */\n    public abstract JsonStreamContext getOutputContext();\n\n    /*\n    /**********************************************************\n    /* Public API, buffer handling\n    /**********************************************************\n     */\n\n    /**\n     * Method called to flush any buffered content to the underlying\n     * target (output stream, writer), and to flush the target itself\n     * as well.\n     */\n    @Override\n    public abstract void flush() throws IOException;\n\n    /**\n     * Method that can be called to determine whether this generator\n     * is closed or not. If it is closed, no more output can be done.\n     */\n    public abstract boolean isClosed();\n\n    /*\n    /**********************************************************\n    /* Closeable implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method called to close this generator, so that no more content\n     * can be written.\n     *<p>\n     * Whether the underlying target (stream, writer) gets closed depends\n     * on whether this generator either manages the target (i.e. is the\n     * only one with access to the target -- case if caller passes a\n     * reference to the resource such as File, but not stream); or\n     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.\n     * If either of above is true, the target is also closed. Otherwise\n     * (not managing, feature not enabled), target is not closed.\n     */\n    @Override\n    public abstract void close() throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used for constructing and throwing\n     * {@link JsonGenerationException} with given base message.\n     *<p>\n     * Note that sub-classes may override this method to add more detail\n     * or use a {@link JsonGenerationException} sub-class.\n     */\n    protected void _reportError(String msg) throws JsonGenerationException {\n        throw new JsonGenerationException(msg, this);\n    }\n\n    protected final void _throwInternal() { VersionUtil.throwInternal(); }\n\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected final void _verifyOffsets(int arrayLength, int offset, int length)\n    {\n        if ((offset < 0) || (offset + length) > arrayLength) {\n            throw new IllegalArgumentException(String.format(\n                    \"invalid argument(s) (offset=%d, length=%d) for input array of %d element\",\n                    offset, length, arrayLength));\n        }\n    }\n\n    /**\n     * Helper method to try to call appropriate write method for given\n     * untyped Object. At this point, no structural conversions should be done,\n     * only simple basic types are to be coerced as necessary.\n     *\n     * @param value Non-null value to write\n     */\n    protected void _writeSimpleObject(Object value)  throws IOException\n    {\n        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n         *    types even without codec. This can improve interoperability,\n         *    and specifically help with TokenBuffer.\n         */\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        if (value instanceof String) {\n            writeString((String) value);\n            return;\n        }\n        if (value instanceof Number) {\n            Number n = (Number) value;\n            if (n instanceof Integer) {\n                writeNumber(n.intValue());\n                return;\n            } else if (n instanceof Long) {\n                writeNumber(n.longValue());\n                return;\n            } else if (n instanceof Double) {\n                writeNumber(n.doubleValue());\n                return;\n            } else if (n instanceof Float) {\n                writeNumber(n.floatValue());\n                return;\n            } else if (n instanceof Short) {\n                writeNumber(n.shortValue());\n                return;\n            } else if (n instanceof Byte) {\n                writeNumber(n.byteValue());\n                return;\n            } else if (n instanceof BigInteger) {\n                writeNumber((BigInteger) n);\n                return;\n            } else if (n instanceof BigDecimal) {\n                writeNumber((BigDecimal) n);\n                return;\n\n            // then Atomic types\n            } else if (n instanceof AtomicInteger) {\n                writeNumber(((AtomicInteger) n).get());\n                return;\n            } else if (n instanceof AtomicLong) {\n                writeNumber(((AtomicLong) n).get());\n                return;\n            }\n        } else if (value instanceof byte[]) {\n            writeBinary((byte[]) value);\n            return;\n        } else if (value instanceof Boolean) {\n            writeBoolean((Boolean) value);\n            return;\n        } else if (value instanceof AtomicBoolean) {\n            writeBoolean(((AtomicBoolean) value).get());\n            return;\n        }\n        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                +value.getClass().getName()+\")\");\n    }    \n}\n", "fixed_version": "/* Jackson JSON-processor.\n *\n * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n */\npackage com.fasterxml.jackson.core;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.fasterxml.jackson.core.JsonParser.NumberType;\nimport com.fasterxml.jackson.core.io.CharacterEscapes;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\n/**\n * Base class that defines public API for writing JSON content.\n * Instances are created using factory methods of\n * a {@link JsonFactory} instance.\n *\n * @author Tatu Saloranta\n */\npublic abstract class JsonGenerator\n    implements Closeable, Flushable, Versioned\n{\n    /**\n     * Enumeration that defines all togglable features for generators.\n     */\n    public enum Feature {\n        // // Low-level I/O / content features\n        \n        /**\n         * Feature that determines whether generator will automatically\n         * close underlying output target that is NOT owned by the\n         * generator.\n         * If disabled, calling application has to separately\n         * close the underlying {@link OutputStream} and {@link Writer}\n         * instances used to create the generator. If enabled, generator\n         * will handle closing, as long as generator itself gets closed:\n         * this happens when end-of-input is encountered, or generator\n         * is closed by a call to {@link JsonGenerator#close}.\n         *<p>\n         * Feature is enabled by default.\n         */\n        AUTO_CLOSE_TARGET(true),\n\n        /**\n         * Feature that determines what happens when the generator is\n         * closed while there are still unmatched\n         * {@link JsonToken#START_ARRAY} or {@link JsonToken#START_OBJECT}\n         * entries in output content. If enabled, such Array(s) and/or\n         * Object(s) are automatically closed; if disabled, nothing\n         * specific is done.\n         *<p>\n         * Feature is enabled by default.\n         */\n        AUTO_CLOSE_JSON_CONTENT(true),\n\n        /**\n         * Feature that specifies that calls to {@link #flush} will cause\n         * matching <code>flush()</code> to underlying {@link OutputStream}\n         * or {@link Writer}; if disabled this will not be done.\n         * Main reason to disable this feature is to prevent flushing at\n         * generator level, if it is not possible to prevent method being\n         * called by other code (like <code>ObjectMapper</code> or third\n         * party libraries).\n         *<p>\n         * Feature is enabled by default.\n         */\n        FLUSH_PASSED_TO_STREAM(true),\n\n        // // Quoting-related features\n        \n        /**\n         * Feature that determines whether JSON Object field names are\n         * quoted using double-quotes, as specified by JSON specification\n         * or not. Ability to disable quoting was added to support use\n         * cases where they are not usually expected, which most commonly\n         * occurs when used straight from Javascript.\n         *<p>\n         * Feature is enabled by default (since it is required by JSON specification).\n         */\n        QUOTE_FIELD_NAMES(true),\n\n        /**\n         * Feature that determines whether \"exceptional\" (not real number)\n         * float/double values are output as quoted strings.\n         * The values checked are Double.Nan,\n         * Double.POSITIVE_INFINITY and Double.NEGATIVE_INIFINTY (and \n         * associated Float values).\n         * If feature is disabled, these numbers are still output using\n         * associated literal values, resulting in non-conformant\n         * output.\n         *<p>\n         * Feature is enabled by default.\n         */\n        QUOTE_NON_NUMERIC_NUMBERS(true),\n\n        /**\n         * Feature that forces all Java numbers to be written as JSON strings.\n         * Default state is 'false', meaning that Java numbers are to\n         * be serialized using basic numeric serialization (as JSON\n         * numbers, integral or floating point). If enabled, all such\n         * numeric values are instead written out as JSON Strings.\n         *<p>\n         * One use case is to avoid problems with Javascript limitations:\n         * since Javascript standard specifies that all number handling\n         * should be done using 64-bit IEEE 754 floating point values,\n         * result being that some 64-bit integer values can not be\n         * accurately represent (as mantissa is only 51 bit wide).\n         *<p>\n         * Feature is disabled by default.\n         */\n        WRITE_NUMBERS_AS_STRINGS(false),\n\n        /**\n         * Feature that determines whether {@link java.math.BigDecimal} entries are\n         * serialized using {@link java.math.BigDecimal#toPlainString()} to prevent\n         * values to be written using scientific notation.\n         *<p>\n         * Feature is disabled by default, so default output mode is used; this generally\n         * depends on how {@link BigDecimal} has been created.\n         * \n         * @since 2.3\n         */\n        WRITE_BIGDECIMAL_AS_PLAIN(false),\n        \n        /**\n         * Feature that specifies that all characters beyond 7-bit ASCII\n         * range (i.e. code points of 128 and above) need to be output\n         * using format-specific escapes (for JSON, backslash escapes),\n         * if format uses escaping mechanisms (which is generally true\n         * for textual formats but not for binary formats).\n         *<p>\n         * Note that this setting may not necessarily make sense for all\n         * data formats (for example, binary formats typically do not use\n         * any escaping mechanisms; and some textual formats do not have\n         * general-purpose escaping); if so, settings is simply ignored.\n         * Put another way, effects of this feature are data-format specific.\n         *<p>\n         * Feature is disabled by default.\n         */\n        ESCAPE_NON_ASCII(false),\n\n// 23-Nov-2015, tatu: for [core#223], if and when it gets implemented\n        /**\n         * Feature that specifies handling of UTF-8 content that contains\n         * characters beyond BMP (Basic Multilingual Plane), which are\n         * represented in UCS-2 (Java internal character encoding) as two\n         * \"surrogate\" characters. If feature is enabled, these surrogate\n         * pairs are separately escaped using backslash escapes; if disabled,\n         * native output (4-byte UTF-8 sequence, or, with char-backed output\n         * targets, writing of surrogates as is which is typically converted\n         * by {@link java.io.Writer} into 4-byte UTF-8 sequence eventually)\n         * is used.\n         *<p>\n         * Note that the original JSON specification suggests use of escaping;\n         * but that this is not correct from standard UTF-8 handling perspective.\n         * Because of two competing goals, this feature was added to allow either\n         * behavior to be used, but defaulting to UTF-8 specification compliant\n         * mode.\n         *<p>\n         * Feature is disabled by default.\n         *\n         * @since Xxx\n         */\n//        ESCAPE_UTF8_SURROGATES(false),\n        \n        // // Schema/Validity support features\n\n        /**\n         * Feature that determines whether {@link JsonGenerator} will explicitly\n         * check that no duplicate JSON Object field names are written.\n         * If enabled, generator will check all names within context and report\n         * duplicates by throwing a {@link JsonGenerationException}; if disabled,\n         * no such checking will be done. Assumption in latter case is\n         * that caller takes care of not trying to write duplicate names.\n         *<p>\n         * Note that enabling this feature will incur performance overhead\n         * due to having to store and check additional information.\n         *<p>\n         * Feature is disabled by default.\n         * \n         * @since 2.3\n         */\n        STRICT_DUPLICATE_DETECTION(false),\n        \n        /**\n         * Feature that determines what to do if the underlying data format requires knowledge\n         * of all properties to output, and if no definition is found for a property that\n         * caller tries to write. If enabled, such properties will be quietly ignored;\n         * if disabled, a {@link JsonProcessingException} will be thrown to indicate the\n         * problem.\n         * Typically most textual data formats do NOT require schema information (although\n         * some do, such as CSV), whereas many binary data formats do require definitions\n         * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n         *<p>\n         * Note that support for this feature is implemented by individual data format\n         * module, if (and only if) it makes sense for the format in question. For JSON,\n         * for example, this feature has no effect as properties need not be pre-defined.\n         *<p>\n         * Feature is disabled by default, meaning that if the underlying data format\n         * requires knowledge of all properties to output, attempts to write an unknown\n         * property will result in a {@link JsonProcessingException}\n         *\n         * @since 2.5\n         */\n        IGNORE_UNKNOWN(false),\n        ;\n\n        private final boolean _defaultState;\n        private final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        public boolean enabledByDefault() { return _defaultState; }\n\n        /**\n         * @since 2.3\n         */\n        public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n\n        public int getMask() { return _mask; }\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Object that handles pretty-printing (usually additional\n     * white space to make results more human-readable) during\n     * output. If null, no pretty-printing is done.\n     */\n    protected PrettyPrinter _cfgPrettyPrinter;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n    \n    protected JsonGenerator() { }\n\n    /**\n     * Method that can be called to set or reset the object to\n     * use for writing Java objects as JsonContent\n     * (using method {@link #writeObject}).\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator setCodec(ObjectCodec oc);\n\n    /**\n     * Method for accessing the object used for writing Java\n     * object as JSON content\n     * (using method {@link #writeObject}).\n     */\n    public abstract ObjectCodec getCodec();\n\n    /**\n     * Accessor for finding out version of the bundle that provided this generator instance.\n     */\n    @Override\n    public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Public API, Feature configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method for enabling specified parser features:\n     * check {@link Feature} for list of available features.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator enable(Feature f);\n\n    /**\n     * Method for disabling specified  features\n     * (check {@link Feature} for list of features)\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator disable(Feature f);\n\n    /**\n     * Method for enabling or disabling specified feature:\n     * check {@link Feature} for list of available features.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public final JsonGenerator configure(Feature f, boolean state) {\n        if (state) enable(f); else disable(f);\n        return this;\n    }\n\n    /**\n     * Method for checking whether given feature is enabled.\n     * Check {@link Feature} for list of available features.\n     */\n    public abstract boolean isEnabled(Feature f);\n\n    /**\n     * Bulk access method for getting state of all standard (non-dataformat-specific)\n     * {@link JsonGenerator.Feature}s.\n     * \n     * @return Bit mask that defines current states of all standard {@link JsonGenerator.Feature}s.\n     * \n     * @since 2.3\n     */\n    public abstract int getFeatureMask();\n\n    /**\n     * Bulk set method for (re)setting states of all standard {@link Feature}s\n     * \n     * @since 2.3\n     * \n     * @param values Bitmask that defines which {@link Feature}s are enabled\n     *    and which disabled\n     *\n     * @return This parser object, to allow chaining of calls\n     *\n     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead -- remove from 2.9\n     */\n    @Deprecated\n    public abstract JsonGenerator setFeatureMask(int values);\n\n    /**\n     * Bulk set method for (re)setting states of features specified by <code>mask</code>.\n     * Functionally equivalent to\n     *<code>\n     *    int oldState = getFeatureMask();\n     *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n     *    setFeatureMask(newState);\n     *</code>\n     * but preferred as this lets caller more efficiently specify actual changes made.\n     * \n     * @param values Bit mask of set/clear state for features to change\n     * @param mask Bit mask of features to change\n     * \n     * @since 2.6\n     */\n    public JsonGenerator overrideStdFeatures(int values, int mask) {\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n    }\n\n    /**\n     * Bulk access method for getting state of all {@link FormatFeature}s, format-specific\n     * on/off configuration settings.\n     * \n     * @return Bit mask that defines current states of all standard {@link FormatFeature}s.\n     * \n     * @since 2.6\n     */\n    public int getFormatFeatures() {\n        return 0;\n    }\n    \n    /**\n     * Bulk set method for (re)setting states of {@link FormatFeature}s,\n     * by specifying values (set / clear) along with a mask, to determine\n     * which features to change, if any.\n     *<p>\n     * Default implementation will simply throw an exception to indicate that\n     * the generator implementation does not support any {@link FormatFeature}s.\n     * \n     * @param values Bit mask of set/clear state for features to change\n     * @param mask Bit mask of features to change\n     * \n     * @since 2.6\n     */\n    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n        throw new IllegalArgumentException(\"No FormatFeatures defined for generator of type \"+getClass().getName());\n        /*\n        int oldState = getFeatureMask();\n        int newState = (oldState & ~mask) | (values & mask);\n        return setFeatureMask(newState);\n        */\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, Schema configuration\n    /**********************************************************\n     */\n\n    /**\n     * Method to call to make this generator use specified schema.\n     * Method must be called before generating any content, right after instance\n     * has been created.\n     * Note that not all generators support schemas; and those that do usually only\n     * accept specific types of schemas: ones defined for data format this generator\n     * produces.\n     *<p>\n     * If generator does not support specified schema, {@link UnsupportedOperationException}\n     * is thrown.\n     * \n     * @param schema Schema to use\n     * \n     * @throws UnsupportedOperationException if generator does not support schema\n     */\n    public void setSchema(FormatSchema schema) {\n        throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                +schema.getSchemaType()+\"'\");\n    }\n\n    /**\n     * Method for accessing Schema that this parser uses, if any.\n     * Default implementation returns null.\n     *\n     * @since 2.1\n     */\n    public FormatSchema getSchema() { return null; }\n\n    /*\n    /**********************************************************\n    /* Public API, other configuration\n    /**********************************************************\n      */\n\n    /**\n     * Method for setting a custom pretty printer, which is usually\n     * used to add indentation for improved human readability.\n     * By default, generator does not do pretty printing.\n     *<p>\n     * To use the default pretty printer that comes with core\n     * Jackson distribution, call {@link #useDefaultPrettyPrinter}\n     * instead.\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        return this;\n    }\n\n    /**\n     * Accessor for checking whether this generator has a configured\n     * {@link PrettyPrinter}; returns it if so, null if none configured.\n     * \n     * @since 2.1\n     */\n    public PrettyPrinter getPrettyPrinter() {\n        return _cfgPrettyPrinter;\n    }\n    \n    /**\n     * Convenience method for enabling pretty-printing using\n     * the default pretty printer\n     * ({@link com.fasterxml.jackson.core.util.DefaultPrettyPrinter}).\n     *\n     * @return Generator itself (this), to allow chaining\n     */\n    public abstract JsonGenerator useDefaultPrettyPrinter();\n\n    /**\n     * Method that can be called to request that generator escapes\n     * all character codes above specified code point (if positive value);\n     * or, to not escape any characters except for ones that must be\n     * escaped for the data format (if -1).\n     * To force escaping of all non-ASCII characters, for example,\n     * this method would be called with value of 127.\n     *<p>\n     * Note that generators are NOT required to support setting of value\n     * higher than 127, because there are other ways to affect quoting\n     * (or lack thereof) of character codes between 0 and 127.\n     * Not all generators support concept of escaping, either; if so,\n     * calling this method will have no effect.\n     *<p>\n     * Default implementation does nothing; sub-classes need to redefine\n     * it according to rules of supported data format.\n     * \n     * @param charCode Either -1 to indicate that no additional escaping\n     *   is to be done; or highest code point not to escape (meaning higher\n     *   ones will be), if positive value.\n     */\n    public JsonGenerator setHighestNonEscapedChar(int charCode) { return this; }\n\n    /**\n     * Accessor method for testing what is the highest unescaped character\n     * configured for this generator. This may be either positive value\n     * (when escaping configuration has been set and is in effect), or\n     * 0 to indicate that no additional escaping is in effect.\n     * Some generators may not support additional escaping: for example,\n     * generators for binary formats that do not use escaping should\n     * simply return 0.\n     * \n     * @return Currently active limitation for highest non-escaped character,\n     *   if defined; or -1 to indicate no additional escaping is performed.\n     */\n    public int getHighestEscapedChar() { return 0; }\n\n    /**\n     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     */\n    public CharacterEscapes getCharacterEscapes() { return null; }\n\n    /**\n     * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n     * it creates.\n     *<p>\n     * Default implementation does nothing and simply returns this instance.\n     */\n    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n\n    /**\n     * Method that allows overriding String used for separating root-level\n     * JSON values (default is single space character)\n     *<p>\n     * Default implementation throws {@link UnsupportedOperationException}.\n     * \n     * @param sep Separator to use, if any; null means that no separator is\n     *   automatically added\n     * \n     * @since 2.1\n     */\n    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n        throw new UnsupportedOperationException();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, output state access\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be used to get access to object that is used\n     * as target for generated output; this is usually either\n     * {@link OutputStream} or {@link Writer}, depending on what\n     * generator was constructed with.\n     * Note that returned value may be null in some cases; including\n     * case where implementation does not want to exposed raw\n     * source to caller.\n     * In cases where output has been decorated, object returned here\n     * is the decorated version; this allows some level of interaction\n     * between users of generator and decorator object.\n     *<p>\n     * In general use of this accessor should be considered as\n     * \"last effort\", i.e. only used if no other mechanism is applicable.\n     */\n    public Object getOutputTarget() {\n        return null;\n    }\n\n    /**\n     * Method for verifying amount of content that is buffered by generator\n     * but not yet flushed to the underlying target (stream, writer),\n     * in units (byte, char) that the generator implementation uses for buffering;\n     * or -1 if this information is not available.\n     * Unit used is often the same as the unit of underlying target (that is,\n     * `byte` for {@link java.io.OutputStream}, `char` for {@link java.io.Writer}),\n     * but may differ if buffering is done before encoding.\n     * Default JSON-backed implementations do use matching units.\n     *<p>\n     * Note: non-JSON implementations will be retrofitted for 2.6 and beyond;\n     * please report if you see -1 (missing override)\n     *\n     * @return Amount of content buffered in internal units, if amount known and\n     *    accessible; -1 if not accessible.\n     *\n     * @since 2.6\n     */\n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    /**\n     * Helper method, usually equivalent to:\n     *<code>\n     *   getOutputContext().getCurrentValue();\n     *</code>\n     *<p>\n     * Note that \"current value\" is NOT populated (or used) by Streaming parser;\n     * it is only used by higher-level data-binding functionality.\n     * The reason it is included here is that it can be stored and accessed hierarchically,\n     * and gets passed through data-binding.\n     * \n     * @since 2.5\n     */\n    public Object getCurrentValue() {\n        JsonStreamContext ctxt = getOutputContext();\n        return (ctxt == null) ? null : ctxt.getCurrentValue();\n    }\n\n    /**\n     * Helper method, usually equivalent to:\n     *<code>\n     *   getOutputContext().setCurrentValue(v);\n     *</code>\n     * \n     * @since 2.5\n     */\n    public void setCurrentValue(Object v) {\n        JsonStreamContext ctxt = getOutputContext();\n        if (ctxt != null) {\n            ctxt.setCurrentValue(v);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, capability introspection methods\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to verify that given schema can be used with\n     * this generator (using {@link #setSchema}).\n     * \n     * @param schema Schema to check\n     * \n     * @return True if this generator can use given schema; false if not\n     */\n    public boolean canUseSchema(FormatSchema schema) { return false; }\n    \n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports some kind of Object Ids natively (many do not;\n     * for example, JSON doesn't).\n     * This method <b>must</b> be called prior to calling\n     * {@link #writeObjectId} or {@link #writeObjectRef}.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native Object Ids. Caller is expected to either\n     * use a non-native notation (explicit property or such), or fail,\n     * in case it can not use native object ids.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteObjectId() { return false; }\n\n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports some kind of Type Ids natively (many do not;\n     * for example, JSON doesn't).\n     * This method <b>must</b> be called prior to calling\n     * {@link #writeTypeId}.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native Type Ids. Caller is expected to either\n     * use a non-native notation (explicit property or such), or fail,\n     * in case it can not use native type ids.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteTypeId() { return false; }\n\n    /**\n     * Introspection method that may be called to see if the underlying\n     * data format supports \"native\" binary data; that is, an efficient\n     * output of binary content without encoding.\n     *<p>\n     * Default implementation returns false; overridden by data formats\n     * that do support native binary content.\n     * \n     * @since 2.3\n     */\n    public boolean canWriteBinaryNatively() { return false; }\n    \n    /**\n     * Introspection method to call to check whether it is ok to omit\n     * writing of Object fields or not. Most formats do allow omission,\n     * but certain positional formats (such as CSV) require output of\n     * placeholders, even if no real values are to be emitted.\n     * \n     * @since 2.3\n     */\n    public boolean canOmitFields() { return true; }\n\n    /**\n     * Introspection method to call to check whether it is possible\n     * to write numbers using {@link #writeNumber(java.lang.String)}\n     * using possible custom format, or not. Typically textual formats\n     * allow this (and JSON specifically does), whereas binary formats\n     * do not allow this (except by writing them as Strings).\n     * Usual reason for calling this method is to check whether custom\n     * formatting of numbers may be applied by higher-level code (databinding)\n     * or not.\n     *\n     * @since 2.8\n     */\n    public boolean canWriteFormattedNumbers() { return false; }\n    \n    /*\n    /**********************************************************\n    /* Public API, write methods, structural\n    /**********************************************************\n     */\n\n    /**\n     * Method for writing starting marker of a Array value\n     * (for JSON this is character '['; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Array values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartArray() throws IOException;\n\n    /**\n     * Method for writing start marker of an Array value, similar\n     * to {@link #writeStartArray()}, but also specifying how many\n     * elements will be written for the array before calling\n     * {@link #writeEndArray()}.\n     *<p>\n     * Default implementation simply calls {@link #writeStartArray()}.\n     * \n     * @param size Number of elements this array will have: actual\n     *   number of values written (before matching call to\n     *   {@link #writeEndArray()} MUST match; generator MAY verify\n     *   this is the case.\n     *   \n     * @since 2.4\n     */\n    public void writeStartArray(int size) throws IOException {\n        writeStartArray();\n    }\n    \n    /**\n     * Method for writing closing marker of a JSON Array value\n     * (character ']'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Array.\n     */\n    public abstract void writeEndArray() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     */\n    public abstract void writeStartObject() throws IOException;\n\n    /**\n     * Method for writing starting marker of a JSON Object value\n     * (character '{'; plus possible white space decoration\n     * if pretty-printing is enabled), to represent Java given\n     * as the argument. Argument is offered as metadata, but more\n     * importantly it should be assigned as the \"current value\"\n     * for the Object content that gets constructed and initialized.\n     *<p>\n     * Object values can be written in any context where values\n     * are allowed: meaning everywhere except for when\n     * a field name is expected.\n     *\n     * @since 2.8.\n     */\n    public void writeStartObject(Object forValue) throws IOException\n    {\n        writeStartObject();\n        setCurrentValue(forValue);\n    }\n\n    /**\n     * Method for writing closing marker of a JSON Object value\n     * (character '}'; plus possible white space decoration\n     * if pretty-printing is enabled).\n     *<p>\n     * Marker can be written if the innermost structured type\n     * is Object, and the last written event was either a\n     * complete value, or START-OBJECT marker (see JSON specification\n     * for more details).\n     */\n    public abstract void writeEndObject() throws IOException;\n\n    /**\n     * Method for writing a field name (JSON String surrounded by\n     * double quotes: syntactically identical to a JSON String value),\n     * possibly decorated by white space if pretty-printing is enabled.\n     *<p>\n     * Field names can only be written in Object context (check out\n     * JSON specification for details), when field name is expected\n     * (field names alternate with values).\n     */\n    public abstract void writeFieldName(String name) throws IOException;\n\n    /**\n     * Method similar to {@link #writeFieldName(String)}, main difference\n     * being that it may perform better as some of processing (such as\n     * quoting of certain characters, or encoding into external encoding\n     * if supported by generator) can be done just once and reused for\n     * later calls.\n     *<p>\n     * Default implementation simple uses unprocessed name container in\n     * serialized String; implementations are strongly encouraged to make\n     * use of more efficient methods argument object has.\n     */\n    public abstract void writeFieldName(SerializableString name) throws IOException;\n\n    /**\n     * Alternative to {@link #writeFieldName(String)} that may be used\n     * in cases where property key is of numeric type; either where\n     * underlying format supports such notion (some binary formats do,\n     * unlike JSON), or for convenient conversion into String presentation.\n     * Default implementation will simply convert id into <code>String</code>\n     * and call {@link #writeFieldName(String)}.\n     *\n     * @since 2.8\n     */\n    public void writeFieldId(long id) throws IOException {\n        writeFieldName(Long.toString(id));\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, scalar arrays (2.8)\n    /**********************************************************\n     */\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_INT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(int[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_INT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(long[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /**\n     * Value write method that can be called to write a single\n     * array (sequence of {@link JsonToken#START_ARRAY}, zero or\n     * more {@link JsonToken#VALUE_NUMBER_FLOAT}, {@link JsonToken#END_ARRAY})\n     *\n     * @since 2.8\n     *\n     * @param array Array that contains values to write\n     * @param offset Offset of the first element to write, within array\n     * @param length Number of elements in array to write, from `offset` to `offset + len - 1`\n     */\n    public void writeArray(double[] array, int offset, int length) throws IOException\n    {\n        if (array == null) {\n            throw new IllegalArgumentException(\"null array\");\n        }\n        _verifyOffsets(array.length, offset, length);\n        writeStartArray();\n        for (int i = offset, end = offset+length; i < end; ++i) {\n            writeNumber(array[i]);\n        }\n        writeEndArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, text/String values\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting a String value. Depending on context\n     * this means either array element, (object) field value or\n     * a stand alone String; but in all cases, String will be\n     * surrounded in double quotes, and contents will be properly\n     * escaped as required by JSON specification.\n     */\n    public abstract void writeString(String text) throws IOException;\n\n    /**\n     * Method for outputting a String value. Depending on context\n     * this means either array element, (object) field value or\n     * a stand alone String; but in all cases, String will be\n     * surrounded in double quotes, and contents will be properly\n     * escaped as required by JSON specification.\n     */\n    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)}, but that takes\n     * {@link SerializableString} which can make this potentially\n     * more efficient to call as generator may be able to reuse\n     * quoted and/or encoded representation.\n     *<p>\n     * Default implementation just calls {@link #writeString(String)};\n     * sub-classes should override it with more efficient implementation\n     * if possible.\n     */\n    public abstract void writeString(SerializableString text) throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)} but that takes as\n     * its input a UTF-8 encoded String that is to be output as-is, without additional\n     * escaping (type of which depends on data format; backslashes for JSON).\n     * However, quoting that data format requires (like double-quotes for JSON) will be added\n     * around the value if and as necessary.\n     *<p>\n     * Note that some backends may choose not to support this method: for\n     * example, if underlying destination is a {@link java.io.Writer}\n     * using this method would require UTF-8 decoding.\n     * If so, implementation may instead choose to throw a\n     * {@link UnsupportedOperationException} due to ineffectiveness\n     * of having to decode input.\n     */\n    public abstract void writeRawUTF8String(byte[] text, int offset, int length)\n        throws IOException;\n\n    /**\n     * Method similar to {@link #writeString(String)} but that takes as its input\n     * a UTF-8 encoded String which has <b>not</b> been escaped using whatever\n     * escaping scheme data format requires (for JSON that is backslash-escaping\n     * for control characters and double-quotes; for other formats something else).\n     * This means that textual JSON backends need to check if value needs\n     * JSON escaping, but otherwise can just be copied as is to output.\n     * Also, quoting that data format requires (like double-quotes for JSON) will be added\n     * around the value if and as necessary.\n     *<p>\n     * Note that some backends may choose not to support this method: for\n     * example, if underlying destination is a {@link java.io.Writer}\n     * using this method would require UTF-8 decoding.\n     * In this case\n     * generator implementation may instead choose to throw a\n     * {@link UnsupportedOperationException} due to ineffectiveness\n     * of having to decode input.\n     */\n    public abstract void writeUTF8String(byte[] text, int offset, int length)\n        throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, binary/raw content\n    /**********************************************************\n     */\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(String text) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(String text, int offset, int len) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     */\n    public abstract void writeRaw(char c) throws IOException;\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim with <b>no</b> modifications (including\n     * that no escaping is done and no separators are added even\n     * if context [array, object] would otherwise require such).\n     * If such separators are desired, use\n     * {@link #writeRawValue(String)} instead.\n     *<p>\n     * Note that not all generator implementations necessarily support\n     * such by-pass methods: those that do not will throw\n     * {@link UnsupportedOperationException}.\n     *<p>\n     * The default implementation delegates to {@link #writeRaw(String)};\n     * other backends that support raw inclusion of text are encouraged\n     * to implement it in more efficient manner (especially if they\n     * use UTF-8 encoding).\n     * \n     * @since 2.1\n     */\n    public void writeRaw(SerializableString raw) throws IOException {\n        writeRaw(raw.getValue());\n    }\n\n    /**\n     * Method that will force generator to copy\n     * input text verbatim without any modifications, but assuming\n     * it must constitute a single legal JSON value (number, string,\n     * boolean, null, Array or List). Assuming this, proper separators\n     * are added if and as needed (comma or colon), and generator\n     * state updated to reflect this.\n     */\n    public abstract void writeRawValue(String text) throws IOException;\n\n    public abstract void writeRawValue(String text, int offset, int len) throws IOException;\n\n    public abstract void writeRawValue(char[] text, int offset, int len) throws IOException;\n\n    /**\n     * Method similar to {@link #writeRawValue(String)}, but potentially more\n     * efficient as it may be able to use pre-encoded content (similar to\n     * {@link #writeRaw(SerializableString)}.\n     * \n     * @since 2.5\n     */\n    public void writeRawValue(SerializableString raw) throws IOException {\n        writeRawValue(raw.getValue());\n    }\n\n    /**\n     * Method that will output given chunk of binary data as base64\n     * encoded, as a complete String value (surrounded by double quotes).\n     * This method defaults\n     *<p>\n     * Note: because JSON Strings can not contain unescaped linefeeds,\n     * if linefeeds are included (as per last argument), they must be\n     * escaped. This adds overhead for decoding without improving\n     * readability.\n     * Alternatively if linefeeds are not included,\n     * resulting String value may violate the requirement of base64\n     * RFC which mandates line-length of 76 characters and use of\n     * linefeeds. However, all {@link JsonParser} implementations\n     * are required to accept such \"long line base64\"; as do\n     * typical production-level base64 decoders.\n     *\n     * @param bv Base64 variant to use: defines details such as\n     *   whether padding is used (and if so, using which character);\n     *   what is the maximum line length before adding linefeed,\n     *   and also the underlying alphabet to use.\n     */\n    public abstract void writeBinary(Base64Variant bv,\n            byte[] data, int offset, int len) throws IOException;\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     */\n    public void writeBinary(byte[] data, int offset, int len) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n    }\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n     * assumes that whole byte array is to be output.\n     */\n    public void writeBinary(byte[] data) throws IOException {\n        writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n    }\n\n    /**\n     * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},\n     * but assumes default to using the Jackson default Base64 variant \n     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n     * \n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known. Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may\n     */\n    public int writeBinary(InputStream data, int dataLength)\n        throws IOException {\n        return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n    }\n    \n    /**\n     * Method similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n     * but where input is provided through a stream, allowing for incremental\n     * writes without holding the whole input in memory.\n     * \n     * @param bv Base64 variant to use\n     * @param data InputStream to use for reading binary data to write.\n     *    Will not be closed after successful write operation\n     * @param dataLength (optional) number of bytes that will be available;\n     *    or -1 to be indicate it is not known.\n     *    If a positive length is given, <code>data</code> MUST provide at least\n     *    that many bytes: if not, an exception will be thrown.\n     *    Note that implementations\n     *    need not support cases where length is not known in advance; this\n     *    depends on underlying data format: JSON output does NOT require length,\n     *    other formats may.\n     * \n     * @return Number of bytes read from <code>data</code> and written as binary payload\n     * \n     * @since 2.1\n     */\n    public abstract int writeBinary(Base64Variant bv,\n            InputStream data, int dataLength) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, numeric\n    /**********************************************************\n     */\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     *\n     * @since 2.2\n     */\n    public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(int v) throws IOException;\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(long v) throws IOException;\n\n    /**\n     * Method for outputting given value as JSON number.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(BigInteger v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(double v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(float v) throws IOException;\n\n    /**\n     * Method for outputting indicate JSON numeric value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     *\n     * @param v Number value to write\n     */\n    public abstract void writeNumber(BigDecimal v) throws IOException;\n\n    /**\n     * Write method that can be used for custom numeric types that can\n     * not be (easily?) converted to \"standard\" Java number types.\n     * Because numbers are not surrounded by double quotes, regular\n     * {@link #writeString} method can not be used; nor\n     * {@link #writeRaw} because that does not properly handle\n     * value separators needed in Array or Object contexts.\n     *<p>\n     * Note: because of lack of type safety, some generator\n     * implementations may not be able to implement this\n     * method. For example, if a binary JSON format is used,\n     * it may require type information for encoding; similarly\n     * for generator-wrappers around Java objects or JSON nodes.\n     * If implementation does not implement this method,\n     * it needs to throw {@link UnsupportedOperationException}.\n     * \n     * @throws UnsupportedOperationException If underlying data format does not\n     *   support numbers serialized textually AND if generator is not allowed\n     *   to just output a String instead (Schema-based formats may require actual\n     *   number, for example)\n     */\n    public abstract void writeNumber(String encodedValue) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, other value types\n    /**********************************************************\n     */\n    \n    /**\n     * Method for outputting literal JSON boolean value (one of\n     * Strings 'true' and 'false').\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeBoolean(boolean state) throws IOException;\n\n    /**\n     * Method for outputting literal JSON null value.\n     * Can be called in any context where a value is expected\n     * (Array value, Object field value, root-level value).\n     * Additional white space may be added around the value\n     * if pretty-printing is enabled.\n     */\n    public abstract void writeNull() throws IOException;\n\n    /**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */\n    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        if (object == null) {\n            writeNull();\n            return;\n        }\n        if (object instanceof byte[]) {\n            writeBinary((byte[]) object);\n            return;\n        }\n        throw new JsonGenerationException(\"No native support for writing embedded objects of type \"\n                +object.getClass().getName(),\n                this);\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, write methods, Native Ids (type, object)\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be called to output so-called native Object Id.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteObjectId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     * \n     * @since 2.3\n     */\n    public void writeObjectId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }\n\n    /**\n     * Method that can be called to output references to native Object Ids.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteObjectId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     */\n    public void writeObjectRef(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n    }\n    \n    /**\n     * Method that can be called to output so-called native Type Id.\n     * Note that it may only be called after ensuring this is legal\n     * (with {@link #canWriteTypeId()}), as not all data formats\n     * have native type id support; and some may only allow them in\n     * certain positions or locations.\n     * If output is not allowed by the data format in this position,\n     * a {@link JsonGenerationException} will be thrown.\n     * \n     * @since 2.3\n     */\n    public void writeTypeId(Object id) throws IOException {\n        throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n    }\n\n    // 24-May-2016, tatu: Looks like this won't quite make it in 2.8... too\n    //   many open questions on whether return value may be used and such to\n    //   really close the loop. But leaving code sample in, in case we can resolve it\n    //   it for 2.9.\n\n    /*\n     * Replacement method for {@link #writeTypeId(Object)} which is called\n     * regardless of whether format has native type ids. If it does have native\n     * type ids, those are to be used (if configuration allows this), if not,\n     * structural type id inclusion is to be used. For JSON, for example, no\n     * native type ids exist and structural inclusion is always used.\n     *<p>\n     * NOTE: from databind perspective, only \"as-wrapper-array\", \"as-wrapper-object\" and\n     * \"as-property\" inclusion styles call this method; the remaining \"as-external-property\"\n     * mechanism always uses writes type id value as simple property.\n     *\n     * @param inclStyle Kind of inclusion; {@link JsonToken#START_ARRAY} for \"as-wrapper-array\",\n     *     {@link JsonToken#START_OBJECT} for \"as-wrapper-object\" and {@link JsonToken#FIELD_NAME}\n     *     for \"as-property\"\n     * @param forValue Java object for which type is being written; not used by standard mechanism\n     * @param valueShape Expected shape of the value to write, as expressed by the first token (for\n     *    structural type), or any of scalar types for non-structured values (typically\n     *    just {@link JsonToken#VALUE_STRING} -- exact token not required, just the fact it's scalar)\n     * @param typeId Type id to write\n     * @param propertyName Name of property to use, in case of \"as-property\" inclusion style\n     *\n     * @since 2.8\n     */\n    /*\n    public Object writeTypeSuffix(JsonToken inclStyle, Object forValue, JsonToken valueShape,\n            String typeId, String propertyName) throws IOException\n    {\n        if (inclStyle == JsonToken.FIELD_NAME) { // as-property\n            if (typeId == null) { // should not include `null` type id in any form with this style\n                writeStartObject();\n            } else if (valueShape == JsonToken.START_OBJECT) {\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                    writeStartObject();\n                } else {\n                    writeStartObject();\n                    writeStringField(propertyName, typeId);\n                }\n            } else if (valueShape == JsonToken.START_ARRAY) {\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                    writeStartArray();\n                } else {\n                    writeStartArray();\n                    writeString(typeId);\n                }\n            } else { // any scalar\n                if (canWriteTypeId()) {\n                    writeTypeId(typeId);\n                }\n            }\n            return JsonToken.END_OBJECT;\n        }\n        if (inclStyle == JsonToken.START_ARRAY) { // as-wrapper-array\n        } else if (inclStyle == JsonToken.START_OBJECT) { // as-wrapper-object\n            \n        } else {\n            throw new JsonGenerationException(\"Unrecognized inclusion style: \"+inclStyle, this);\n        }\n    }\n    */\n\n    /*\n    /**********************************************************\n    /* Public API, write methods, serializing Java objects\n    /**********************************************************\n     */\n\n    /**\n     * Method for writing given Java object (POJO) as Json.\n     * Exactly how the object gets written depends on object\n     * in question (ad on codec, its configuration); for most\n     * beans it will result in JSON Object, but for others JSON\n     * Array, or String or numeric value (and for nulls, JSON\n     * null literal.\n     * <b>NOTE</b>: generator must have its <b>object codec</b>\n     * set to non-null value; for generators created by a mapping\n     * factory this is the case, for others not.\n     */\n    public abstract void writeObject(Object pojo) throws IOException;\n\n    /**\n     * Method for writing given JSON tree (expressed as a tree\n     * where given JsonNode is the root) using this generator.\n     * This will generally just call\n     * {@link #writeObject} with given node, but is added\n     * for convenience and to make code more explicit in cases\n     * where it deals specifically with trees.\n     */\n    public abstract void writeTree(TreeNode rootNode) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, convenience field write methods\n    /**********************************************************\n     */\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has a String value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeString(value);\n     *</pre>\n     *<p>\n     * Note: many performance-sensitive implementations override this method\n     */\n    public void writeStringField(String fieldName, String value) throws IOException {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has a boolean value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeBoolean(value);\n     *</pre>\n     */\n    public final void writeBooleanField(String fieldName, boolean value) throws IOException {\n        writeFieldName(fieldName);\n        writeBoolean(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has JSON literal value null. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNull();\n     *</pre>\n     */\n    public final void writeNullField(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeNull();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, int value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, long value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, double value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value. Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, float value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has the specified numeric value.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeNumber(value);\n     *</pre>\n     */\n    public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {\n        writeFieldName(fieldName);\n        writeNumber(value);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that contains specified data in base64-encoded form.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeBinary(value);\n     *</pre>\n     */\n    public final void writeBinaryField(String fieldName, byte[] data) throws IOException {\n        writeFieldName(fieldName);\n        writeBinary(data);\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * (that will contain a JSON Array value), and the START_ARRAY marker.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeStartArray();\n     *</pre>\n     *<p>\n     * Note: caller still has to take care to close the array\n     * (by calling {#link #writeEndArray}) after writing all values\n     * of the value Array.\n     */\n    public final void writeArrayFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartArray();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * (that will contain a JSON Object value), and the START_OBJECT marker.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeStartObject();\n     *</pre>\n     *<p>\n     * Note: caller still has to take care to close the Object\n     * (by calling {#link #writeEndObject}) after writing all\n     * entries of the value Object.\n     */\n    public final void writeObjectFieldStart(String fieldName) throws IOException {\n        writeFieldName(fieldName);\n        writeStartObject();\n    }\n\n    /**\n     * Convenience method for outputting a field entry (\"member\")\n     * that has contents of specific Java object as its value.\n     * Equivalent to:\n     *<pre>\n     *  writeFieldName(fieldName);\n     *  writeObject(pojo);\n     *</pre>\n     */\n    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n        writeFieldName(fieldName);\n        writeObject(pojo);\n    }\n\n    /**\n     * Method called to indicate that a property in this position was\n     * skipped. It is usually only called for generators that return\n     * <code>false</code> from {@link #canOmitFields()}.\n     *<p>\n     * Default implementation does nothing.\n     * \n     * @since 2.3\n     */\n    public void writeOmittedField(String fieldName) throws IOException { }\n    \n    /*\n    /**********************************************************\n    /* Public API, copy-through methods\n    /**********************************************************\n     */\n\n    /**\n     * Method for copying contents of the current event that\n     * the given parser instance points to.\n     * Note that the method <b>will not</b> copy any other events,\n     * such as events contained within JSON Array or Object structures.\n     *<p>\n     * Calling this method will not advance the given\n     * parser, although it may cause parser to internally process\n     * more data (if it lazy loads contents of value events, for example)\n     */\n    public void copyCurrentEvent(JsonParser p) throws IOException\n    {\n        JsonToken t = p.currentToken();\n        // sanity check; what to do?\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        switch (t.id()) {\n        case ID_NOT_AVAILABLE:\n            _reportError(\"No current event to copy\");\n            break; // never gets here\n        case ID_START_OBJECT:\n            writeStartObject();\n            break;\n        case ID_END_OBJECT:\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            break;\n        case ID_END_ARRAY:\n            writeEndArray();\n            break;\n        case ID_FIELD_NAME:\n            writeFieldName(p.getCurrentName());\n            break;\n        case ID_STRING:\n            if (p.hasTextCharacters()) {\n                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n            } else {\n                writeString(p.getText());\n            }\n            break;\n        case ID_NUMBER_INT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.INT) {\n                writeNumber(p.getIntValue());\n            } else if (n == NumberType.BIG_INTEGER) {\n                writeNumber(p.getBigIntegerValue());\n            } else {\n                writeNumber(p.getLongValue());\n            }\n            break;\n        }\n        case ID_NUMBER_FLOAT:\n        {\n            NumberType n = p.getNumberType();\n            if (n == NumberType.BIG_DECIMAL) {\n                writeNumber(p.getDecimalValue());\n            } else if (n == NumberType.FLOAT) {\n                writeNumber(p.getFloatValue());\n            } else {\n                writeNumber(p.getDoubleValue());\n            }\n            break;\n        }\n        case ID_TRUE:\n            writeBoolean(true);\n            break;\n        case ID_FALSE:\n            writeBoolean(false);\n            break;\n        case ID_NULL:\n            writeNull();\n            break;\n        case ID_EMBEDDED_OBJECT:\n            writeObject(p.getEmbeddedObject());\n            break;\n        default:\n            _throwInternal();\n        }\n    }\n\n    /**\n     * Method for copying contents of the current event\n     * <b>and following events that it encloses</b>\n     * the given parser instance points to.\n     *<p>\n     * So what constitutes enclosing? Here is the list of\n     * events that have associated enclosed events that will\n     * get copied:\n     *<ul>\n     * <li>{@link JsonToken#START_OBJECT}:\n     *   all events up to and including matching (closing)\n     *   {@link JsonToken#END_OBJECT} will be copied\n     *  </li>\n     * <li>{@link JsonToken#START_ARRAY}\n     *   all events up to and including matching (closing)\n     *   {@link JsonToken#END_ARRAY} will be copied\n     *  </li>\n     * <li>{@link JsonToken#FIELD_NAME} the logical value (which\n     *   can consist of a single scalar value; or a sequence of related\n     *   events for structured types (JSON Arrays, Objects)) will\n     *   be copied along with the name itself. So essentially the\n     *   whole <b>field entry</b> (name and value) will be copied.\n     *  </li>\n     *</ul>\n     *<p>\n     * After calling this method, parser will point to the\n     * <b>last event</b> that was copied. This will either be\n     * the event parser already pointed to (if there were no\n     * enclosed events), or the last enclosed event copied.\n     */\n    public void copyCurrentStructure(JsonParser p) throws IOException\n    {\n        JsonToken t = p.currentToken();\n        if (t == null) {\n            _reportError(\"No current event to copy\");\n        }\n        // Let's handle field-name separately first\n        int id = t.id();\n        if (id == ID_FIELD_NAME) {\n            writeFieldName(p.getCurrentName());\n            t = p.nextToken();\n            id = t.id();\n            // fall-through to copy the associated value\n        }\n        switch (id) {\n        case ID_START_OBJECT:\n            writeStartObject();\n            while (p.nextToken() != JsonToken.END_OBJECT) {\n                copyCurrentStructure(p);\n            }\n            writeEndObject();\n            break;\n        case ID_START_ARRAY:\n            writeStartArray();\n            while (p.nextToken() != JsonToken.END_ARRAY) {\n                copyCurrentStructure(p);\n            }\n            writeEndArray();\n            break;\n        default:\n            copyCurrentEvent(p);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, context access\n    /**********************************************************\n     */\n\n    /**\n     * @return Context object that can give information about logical\n     *   position within generated json content.\n     */\n    public abstract JsonStreamContext getOutputContext();\n\n    /*\n    /**********************************************************\n    /* Public API, buffer handling\n    /**********************************************************\n     */\n\n    /**\n     * Method called to flush any buffered content to the underlying\n     * target (output stream, writer), and to flush the target itself\n     * as well.\n     */\n    @Override\n    public abstract void flush() throws IOException;\n\n    /**\n     * Method that can be called to determine whether this generator\n     * is closed or not. If it is closed, no more output can be done.\n     */\n    public abstract boolean isClosed();\n\n    /*\n    /**********************************************************\n    /* Closeable implementation\n    /**********************************************************\n     */\n\n    /**\n     * Method called to close this generator, so that no more content\n     * can be written.\n     *<p>\n     * Whether the underlying target (stream, writer) gets closed depends\n     * on whether this generator either manages the target (i.e. is the\n     * only one with access to the target -- case if caller passes a\n     * reference to the resource such as File, but not stream); or\n     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.\n     * If either of above is true, the target is also closed. Otherwise\n     * (not managing, feature not enabled), target is not closed.\n     */\n    @Override\n    public abstract void close() throws IOException;\n\n    /*\n    /**********************************************************\n    /* Helper methods for sub-classes\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used for constructing and throwing\n     * {@link JsonGenerationException} with given base message.\n     *<p>\n     * Note that sub-classes may override this method to add more detail\n     * or use a {@link JsonGenerationException} sub-class.\n     */\n    protected void _reportError(String msg) throws JsonGenerationException {\n        throw new JsonGenerationException(msg, this);\n    }\n\n    protected final void _throwInternal() { VersionUtil.throwInternal(); }\n\n    protected void _reportUnsupportedOperation() {\n        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected final void _verifyOffsets(int arrayLength, int offset, int length)\n    {\n        if ((offset < 0) || (offset + length) > arrayLength) {\n            throw new IllegalArgumentException(String.format(\n                    \"invalid argument(s) (offset=%d, length=%d) for input array of %d element\",\n                    offset, length, arrayLength));\n        }\n    }\n\n    /**\n     * Helper method to try to call appropriate write method for given\n     * untyped Object. At this point, no structural conversions should be done,\n     * only simple basic types are to be coerced as necessary.\n     *\n     * @param value Non-null value to write\n     */\n    protected void _writeSimpleObject(Object value)  throws IOException\n    {\n        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n         *    types even without codec. This can improve interoperability,\n         *    and specifically help with TokenBuffer.\n         */\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        if (value instanceof String) {\n            writeString((String) value);\n            return;\n        }\n        if (value instanceof Number) {\n            Number n = (Number) value;\n            if (n instanceof Integer) {\n                writeNumber(n.intValue());\n                return;\n            } else if (n instanceof Long) {\n                writeNumber(n.longValue());\n                return;\n            } else if (n instanceof Double) {\n                writeNumber(n.doubleValue());\n                return;\n            } else if (n instanceof Float) {\n                writeNumber(n.floatValue());\n                return;\n            } else if (n instanceof Short) {\n                writeNumber(n.shortValue());\n                return;\n            } else if (n instanceof Byte) {\n                writeNumber(n.byteValue());\n                return;\n            } else if (n instanceof BigInteger) {\n                writeNumber((BigInteger) n);\n                return;\n            } else if (n instanceof BigDecimal) {\n                writeNumber((BigDecimal) n);\n                return;\n\n            // then Atomic types\n            } else if (n instanceof AtomicInteger) {\n                writeNumber(((AtomicInteger) n).get());\n                return;\n            } else if (n instanceof AtomicLong) {\n                writeNumber(((AtomicLong) n).get());\n                return;\n            }\n        } else if (value instanceof byte[]) {\n            writeBinary((byte[]) value);\n            return;\n        } else if (value instanceof Boolean) {\n            writeBoolean((Boolean) value);\n            return;\n        } else if (value instanceof AtomicBoolean) {\n            writeBoolean(((AtomicBoolean) value).get());\n            return;\n        }\n        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n                +value.getClass().getName()+\")\");\n    }    \n}\n"}]}
{"project": "JacksonCore", "bug_id": 21, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate", "buggy_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n", "fixed_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n            if (!_includePath) {\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled()) {\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                    // then return null \n                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                        return (_currToken = null);\n                    }\n                }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}]}
{"project": "JacksonCore", "bug_id": 22, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate", "buggy_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                            return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                            return _nextBuffered(buffRoot);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n", "fixed_version": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}]}
{"project": "JacksonCore", "bug_id": 23, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter", "buggy_version": "package com.fasterxml.jackson.core.util;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.SerializedString;\n\n/**\n * Default {@link PrettyPrinter} implementation that uses 2-space\n * indentation with platform-default linefeeds.\n * Usually this class is not instantiated directly, but instead\n * method {@link JsonGenerator#useDefaultPrettyPrinter} is\n * used, which will use an instance of this class for operation.\n */\n@SuppressWarnings(\"serial\")\npublic class DefaultPrettyPrinter\n    implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Constant that specifies default \"root-level\" separator to use between\n     * root values: a single space character.\n     * \n     * @since 2.1\n     */\n    public final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n\n    /**\n     * Interface that defines objects that can produce indentation used\n     * to separate object entries and array values. Indentation in this\n     * context just means insertion of white space, independent of whether\n     * linefeeds are output.\n     */\n    public interface Indenter\n    {\n        void writeIndentation(JsonGenerator g, int level) throws IOException;\n\n        /**\n         * @return True if indenter is considered inline (does not add linefeeds),\n         *   false otherwise\n         */\n        boolean isInline();\n    }\n\n    // // // Config, indentation\n\n    /**\n     * By default, let's use only spaces to separate array values.\n     */\n    protected Indenter _arrayIndenter = FixedSpaceIndenter.instance;\n\n    /**\n     * By default, let's use linefeed-adding indenter for separate\n     * object entries. We'll further configure indenter to use\n     * system-specific linefeeds, and 2 spaces per level (as opposed to,\n     * say, single tabs)\n     */\n    protected Indenter _objectIndenter = DefaultIndenter.SYSTEM_LINEFEED_INSTANCE;\n\n    /**\n     * String printed between root-level values, if any.\n     */\n    protected final SerializableString _rootSeparator;\n\n    // // // Config, other white space configuration\n\n    /**\n     * By default we will add spaces around colons used to\n     * separate object fields and values.\n     * If disabled, will not use spaces around colon.\n     */\n    protected boolean _spacesInObjectEntries = true;\n\n    // // // State:\n\n    /**\n     * Number of open levels of nesting. Used to determine amount of\n     * indentation to use.\n     */\n    protected transient int _nesting;\n\n    /**\n     * @since 2.9\n     */\n    protected Separators _separators;\n\n    /**\n     * @since 2.9\n     */\n    protected String _objectFieldValueSeparatorWithSpaces;\n\n    /*\n    /**********************************************************\n    /* Life-cycle (construct, configure)\n    /**********************************************************\n    */\n\n    public DefaultPrettyPrinter() {\n        this(DEFAULT_ROOT_VALUE_SEPARATOR);\n    }\n\n    /**\n     * Constructor that specifies separator String to use between root values;\n     * if null, no separator is printed.\n     *<p>\n     * Note: simply constructs a {@link SerializedString} out of parameter,\n     * calls {@link #DefaultPrettyPrinter(SerializableString)}\n     * \n     * @param rootSeparator\n     * \n     * @since 2.1\n     */\n    public DefaultPrettyPrinter(String rootSeparator) {\n        this((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n    }\n\n    /**\n     * Constructor that specifies separator String to use between root values;\n     * if null, no separator is printed.\n     * \n     * @param rootSeparator\n     * \n     * @since 2.1\n     */\n    public DefaultPrettyPrinter(SerializableString rootSeparator) {\n        _rootSeparator = rootSeparator;\n        withSeparators(DEFAULT_SEPARATORS);\n    }\n    \n    public DefaultPrettyPrinter(DefaultPrettyPrinter base) {\n        this(base, base._rootSeparator);\n    }\n\n    public DefaultPrettyPrinter(DefaultPrettyPrinter base,\n            SerializableString rootSeparator)\n    {\n        _arrayIndenter = base._arrayIndenter;\n        _objectIndenter = base._objectIndenter;\n        _spacesInObjectEntries = base._spacesInObjectEntries;\n        _nesting = base._nesting;\n\n        _separators = base._separators;\n        _objectFieldValueSeparatorWithSpaces = base._objectFieldValueSeparatorWithSpaces;\n\n        _rootSeparator = rootSeparator;\n    }\n\n    public DefaultPrettyPrinter withRootSeparator(SerializableString rootSeparator)\n    {\n        if (_rootSeparator == rootSeparator ||\n                (rootSeparator != null && rootSeparator.equals(_rootSeparator))) {\n            return this;\n        }\n        return new DefaultPrettyPrinter(this, rootSeparator);\n    }\n\n    /**\n     * @since 2.6\n     */\n    public DefaultPrettyPrinter withRootSeparator(String rootSeparator) {\n        return withRootSeparator((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n    }\n\n    public void indentArraysWith(Indenter i) {\n        _arrayIndenter = (i == null) ? NopIndenter.instance : i;\n    }\n\n    public void indentObjectsWith(Indenter i) {\n        _objectIndenter = (i == null) ? NopIndenter.instance : i;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withArrayIndenter(Indenter i) {\n        if (i == null) {\n            i = NopIndenter.instance;\n        }\n        if (_arrayIndenter == i) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._arrayIndenter = i;\n        return pp;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withObjectIndenter(Indenter i) {\n        if (i == null) {\n            i = NopIndenter.instance;\n        }\n        if (_objectIndenter == i) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._objectIndenter = i;\n        return pp;\n    }\n\n    /**\n     * \"Mutant factory\" method that will return a pretty printer instance\n     * that does use spaces inside object entries; if 'this' instance already\n     * does this, it is returned; if not, a new instance will be constructed\n     * and returned.\n     *\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withSpacesInObjectEntries() {\n        return _withSpaces(true);\n    }\n\n    /**\n     * \"Mutant factory\" method that will return a pretty printer instance\n     * that does not use spaces inside object entries; if 'this' instance already\n     * does this, it is returned; if not, a new instance will be constructed\n     * and returned.\n     *\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withoutSpacesInObjectEntries() {\n        return _withSpaces(false);\n    }\n\n    protected DefaultPrettyPrinter _withSpaces(boolean state)\n    {\n        if (_spacesInObjectEntries == state) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._spacesInObjectEntries = state;\n        return pp;\n    }\n\n    /**\n     * @since 2.9\n     */\n    public DefaultPrettyPrinter withSeparators(Separators separators) {\n        _separators = separators;\n        _objectFieldValueSeparatorWithSpaces = \" \" + separators.getObjectFieldValueSeparator() + \" \";\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Instantiatable impl\n    /**********************************************************\n     */\n\n    @Override\n    public DefaultPrettyPrinter createInstance() {\n        return new DefaultPrettyPrinter(this);\n    }\n\n    /*\n    /**********************************************************\n    /* PrettyPrinter impl\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRootValueSeparator(JsonGenerator g) throws IOException\n    {\n        if (_rootSeparator != null) {\n            g.writeRaw(_rootSeparator);\n        }\n    }\n\n    @Override\n    public void writeStartObject(JsonGenerator g) throws IOException\n    {\n        g.writeRaw('{');\n        if (!_objectIndenter.isInline()) {\n            ++_nesting;\n        }\n    }\n\n    @Override\n    public void beforeObjectEntries(JsonGenerator g) throws IOException\n    {\n        _objectIndenter.writeIndentation(g, _nesting);\n    }\n\n    /**\n     * Method called after an object field has been output, but\n     * before the value is output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * colon to separate the two. Pretty-printer is\n     * to output a colon as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeObjectFieldValueSeparator(JsonGenerator g) throws IOException\n    {\n        if (_spacesInObjectEntries) {\n            g.writeRaw(_objectFieldValueSeparatorWithSpaces);\n        } else {\n            g.writeRaw(_separators.getObjectFieldValueSeparator());\n        }\n    }\n\n    /**\n     * Method called after an object entry (field:value) has been completely\n     * output, and before another value is to be output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * comma to separate the two. Pretty-printer is\n     * to output a comma as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeObjectEntrySeparator(JsonGenerator g) throws IOException\n    {\n        g.writeRaw(_separators.getObjectEntrySeparator());\n        _objectIndenter.writeIndentation(g, _nesting);\n    }\n\n    @Override\n    public void writeEndObject(JsonGenerator g, int nrOfEntries) throws IOException\n    {\n        if (!_objectIndenter.isInline()) {\n            --_nesting;\n        }\n        if (nrOfEntries > 0) {\n            _objectIndenter.writeIndentation(g, _nesting);\n        } else {\n            g.writeRaw(' ');\n        }\n        g.writeRaw('}');\n    }\n\n    @Override\n    public void writeStartArray(JsonGenerator g) throws IOException\n    {\n        if (!_arrayIndenter.isInline()) {\n            ++_nesting;\n        }\n        g.writeRaw('[');\n    }\n\n    @Override\n    public void beforeArrayValues(JsonGenerator g) throws IOException {\n        _arrayIndenter.writeIndentation(g, _nesting);\n    }\n\n    /**\n     * Method called after an array value has been completely\n     * output, and before another value is to be output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * comma to separate the two. Pretty-printer is\n     * to output a comma as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeArrayValueSeparator(JsonGenerator g) throws IOException\n    {\n        g.writeRaw(_separators.getArrayValueSeparator());\n        _arrayIndenter.writeIndentation(g, _nesting);\n    }\n\n    @Override\n    public void writeEndArray(JsonGenerator g, int nrOfValues) throws IOException\n    {\n        if (!_arrayIndenter.isInline()) {\n            --_nesting;\n        }\n        if (nrOfValues > 0) {\n            _arrayIndenter.writeIndentation(g, _nesting);\n        } else {\n            g.writeRaw(' ');\n        }\n        g.writeRaw(']');\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Dummy implementation that adds no indentation whatsoever\n     */\n    public static class NopIndenter\n        implements Indenter, java.io.Serializable\n    {\n        public static final NopIndenter instance = new NopIndenter();\n\n        @Override\n        public void writeIndentation(JsonGenerator g, int level) throws IOException { }\n\n        @Override\n        public boolean isInline() { return true; }\n    }\n\n    /**\n     * This is a very simple indenter that only adds a\n     * single space for indentation. It is used as the default\n     * indenter for array values.\n     */\n    public static class FixedSpaceIndenter extends NopIndenter\n    {\n        public static final FixedSpaceIndenter instance = new FixedSpaceIndenter();\n\n        @Override\n        public void writeIndentation(JsonGenerator g, int level) throws IOException\n        {\n            g.writeRaw(' ');\n        }\n\n        @Override\n        public boolean isInline() { return true; }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.util;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.SerializedString;\n\n/**\n * Default {@link PrettyPrinter} implementation that uses 2-space\n * indentation with platform-default linefeeds.\n * Usually this class is not instantiated directly, but instead\n * method {@link JsonGenerator#useDefaultPrettyPrinter} is\n * used, which will use an instance of this class for operation.\n */\n@SuppressWarnings(\"serial\")\npublic class DefaultPrettyPrinter\n    implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>,\n        java.io.Serializable\n{\n    private static final long serialVersionUID = 1;\n\n    /**\n     * Constant that specifies default \"root-level\" separator to use between\n     * root values: a single space character.\n     * \n     * @since 2.1\n     */\n    public final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n\n    /**\n     * Interface that defines objects that can produce indentation used\n     * to separate object entries and array values. Indentation in this\n     * context just means insertion of white space, independent of whether\n     * linefeeds are output.\n     */\n    public interface Indenter\n    {\n        void writeIndentation(JsonGenerator g, int level) throws IOException;\n\n        /**\n         * @return True if indenter is considered inline (does not add linefeeds),\n         *   false otherwise\n         */\n        boolean isInline();\n    }\n\n    // // // Config, indentation\n\n    /**\n     * By default, let's use only spaces to separate array values.\n     */\n    protected Indenter _arrayIndenter = FixedSpaceIndenter.instance;\n\n    /**\n     * By default, let's use linefeed-adding indenter for separate\n     * object entries. We'll further configure indenter to use\n     * system-specific linefeeds, and 2 spaces per level (as opposed to,\n     * say, single tabs)\n     */\n    protected Indenter _objectIndenter = DefaultIndenter.SYSTEM_LINEFEED_INSTANCE;\n\n    /**\n     * String printed between root-level values, if any.\n     */\n    protected final SerializableString _rootSeparator;\n\n    // // // Config, other white space configuration\n\n    /**\n     * By default we will add spaces around colons used to\n     * separate object fields and values.\n     * If disabled, will not use spaces around colon.\n     */\n    protected boolean _spacesInObjectEntries = true;\n\n    // // // State:\n\n    /**\n     * Number of open levels of nesting. Used to determine amount of\n     * indentation to use.\n     */\n    protected transient int _nesting;\n\n    /**\n     * @since 2.9\n     */\n    protected Separators _separators;\n\n    /**\n     * @since 2.9\n     */\n    protected String _objectFieldValueSeparatorWithSpaces;\n\n    /*\n    /**********************************************************\n    /* Life-cycle (construct, configure)\n    /**********************************************************\n    */\n\n    public DefaultPrettyPrinter() {\n        this(DEFAULT_ROOT_VALUE_SEPARATOR);\n    }\n\n    /**\n     * Constructor that specifies separator String to use between root values;\n     * if null, no separator is printed.\n     *<p>\n     * Note: simply constructs a {@link SerializedString} out of parameter,\n     * calls {@link #DefaultPrettyPrinter(SerializableString)}\n     * \n     * @param rootSeparator\n     * \n     * @since 2.1\n     */\n    public DefaultPrettyPrinter(String rootSeparator) {\n        this((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n    }\n\n    /**\n     * Constructor that specifies separator String to use between root values;\n     * if null, no separator is printed.\n     * \n     * @param rootSeparator\n     * \n     * @since 2.1\n     */\n    public DefaultPrettyPrinter(SerializableString rootSeparator) {\n        _rootSeparator = rootSeparator;\n        withSeparators(DEFAULT_SEPARATORS);\n    }\n    \n    public DefaultPrettyPrinter(DefaultPrettyPrinter base) {\n        this(base, base._rootSeparator);\n    }\n\n    public DefaultPrettyPrinter(DefaultPrettyPrinter base,\n            SerializableString rootSeparator)\n    {\n        _arrayIndenter = base._arrayIndenter;\n        _objectIndenter = base._objectIndenter;\n        _spacesInObjectEntries = base._spacesInObjectEntries;\n        _nesting = base._nesting;\n\n        _separators = base._separators;\n        _objectFieldValueSeparatorWithSpaces = base._objectFieldValueSeparatorWithSpaces;\n\n        _rootSeparator = rootSeparator;\n    }\n\n    public DefaultPrettyPrinter withRootSeparator(SerializableString rootSeparator)\n    {\n        if (_rootSeparator == rootSeparator ||\n                (rootSeparator != null && rootSeparator.equals(_rootSeparator))) {\n            return this;\n        }\n        return new DefaultPrettyPrinter(this, rootSeparator);\n    }\n\n    /**\n     * @since 2.6\n     */\n    public DefaultPrettyPrinter withRootSeparator(String rootSeparator) {\n        return withRootSeparator((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n    }\n\n    public void indentArraysWith(Indenter i) {\n        _arrayIndenter = (i == null) ? NopIndenter.instance : i;\n    }\n\n    public void indentObjectsWith(Indenter i) {\n        _objectIndenter = (i == null) ? NopIndenter.instance : i;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withArrayIndenter(Indenter i) {\n        if (i == null) {\n            i = NopIndenter.instance;\n        }\n        if (_arrayIndenter == i) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._arrayIndenter = i;\n        return pp;\n    }\n\n    /**\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withObjectIndenter(Indenter i) {\n        if (i == null) {\n            i = NopIndenter.instance;\n        }\n        if (_objectIndenter == i) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._objectIndenter = i;\n        return pp;\n    }\n\n    /**\n     * \"Mutant factory\" method that will return a pretty printer instance\n     * that does use spaces inside object entries; if 'this' instance already\n     * does this, it is returned; if not, a new instance will be constructed\n     * and returned.\n     *\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withSpacesInObjectEntries() {\n        return _withSpaces(true);\n    }\n\n    /**\n     * \"Mutant factory\" method that will return a pretty printer instance\n     * that does not use spaces inside object entries; if 'this' instance already\n     * does this, it is returned; if not, a new instance will be constructed\n     * and returned.\n     *\n     * @since 2.3\n     */\n    public DefaultPrettyPrinter withoutSpacesInObjectEntries() {\n        return _withSpaces(false);\n    }\n\n    protected DefaultPrettyPrinter _withSpaces(boolean state)\n    {\n        if (_spacesInObjectEntries == state) {\n            return this;\n        }\n        DefaultPrettyPrinter pp = new DefaultPrettyPrinter(this);\n        pp._spacesInObjectEntries = state;\n        return pp;\n    }\n\n    /**\n     * @since 2.9\n     */\n    public DefaultPrettyPrinter withSeparators(Separators separators) {\n        _separators = separators;\n        _objectFieldValueSeparatorWithSpaces = \" \" + separators.getObjectFieldValueSeparator() + \" \";\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Instantiatable impl\n    /**********************************************************\n     */\n\n    @Override\n    public DefaultPrettyPrinter createInstance() {\n        if (getClass() != DefaultPrettyPrinter.class) { // since 2.10\n            throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName()\n                    +\" does not override method; it has to\");\n        }\n        return new DefaultPrettyPrinter(this);\n    }\n\n    /*\n    /**********************************************************\n    /* PrettyPrinter impl\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRootValueSeparator(JsonGenerator g) throws IOException\n    {\n        if (_rootSeparator != null) {\n            g.writeRaw(_rootSeparator);\n        }\n    }\n\n    @Override\n    public void writeStartObject(JsonGenerator g) throws IOException\n    {\n        g.writeRaw('{');\n        if (!_objectIndenter.isInline()) {\n            ++_nesting;\n        }\n    }\n\n    @Override\n    public void beforeObjectEntries(JsonGenerator g) throws IOException\n    {\n        _objectIndenter.writeIndentation(g, _nesting);\n    }\n\n    /**\n     * Method called after an object field has been output, but\n     * before the value is output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * colon to separate the two. Pretty-printer is\n     * to output a colon as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeObjectFieldValueSeparator(JsonGenerator g) throws IOException\n    {\n        if (_spacesInObjectEntries) {\n            g.writeRaw(_objectFieldValueSeparatorWithSpaces);\n        } else {\n            g.writeRaw(_separators.getObjectFieldValueSeparator());\n        }\n    }\n\n    /**\n     * Method called after an object entry (field:value) has been completely\n     * output, and before another value is to be output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * comma to separate the two. Pretty-printer is\n     * to output a comma as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeObjectEntrySeparator(JsonGenerator g) throws IOException\n    {\n        g.writeRaw(_separators.getObjectEntrySeparator());\n        _objectIndenter.writeIndentation(g, _nesting);\n    }\n\n    @Override\n    public void writeEndObject(JsonGenerator g, int nrOfEntries) throws IOException\n    {\n        if (!_objectIndenter.isInline()) {\n            --_nesting;\n        }\n        if (nrOfEntries > 0) {\n            _objectIndenter.writeIndentation(g, _nesting);\n        } else {\n            g.writeRaw(' ');\n        }\n        g.writeRaw('}');\n    }\n\n    @Override\n    public void writeStartArray(JsonGenerator g) throws IOException\n    {\n        if (!_arrayIndenter.isInline()) {\n            ++_nesting;\n        }\n        g.writeRaw('[');\n    }\n\n    @Override\n    public void beforeArrayValues(JsonGenerator g) throws IOException {\n        _arrayIndenter.writeIndentation(g, _nesting);\n    }\n\n    /**\n     * Method called after an array value has been completely\n     * output, and before another value is to be output.\n     *<p>\n     * Default handling (without pretty-printing) will output a single\n     * comma to separate the two. Pretty-printer is\n     * to output a comma as well, but can surround that with other\n     * (white-space) decoration.\n     */\n    @Override\n    public void writeArrayValueSeparator(JsonGenerator g) throws IOException\n    {\n        g.writeRaw(_separators.getArrayValueSeparator());\n        _arrayIndenter.writeIndentation(g, _nesting);\n    }\n\n    @Override\n    public void writeEndArray(JsonGenerator g, int nrOfValues) throws IOException\n    {\n        if (!_arrayIndenter.isInline()) {\n            --_nesting;\n        }\n        if (nrOfValues > 0) {\n            _arrayIndenter.writeIndentation(g, _nesting);\n        } else {\n            g.writeRaw(' ');\n        }\n        g.writeRaw(']');\n    }\n\n    /*\n    /**********************************************************\n    /* Helper classes\n    /**********************************************************\n     */\n\n    /**\n     * Dummy implementation that adds no indentation whatsoever\n     */\n    public static class NopIndenter\n        implements Indenter, java.io.Serializable\n    {\n        public static final NopIndenter instance = new NopIndenter();\n\n        @Override\n        public void writeIndentation(JsonGenerator g, int level) throws IOException { }\n\n        @Override\n        public boolean isInline() { return true; }\n    }\n\n    /**\n     * This is a very simple indenter that only adds a\n     * single space for indentation. It is used as the default\n     * indenter for array values.\n     */\n    public static class FixedSpaceIndenter extends NopIndenter\n    {\n        public static final FixedSpaceIndenter instance = new FixedSpaceIndenter();\n\n        @Override\n        public void writeIndentation(JsonGenerator g, int level) throws IOException\n        {\n            g.writeRaw(' ');\n        }\n\n        @Override\n        public boolean isInline() { return true; }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 24, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.base.ParserBase", "buggy_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.PackageVersion;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations. Contains most common things that are independent\n * of actual underlying input source.\n */\npublic abstract class ParserBase extends ParserMinimalBase\n{\n    /*\n    /**********************************************************\n    /* Generic I/O state\n    /**********************************************************\n     */\n\n    /**\n     * I/O context for this reader. It handles buffer allocation\n     * for the reader.\n     */\n    final protected IOContext _ioContext;\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    // Note: type of actual buffer depends on sub-class, can't include\n\n    /**\n     * Pointer to next available character in buffer\n     */\n    protected int _inputPtr;\n\n    /**\n     * Index of character after last available one in the buffer.\n     */\n    protected int _inputEnd;\n\n    /*\n    /**********************************************************\n    /* Current input location information\n    /**********************************************************\n     */\n\n    /**\n     * Number of characters/bytes that were contained in previous blocks\n     * (blocks that were already processed prior to the current buffer).\n     */\n    protected long _currInputProcessed;\n\n    /**\n     * Current row location of current point in input buffer, starting\n     * from 1, if available.\n     */\n    protected int _currInputRow = 1;\n\n    /**\n     * Current index of the first character of the current row in input\n     * buffer. Needed to calculate column position, if necessary; benefit\n     * of not having column itself is that this only has to be updated\n     * once per line.\n     */\n    protected int _currInputRowStart;\n\n    /*\n    /**********************************************************\n    /* Information about starting location of event\n    /* Reader is pointing to; updated on-demand\n    /**********************************************************\n     */\n\n    // // // Location info at point when current token was started\n\n    /**\n     * Total number of bytes/characters read before start of current token.\n     * For big (gigabyte-sized) sizes are possible, needs to be long,\n     * unlike pointers and sizes related to in-memory buffers.\n     */\n    protected long _tokenInputTotal;\n\n    /**\n     * Input row on which current token starts, 1-based\n     */\n    protected int _tokenInputRow = 1;\n\n    /**\n     * Column on input row that current token starts; 0-based (although\n     * in the end it'll be converted to 1-based)\n     */\n    protected int _tokenInputCol;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected JsonReadContext _parsingContext;\n    \n    /**\n     * Secondary token related to the next token after current one;\n     * used if its type is known. This may be value token that\n     * follows FIELD_NAME, for example.\n     */\n    protected JsonToken _nextToken;\n\n    /*\n    /**********************************************************\n    /* Buffer(s) for local name(s) and text content\n    /**********************************************************\n     */\n\n    /**\n     * Buffer that contains contents of String values, including\n     * field names if necessary (name split across boundary,\n     * contains escape sequence, or access needed to char array)\n     */\n    protected final TextBuffer _textBuffer;\n\n    /**\n     * Temporary buffer that is needed if field name is accessed\n     * using {@link #getTextCharacters} method (instead of String\n     * returning alternatives)\n     */\n    protected char[] _nameCopyBuffer;\n\n    /**\n     * Flag set to indicate whether the field name is available\n     * from the name copy buffer or not (in addition to its String\n     * representation  being available via read context)\n     */\n    protected boolean _nameCopied;\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    // Numeric value holders: multiple fields used for\n    // for efficiency\n\n    /**\n     * Bitfield that indicates which numeric representations\n     * have been calculated for the current type\n     */\n    protected int _numTypesValid = NR_UNKNOWN;\n\n    // First primitives\n\n    protected int _numberInt;\n\n    protected long _numberLong;\n\n    protected double _numberDouble;\n\n    // And then object types\n\n    protected BigInteger _numberBigInt;\n\n    protected BigDecimal _numberBigDecimal;\n\n    // And then other information about value itself\n\n    /**\n     * Flag that indicates whether numeric value has a negative\n     * value. That is, whether its textual representation starts\n     * with minus character.\n     */\n    protected boolean _numberNegative;\n\n    /**\n     * Length of integer part of the number, in characters\n     */\n    protected int _intLength;\n\n    /**\n     * Length of the fractional part (not including decimal\n     * point or exponent), in characters.\n     * Not used for  pure integer values.\n     */\n    protected int _fractLength;\n\n    /**\n     * Length of the exponent part of the number, if any, not\n     * including 'e' marker or sign, just digits. \n     * Not used for  pure integer values.\n     */\n    protected int _expLength;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserBase(IOContext ctxt, int features) {\n        super(features);\n        _ioContext = ctxt;\n        _textBuffer = ctxt.constructTextBuffer();\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _parsingContext = JsonReadContext.createRootContext(dups);\n    }\n\n    @Override public Version version() { return PackageVersion.VERSION; }\n\n    @Override\n    public Object getCurrentValue() {\n        return _parsingContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _parsingContext.setCurrentValue(v);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for Feature handling\n    /**********************************************************\n     */\n\n    @Override\n    public JsonParser enable(Feature f) {\n        _features |= f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) { // enabling dup detection?\n            if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonParser disable(Feature f) {\n        _features &= ~f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n            _parsingContext = _parsingContext.withDupDetector(null);\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonParser setFeatureMask(int newMask) {\n        int changes = (_features ^ newMask);\n        if (changes != 0) {\n            _features = newMask;\n            _checkStdFeatureChanges(newMask, changes);\n        }\n        return this;\n    }\n\n    @Override // since 2.7\n    public JsonParser overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    /**\n     * Helper method called to verify changes to standard features.\n     *\n     * @param newFeatureFlags Bitflag of standard features after they were changed\n     * @param changedFeatures Bitflag of standard features for which setting\n     *    did change\n     *\n     * @since 2.7\n     */\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n    {\n        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n        \n        if ((changedFeatures & f) != 0) {\n            if ((newFeatureFlags & f) != 0) {\n                if (_parsingContext.getDupDetector() == null) {\n                    _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n                } else { // disabling\n                    _parsingContext = _parsingContext.withDupDetector(null);\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override public String getCurrentName() throws IOException {\n        // [JACKSON-395]: start markers require information from parent\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonReadContext parent = _parsingContext.getParent();\n            if (parent != null) {\n                return parent.getCurrentName();\n            }\n        }\n        return _parsingContext.getCurrentName();\n    }\n\n    @Override public void overrideCurrentName(String name) {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        JsonReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        /* 24-Sep-2013, tatu: Unfortunate, but since we did not expose exceptions,\n         *   need to wrap this here\n         */\n        try {\n            ctxt.setCurrentName(name);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override public void close() throws IOException {\n        if (!_closed) {\n            // 19-Jan-2018, tatu: as per [core#440] need to ensure no more data assumed available\n            _inputPtr = Math.max(_inputPtr, _inputEnd);\n            _closed = true;\n            try {\n                _closeInput();\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override public boolean isClosed() { return _closed; }\n    @Override public JsonReadContext getParsingContext() { return _parsingContext; }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_getSourceReference(),\n                -1L, getTokenCharacterOffset(), // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr, // bytes, chars\n                _currInputRow, col);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text and similar\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasTextCharacters() {\n        if (_currToken == JsonToken.VALUE_STRING) { return true; } // usually true        \n        if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }\n        return false;\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override // since 2.7\n    public byte[] getBinaryValue(Base64Variant variant) throws IOException\n    {\n        if (_binaryValue == null) {\n            if (_currToken != JsonToken.VALUE_STRING) {\n                _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\");\n            }\n            ByteArrayBuilder builder = _getByteArrayBuilder();\n            _decodeBase64(getText(), builder, variant);\n            _binaryValue = builder.toByteArray();\n        }\n        return _binaryValue;\n    }\n\n    /*\n    /**********************************************************\n    /* Public low-level accessors\n    /**********************************************************\n     */\n\n    public long getTokenCharacterOffset() { return _tokenInputTotal; }\n    public int getTokenLineNr() { return _tokenInputRow; }\n    public int getTokenColumnNr() {\n        // note: value of -1 means \"not available\"; otherwise convert from 0-based to 1-based\n        int col = _tokenInputCol;\n        return (col < 0) ? col : (col + 1);\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods for sub-classes to implement\n    /**********************************************************\n     */\n\n    protected abstract void _closeInput() throws IOException;\n    \n    /*\n    /**********************************************************\n    /* Low-level reading, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    protected void _releaseBuffers() throws IOException {\n        _textBuffer.releaseBuffers();\n        char[] buf = _nameCopyBuffer;\n        if (buf != null) {\n            _nameCopyBuffer = null;\n            _ioContext.releaseNameCopyBuffer(buf);\n        }\n    }\n    \n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n            _reportInvalidEOF(String.format(\n                    \": expected close marker for %s (start marker at %s)\",\n                    marker,\n                    _parsingContext.getStartLocation(_getSourceReference())),\n                    null);\n        }\n    }\n\n    /**\n     * @since 2.4\n     */\n    protected final int _eofAsNextChar() throws JsonParseException {\n        _handleEOF();\n        return -1;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: shared/reusable builders\n    /**********************************************************\n     */\n    \n    public ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    /*\n    /**********************************************************\n    /* Methods from former JsonNumericParserBase\n    /**********************************************************\n     */\n\n    // // // Life-cycle of number-parsing\n    \n    protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)\n    {\n        if (fractLen < 1 && expLen < 1) { // integer\n            return resetInt(negative, intLen);\n        }\n        return resetFloat(negative, intLen, fractLen, expLen);\n    }\n        \n    protected final JsonToken resetInt(boolean negative, int intLen)\n    {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = 0;\n        _expLength = 0;\n        _numTypesValid = NR_UNKNOWN; // to force parsing\n        return JsonToken.VALUE_NUMBER_INT;\n    }\n    \n    protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)\n    {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = fractLen;\n        _expLength = expLen;\n        _numTypesValid = NR_UNKNOWN; // to force parsing\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n    \n    protected final JsonToken resetAsNaN(String valueStr, double value)\n    {\n        _textBuffer.resetWithString(valueStr);\n        _numberDouble = value;\n        _numTypesValid = NR_DOUBLE;\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            if ((_numTypesValid & NR_DOUBLE) != 0) {\n                // 10-Mar-2017, tatu: Alas, `Double.isFinite(d)` only added in JDK 8\n                double d = _numberDouble;\n                return Double.isNaN(d) || Double.isInfinite(d);              \n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Numeric accessors of public API\n    /**********************************************************\n     */\n    \n    @Override\n    public Number getNumberValue() throws IOException\n    {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); // will also check event type\n        }\n        // Separate types for int types\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return _numberInt;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return _numberLong;\n            }\n            if ((_numTypesValid & NR_BIGINT) != 0) {\n                return _numberBigInt;\n            }\n            // Shouldn't get this far but if we do\n            return _numberBigDecimal;\n        }\n    \n        /* And then floating point types. But here optimal type\n         * needs to be big decimal, to avoid losing any data?\n         */\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return _numberBigDecimal;\n        }\n        if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check\n            _throwInternal();\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public NumberType getNumberType() throws IOException\n    {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); // will also check event type\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return NumberType.INT;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return NumberType.LONG;\n            }\n            return NumberType.BIG_INTEGER;\n        }\n    \n        /* And then floating point types. Here optimal type\n         * needs to be big decimal, to avoid losing any data?\n         * However... using BD is slow, so let's allow returning\n         * double as type if no explicit call has been made to access\n         * data as BD?\n         */\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return NumberType.BIG_DECIMAL;\n        }\n        return NumberType.DOUBLE;\n    }\n    \n    @Override\n    public int getIntValue() throws IOException\n    {\n        if ((_numTypesValid & NR_INT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n                return _parseIntValue();\n            }\n            if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n                convertNumberToInt(); // let's make it so, if possible\n            }\n        }\n        return _numberInt;\n    }\n    \n    @Override\n    public long getLongValue() throws IOException\n    {\n        if ((_numTypesValid & NR_LONG) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_LONG);\n            }\n            if ((_numTypesValid & NR_LONG) == 0) {\n                convertNumberToLong();\n            }\n        }\n        return _numberLong;\n    }\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGINT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGINT);\n            }\n            if ((_numTypesValid & NR_BIGINT) == 0) {\n                convertNumberToBigInteger();\n            }\n        }\n        return _numberBigInt;\n    }\n    \n    @Override\n    public float getFloatValue() throws IOException\n    {\n        double value = getDoubleValue();\n        /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n         *   here, so let's not bother even trying...\n         */\n        /*\n        if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) {\n            _reportError(\"Numeric value (\"+getText()+\") out of range of Java float\");\n        }\n        */\n        return (float) value;\n    }\n    \n    @Override\n    public double getDoubleValue() throws IOException\n    {\n        if ((_numTypesValid & NR_DOUBLE) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_DOUBLE);\n            }\n            if ((_numTypesValid & NR_DOUBLE) == 0) {\n                convertNumberToDouble();\n            }\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public BigDecimal getDecimalValue() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGDECIMAL);\n            }\n            if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n                convertNumberToBigDecimal();\n            }\n        }\n        return _numberBigDecimal;\n    }\n\n    /*\n    /**********************************************************\n    /* Conversion from textual to numeric representation\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will parse actual numeric value out of a syntactically\n     * valid number value. Type it will parse into depends on whether\n     * it is a floating point number, as well as its magnitude: smallest\n     * legal type (of ones available) is used for efficiency.\n     *\n     * @param expType Numeric type that we will immediately need, if any;\n     *   mostly necessary to optimize handling of floating point numbers\n     */\n    protected void _parseNumericValue(int expType) throws IOException\n    {\n        // Int or float?\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            int len = _intLength;\n            // First: optimization for simple int\n            if (len <= 9) { \n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return;\n            }\n            if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls\n                long l = _textBuffer.contentsAsLong(_numberNegative);\n                // Might still fit in int, need to check\n                if (len == 10) {\n                    if (_numberNegative) {\n                        if (l >= MIN_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    } else {\n                        if (l <= MAX_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    }\n                }\n                _numberLong = l;\n                _numTypesValid = NR_LONG;\n                return;\n            }\n            _parseSlowInt(expType);\n            return;\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            _parseSlowFloat(expType);\n            return;\n        }\n        _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected int _parseIntValue() throws IOException\n    {\n        // Inlined variant of: _parseNumericValue(NR_INT)\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if (_intLength <= 9) {\n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return i;\n            }\n        }\n        // if not optimizable, use more generic\n        _parseNumericValue(NR_INT);\n        if ((_numTypesValid & NR_INT) == 0) {\n            convertNumberToInt();\n        }\n        return _numberInt;\n    }\n\n    private void _parseSlowFloat(int expType) throws IOException\n    {\n        /* Nope: floating point. Here we need to be careful to get\n         * optimal parsing strategy: choice is between accurate but\n         * slow (BigDecimal) and lossy but fast (Double). For now\n         * let's only use BD when explicitly requested -- it can\n         * still be constructed correctly at any point since we do\n         * retain textual representation\n         */\n        try {\n            if (expType == NR_BIGDECIMAL) {\n                _numberBigDecimal = _textBuffer.contentsAsDecimal();\n                _numTypesValid = NR_BIGDECIMAL;\n            } else {\n                // Otherwise double has to do\n                _numberDouble = _textBuffer.contentsAsDouble();\n                _numTypesValid = NR_DOUBLE;\n            }\n        } catch (NumberFormatException nex) {\n            // Can this ever occur? Due to overflow, maybe?\n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex);\n        }\n    }\n\n    private void _parseSlowInt(int expType) throws IOException\n    {\n        String numStr = _textBuffer.contentsAsString();\n        try {\n            int len = _intLength;\n            char[] buf = _textBuffer.getTextBuffer();\n            int offset = _textBuffer.getTextOffset();\n            if (_numberNegative) {\n                ++offset;\n            }\n            // Some long cases still...\n            if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n                // Probably faster to construct a String, call parse, than to use BigInteger\n                _numberLong = Long.parseLong(numStr);\n                _numTypesValid = NR_LONG;\n            } else {\n                // 16-Oct-2018, tatu: Need to catch \"too big\" early due to [jackson-core#488]\n                if ((expType == NR_INT) || (expType == NR_LONG)) {\n                    _reportTooLongIntegral(expType, numStr);\n                }\n                if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                    _numberDouble = NumberInput.parseDouble(numStr);\n                    _numTypesValid = NR_DOUBLE;\n                } else {\n                    // nope, need the heavy guns... (rare case)\n                    _numberBigInt = new BigInteger(numStr);\n                    _numTypesValid = NR_BIGINT;\n                }\n            }\n        } catch (NumberFormatException nex) {\n            // Can this ever occur? Due to overflow, maybe?\n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex);\n        }\n    }\n\n    // @since 2.9.8\n    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n    {\n        final String numDesc = _longIntegerDesc(rawNum);\n        _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n                (expType == NR_LONG) ? \"long\" : \"int\");\n    }\n\n    /*\n    /**********************************************************\n    /* Numeric conversions\n    /**********************************************************\n     */    \n    \n    protected void convertNumberToInt() throws IOException\n    {\n        // First, converting from long ought to be easy\n        if ((_numTypesValid & NR_LONG) != 0) {\n            // Let's verify it's lossless conversion by simple roundtrip\n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }\n    \n    protected void convertNumberToLong() throws IOException\n    {\n        if ((_numTypesValid & NR_INT) != 0) {\n            _numberLong = (long) _numberInt;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_LONG.compareTo(_numberBigInt) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigInt.longValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) {\n                reportOverflowLong();\n            }\n            _numberLong = (long) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigDecimal.longValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_LONG;\n    }\n    \n    protected void convertNumberToBigInteger() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            // here it'll just get truncated, no exceptions thrown\n            _numberBigInt = _numberBigDecimal.toBigInteger();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberInt);\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGINT;\n    }\n    \n    protected void convertNumberToDouble() throws IOException\n    {\n        /* 05-Aug-2008, tatus: Important note: this MUST start with\n         *   more accurate representations, since we don't know which\n         *   value is the original one (others get generated when\n         *   requested)\n         */\n    \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            _numberDouble = _numberBigDecimal.doubleValue();\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberDouble = _numberBigInt.doubleValue();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberDouble = (double) _numberLong;\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberDouble = (double) _numberInt;\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_DOUBLE;\n    }\n    \n    protected void convertNumberToBigDecimal() throws IOException\n    {\n        /* 05-Aug-2008, tatus: Important note: this MUST start with\n         *   more accurate representations, since we don't know which\n         *   value is the original one (others get generated when\n         *   requested)\n         */\n    \n        if ((_numTypesValid & NR_DOUBLE) != 0) {\n            /* Let's actually parse from String representation, to avoid\n             * rounding errors that non-decimal floating operations could incur\n             */\n            _numberBigDecimal = NumberInput.parseBigDecimal(getText());\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberBigDecimal = new BigDecimal(_numberBigInt);\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberInt);\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGDECIMAL;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {\n        JsonReadContext ctxt = getParsingContext();\n        _reportError(String.format(\n                \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\",\n                (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference())));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        // as per [JACKSON-300]\n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        // and [JACKSON-548]\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n\n    /**\n     * Method called to report a problem with unquoted control character.\n     * Note: it is possible to suppress some instances of\n     * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        // JACKSON-208; possible to allow unquoted control chars:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Base64 handling support\n    /**********************************************************\n     */\n\n    /**\n     * Method that sub-classes must implement to support escaped sequences\n     * in base64-encoded sections.\n     * Sub-classes that do not need base64 support can leave this as is\n     */\n    protected char _decodeEscaped() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException\n    {\n        // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        int unescaped = _decodeEscaped();\n        // if white space, skip if first triplet; otherwise errors\n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { // whitespace only allowed to be skipped between triplets\n                return -1;\n            }\n        }\n        // otherwise try to find actual triplet value\n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException\n    {\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        char unescaped = _decodeEscaped();\n        // if white space, skip if first triplet; otherwise errors\n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { // whitespace only allowed to be skipped between triplets\n                return -1;\n            }\n        }\n        // otherwise try to find actual triplet value\n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            // second check since padding can only be 3rd or 4th byte (index #2 or #3)\n            if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException {\n        return reportInvalidBase64Char(b64variant, ch, bindex, null);\n    }\n\n    /**\n     * @param bindex Relative index within base64 character unit; between 0\n     *   and 3 (as unit has exactly 4 characters)\n     */\n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\",\n                    Integer.toHexString(ch), (bindex+1));\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        return new IllegalArgumentException(base);\n    }\n\n    // since 2.9.8\n    protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException\n    {\n        _reportError(b64variant.missingPaddingMessage());\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to encapsulate logic of including (or not) of\n     * \"source reference\" when constructing {@link JsonLocation} instances.\n     *\n     * @since 2.9\n     */\n    protected Object _getSourceReference() {\n        if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {\n            return _ioContext.getSourceReference();\n        }\n        return null;\n    }\n\n    protected static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n    \n    /*\n    /**********************************************************\n    /* Stuff that was abstract and required before 2.8, but that\n    /* is not mandatory in 2.8 or above.\n    /**********************************************************\n     */\n\n    @Deprecated // since 2.8\n    protected void loadMoreGuaranteed() throws IOException {\n        if (!loadMore()) { _reportInvalidEOF(); }\n    }\n\n    @Deprecated // since 2.8\n    protected boolean loadMore() throws IOException { return false; }\n\n    // Can't declare as deprecated, for now, but shouldn't be needed\n    protected void _finishString() throws IOException { }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.json.DupDetector;\nimport com.fasterxml.jackson.core.json.JsonReadContext;\nimport com.fasterxml.jackson.core.json.PackageVersion;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.TextBuffer;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations. Contains most common things that are independent\n * of actual underlying input source.\n */\npublic abstract class ParserBase extends ParserMinimalBase\n{\n    /*\n    /**********************************************************\n    /* Generic I/O state\n    /**********************************************************\n     */\n\n    /**\n     * I/O context for this reader. It handles buffer allocation\n     * for the reader.\n     */\n    final protected IOContext _ioContext;\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    /*\n    /**********************************************************\n    /* Current input data\n    /**********************************************************\n     */\n\n    // Note: type of actual buffer depends on sub-class, can't include\n\n    /**\n     * Pointer to next available character in buffer\n     */\n    protected int _inputPtr;\n\n    /**\n     * Index of character after last available one in the buffer.\n     */\n    protected int _inputEnd;\n\n    /*\n    /**********************************************************\n    /* Current input location information\n    /**********************************************************\n     */\n\n    /**\n     * Number of characters/bytes that were contained in previous blocks\n     * (blocks that were already processed prior to the current buffer).\n     */\n    protected long _currInputProcessed;\n\n    /**\n     * Current row location of current point in input buffer, starting\n     * from 1, if available.\n     */\n    protected int _currInputRow = 1;\n\n    /**\n     * Current index of the first character of the current row in input\n     * buffer. Needed to calculate column position, if necessary; benefit\n     * of not having column itself is that this only has to be updated\n     * once per line.\n     */\n    protected int _currInputRowStart;\n\n    /*\n    /**********************************************************\n    /* Information about starting location of event\n    /* Reader is pointing to; updated on-demand\n    /**********************************************************\n     */\n\n    // // // Location info at point when current token was started\n\n    /**\n     * Total number of bytes/characters read before start of current token.\n     * For big (gigabyte-sized) sizes are possible, needs to be long,\n     * unlike pointers and sizes related to in-memory buffers.\n     */\n    protected long _tokenInputTotal;\n\n    /**\n     * Input row on which current token starts, 1-based\n     */\n    protected int _tokenInputRow = 1;\n\n    /**\n     * Column on input row that current token starts; 0-based (although\n     * in the end it'll be converted to 1-based)\n     */\n    protected int _tokenInputCol;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected JsonReadContext _parsingContext;\n    \n    /**\n     * Secondary token related to the next token after current one;\n     * used if its type is known. This may be value token that\n     * follows FIELD_NAME, for example.\n     */\n    protected JsonToken _nextToken;\n\n    /*\n    /**********************************************************\n    /* Buffer(s) for local name(s) and text content\n    /**********************************************************\n     */\n\n    /**\n     * Buffer that contains contents of String values, including\n     * field names if necessary (name split across boundary,\n     * contains escape sequence, or access needed to char array)\n     */\n    protected final TextBuffer _textBuffer;\n\n    /**\n     * Temporary buffer that is needed if field name is accessed\n     * using {@link #getTextCharacters} method (instead of String\n     * returning alternatives)\n     */\n    protected char[] _nameCopyBuffer;\n\n    /**\n     * Flag set to indicate whether the field name is available\n     * from the name copy buffer or not (in addition to its String\n     * representation  being available via read context)\n     */\n    protected boolean _nameCopied;\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    // Numeric value holders: multiple fields used for\n    // for efficiency\n\n    /**\n     * Bitfield that indicates which numeric representations\n     * have been calculated for the current type\n     */\n    protected int _numTypesValid = NR_UNKNOWN;\n\n    // First primitives\n\n    protected int _numberInt;\n\n    protected long _numberLong;\n\n    protected double _numberDouble;\n\n    // And then object types\n\n    protected BigInteger _numberBigInt;\n\n    protected BigDecimal _numberBigDecimal;\n\n    // And then other information about value itself\n\n    /**\n     * Flag that indicates whether numeric value has a negative\n     * value. That is, whether its textual representation starts\n     * with minus character.\n     */\n    protected boolean _numberNegative;\n\n    /**\n     * Length of integer part of the number, in characters\n     */\n    protected int _intLength;\n\n    /**\n     * Length of the fractional part (not including decimal\n     * point or exponent), in characters.\n     * Not used for  pure integer values.\n     */\n    protected int _fractLength;\n\n    /**\n     * Length of the exponent part of the number, if any, not\n     * including 'e' marker or sign, just digits. \n     * Not used for  pure integer values.\n     */\n    protected int _expLength;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserBase(IOContext ctxt, int features) {\n        super(features);\n        _ioContext = ctxt;\n        _textBuffer = ctxt.constructTextBuffer();\n        DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n                ? DupDetector.rootDetector(this) : null;\n        _parsingContext = JsonReadContext.createRootContext(dups);\n    }\n\n    @Override public Version version() { return PackageVersion.VERSION; }\n\n    @Override\n    public Object getCurrentValue() {\n        return _parsingContext.getCurrentValue();\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        _parsingContext.setCurrentValue(v);\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides for Feature handling\n    /**********************************************************\n     */\n\n    @Override\n    public JsonParser enable(Feature f) {\n        _features |= f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) { // enabling dup detection?\n            if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n            }\n        }\n        return this;\n    }\n\n    @Override\n    public JsonParser disable(Feature f) {\n        _features &= ~f.getMask();\n        if (f == Feature.STRICT_DUPLICATE_DETECTION) {\n            _parsingContext = _parsingContext.withDupDetector(null);\n        }\n        return this;\n    }\n\n    @Override\n    @Deprecated\n    public JsonParser setFeatureMask(int newMask) {\n        int changes = (_features ^ newMask);\n        if (changes != 0) {\n            _features = newMask;\n            _checkStdFeatureChanges(newMask, changes);\n        }\n        return this;\n    }\n\n    @Override // since 2.7\n    public JsonParser overrideStdFeatures(int values, int mask) {\n        int oldState = _features;\n        int newState = (oldState & ~mask) | (values & mask);\n        int changed = oldState ^ newState;\n        if (changed != 0) {\n            _features = newState;\n            _checkStdFeatureChanges(newState, changed);\n        }\n        return this;\n    }\n\n    /**\n     * Helper method called to verify changes to standard features.\n     *\n     * @param newFeatureFlags Bitflag of standard features after they were changed\n     * @param changedFeatures Bitflag of standard features for which setting\n     *    did change\n     *\n     * @since 2.7\n     */\n    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n    {\n        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n        \n        if ((changedFeatures & f) != 0) {\n            if ((newFeatureFlags & f) != 0) {\n                if (_parsingContext.getDupDetector() == null) {\n                    _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n                } else { // disabling\n                    _parsingContext = _parsingContext.withDupDetector(null);\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override public String getCurrentName() throws IOException {\n        // [JACKSON-395]: start markers require information from parent\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonReadContext parent = _parsingContext.getParent();\n            if (parent != null) {\n                return parent.getCurrentName();\n            }\n        }\n        return _parsingContext.getCurrentName();\n    }\n\n    @Override public void overrideCurrentName(String name) {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        JsonReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        /* 24-Sep-2013, tatu: Unfortunate, but since we did not expose exceptions,\n         *   need to wrap this here\n         */\n        try {\n            ctxt.setCurrentName(name);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override public void close() throws IOException {\n        if (!_closed) {\n            // 19-Jan-2018, tatu: as per [core#440] need to ensure no more data assumed available\n            _inputPtr = Math.max(_inputPtr, _inputEnd);\n            _closed = true;\n            try {\n                _closeInput();\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override public boolean isClosed() { return _closed; }\n    @Override public JsonReadContext getParsingContext() { return _parsingContext; }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return new JsonLocation(_getSourceReference(),\n                -1L, getTokenCharacterOffset(), // bytes, chars\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr, // bytes, chars\n                _currInputRow, col);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text and similar\n    /**********************************************************\n     */\n\n    @Override\n    public boolean hasTextCharacters() {\n        if (_currToken == JsonToken.VALUE_STRING) { return true; } // usually true        \n        if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }\n        return false;\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override // since 2.7\n    public byte[] getBinaryValue(Base64Variant variant) throws IOException\n    {\n        if (_binaryValue == null) {\n            if (_currToken != JsonToken.VALUE_STRING) {\n                _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\");\n            }\n            ByteArrayBuilder builder = _getByteArrayBuilder();\n            _decodeBase64(getText(), builder, variant);\n            _binaryValue = builder.toByteArray();\n        }\n        return _binaryValue;\n    }\n\n    /*\n    /**********************************************************\n    /* Public low-level accessors\n    /**********************************************************\n     */\n\n    public long getTokenCharacterOffset() { return _tokenInputTotal; }\n    public int getTokenLineNr() { return _tokenInputRow; }\n    public int getTokenColumnNr() {\n        // note: value of -1 means \"not available\"; otherwise convert from 0-based to 1-based\n        int col = _tokenInputCol;\n        return (col < 0) ? col : (col + 1);\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract methods for sub-classes to implement\n    /**********************************************************\n     */\n\n    protected abstract void _closeInput() throws IOException;\n    \n    /*\n    /**********************************************************\n    /* Low-level reading, other\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    protected void _releaseBuffers() throws IOException {\n        _textBuffer.releaseBuffers();\n        char[] buf = _nameCopyBuffer;\n        if (buf != null) {\n            _nameCopyBuffer = null;\n            _ioContext.releaseNameCopyBuffer(buf);\n        }\n    }\n    \n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException {\n        if (!_parsingContext.inRoot()) {\n            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n            _reportInvalidEOF(String.format(\n                    \": expected close marker for %s (start marker at %s)\",\n                    marker,\n                    _parsingContext.getStartLocation(_getSourceReference())),\n                    null);\n        }\n    }\n\n    /**\n     * @since 2.4\n     */\n    protected final int _eofAsNextChar() throws JsonParseException {\n        _handleEOF();\n        return -1;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: shared/reusable builders\n    /**********************************************************\n     */\n    \n    public ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    /*\n    /**********************************************************\n    /* Methods from former JsonNumericParserBase\n    /**********************************************************\n     */\n\n    // // // Life-cycle of number-parsing\n    \n    protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)\n    {\n        if (fractLen < 1 && expLen < 1) { // integer\n            return resetInt(negative, intLen);\n        }\n        return resetFloat(negative, intLen, fractLen, expLen);\n    }\n        \n    protected final JsonToken resetInt(boolean negative, int intLen)\n    {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = 0;\n        _expLength = 0;\n        _numTypesValid = NR_UNKNOWN; // to force parsing\n        return JsonToken.VALUE_NUMBER_INT;\n    }\n    \n    protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)\n    {\n        _numberNegative = negative;\n        _intLength = intLen;\n        _fractLength = fractLen;\n        _expLength = expLen;\n        _numTypesValid = NR_UNKNOWN; // to force parsing\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n    \n    protected final JsonToken resetAsNaN(String valueStr, double value)\n    {\n        _textBuffer.resetWithString(valueStr);\n        _numberDouble = value;\n        _numTypesValid = NR_DOUBLE;\n        return JsonToken.VALUE_NUMBER_FLOAT;\n    }\n\n    @Override\n    public boolean isNaN() {\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            if ((_numTypesValid & NR_DOUBLE) != 0) {\n                // 10-Mar-2017, tatu: Alas, `Double.isFinite(d)` only added in JDK 8\n                double d = _numberDouble;\n                return Double.isNaN(d) || Double.isInfinite(d);              \n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Numeric accessors of public API\n    /**********************************************************\n     */\n    \n    @Override\n    public Number getNumberValue() throws IOException\n    {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); // will also check event type\n        }\n        // Separate types for int types\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return _numberInt;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return _numberLong;\n            }\n            if ((_numTypesValid & NR_BIGINT) != 0) {\n                return _numberBigInt;\n            }\n            // Shouldn't get this far but if we do\n            return _numberBigDecimal;\n        }\n    \n        /* And then floating point types. But here optimal type\n         * needs to be big decimal, to avoid losing any data?\n         */\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return _numberBigDecimal;\n        }\n        if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check\n            _throwInternal();\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public NumberType getNumberType() throws IOException\n    {\n        if (_numTypesValid == NR_UNKNOWN) {\n            _parseNumericValue(NR_UNKNOWN); // will also check event type\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if ((_numTypesValid & NR_INT) != 0) {\n                return NumberType.INT;\n            }\n            if ((_numTypesValid & NR_LONG) != 0) {\n                return NumberType.LONG;\n            }\n            return NumberType.BIG_INTEGER;\n        }\n    \n        /* And then floating point types. Here optimal type\n         * needs to be big decimal, to avoid losing any data?\n         * However... using BD is slow, so let's allow returning\n         * double as type if no explicit call has been made to access\n         * data as BD?\n         */\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            return NumberType.BIG_DECIMAL;\n        }\n        return NumberType.DOUBLE;\n    }\n    \n    @Override\n    public int getIntValue() throws IOException\n    {\n        if ((_numTypesValid & NR_INT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n                return _parseIntValue();\n            }\n            if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n                convertNumberToInt(); // let's make it so, if possible\n            }\n        }\n        return _numberInt;\n    }\n    \n    @Override\n    public long getLongValue() throws IOException\n    {\n        if ((_numTypesValid & NR_LONG) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_LONG);\n            }\n            if ((_numTypesValid & NR_LONG) == 0) {\n                convertNumberToLong();\n            }\n        }\n        return _numberLong;\n    }\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGINT) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGINT);\n            }\n            if ((_numTypesValid & NR_BIGINT) == 0) {\n                convertNumberToBigInteger();\n            }\n        }\n        return _numberBigInt;\n    }\n    \n    @Override\n    public float getFloatValue() throws IOException\n    {\n        double value = getDoubleValue();\n        /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n         *   here, so let's not bother even trying...\n         */\n        /*\n        if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) {\n            _reportError(\"Numeric value (\"+getText()+\") out of range of Java float\");\n        }\n        */\n        return (float) value;\n    }\n    \n    @Override\n    public double getDoubleValue() throws IOException\n    {\n        if ((_numTypesValid & NR_DOUBLE) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_DOUBLE);\n            }\n            if ((_numTypesValid & NR_DOUBLE) == 0) {\n                convertNumberToDouble();\n            }\n        }\n        return _numberDouble;\n    }\n    \n    @Override\n    public BigDecimal getDecimalValue() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n            if (_numTypesValid == NR_UNKNOWN) {\n                _parseNumericValue(NR_BIGDECIMAL);\n            }\n            if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n                convertNumberToBigDecimal();\n            }\n        }\n        return _numberBigDecimal;\n    }\n\n    /*\n    /**********************************************************\n    /* Conversion from textual to numeric representation\n    /**********************************************************\n     */\n    \n    /**\n     * Method that will parse actual numeric value out of a syntactically\n     * valid number value. Type it will parse into depends on whether\n     * it is a floating point number, as well as its magnitude: smallest\n     * legal type (of ones available) is used for efficiency.\n     *\n     * @param expType Numeric type that we will immediately need, if any;\n     *   mostly necessary to optimize handling of floating point numbers\n     */\n    protected void _parseNumericValue(int expType) throws IOException\n    {\n        // Int or float?\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            int len = _intLength;\n            // First: optimization for simple int\n            if (len <= 9) { \n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return;\n            }\n            if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls\n                long l = _textBuffer.contentsAsLong(_numberNegative);\n                // Might still fit in int, need to check\n                if (len == 10) {\n                    if (_numberNegative) {\n                        if (l >= MIN_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    } else {\n                        if (l <= MAX_INT_L) {\n                            _numberInt = (int) l;\n                            _numTypesValid = NR_INT;\n                            return;\n                        }\n                    }\n                }\n                _numberLong = l;\n                _numTypesValid = NR_LONG;\n                return;\n            }\n            _parseSlowInt(expType);\n            return;\n        }\n        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n            _parseSlowFloat(expType);\n            return;\n        }\n        _reportError(\"Current token (%s) not numeric, can not use numeric value accessors\", _currToken);\n    }\n\n    /**\n     * @since 2.6\n     */\n    protected int _parseIntValue() throws IOException\n    {\n        // Inlined variant of: _parseNumericValue(NR_INT)\n        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n            if (_intLength <= 9) {\n                int i = _textBuffer.contentsAsInt(_numberNegative);\n                _numberInt = i;\n                _numTypesValid = NR_INT;\n                return i;\n            }\n        }\n        // if not optimizable, use more generic\n        _parseNumericValue(NR_INT);\n        if ((_numTypesValid & NR_INT) == 0) {\n            convertNumberToInt();\n        }\n        return _numberInt;\n    }\n\n    private void _parseSlowFloat(int expType) throws IOException\n    {\n        /* Nope: floating point. Here we need to be careful to get\n         * optimal parsing strategy: choice is between accurate but\n         * slow (BigDecimal) and lossy but fast (Double). For now\n         * let's only use BD when explicitly requested -- it can\n         * still be constructed correctly at any point since we do\n         * retain textual representation\n         */\n        try {\n            if (expType == NR_BIGDECIMAL) {\n                _numberBigDecimal = _textBuffer.contentsAsDecimal();\n                _numTypesValid = NR_BIGDECIMAL;\n            } else {\n                // Otherwise double has to do\n                _numberDouble = _textBuffer.contentsAsDouble();\n                _numTypesValid = NR_DOUBLE;\n            }\n        } catch (NumberFormatException nex) {\n            // Can this ever occur? Due to overflow, maybe?\n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(_textBuffer.contentsAsString())+\")\", nex);\n        }\n    }\n\n    private void _parseSlowInt(int expType) throws IOException\n    {\n        String numStr = _textBuffer.contentsAsString();\n        try {\n            int len = _intLength;\n            char[] buf = _textBuffer.getTextBuffer();\n            int offset = _textBuffer.getTextOffset();\n            if (_numberNegative) {\n                ++offset;\n            }\n            // Some long cases still...\n            if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n                // Probably faster to construct a String, call parse, than to use BigInteger\n                _numberLong = Long.parseLong(numStr);\n                _numTypesValid = NR_LONG;\n            } else {\n                // 16-Oct-2018, tatu: Need to catch \"too big\" early due to [jackson-core#488]\n                if ((expType == NR_INT) || (expType == NR_LONG)) {\n                    _reportTooLongIntegral(expType, numStr);\n                }\n                if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                    _numberDouble = NumberInput.parseDouble(numStr);\n                    _numTypesValid = NR_DOUBLE;\n                } else {\n                    // nope, need the heavy guns... (rare case)\n                    _numberBigInt = new BigInteger(numStr);\n                    _numTypesValid = NR_BIGINT;\n                }\n            }\n        } catch (NumberFormatException nex) {\n            // Can this ever occur? Due to overflow, maybe?\n            _wrapError(\"Malformed numeric value (\"+_longNumberDesc(numStr)+\")\", nex);\n        }\n    }\n\n    // @since 2.9.8\n    protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n    {\n        if (expType == NR_INT) {\n            reportOverflowInt(rawNum);\n        } else {\n            reportOverflowLong(rawNum);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Numeric conversions\n    /**********************************************************\n     */    \n    \n    protected void convertNumberToInt() throws IOException\n    {\n        // First, converting from long ought to be easy\n        if ((_numTypesValid & NR_LONG) != 0) {\n            // Let's verify it's lossless conversion by simple roundtrip\n            int result = (int) _numberLong;\n            if (((long) result) != _numberLong) {\n                reportOverflowInt(getText(), currentToken());\n            }\n            _numberInt = result;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigInt.intValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n                reportOverflowInt();\n            }\n            _numberInt = (int) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowInt();\n            }\n            _numberInt = _numberBigDecimal.intValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_INT;\n    }\n    \n    protected void convertNumberToLong() throws IOException\n    {\n        if ((_numTypesValid & NR_INT) != 0) {\n            _numberLong = (long) _numberInt;\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 \n                    || BI_MAX_LONG.compareTo(_numberBigInt) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigInt.longValue();\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            // Need to check boundaries\n            if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) {\n                reportOverflowLong();\n            }\n            _numberLong = (long) _numberDouble;\n        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 \n                || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) {\n                reportOverflowLong();\n            }\n            _numberLong = _numberBigDecimal.longValue();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_LONG;\n    }\n    \n    protected void convertNumberToBigInteger() throws IOException\n    {\n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            // here it'll just get truncated, no exceptions thrown\n            _numberBigInt = _numberBigDecimal.toBigInteger();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigInt = BigInteger.valueOf(_numberInt);\n        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGINT;\n    }\n    \n    protected void convertNumberToDouble() throws IOException\n    {\n        /* 05-Aug-2008, tatus: Important note: this MUST start with\n         *   more accurate representations, since we don't know which\n         *   value is the original one (others get generated when\n         *   requested)\n         */\n    \n        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n            _numberDouble = _numberBigDecimal.doubleValue();\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberDouble = _numberBigInt.doubleValue();\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberDouble = (double) _numberLong;\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberDouble = (double) _numberInt;\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_DOUBLE;\n    }\n    \n    protected void convertNumberToBigDecimal() throws IOException\n    {\n        /* 05-Aug-2008, tatus: Important note: this MUST start with\n         *   more accurate representations, since we don't know which\n         *   value is the original one (others get generated when\n         *   requested)\n         */\n    \n        if ((_numTypesValid & NR_DOUBLE) != 0) {\n            /* Let's actually parse from String representation, to avoid\n             * rounding errors that non-decimal floating operations could incur\n             */\n            _numberBigDecimal = NumberInput.parseBigDecimal(getText());\n        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n            _numberBigDecimal = new BigDecimal(_numberBigInt);\n        } else if ((_numTypesValid & NR_LONG) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberLong);\n        } else if ((_numTypesValid & NR_INT) != 0) {\n            _numberBigDecimal = BigDecimal.valueOf(_numberInt);\n        } else {\n            _throwInternal();\n        }\n        _numTypesValid |= NR_BIGDECIMAL;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {\n        JsonReadContext ctxt = getParsingContext();\n        _reportError(String.format(\n                \"Unexpected close marker '%s': expected '%c' (for %s starting at %s)\",\n                (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference())));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n        // as per [JACKSON-300]\n        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n            return ch;\n        }\n        // and [JACKSON-548]\n        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return ch;\n        }\n        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n        return ch;\n    }\n\n    /**\n     * Method called to report a problem with unquoted control character.\n     * Note: it is possible to suppress some instances of\n     * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n        // JACKSON-208; possible to allow unquoted control chars:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i > INT_SPACE) {\n            char c = (char) i;\n            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n            _reportError(msg);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Base64 handling support\n    /**********************************************************\n     */\n\n    /**\n     * Method that sub-classes must implement to support escaped sequences\n     * in base64-encoded sections.\n     * Sub-classes that do not need base64 support can leave this as is\n     */\n    protected char _decodeEscaped() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException\n    {\n        // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        int unescaped = _decodeEscaped();\n        // if white space, skip if first triplet; otherwise errors\n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { // whitespace only allowed to be skipped between triplets\n                return -1;\n            }\n        }\n        // otherwise try to find actual triplet value\n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException\n    {\n        if (ch != '\\\\') {\n            throw reportInvalidBase64Char(b64variant, ch, index);\n        }\n        char unescaped = _decodeEscaped();\n        // if white space, skip if first triplet; otherwise errors\n        if (unescaped <= INT_SPACE) {\n            if (index == 0) { // whitespace only allowed to be skipped between triplets\n                return -1;\n            }\n        }\n        // otherwise try to find actual triplet value\n        int bits = b64variant.decodeBase64Char(unescaped);\n        if (bits < 0) {\n            // second check since padding can only be 3rd or 4th byte (index #2 or #3)\n            if ((bits != Base64Variant.BASE64_VALUE_PADDING) || (index < 2)) {\n                throw reportInvalidBase64Char(b64variant, unescaped, index);\n            }\n        }\n        return bits;\n    }\n    \n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException {\n        return reportInvalidBase64Char(b64variant, ch, bindex, null);\n    }\n\n    /**\n     * @param bindex Relative index within base64 character unit; between 0\n     *   and 3 (as unit has exactly 4 characters)\n     */\n    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {\n        String base;\n        if (ch <= INT_SPACE) {\n            base = String.format(\"Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units\",\n                    Integer.toHexString(ch), (bindex+1));\n        } else if (b64variant.usesPaddingChar(ch)) {\n            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        } else {\n            base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n        }\n        if (msg != null) {\n            base = base + \": \" + msg;\n        }\n        return new IllegalArgumentException(base);\n    }\n\n    // since 2.9.8\n    protected void _handleBase64MissingPadding(Base64Variant b64variant) throws IOException\n    {\n        _reportError(b64variant.missingPaddingMessage());\n    }\n\n    /*\n    /**********************************************************\n    /* Internal/package methods: other\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to encapsulate logic of including (or not) of\n     * \"source reference\" when constructing {@link JsonLocation} instances.\n     *\n     * @since 2.9\n     */\n    protected Object _getSourceReference() {\n        if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {\n            return _ioContext.getSourceReference();\n        }\n        return null;\n    }\n\n    protected static int[] growArrayBy(int[] arr, int more)\n    {\n        if (arr == null) {\n            return new int[more];\n        }\n        return Arrays.copyOf(arr, arr.length + more);\n    }\n    \n    /*\n    /**********************************************************\n    /* Stuff that was abstract and required before 2.8, but that\n    /* is not mandatory in 2.8 or above.\n    /**********************************************************\n     */\n\n    @Deprecated // since 2.8\n    protected void loadMoreGuaranteed() throws IOException {\n        if (!loadMore()) { _reportInvalidEOF(); }\n    }\n\n    @Deprecated // since 2.8\n    protected boolean loadMore() throws IOException { return false; }\n\n    // Can't declare as deprecated, for now, but shouldn't be needed\n    protected void _finishString() throws IOException { }\n}\n"}, {"class_name": "com.fasterxml.jackson.core.base.ParserMinimalBase", "buggy_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.exc.InputCoercionException;\nimport com.fasterxml.jackson.core.io.JsonEOFException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    // Control chars:\n    protected final static int INT_TAB = '\\t';\n    protected final static int INT_LF = '\\n';\n    protected final static int INT_CR = '\\r';\n    protected final static int INT_SPACE = 0x0020;\n\n    // Markup\n    protected final static int INT_LBRACKET = '[';\n    protected final static int INT_RBRACKET = ']';\n    protected final static int INT_LCURLY = '{';\n    protected final static int INT_RCURLY = '}';\n    protected final static int INT_QUOTE = '\"';\n    protected final static int INT_APOS = '\\'';\n    protected final static int INT_BACKSLASH = '\\\\';\n    protected final static int INT_SLASH = '/';\n    protected final static int INT_ASTERISK = '*';\n    protected final static int INT_COLON = ':';\n    protected final static int INT_COMMA = ',';\n    protected final static int INT_HASH = '#';\n\n    // Number chars\n    protected final static int INT_0 = '0';\n    protected final static int INT_9 = '9';\n    protected final static int INT_MINUS = '-';\n    protected final static int INT_PLUS = '+';\n\n    protected final static int INT_PERIOD = '.';\n    protected final static int INT_e = 'e';\n    protected final static int INT_E = 'E';\n\n    protected final static char CHAR_NULL = '\\0';\n\n    /**\n     * @since 2.9\n     */\n    protected final static byte[] NO_BYTES = new byte[0];\n\n    /**\n     * @since 2.9\n     */\n    protected final static int[] NO_INTS = new int[0];\n    \n    /*\n    /**********************************************************\n    /* Constants and fields of former 'JsonNumericParserBase'\n    /**********************************************************\n     */\n\n    protected final static int NR_UNKNOWN = 0;\n\n    // First, integer types\n\n    protected final static int NR_INT = 0x0001;\n    protected final static int NR_LONG = 0x0002;\n    protected final static int NR_BIGINT = 0x0004;\n\n    // And then floating point types\n\n    protected final static int NR_DOUBLE = 0x008;\n    protected final static int NR_BIGDECIMAL = 0x0010;\n\n    /**\n     * NOTE! Not used by JSON implementation but used by many of binary codecs\n     *\n     * @since 2.9\n     */\n    protected final static int NR_FLOAT = 0x020;\n\n    // Also, we need some numeric constants\n\n    protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\n    protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\n\n    protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n    protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\n    protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\n    protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\n\n    protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\n    protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\n\n    protected final static long MIN_INT_L = (long) Integer.MIN_VALUE;\n    protected final static long MAX_INT_L = (long) Integer.MAX_VALUE;\n\n    // These are not very accurate, but have to do... (for bounds checks)\n\n    protected final static double MIN_LONG_D = (double) Long.MIN_VALUE;\n    protected final static double MAX_LONG_D = (double) Long.MAX_VALUE;\n\n    protected final static double MIN_INT_D = (double) Integer.MIN_VALUE;\n    protected final static double MAX_INT_D = (double) Integer.MAX_VALUE;\n\n    /*\n    /**********************************************************\n    /* Misc other constants\n    /**********************************************************\n     */\n\n    /**\n     * Maximum number of characters to include in token reported\n     * as part of error messages.\n     *\n     * @since 2.9\n     */\n    protected final static int MAX_ERROR_TOKEN_LENGTH = 256;\n\n    /*\n    /**********************************************************\n    /* Minimal generally useful state\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    // NOTE: had base impl in 2.3 and before; but shouldn't\n    // public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Configuration overrides if any\n    /**********************************************************\n     */\n\n    // from base class:\n\n    //public void enableFeature(Feature f)\n    //public void disableFeature(Feature f)\n    //public void setFeature(Feature f, boolean state)\n    //public boolean isFeatureEnabled(Feature f)\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n\n    @Override public JsonToken currentToken() { return _currToken; }\n    @Override public int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    \n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Implementation should be as trivial as follows; only needs to change if\n        // we are to skip other tokens (for example, if comments were exposed as tokens)\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                /* given constraints, above should never return;\n                 * however, FindBugs doesn't know about it and\n                 * complains... so let's add dummy break here\n                 */\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n                // 23-May-2018, tatu: [core#463] Need to consider non-blocking case...\n            } else if (t == JsonToken.NOT_AVAILABLE) {\n                // Nothing much we can do except to either return `null` (which seems wrong),\n                // or, what we actually do, signal error\n                _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\",\n                            getClass().getName());\n            }\n        }\n    }\n\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name);\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base64 decoding\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that can be used for base64 decoding in cases where\n     * encoded content has already been read as a String.\n     */\n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException\n    {\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Coercion helper methods (overridable)\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to determine whether we are currently pointing to\n     * a String value of \"null\" (NOT a null token); and, if so, that parser\n     * is to recognize and return it similar to if it was real null token.\n     * \n     * @since 2.3\n     */\n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n        String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    /**\n     * Method called to throw an exception for input token that looks like a number\n     * based on first character(s), but is not valid according to rules of format.\n     * In case of JSON this also includes invalid forms like positive sign and\n     * leading zeroes.\n     */\n    protected void reportInvalidNumber(String msg) throws JsonParseException {\n        _reportError(\"Invalid numeric value: \"+msg);\n    }\n\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 32-bit range when requested as {@link int}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowInt() throws IOException {\n        reportOverflowInt(getText());\n    }\n\n    // @since 2.10\n    protected void reportOverflowInt(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE));\n    }\n\n    // @since 2.10\n\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 64-bit range when requested as {@link long}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowLong() throws IOException {\n        reportOverflowLong(getText());\n    }\n\n    // @since 2.10\n    protected void reportOverflowLong(String numDesc) throws IOException {\n        _reportError(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE));\n    }\n\n    // @since 2.10\n\n    /**\n     * @since 2.10\n     */\n    protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType)\n            throws InputCoercionException {\n        throw new InputCoercionException(this, msg, inputType, targetType);\n    }\n\n    // @since 2.9.8\n    protected String _longIntegerDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[Integer with %d digits]\", rawLen);\n    }\n\n    // @since 2.9.8\n    protected String _longNumberDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[number with %d characters]\", rawLen);\n    }\n\n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException\n    {\n        if (ch < 0) { // sanity check\n            _reportInvalidEOF();\n        }\n        String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken, _currToken);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException {\n        String msg;\n        if (type == JsonToken.VALUE_STRING) {\n            msg = \" in a String value\";\n        } else if ((type == JsonToken.VALUE_NUMBER_INT)\n                || (type == JsonToken.VALUE_NUMBER_FLOAT)) {\n            msg = \" in a Number value\";\n        } else {\n            msg = \" in a value\";\n        }\n        _reportInvalidEOF(msg, type);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException {\n        throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg);\n    }\n\n    /**\n     * @deprecated Since 2.8 use {@link #_reportInvalidEOF(String, JsonToken)} instead\n     */\n    @Deprecated // since 2.8\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n    \n    /**\n     * @deprecated Since 2.8 use {@link #_reportInvalidEOF(String, JsonToken)} instead\n     */\n    @Deprecated // since 2.8\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg);\n    }\n    \n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting, generic\n    /**********************************************************\n     */\n\n    protected final static String _getCharDesc(int ch)\n    {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    // @since 2.9\n    protected final void _reportError(String msg, Object arg) throws JsonParseException {\n        throw _constructError(String.format(msg, arg));\n    }\n\n    // @since 2.9\n    protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException {\n        throw _constructError(String.format(msg, arg1, arg2));\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(this, msg, t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n\n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { // never occurs\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.base;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.exc.InputCoercionException;\nimport com.fasterxml.jackson.core.io.JsonEOFException;\nimport com.fasterxml.jackson.core.io.NumberInput;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Intermediate base class used by all Jackson {@link JsonParser}\n * implementations, but does not add any additional fields that depend\n * on particular method of obtaining input.\n *<p>\n * Note that 'minimal' here mostly refers to minimal number of fields\n * (size) and functionality that is specific to certain types\n * of parser implementations; but not necessarily to number of methods.\n */\npublic abstract class ParserMinimalBase extends JsonParser\n{\n    // Control chars:\n    protected final static int INT_TAB = '\\t';\n    protected final static int INT_LF = '\\n';\n    protected final static int INT_CR = '\\r';\n    protected final static int INT_SPACE = 0x0020;\n\n    // Markup\n    protected final static int INT_LBRACKET = '[';\n    protected final static int INT_RBRACKET = ']';\n    protected final static int INT_LCURLY = '{';\n    protected final static int INT_RCURLY = '}';\n    protected final static int INT_QUOTE = '\"';\n    protected final static int INT_APOS = '\\'';\n    protected final static int INT_BACKSLASH = '\\\\';\n    protected final static int INT_SLASH = '/';\n    protected final static int INT_ASTERISK = '*';\n    protected final static int INT_COLON = ':';\n    protected final static int INT_COMMA = ',';\n    protected final static int INT_HASH = '#';\n\n    // Number chars\n    protected final static int INT_0 = '0';\n    protected final static int INT_9 = '9';\n    protected final static int INT_MINUS = '-';\n    protected final static int INT_PLUS = '+';\n\n    protected final static int INT_PERIOD = '.';\n    protected final static int INT_e = 'e';\n    protected final static int INT_E = 'E';\n\n    protected final static char CHAR_NULL = '\\0';\n\n    /**\n     * @since 2.9\n     */\n    protected final static byte[] NO_BYTES = new byte[0];\n\n    /**\n     * @since 2.9\n     */\n    protected final static int[] NO_INTS = new int[0];\n    \n    /*\n    /**********************************************************\n    /* Constants and fields of former 'JsonNumericParserBase'\n    /**********************************************************\n     */\n\n    protected final static int NR_UNKNOWN = 0;\n\n    // First, integer types\n\n    protected final static int NR_INT = 0x0001;\n    protected final static int NR_LONG = 0x0002;\n    protected final static int NR_BIGINT = 0x0004;\n\n    // And then floating point types\n\n    protected final static int NR_DOUBLE = 0x008;\n    protected final static int NR_BIGDECIMAL = 0x0010;\n\n    /**\n     * NOTE! Not used by JSON implementation but used by many of binary codecs\n     *\n     * @since 2.9\n     */\n    protected final static int NR_FLOAT = 0x020;\n\n    // Also, we need some numeric constants\n\n    protected final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\n    protected final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\n\n    protected final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n    protected final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\n    protected final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\n    protected final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\n\n    protected final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\n    protected final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\n\n    protected final static long MIN_INT_L = (long) Integer.MIN_VALUE;\n    protected final static long MAX_INT_L = (long) Integer.MAX_VALUE;\n\n    // These are not very accurate, but have to do... (for bounds checks)\n\n    protected final static double MIN_LONG_D = (double) Long.MIN_VALUE;\n    protected final static double MAX_LONG_D = (double) Long.MAX_VALUE;\n\n    protected final static double MIN_INT_D = (double) Integer.MIN_VALUE;\n    protected final static double MAX_INT_D = (double) Integer.MAX_VALUE;\n\n    /*\n    /**********************************************************\n    /* Misc other constants\n    /**********************************************************\n     */\n\n    /**\n     * Maximum number of characters to include in token reported\n     * as part of error messages.\n     *\n     * @since 2.9\n     */\n    protected final static int MAX_ERROR_TOKEN_LENGTH = 256;\n\n    /*\n    /**********************************************************\n    /* Minimal generally useful state\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    protected ParserMinimalBase() { }\n    protected ParserMinimalBase(int features) { super(features); }\n\n    // NOTE: had base impl in 2.3 and before; but shouldn't\n    // public abstract Version version();\n\n    /*\n    /**********************************************************\n    /* Configuration overrides if any\n    /**********************************************************\n     */\n\n    // from base class:\n\n    //public void enableFeature(Feature f)\n    //public void disableFeature(Feature f)\n    //public void setFeature(Feature f, boolean state)\n    //public boolean isFeatureEnabled(Feature f)\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n\n    @Override public abstract JsonToken nextToken() throws IOException;\n\n    @Override public JsonToken currentToken() { return _currToken; }\n    @Override public int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    \n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n    \n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Implementation should be as trivial as follows; only needs to change if\n        // we are to skip other tokens (for example, if comments were exposed as tokens)\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if (_currToken != JsonToken.START_OBJECT\n            && _currToken != JsonToken.START_ARRAY) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) {\n                _handleEOF();\n                /* given constraints, above should never return;\n                 * however, FindBugs doesn't know about it and\n                 * complains... so let's add dummy break here\n                 */\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n                // 23-May-2018, tatu: [core#463] Need to consider non-blocking case...\n            } else if (t == JsonToken.NOT_AVAILABLE) {\n                // Nothing much we can do except to either return `null` (which seems wrong),\n                // or, what we actually do, signal error\n                _reportError(\"Not enough content available for `skipChildren()`: non-blocking parser? (%s)\",\n                            getClass().getName());\n            }\n        }\n    }\n\n    /**\n     * Method sub-classes need to implement\n     */\n    protected abstract void _handleEOF() throws JsonParseException;\n\n    //public JsonToken getCurrentToken()\n    //public boolean hasCurrentToken()\n\n    @Override public abstract String getCurrentName() throws IOException;\n    @Override public abstract void close() throws IOException;\n    @Override public abstract boolean isClosed();\n\n    @Override public abstract JsonStreamContext getParsingContext();\n\n//    public abstract JsonLocation getTokenLocation();\n\n//   public abstract JsonLocation getCurrentLocation();\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override public abstract void overrideCurrentName(String name);\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public abstract String getText() throws IOException;\n    @Override public abstract char[] getTextCharacters() throws IOException;\n    @Override public abstract boolean hasTextCharacters();\n    @Override public abstract int getTextLength() throws IOException;\n    @Override public abstract int getTextOffset() throws IOException;  \n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n\n    /*\n    /**********************************************************\n    /* Public API, access with conversion/coercion\n    /**********************************************************\n     */\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText().trim();\n                if (\"true\".equals(str)) {\n                    return true;\n                }\n                if (\"false\".equals(str)) {\n                    return false;\n                }\n                if (_hasTextualNull(str)) {\n                    return false;\n                }\n                break;\n            case ID_NUMBER_INT:\n                return getIntValue() != 0;\n            case ID_TRUE:\n                return true;\n            case ID_FALSE:\n            case ID_NULL:\n                return false;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Boolean) {\n                    return (Boolean) value;\n                }\n                break;\n            default:\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public int getValueAsInt() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        return getValueAsInt(0);\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getIntValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0;\n                }\n                return NumberInput.parseAsInt(str, defaultValue);\n            case ID_TRUE:\n                return 1;\n            case ID_FALSE:\n                return 0;\n            case ID_NULL:\n                return 0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).intValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public long getValueAsLong() throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        return getValueAsLong(0L);\n    }\n    \n    @Override\n    public long getValueAsLong(long defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n            return getLongValue();\n        }\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsLong(str, defaultValue);\n            case ID_TRUE:\n                return 1L;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0L;\n            case ID_EMBEDDED_OBJECT:\n                Object value = getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).longValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t != null) {\n            switch (t.id()) {\n            case ID_STRING:\n                String str = getText();\n                if (_hasTextualNull(str)) {\n                    return 0L;\n                }\n                return NumberInput.parseAsDouble(str, defaultValue);\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return getDoubleValue();\n            case ID_TRUE:\n                return 1.0;\n            case ID_FALSE:\n            case ID_NULL:\n                return 0.0;\n            case ID_EMBEDDED_OBJECT:\n                Object value = this.getEmbeddedObject();\n                if (value instanceof Number) {\n                    return ((Number) value).doubleValue();\n                }\n            }\n        }\n        return defaultValue;\n    }\n\n    @Override\n    public String getValueAsString() throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return getValueAsString(null);\n    }\n    \n    @Override\n    public String getValueAsString(String defaultValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            return getText();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n            return defaultValue;\n        }\n        return getText();\n    }\n    \n    /*\n    /**********************************************************\n    /* Base64 decoding\n    /**********************************************************\n     */\n\n    /**\n     * Helper method that can be used for base64 decoding in cases where\n     * encoded content has already been read as a String.\n     */\n    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException\n    {\n        try {\n            b64variant.decode(str, builder);\n        } catch (IllegalArgumentException e) {\n            _reportError(e.getMessage());\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Coercion helper methods (overridable)\n    /**********************************************************\n     */\n\n    /**\n     * Helper method used to determine whether we are currently pointing to\n     * a String value of \"null\" (NOT a null token); and, if so, that parser\n     * is to recognize and return it similar to if it was real null token.\n     * \n     * @since 2.3\n     */\n    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n        String msg = String.format(\"Unexpected character (%s) in numeric value\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    /**\n     * Method called to throw an exception for input token that looks like a number\n     * based on first character(s), but is not valid according to rules of format.\n     * In case of JSON this also includes invalid forms like positive sign and\n     * leading zeroes.\n     */\n    protected void reportInvalidNumber(String msg) throws JsonParseException {\n        _reportError(\"Invalid numeric value: \"+msg);\n    }\n\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 32-bit range when requested as {@link int}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowInt() throws IOException {\n        reportOverflowInt(getText());\n    }\n\n    // @since 2.10\n    protected void reportOverflowInt(String numDesc) throws IOException {\n        reportOverflowInt(numDesc, JsonToken.VALUE_NUMBER_INT);\n    }\n\n    // @since 2.10\n    protected void reportOverflowInt(String numDesc, JsonToken inputType) throws IOException {\n        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of int (%d - %s)\",\n                _longIntegerDesc(numDesc), Integer.MIN_VALUE, Integer.MAX_VALUE),\n                inputType, Integer.TYPE);\n    }\n\n    /**\n     * Method called to throw an exception for integral (not floating point) input\n     * token with value outside of Java signed 64-bit range when requested as {@link long}.\n     * Result will be {@link InputCoercionException} being thrown.\n     */\n    protected void reportOverflowLong() throws IOException {\n        reportOverflowLong(getText());\n    }\n\n    // @since 2.10\n    protected void reportOverflowLong(String numDesc) throws IOException {\n        reportOverflowLong(numDesc, JsonToken.VALUE_NUMBER_INT);\n    }\n\n    // @since 2.10\n    protected void reportOverflowLong(String numDesc, JsonToken inputType) throws IOException {\n        _reportInputCoercion(String.format(\"Numeric value (%s) out of range of long (%d - %s)\",\n                _longIntegerDesc(numDesc), Long.MIN_VALUE, Long.MAX_VALUE),\n                inputType, Long.TYPE);\n    }\n\n    /**\n     * @since 2.10\n     */\n    protected void _reportInputCoercion(String msg, JsonToken inputType, Class<?> targetType)\n            throws InputCoercionException {\n        throw new InputCoercionException(this, msg, inputType, targetType);\n    }\n\n    // @since 2.9.8\n    protected String _longIntegerDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[Integer with %d digits]\", rawLen);\n    }\n\n    // @since 2.9.8\n    protected String _longNumberDesc(String rawNum) {\n        int rawLen = rawNum.length();\n        if (rawLen < 1000) {\n            return rawNum;\n        }\n        if (rawNum.startsWith(\"-\")) {\n            rawLen -= 1;\n        }\n        return String.format(\"[number with %d characters]\", rawLen);\n    }\n\n    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException\n    {\n        if (ch < 0) { // sanity check\n            _reportInvalidEOF();\n        }\n        String msg = String.format(\"Unexpected character (%s)\", _getCharDesc(ch));\n        if (comment != null) {\n            msg += \": \"+comment;\n        }\n        _reportError(msg);\n    }\n\n    protected void _reportInvalidEOF() throws JsonParseException {\n        _reportInvalidEOF(\" in \"+_currToken, _currToken);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected void _reportInvalidEOFInValue(JsonToken type) throws JsonParseException {\n        String msg;\n        if (type == JsonToken.VALUE_STRING) {\n            msg = \" in a String value\";\n        } else if ((type == JsonToken.VALUE_NUMBER_INT)\n                || (type == JsonToken.VALUE_NUMBER_FLOAT)) {\n            msg = \" in a Number value\";\n        } else {\n            msg = \" in a value\";\n        }\n        _reportInvalidEOF(msg, type);\n    }\n\n    /**\n     * @since 2.8\n     */\n    protected void _reportInvalidEOF(String msg, JsonToken currToken) throws JsonParseException {\n        throw new JsonEOFException(this, currToken, \"Unexpected end-of-input\"+msg);\n    }\n\n    /**\n     * @deprecated Since 2.8 use {@link #_reportInvalidEOF(String, JsonToken)} instead\n     */\n    @Deprecated // since 2.8\n    protected void _reportInvalidEOFInValue() throws JsonParseException {\n        _reportInvalidEOF(\" in a value\");\n    }\n    \n    /**\n     * @deprecated Since 2.8 use {@link #_reportInvalidEOF(String, JsonToken)} instead\n     */\n    @Deprecated // since 2.8\n    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n        throw new JsonEOFException(this, null, \"Unexpected end-of-input\"+msg);\n    }\n    \n    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n    }\n    \n    protected void _throwInvalidSpace(int i) throws JsonParseException {\n        char c = (char) i;\n        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n        _reportError(msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting, generic\n    /**********************************************************\n     */\n\n    protected final static String _getCharDesc(int ch)\n    {\n        char c = (char) ch;\n        if (Character.isISOControl(c)) {\n            return \"(CTRL-CHAR, code \"+ch+\")\";\n        }\n        if (ch > 255) {\n            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n        }\n        return \"'\"+c+\"' (code \"+ch+\")\";\n    }\n\n    protected final void _reportError(String msg) throws JsonParseException {\n        throw _constructError(msg);\n    }\n\n    // @since 2.9\n    protected final void _reportError(String msg, Object arg) throws JsonParseException {\n        throw _constructError(String.format(msg, arg));\n    }\n\n    // @since 2.9\n    protected final void _reportError(String msg, Object arg1, Object arg2) throws JsonParseException {\n        throw _constructError(String.format(msg, arg1, arg2));\n    }\n\n    protected final void _wrapError(String msg, Throwable t) throws JsonParseException {\n        throw _constructError(msg, t);\n    }\n\n    protected final void _throwInternal() {\n        VersionUtil.throwInternal();\n    }\n\n    protected final JsonParseException _constructError(String msg, Throwable t) {\n        return new JsonParseException(this, msg, t);\n    }\n\n    protected static byte[] _asciiBytes(String str) {\n        byte[] b = new byte[str.length()];\n        for (int i = 0, len = str.length(); i < len; ++i) {\n            b[i] = (byte) str.charAt(i);\n        }\n        return b;\n    }\n\n    protected static String _ascii(byte[] b) {\n        try {\n            return new String(b, \"US-ASCII\");\n        } catch (IOException e) { // never occurs\n            throw new RuntimeException(e);\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 25, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}]}
{"project": "JacksonCore", "bug_id": 26, "classes_modified": [{"class_name": "com.fasterxml.jackson.core.json.async.NonBlockingJsonParser", "buggy_version": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}\n", "fixed_version": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}\n"}]}
