{"project": "Csv", "bug_id": 1, "classes_modified": [{"class_name": "org.apache.commons.csv.ExtendedBufferedReader", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * ExtendedBufferedReader\n *\n * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                char ch = buf[i];\n                if (ch == '\\n') {\n                    if ('\\r' != (i > 0 ? buf[i-1]: lastChar)) {\n                        lineCounter++;                        \n                    }\n                } else if (ch == '\\r') {\n                    lineCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n        \n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).\n     * This method should only be called when processing a comment, otherwise\n     * information can be lost.\n     * <p>\n     * Increments  {@link #lineCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, \n     * otherwise to last character on the line (won't be CR or LF) \n     * \n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        String line = super.readLine();\n\n        if (line != null) {\n            if (line.length() > 0) {\n                lastChar = line.charAt(line.length() - 1);\n            }\n            lineCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So\n     * the next call to {@link #read()} will still return this value.\n     * \n     * @return the next character\n     * \n     * @throws IOException if there is an error in reading\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber() {\n        return lineCounter;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\n\n/**\n * ExtendedBufferedReader\n *\n * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n                char ch = buf[i];\n                if (ch == '\\n') {\n                    if ('\\r' != (i > 0 ? buf[i-1]: lastChar)) {\n                        lineCounter++;                        \n                    }\n                } else if (ch == '\\r') {\n                    lineCounter++;\n                }\n            }\n\n            lastChar = buf[offset + len - 1];\n\n        } else if (len == -1) {\n            lastChar = END_OF_STREAM;\n        }\n        \n        return len;\n    }\n\n    /**\n     * Calls {@link BufferedReader#readLine()} which drops the line terminator(s).\n     * This method should only be called when processing a comment, otherwise\n     * information can be lost.\n     * <p>\n     * Increments  {@link #lineCounter}\n     * <p>\n     * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, \n     * otherwise to last character on the line (won't be CR or LF) \n     * \n     * @return the line that was read, or null if reached EOF.\n     */\n    @Override\n    public String readLine() throws IOException {\n        String line = super.readLine();\n\n        if (line != null) {\n            if (line.length() > 0) {\n                lastChar = line.charAt(line.length() - 1);\n            }\n            lineCounter++;\n        } else {\n            lastChar = END_OF_STREAM;\n        }\n\n        return line;\n    }\n\n    /**\n     * Returns the next character in the current reader without consuming it. So\n     * the next call to {@link #read()} will still return this value.\n     * \n     * @return the next character\n     * \n     * @throws IOException if there is an error in reading\n     */\n    int lookAhead() throws IOException {\n        super.mark(1);\n        int c = super.read();\n        super.reset();\n\n        return c;\n    }\n\n    /**\n     * Returns the nof line read\n     *\n     * @return the current-line-number (or -1)\n     */\n    int getLineNumber() {\n        return lineCounter;\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 2, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVRecord", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n            return index != null ? values[index.intValue()] : null;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     * @see CSVParserTest#org.apache.commons.csv.CSVParserTest.testMappedButNotSetAsOutlook2007ContactExport()\n     */\n    public boolean isConsistent() {\n        return mapping == null ? true : mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null ? mapping.containsKey(name) : false;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped.\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return Arrays.asList(values).iterator();\n    }\n\n    String[] values() {\n        return values;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    /** The values of the record */\n    private final String[] values;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, or {@code null} if the column name is not found\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if the record is inconsistent\n     * @see #isConsistent()\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        try {\n            return index != null ? values[index.intValue()] : null;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\n                            \"Index for header '%s' is %d but CSVRecord only has %d values!\",\n                            name, index.intValue(), values.length));\n        }\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     * @see CSVParserTest#org.apache.commons.csv.CSVParserTest.testMappedButNotSetAsOutlook2007ContactExport()\n     */\n    public boolean isConsistent() {\n        return mapping == null ? true : mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null ? mapping.containsKey(name) : false;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped.\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return Arrays.asList(values).iterator();\n    }\n\n    String[] values() {\n        return values;\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n}\n"}]}
{"project": "Csv", "bug_id": 3, "classes_modified": [{"class_name": "org.apache.commons.csv.Lexer", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.IOException;\n\n/**\n * Abstract lexer class; contains common utility routines shared by lexers\n *\n * @version $Id$\n */\nabstract class Lexer {\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commmentStart;\n\n    final boolean ignoreSurroundingSpaces;\n    final boolean ignoreEmptyLines;\n\n    final CSVFormat format;\n\n    /** The input stream */\n    final ExtendedBufferedReader in;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n        this.format = format;\n        this.in = in;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscape());\n        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n        this.commmentStart = mapNullToDisabled(format.getCommentStart());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    private final char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    long getLineNumber() {\n        return in.getLineNumber();\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n                return c;\n            // indicate unexpected char - available from in.getLastChar()\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int c) throws IOException {\n        // check if we have \\r\\n...\n        if (c == CR && in.lookAhead() == LF) {\n            // note: does not change c outside of this method!\n            c = in.read();\n        }\n        return c == LF || c == CR;\n    }\n\n    abstract Token nextToken(Token reusableToken) throws IOException;\n\n    /**\n     * @return true if the given char is a whitespace character\n     */\n    boolean isWhitespace(final int c) {\n        return c != format.getDelimiter() && Character.isWhitespace((char) c);\n    }\n\n    /**\n     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param c the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int c) {\n        return c == LF || c == CR || c == UNDEFINED;\n    }\n\n    /**\n     * @return true if the given character indicates end of file\n     */\n    boolean isEndOfFile(final int c) {\n        return c == END_OF_STREAM;\n    }\n\n    boolean isDelimiter(final int c) {\n        return c == delimiter;\n    }\n\n    boolean isEscape(final int c) {\n        return c == escape;\n    }\n\n    boolean isQuoteChar(final int c) {\n        return c == quoteChar;\n    }\n\n    boolean isCommentStart(final int c) {\n        return c == commmentStart;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSPACE;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.END_OF_STREAM;\nimport static org.apache.commons.csv.Constants.FF;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\nimport static org.apache.commons.csv.Constants.UNDEFINED;\n\nimport java.io.IOException;\n\n/**\n * Abstract lexer class; contains common utility routines shared by lexers\n *\n * @version $Id$\n */\nabstract class Lexer {\n\n    /**\n     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n     * chars (using surrogates) and thus there should never be a collision with a real text char.\n     */\n    private static final char DISABLED = '\\ufffe';\n\n    private final char delimiter;\n    private final char escape;\n    private final char quoteChar;\n    private final char commmentStart;\n\n    final boolean ignoreSurroundingSpaces;\n    final boolean ignoreEmptyLines;\n\n    final CSVFormat format;\n\n    /** The input stream */\n    final ExtendedBufferedReader in;\n\n    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n        this.format = format;\n        this.in = in;\n        this.delimiter = format.getDelimiter();\n        this.escape = mapNullToDisabled(format.getEscape());\n        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n        this.commmentStart = mapNullToDisabled(format.getCommentStart());\n        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n    }\n\n    private final char mapNullToDisabled(final Character c) {\n        return c == null ? DISABLED : c.charValue();\n    }\n\n    long getLineNumber() {\n        return in.getLineNumber();\n    }\n\n    // TODO escape handling needs more work\n    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n            if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) {\n                return c;\n            }\n            // indicate unexpected char - available from in.getLastChar()\n            return END_OF_STREAM;\n        }\n    }\n\n    void trimTrailingSpaces(final StringBuilder buffer) {\n        int length = buffer.length();\n        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n            length = length - 1;\n        }\n        if (length != buffer.length()) {\n            buffer.setLength(length);\n        }\n    }\n\n    /**\n     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator\n     */\n    boolean readEndOfLine(int c) throws IOException {\n        // check if we have \\r\\n...\n        if (c == CR && in.lookAhead() == LF) {\n            // note: does not change c outside of this method!\n            c = in.read();\n        }\n        return c == LF || c == CR;\n    }\n\n    abstract Token nextToken(Token reusableToken) throws IOException;\n\n    /**\n     * @return true if the given char is a whitespace character\n     */\n    boolean isWhitespace(final int c) {\n        return c != format.getDelimiter() && Character.isWhitespace((char) c);\n    }\n\n    /**\n     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param c the character to check\n     * @return true if the character is at the start of a line.\n     */\n    boolean isStartOfLine(final int c) {\n        return c == LF || c == CR || c == UNDEFINED;\n    }\n\n    /**\n     * @return true if the given character indicates end of file\n     */\n    boolean isEndOfFile(final int c) {\n        return c == END_OF_STREAM;\n    }\n\n    boolean isDelimiter(final int c) {\n        return c == delimiter;\n    }\n\n    boolean isEscape(final int c) {\n        return c == escape;\n    }\n\n    boolean isQuoteChar(final int c) {\n        return c == quoteChar;\n    }\n\n    boolean isCommentStart(final int c) {\n        return c == commmentStart;\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 4, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVParser", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h4>Creating instances</h4>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * <p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * </p>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n * \n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h4>Parsing record wise</h4>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h4>Parsing into memory</h4>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <p>\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n * </p>\n *\n * <h4>Notes</h4>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h4>Creating instances</h4>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * <p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * </p>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n * \n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h4>Parsing record wise</h4>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h4>Parsing into memory</h4>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <p>\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n * </p>\n *\n * <h4>Notes</h4>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(),\n                             charset == null ? Charset.forName(\"UTF-8\") : charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord record = this.nextRecord();\n                if (record != null) {\n                    header = record.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n"}]}
{"project": "Csv", "bug_id": 5, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVPrinter", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p/>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats\n     * (encapsulation and escaping with a different character) are not supported.\n     *\n     * @param out\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n     * beginning of each new line in the comment.\n     * <p/>\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n            out.append(recordSeparator);\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable. \n     * \n     * @return the target Appendable. \n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p/>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats\n     * (encapsulation and escaping with a different character) are not supported.\n     *\n     * @param out\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n     * beginning of each new line in the comment.\n     * <p/>\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable. \n     * \n     * @return the target Appendable. \n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 6, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVRecord", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null ? true : mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null ? mapping.containsKey(name) : false;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n                map.put(entry.getKey(), values[col]);\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null ? true : mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null ? mapping.containsKey(name) : false;\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n"}]}
{"project": "Csv", "bug_id": 7, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVParser", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new FileReader(file), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        format.validate();\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] header = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    header = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                header = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (header != null) {\n                for (int i = 0; i < header.length; i++) {\n                    if (hdrMap.containsKey(header[i])) {\n                        throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n                    }\n                    hdrMap.put(header[i], Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n"}]}
{"project": "Csv", "bug_id": 8, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVFormat", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVRecord} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteChar; // null if quoting is disabled\n    private final Quote quotePolicy;\n    private final Character commentStart; // null if commenting is disabled\n    private final Character escape; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     * <h3>Additional:</h3>\n     * <ul>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n                                                            false, true, CRLF, null, null, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.newBuilder(EXCEL).withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     * Note: this is currently the same as RFC4180\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n\n    /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n     * a tab-delimited format with a LF character as the line separator. Values are not quoted and special characters\n     * are escaped with '\\'.\n     *\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuoteChar(null)\n            .withRecordSeparator(LF);\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quotePolicy\n     *            the quote policy\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            <tt>true</tt> when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            <tt>true</tt> when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar,\n            final Quote quotePolicy, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, final boolean skipHeaderRecord) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteChar = quoteChar;\n        this.quotePolicy = quotePolicy;\n        this.commentStart = commentStart;\n        this.escape = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n        \tthis.header = null;\n        } else {\n            this.header = header.clone();        \t\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quotePolicy != other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar == null) {\n            if (other.quoteChar != null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart == null) {\n            if (other.commentStart != null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape == null) {\n            if (other.escape != null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentStart() {\n        return commentStart;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscape() {\n        return escape;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n     *         value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.\n     * </li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteChar() {\n        return quoteChar;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public Quote getQuotePolicy() {\n        return quotePolicy;\n    }\n\n    /**\n     * Returns the line separator delimiting output records.\n     *\n     * @return the line separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n     */\n    public boolean isCommentingEnabled() {\n        return commentStart != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscaping() {\n        return escape != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullHandling() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoting() {\n        return quoteChar != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscaping()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escape).append('>');\n        }\n        if (isQuoting()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n        }\n        if (isCommentingEnabled()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n        }\n        if (isNullHandling()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     */\n    void validate() throws IllegalStateException {\n        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n            throw new IllegalStateException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n        }\n\n        if (escape != null && delimiter == escape.charValue()) {\n            throw new IllegalStateException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n        }\n\n        if (commentStart != null && delimiter == commentStart.charValue()) {\n            throw new IllegalStateException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (quoteChar != null && quoteChar.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape != null && escape.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape == null && quotePolicy == Quote.NONE) {\n            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n        }\n\n        if (header != null) {\n            final Set<String> set = new HashSet<String>(header.length);\n            set.addAll(Arrays.asList(header));\n            if (set.size() != header.length) {\n                throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n            }\n        }\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n     *            <tt>false</tt> to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quotePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVRecord} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVFormat.parseFile(file, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteChar; // null if quoting is disabled\n    private final Quote quotePolicy;\n    private final Character commentStart; // null if commenting is disabled\n    private final Character escape; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     * <h3>Additional:</h3>\n     * <ul>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n                                                            false, true, CRLF, null, null, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     * <h3>RFC 4180:</h3>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.newBuilder(EXCEL).withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuoteChar('\"')</li>\n     * <li>withRecordSeparator(CRLF)</li>\n     * </ul>\n     * Note: this is currently the same as RFC4180\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n\n    /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n     * a tab-delimited format with a LF character as the line separator. Values are not quoted and special characters\n     * are escaped with '\\'.\n     *\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuoteChar(null)\n            .withRecordSeparator(LF);\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quotePolicy\n     *            the quote policy\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            <tt>true</tt> when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            <tt>true</tt> when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar,\n            final Quote quotePolicy, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, final boolean skipHeaderRecord) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteChar = quoteChar;\n        this.quotePolicy = quotePolicy;\n        this.commentStart = commentStart;\n        this.escape = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n        \tthis.header = null;\n        } else {\n        \tSet<String> dupCheck = new HashSet<String>();\n        \tfor(String hdr : header) {\n        \t\tif (!dupCheck.add(hdr)) {\n        \t\t\tthrow new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n        \t\t}\n        \t}\n            this.header = header.clone();        \t\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quotePolicy != other.quotePolicy) {\n            return false;\n        }\n        if (quoteChar == null) {\n            if (other.quoteChar != null) {\n                return false;\n            }\n        } else if (!quoteChar.equals(other.quoteChar)) {\n            return false;\n        }\n        if (commentStart == null) {\n            if (other.commentStart != null) {\n                return false;\n            }\n        } else if (!commentStart.equals(other.commentStart)) {\n            return false;\n        }\n        if (escape == null) {\n            if (other.escape != null) {\n                return false;\n            }\n        } else if (!escape.equals(other.escape)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentStart() {\n        return commentStart;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscape() {\n        return escape;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n     *         value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.\n     * </li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteChar() {\n        return quoteChar;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public Quote getQuotePolicy() {\n        return quotePolicy;\n    }\n\n    /**\n     * Returns the line separator delimiting output records.\n     *\n     * @return the line separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode());\n        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n     */\n    public boolean isCommentingEnabled() {\n        return commentStart != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscaping() {\n        return escape != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullHandling() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoting() {\n        return quoteChar != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscaping()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escape).append('>');\n        }\n        if (isQuoting()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n        }\n        if (isCommentingEnabled()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n        }\n        if (isNullHandling()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n     *\n     * @throws IllegalStateException\n     */\n    void validate() throws IllegalStateException {\n        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n            throw new IllegalStateException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n        }\n\n        if (escape != null && delimiter == escape.charValue()) {\n            throw new IllegalStateException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n        }\n\n        if (commentStart != null && delimiter == commentStart.charValue()) {\n            throw new IllegalStateException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (quoteChar != null && quoteChar.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape != null && escape.equals(commentStart)) {\n            throw new IllegalStateException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n        }\n\n        if (escape == null && quotePolicy == Quote.NONE) {\n            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n        }\n\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentStart(final char commentStart) {\n        return withCommentStart(Character.valueOf(commentStart));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentStart\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentStart(final Character commentStart) {\n        if (isLineBreak(commentStart)) {\n            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n     *            <tt>false</tt> to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuoteChar(final char quoteChar) {\n        return withQuoteChar(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuoteChar(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quotePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 9, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVRecord", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/**\n * A CSV record parsed from a CSV file.\n *\n * @version $Id$\n */\npublic final class CSVRecord implements Serializable, Iterable<String> {\n\n    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final long serialVersionUID = 1L;\n\n    /** The accumulated comments (if any) */\n    private final String comment;\n\n    /** The column name to index mapping. */\n    private final Map<String, Integer> mapping;\n\n    /** The record number. */\n    private final long recordNumber;\n\n    /** The values of the record */\n    private final String[] values;\n\n    CSVRecord(final String[] values, final Map<String, Integer> mapping,\n            final String comment, final long recordNumber) {\n        this.recordNumber = recordNumber;\n        this.values = values != null ? values : EMPTY_STRING_ARRAY;\n        this.mapping = mapping;\n        this.comment = comment;\n    }\n\n    /**\n     * Returns a value by {@link Enum}.\n     *\n     * @param e\n     *            an enum\n     * @return the String at the given enum String\n     */\n    public String get(final Enum<?> e) {\n        return get(e.toString());\n    }\n\n    /**\n     * Returns a value by index.\n     *\n     * @param i\n     *            a column index (0-based)\n     * @return the String at the given index\n     */\n    public String get(final int i) {\n        return values[i];\n    }\n\n    /**\n     * Returns a value by name.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isConsistent()\n     * @see CSVFormat#withNullString(String)\n     */\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(String.format(\"Mapping for %s not found, expected one of %s\", name,\n                    mapping.keySet()));\n        }\n        try {\n            return values[index.intValue()];\n        } catch (final ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index,\n                    Integer.valueOf(values.length)));\n        }\n    }\n\n    /**\n     * Returns the comment for this record, if any.\n     *\n     * @return the comment for this record, or null if no comment for this\n     *         record is available.\n     */\n    public String getComment() {\n        return comment;\n    }\n\n    /**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */\n    public long getRecordNumber() {\n        return recordNumber;\n    }\n\n    /**\n     * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n     * the header size. Some programs can export files that fails this test but still produce parsable files.\n     *\n     * @return true of this record is valid, false if not\n     */\n    public boolean isConsistent() {\n        return mapping == null || mapping.size() == values.length;\n    }\n\n    /**\n     * Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped.\n     */\n    public boolean isMapped(final String name) {\n        return mapping != null && mapping.containsKey(name);\n    }\n\n    /**\n     * Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value\n     */\n    public boolean isSet(final String name) {\n        return isMapped(name) && mapping.get(name).intValue() < values.length;\n    }\n\n    /**\n     * Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record.\n     */\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        if (mapping == null) {\n            return map;\n        }\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length) {\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Returns the number of values in this record.\n     *\n     * @return the number of values.\n     */\n    public int size() {\n        return values.length;\n    }\n\n    /**\n     * Converts the values to a List.\n     *\n     * TODO: Maybe make this public?\n     * @return a new List\n     */\n    private List<String> toList() {\n        return Arrays.asList(values);\n    }\n\n    /**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */\n    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }\n\n    @Override\n    public String toString() {\n        return Arrays.toString(values);\n    }\n\n    String[] values() {\n        return values;\n    }\n\n\n}\n"}]}
{"project": "Csv", "bug_id": 10, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVPrinter", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     * \n     * @param out\n     *        stream to which to print. Must not be null.\n     * @param format\n     *        the CSV format. Must not be null.\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *         thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        this.format.validate();\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeader() != null) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoting()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscaping()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscape().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value,\n            final int offset, final int len) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteChar().charValue();\n\n        Quote quotePolicy = format.getQuotePolicy();\n        if (quotePolicy == null) {\n            quotePolicy = Quote.MINIMAL;\n        }\n        switch (quotePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // Hmmm, where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                    // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // if (c == ' ' || c == '\\f' || c == '\\t') {\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quotePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentingEnabled()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentStart().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentStart().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n     * characters will be escaped.\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array.\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object[] values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet result set\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getString(i));\n            }\n            println();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 11, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVParser", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport static org.apache.commons.csv.Token.Type.*;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat JavaDoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @version $Id$\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * <p><strong>Note:</strong> This method internally creates a FileReader using\n     * {@link FileReader#FileReader(java.io.File)} which in turn relies on the default encoding of the JVM that\n     * is executing the code. If this is insufficient create a URL to the file and use\n     * {@link #parse(URL, Charset, CSVFormat)}</p>\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        // Use the default Charset explicitly\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> record = new ArrayList<String>();\n\n    private long recordNumber;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n    }\n\n    private void addRecordValue() {\n        final String input = this.reusableToken.content.toString();\n        final String nullString = this.format.getNullString();\n        if (nullString == null) {\n            this.record.add(input);\n        } else {\n            this.record.add(input.equalsIgnoreCase(nullString) ? null : input);\n        }\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        return getRecords(new ArrayList<CSVRecord>());\n    }\n\n    /**\n     * Parses the CSV input according to the given format and adds the content to the collection of {@link CSVRecord\n     * CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @param records\n     *            The collection to add to.\n     * @param <T> the type of collection used.\n     * @return a collection of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException {\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n\n            private CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final IOException e) {\n                    // TODO: This is not great, throw an ISE instead?\n                    throw new RuntimeException(e);\n                }\n            }\n\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n\n                return this.current != null;\n            }\n\n            public CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new NoSuchElementException(\"CSVParser has been closed\");\n                }\n                CSVRecord next = this.current;\n                this.current = null;\n\n                if (next == null) {\n                    // hasNext() wasn't called before\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n\n                return next;\n            }\n\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.record.clear();\n        StringBuilder sb = null;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue();\n                break;\n            case EORECORD:\n                this.addRecordValue();\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue();\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.record.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n                    this.recordNumber);\n        }\n        return result;\n    }\n\n}\n"}]}
{"project": "Csv", "bug_id": 12, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVFormat", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter(',')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n                                                            false, true, CRLF, null, null, false, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter(',')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n     * </p>\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with '\\'.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar(null)</li>\n     *   <li>withRecordSeparator('\\n')</li>\n     *   <li>withIgnoreEmptyLines(false)</li>\n     *   <li>withEscape('\\\\')</li>\n     * </ul>\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF);\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be\n     * initialized with null/false.</p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @param allowMissingColumnNames TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar,\n            final QuoteMode quoteMode, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n            this.header = null;\n        } else {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n            this.header = header.clone();\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the\n     *         value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.\n     * </li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *        the output\n     * @return a printer to an output\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n *      <li>{@link #DEFAULT}</li>\n *      <li>{@link #EXCEL}</li>\n *      <li>{@link #MYSQL}</li>\n *      <li>{@link #RFC4180}</li>\n *      <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);</pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL\n *   .withNullString(&quot;N/A&quot;)\n *   .withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns,\n * by using {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final boolean skipHeaderRecord;\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter(',')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n                                                            false, true, CRLF, null, null, false, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter(',')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n     * </p>\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar('\"')</li>\n     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n     *   <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     */\n    public static final CSVFormat TDF =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces(true);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with '\\'.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     *   <li>withDelimiter('\\t')</li>\n     *   <li>withQuoteChar(null)</li>\n     *   <li>withRecordSeparator('\\n')</li>\n     *   <li>withIgnoreEmptyLines(false)</li>\n     *   <li>withEscape('\\\\')</li>\n     * </ul>\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL =\n            DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF);\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be\n     * initialized with null/false.</p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param header\n     *            the header\n     * @param skipHeaderRecord TODO\n     * @param allowMissingColumnNames TODO\n     * @throws IllegalArgumentException if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar,\n            final QuoteMode quoteMode, final Character commentStart,\n            final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator,\n            final String nullString, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        if (header == null) {\n            this.header = null;\n        } else {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n            this.header = header.clone();\n        }\n        this.skipHeaderRecord = skipHeaderRecord;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the\n     *         value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.\n     * </li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *        the output\n     * @return a printer to an output\n     * @throws IOException\n     *         thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if(recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p><strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing\n     * currently only works for inputs with '\\n', '\\r' and \"\\r\\n\"</p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *              if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                allowMissingColumnNames);\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 13, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVFormat", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     * \n     * @since 1.2\n     */\n    public static enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT), \n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL), \n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL), \n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        private Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n        \n        /**\n         * Gets the format.\n         * \n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    };\n    \n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final String[] headerComments; // array of header comment lines\n    private final boolean skipHeaderRecord;\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true,\n            CRLF, null, null, null, false, false, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     * @see Predefined#Excel\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     * @see Predefined#TDF\n     */\n    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n            .withQuote(null).withRecordSeparator(LF);\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     * \n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        validate();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output\n     * @return a printer to an output\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        \n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n                    quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n                    escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n        \n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header comments of the format. The comments will be printed first, before the headers. This setting is\n     * ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the trimming behavior of the format to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header ignore case behavior to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since ?\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Sets if header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the\n     *            mapping as is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets skipping the header record to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     * \n     * @since 1.2\n     */\n    public static enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT), \n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL), \n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL), \n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        private Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n        \n        /**\n         * Gets the format.\n         * \n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    };\n    \n    private static final long serialVersionUID = 1L;\n\n    private final char delimiter;\n    private final Character quoteCharacter; // null if quoting is disabled\n    private final QuoteMode quoteMode;\n    private final Character commentMarker; // null if commenting is disabled\n    private final Character escapeCharacter; // null if escaping is disabled\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n    private final boolean allowMissingColumnNames;\n    private final boolean ignoreEmptyLines;\n    private final String recordSeparator; // for outputs\n    private final String nullString; // the string to be used for null values\n    private final String[] header; // array of header column names\n    private final String[] headerComments; // array of header comment lines\n    private final boolean skipHeaderRecord;\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true,\n            CRLF, null, null, null, false, false, false);\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     * @see Predefined#Excel\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     * @see Predefined#TDF\n     */\n    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n     *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n     */\n    public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n            .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     * \n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        validate();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try {\n            new CSVPrinter(out, this).printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output\n     * @return a printer to an output\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        \n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The quoteChar character and the delimiter cannot be the same ('\" +\n                    quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same ('\" +\n                    escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start character and the quoteChar cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same ('\" +\n                    commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n        \n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<String>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate entry: '\" + hdr + \"' in \" +\n                            Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Sets the comment start marker of the format to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the delimiter of the format to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Sets the escape character of the format to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}..\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header comments of the format. The comments will be printed first, before the headers. This setting is\n     * ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Sets the missing column names behavior of the format.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Sets the empty line skipping behavior of the format.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the trimming behavior of the format to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Sets the trimming behavior of the format.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the header ignore case behavior to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since ?\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Sets if header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the\n     *            mapping as is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Performs conversions to and from null for strings on input and output.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Sets the quoteChar of the format to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the output quote policy of the format to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets the record separator of the format to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Sets the record separator of the format to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n\n    /**\n     * Sets skipping the header record to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Sets whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase);\n    }\n}\n"}, {"class_name": "org.apache.commons.csv.CSVPrinter", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     *\n     * @param out\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeaderComments() != null) {\n            for (final String line : format.getHeaderComments()) {\n                if (line != null) {\n                    this.printComment(line);\n                }\n            }\n        }\n        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    @Override\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (format.isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = format.getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // TODO where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentMarker().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentMarker().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given collection only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given collections contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * List&lt;String[]&gt; data = ...\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given array only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Object...)}. If the given collections contains nested collections/arrays those nested\n     * elements will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * String[][] data = new String[3][]\n     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object... values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet\n     *            result set the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getObject(i));\n            }\n            println();\n        }\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Prints values in a CSV format.\n *\n * @version $Id$\n */\npublic final class CSVPrinter implements Flushable, Closeable {\n\n    /** The place that the values get written. */\n    private final Appendable out;\n    private final CSVFormat format;\n\n    /** True if we just began a new record. */\n    private boolean newRecord = true;\n\n    /**\n     * Creates a printer that will print values to the given stream following the CSVFormat.\n     * <p>\n     * Currently, only a pure encapsulation format or a pure escaping format is supported. Hybrid formats (encapsulation\n     * and escaping with a different character) are not supported.\n     * </p>\n     *\n     * @param out\n     *            stream to which to print. Must not be null.\n     * @param format\n     *            the CSV format. Must not be null.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @throws IllegalArgumentException\n     *             thrown if the parameters of the format are inconsistent or if either out or format are null.\n     */\n    public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n        Assertions.notNull(out, \"out\");\n        Assertions.notNull(format, \"format\");\n\n        this.out = out;\n        this.format = format;\n        // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n        // It seems a pain to have to track whether the header has already been printed or not.\n        if (format.getHeaderComments() != null) {\n            for (final String line : format.getHeaderComments()) {\n                if (line != null) {\n                    this.printComment(line);\n                }\n            }\n        }\n        if (format.getHeader() != null && !format.getSkipHeaderRecord()) {\n            this.printRecord((Object[]) format.getHeader());\n        }\n    }\n\n    // ======================================================\n    // printing implementation\n    // ======================================================\n\n    @Override\n    public void close() throws IOException {\n        if (out instanceof Closeable) {\n            ((Closeable) out).close();\n        }\n    }\n\n    /**\n     * Flushes the underlying stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void flush() throws IOException {\n        if (out instanceof Flushable) {\n            ((Flushable) out).flush();\n        }\n    }\n\n    /**\n     * Gets the target Appendable.\n     *\n     * @return the target Appendable.\n     */\n    public Appendable getOut() {\n        return this.out;\n    }\n\n    /**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        if (!newRecord) {\n            out.append(format.getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (format.isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len);\n        } else if (format.isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n        newRecord = false;\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len) throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = format.getDelimiter();\n        final char escape = format.getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len)\n            throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = format.getDelimiter();\n        final char quoteChar = format.getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = format.getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // TODO where did this rule come from?\n                if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Prints a comment on a new line among the delimiter separated values.\n     *\n     * <p>\n     * Comments will always begin on a new line and occupy a least one full line. The character specified to start\n     * comments and a space will be inserted at the beginning of each new line in the comment.\n     * </p>\n     *\n     * If comments are disabled in the current CSV format this method does nothing.\n     *\n     * @param comment\n     *            the comment to output\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printComment(final String comment) throws IOException {\n        if (!format.isCommentMarkerSet()) {\n            return;\n        }\n        if (!newRecord) {\n            println();\n        }\n        out.append(format.getCommentMarker().charValue());\n        out.append(SP);\n        for (int i = 0; i < comment.length(); i++) {\n            final char c = comment.charAt(i);\n            switch (c) {\n            case CR:\n                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n                    i++;\n                }\n                //$FALL-THROUGH$ break intentionally excluded.\n            case LF:\n                println();\n                out.append(format.getCommentMarker().charValue());\n                out.append(SP);\n                break;\n            default:\n                out.append(c);\n                break;\n            }\n        }\n        println();\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints the given values a single record of delimiter separated values followed by the record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\n     * </p>\n     *\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecord(final Object... values) throws IOException {\n        for (final Object value : values) {\n            print(value);\n        }\n        println();\n    }\n\n    /**\n     * Prints all the objects in the given collection handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given collection only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Iterable)}. If the given collections contains nested collections/arrays those nested elements\n     * will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * List&lt;String[]&gt; data = ...\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Iterable<?> values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given array handling nested collections/arrays as records.\n     *\n     * <p>\n     * If the given array only contains simple objects, this method will print a single record like\n     * {@link #printRecord(Object...)}. If the given collections contains nested collections/arrays those nested\n     * elements will each be printed as records using {@link #printRecord(Object...)}.\n     * </p>\n     *\n     * <p>\n     * Given the following data structure:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * String[][] data = new String[3][]\n     * data[0] = String[]{ \"A\", \"B\", \"C\" };\n     * data[1] = new String[]{ \"1\", \"2\", \"3\" };\n     * data[2] = new String[]{ \"A1\", \"B2\", \"C3\" };\n     * </code>\n     * </pre>\n     *\n     * <p>\n     * Calling this method will print:\n     * </p>\n     *\n     * <pre>\n     * <code>\n     * A, B, C\n     * 1, 2, 3\n     * A1, B2, C3\n     * </code>\n     * </pre>\n     *\n     * @param values\n     *            the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public void printRecords(final Object... values) throws IOException {\n        for (final Object value : values) {\n            if (value instanceof Object[]) {\n                this.printRecord((Object[]) value);\n            } else if (value instanceof Iterable) {\n                this.printRecord((Iterable<?>) value);\n            } else {\n                this.printRecord(value);\n            }\n        }\n    }\n\n    /**\n     * Prints all the objects in the given JDBC result set.\n     *\n     * @param resultSet\n     *            result set the values to print.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void printRecords(final ResultSet resultSet) throws SQLException, IOException {\n        final int columnCount = resultSet.getMetaData().getColumnCount();\n        while (resultSet.next()) {\n            for (int i = 1; i <= columnCount; i++) {\n                print(resultSet.getObject(i));\n            }\n            println();\n        }\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 14, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVFormat", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withEscape('\\\\')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF);\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n            .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset \n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, Charset charset) throws IOException {\n        return print(out.toFile(), charset);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n *\n * @version $Id$\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames();\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withEscape('\\\\')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR).withRecordSeparator(LF);\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT.withDelimiter(COMMA).withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    public static final CSVFormat MYSQL = DEFAULT.withDelimiter(TAB).withEscape(BACKSLASH).withIgnoreEmptyLines(false)\n            .withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    public static final CSVFormat TDF = DEFAULT.withDelimiter(TAB).withIgnoreSurroundingSpaces();\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n            final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n            final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n            final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n            final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n            final boolean trailingDelimiter) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset \n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, Charset charset) throws IOException {\n        return print(out.toFile(), charset);\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            charSequence = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Outputs the record separator.\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter);\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 15, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVFormat", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withEscape('\\\\')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    private final boolean autoFlush;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter, final boolean autoFlush) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quoteCharacter + nullString + quoteCharacter;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Constants.BACKSLASH;\nimport static org.apache.commons.csv.Constants.COMMA;\nimport static org.apache.commons.csv.Constants.COMMENT;\nimport static org.apache.commons.csv.Constants.EMPTY;\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.CRLF;\nimport static org.apache.commons.csv.Constants.DOUBLE_QUOTE_CHAR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.PIPE;\nimport static org.apache.commons.csv.Constants.SP;\nimport static org.apache.commons.csv.Constants.TAB;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Specifies the format of a CSV file and parses input.\n *\n * <h2>Using predefined formats</h2>\n *\n * <p>\n * You can use one of the predefined formats:\n * </p>\n *\n * <ul>\n * <li>{@link #DEFAULT}</li>\n * <li>{@link #EXCEL}</li>\n * <li>{@link #MYSQL}</li>\n * <li>{@link #RFC4180}</li>\n * <li>{@link #TDF}</li>\n * </ul>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\n * </pre>\n *\n * <p>\n * The {@link CSVParser} provides static methods to parse other input types, for example:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\n * </pre>\n *\n * <h2>Defining formats</h2>\n *\n * <p>\n * You can extend a format by calling the {@code with} methods. For example:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\n * </pre>\n *\n * <h2>Defining column names</h2>\n *\n * <p>\n * To define the column names you want to use to access records, write:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\n * </pre>\n *\n * <p>\n * Calling {@link #withHeader(String...)} let's you use the given names to address values in a {@link CSVRecord}, and\n * assumes that your CSV source does not contain a first record that also defines column names.\n *\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\n * {@link #withSkipHeaderRecord(boolean)} with {@code true}.\n * </p>\n *\n * <h2>Parsing</h2>\n *\n * <p>\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\n * </p>\n *\n * <pre>\n * Reader in = ...;\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\n * </pre>\n *\n * <p>\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\n * </p>\n *\n * <h2>Referencing columns safely</h2>\n *\n * <p>\n * If your source contains a header record, you can simplify your code and safely reference columns, by using\n * {@link #withHeader(String...)} with no arguments:\n * </p>\n *\n * <pre>\n * CSVFormat.EXCEL.withHeader();\n * </pre>\n *\n * <p>\n * This causes the parser to read the first record and use its values as column names.\n *\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\n * </p>\n *\n * <pre>\n * String value = record.get(&quot;Col1&quot;);\n * </pre>\n *\n * <p>\n * This makes your code impervious to changes in column order in the CSV file.\n * </p>\n *\n * <h2>Notes</h2>\n *\n * <p>\n * This class is immutable.\n * </p>\n */\npublic final class CSVFormat implements Serializable {\n\n    /**\n     * Predefines formats.\n     *\n     * @since 1.2\n     */\n    public enum Predefined {\n\n        /**\n         * @see CSVFormat#DEFAULT\n         */\n        Default(CSVFormat.DEFAULT),\n\n        /**\n         * @see CSVFormat#EXCEL\n         */\n        Excel(CSVFormat.EXCEL),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD\n         * @since 1.3\n         */\n        InformixUnload(CSVFormat.INFORMIX_UNLOAD),\n\n        /**\n         * @see CSVFormat#INFORMIX_UNLOAD_CSV\n         * @since 1.3\n         */\n        InformixUnloadCsv(CSVFormat.INFORMIX_UNLOAD_CSV),\n\n        /**\n         * @see CSVFormat#MYSQL\n         */\n        MySQL(CSVFormat.MYSQL),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         * @since 1.5\n         */\n        PostgreSQLCsv(CSVFormat.POSTGRESQL_CSV),\n\n        /**\n         * @see CSVFormat#POSTGRESQL_CSV\n         */\n        PostgreSQLText(CSVFormat.POSTGRESQL_TEXT),\n\n        /**\n         * @see CSVFormat#RFC4180\n         */\n        RFC4180(CSVFormat.RFC4180),\n\n        /**\n         * @see CSVFormat#TDF\n         */\n        TDF(CSVFormat.TDF);\n\n        private final CSVFormat format;\n\n        Predefined(final CSVFormat format) {\n            this.format = format;\n        }\n\n        /**\n         * Gets the format.\n         *\n         * @return the format.\n         */\n        public CSVFormat getFormat() {\n            return format;\n        }\n    }\n\n    /**\n     * Standard comma separated format, as for {@link #RFC4180} but allowing empty lines.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(true)</li>\n     * </ul>\n     *\n     * @see Predefined#Default\n     */\n    public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null, false, true, CRLF,\n            null, null, null, false, false, false, false, false, false);\n\n    /**\n     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n     * locale dependent, it might be necessary to customize this format to accommodate to your regional settings.\n     *\n     * <p>\n     * For example for parsing or generating a CSV file on a French system the following format will be used:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n     * </pre>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n     * <li>{@link #withQuote(char) withQuote('\"')}</li>\n     * <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n     * <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n     * <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n     * </ul>\n     * <p>\n     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean)\n     * withAllowMissingColumnNames(true)}.\n     * </p>\n     *\n     * @see Predefined#Excel\n     */\n    // @formatter:off\n    public static final CSVFormat EXCEL = DEFAULT\n            .withIgnoreEmptyLines(false)\n            .withAllowMissingColumnNames();\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withEscape('\\\\')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD = DEFAULT\n            .withDelimiter(PIPE)\n            .withEscape(BACKSLASH)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default Informix CSV UNLOAD format used by the {@code UNLOAD TO file_name} operation (escaping is disabled.)\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote(\"\\\"\")</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\n     *      \"http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm\">\n     *      http://www.ibm.com/support/knowledgecenter/SSBJG3_2.5.0/com.ibm.gen_busug.doc/c_fgl_InOutSql_UNLOAD.htm</a>\n     * @since 1.3\n     */\n    // @formatter:off\n    public static final CSVFormat INFORMIX_UNLOAD_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF);\n    // @formatter:on\n\n    /**\n     * Default MySQL format used by the {@code SELECT INTO OUTFILE} and {@code LOAD DATA INFILE} operations.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are not quoted and special\n     * characters are escaped with {@code '\\'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote(null)</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     */\n    // @formatter:off\n    public static final CSVFormat MYSQL = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(BACKSLASH)\n            .withIgnoreEmptyLines(false)\n            .withQuote(null)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL CSV format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a comma-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_CSV = DEFAULT\n            .withDelimiter(COMMA)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(EMPTY)\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Default PostgreSQL text format used by the {@code COPY} operation.\n     *\n     * <p>\n     * This is a tab-delimited format with a LF character as the line separator. Values are double quoted and special\n     * characters are escaped with {@code '\"'}. The default NULL string is {@code \"\\\\N\"}.\n     * </p>\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator('\\n')</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * <li>withEscape('\\\\')</li>\n     * <li>withNullString(\"\\\\N\")</li>\n     * <li>withQuoteMode(QuoteMode.ALL_NON_NULL)</li>\n     * </ul>\n     *\n     * @see Predefined#MySQL\n     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\"> http://dev.mysql.com/doc/refman/5.1/en/load\n     *      -data.html</a>\n     * @since 1.5\n     */\n    // @formatter:off\n    public static final CSVFormat POSTGRESQL_TEXT = DEFAULT\n            .withDelimiter(TAB)\n            .withEscape(DOUBLE_QUOTE_CHAR)\n            .withIgnoreEmptyLines(false)\n            .withQuote(DOUBLE_QUOTE_CHAR)\n            .withRecordSeparator(LF)\n            .withNullString(\"\\\\N\")\n            .withQuoteMode(QuoteMode.ALL_NON_NULL);\n    // @formatter:off\n\n    /**\n     * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter(',')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreEmptyLines(false)</li>\n     * </ul>\n     *\n     * @see Predefined#RFC4180\n     */\n    public static final CSVFormat RFC4180 = DEFAULT.withIgnoreEmptyLines(false);\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Tab-delimited format.\n     *\n     * <p>\n     * Settings are:\n     * </p>\n     * <ul>\n     * <li>withDelimiter('\\t')</li>\n     * <li>withQuote('\"')</li>\n     * <li>withRecordSeparator(\"\\r\\n\")</li>\n     * <li>withIgnoreSurroundingSpaces(true)</li>\n     * </ul>\n     *\n     * @see Predefined#TDF\n     */\n    // @formatter:off\n    public static final CSVFormat TDF = DEFAULT\n            .withDelimiter(TAB)\n            .withIgnoreSurroundingSpaces();\n    // @formatter:on\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check\n     *\n     * @return true if <code>c</code> is a line break character\n     */\n    private static boolean isLineBreak(final char c) {\n        return c == LF || c == CR;\n    }\n\n    /**\n     * Returns true if the given character is a line break character.\n     *\n     * @param c\n     *            the character to check, may be null\n     *\n     * @return true if <code>c</code> is a line break character (and not null)\n     */\n    private static boolean isLineBreak(final Character c) {\n        return c != null && isLineBreak(c.charValue());\n    }\n\n    /**\n     * Creates a new CSV format with the specified delimiter.\n     *\n     * <p>\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized\n     * with null/false.\n     * </p>\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @return a new CSV format.\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     *\n     * @see #DEFAULT\n     * @see #RFC4180\n     * @see #MYSQL\n     * @see #EXCEL\n     * @see #TDF\n     */\n    public static CSVFormat newFormat(final char delimiter) {\n        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false,\n                false, false, false, false);\n    }\n\n    /**\n     * Gets one of the predefined formats from {@link CSVFormat.Predefined}.\n     *\n     * @param format\n     *            name\n     * @return one of the predefined formats\n     * @since 1.2\n     */\n    public static CSVFormat valueOf(final String format) {\n        return CSVFormat.Predefined.valueOf(format).getFormat();\n    }\n\n    private final boolean allowMissingColumnNames;\n\n    private final Character commentMarker; // null if commenting is disabled\n\n    private final char delimiter;\n\n    private final Character escapeCharacter; // null if escaping is disabled\n\n    private final String[] header; // array of header column names\n\n    private final String[] headerComments; // array of header comment lines\n\n    private final boolean ignoreEmptyLines;\n\n    private final boolean ignoreHeaderCase; // should ignore header names case\n\n    private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n\n    private final String nullString; // the string to be used for null values\n\n    private final Character quoteCharacter; // null if quoting is disabled\n\n    private final QuoteMode quoteMode;\n\n    private final String recordSeparator; // for outputs\n\n    private final boolean skipHeaderRecord;\n\n    private final boolean trailingDelimiter;\n\n    private final boolean trim;\n\n    private final boolean autoFlush;\n\n    /**\n     * Creates a customized CSV format.\n     *\n     * @param delimiter\n     *            the char used for value separation, must not be a line break character\n     * @param quoteChar\n     *            the Character used as value encapsulation marker, may be {@code null} to disable\n     * @param quoteMode\n     *            the quote mode\n     * @param commentStart\n     *            the Character used for comment identification, may be {@code null} to disable\n     * @param escape\n     *            the Character used to escape special characters in values, may be {@code null} to disable\n     * @param ignoreSurroundingSpaces\n     *            {@code true} when whitespaces enclosing values should be ignored\n     * @param ignoreEmptyLines\n     *            {@code true} when the parser should skip empty lines\n     * @param recordSeparator\n     *            the line separator to use for output\n     * @param nullString\n     *            the line separator to use for output\n     * @param headerComments\n     *            the comments to be printed by the Printer before the actual CSV data\n     * @param header\n     *            the header\n     * @param skipHeaderRecord\n     *            TODO\n     * @param allowMissingColumnNames\n     *            TODO\n     * @param ignoreHeaderCase\n     *            TODO\n     * @param trim\n     *            TODO\n     * @param trailingDelimiter\n     *            TODO\n     * @param autoFlush\n     * @throws IllegalArgumentException\n     *             if the delimiter is a line break character\n     */\n    private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode,\n                      final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces,\n                      final boolean ignoreEmptyLines, final String recordSeparator, final String nullString,\n                      final Object[] headerComments, final String[] header, final boolean skipHeaderRecord,\n                      final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim,\n                      final boolean trailingDelimiter, final boolean autoFlush) {\n        this.delimiter = delimiter;\n        this.quoteCharacter = quoteChar;\n        this.quoteMode = quoteMode;\n        this.commentMarker = commentStart;\n        this.escapeCharacter = escape;\n        this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n        this.allowMissingColumnNames = allowMissingColumnNames;\n        this.ignoreEmptyLines = ignoreEmptyLines;\n        this.recordSeparator = recordSeparator;\n        this.nullString = nullString;\n        this.headerComments = toStringArray(headerComments);\n        this.header = header == null ? null : header.clone();\n        this.skipHeaderRecord = skipHeaderRecord;\n        this.ignoreHeaderCase = ignoreHeaderCase;\n        this.trailingDelimiter = trailingDelimiter;\n        this.trim = trim;\n        this.autoFlush = autoFlush;\n        validate();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n\n        final CSVFormat other = (CSVFormat) obj;\n        if (delimiter != other.delimiter) {\n            return false;\n        }\n        if (quoteMode != other.quoteMode) {\n            return false;\n        }\n        if (quoteCharacter == null) {\n            if (other.quoteCharacter != null) {\n                return false;\n            }\n        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n            return false;\n        }\n        if (commentMarker == null) {\n            if (other.commentMarker != null) {\n                return false;\n            }\n        } else if (!commentMarker.equals(other.commentMarker)) {\n            return false;\n        }\n        if (escapeCharacter == null) {\n            if (other.escapeCharacter != null) {\n                return false;\n            }\n        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n            return false;\n        }\n        if (nullString == null) {\n            if (other.nullString != null) {\n                return false;\n            }\n        } else if (!nullString.equals(other.nullString)) {\n            return false;\n        }\n        if (!Arrays.equals(header, other.header)) {\n            return false;\n        }\n        if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) {\n            return false;\n        }\n        if (ignoreEmptyLines != other.ignoreEmptyLines) {\n            return false;\n        }\n        if (skipHeaderRecord != other.skipHeaderRecord) {\n            return false;\n        }\n        if (recordSeparator == null) {\n            if (other.recordSeparator != null) {\n                return false;\n            }\n        } else if (!recordSeparator.equals(other.recordSeparator)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Formats the specified values.\n     *\n     * @param values\n     *            the values to format\n     * @return the formatted values\n     */\n    public String format(final Object... values) {\n        final StringWriter out = new StringWriter();\n        try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) {\n            csvPrinter.printRecord(values);\n            return out.toString().trim();\n        } catch (final IOException e) {\n            // should not happen because a StringWriter does not do IO.\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */\n    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }\n\n    /**\n     * Returns the character marking the start of a line comment.\n     *\n     * @return the comment start marker, may be {@code null}\n     */\n    public Character getCommentMarker() {\n        return commentMarker;\n    }\n\n    /**\n     * Returns the character delimiting the values (typically ';', ',' or '\\t').\n     *\n     * @return the delimiter character\n     */\n    public char getDelimiter() {\n        return delimiter;\n    }\n\n    /**\n     * Returns the escape character.\n     *\n     * @return the escape character, may be {@code null}\n     */\n    public Character getEscapeCharacter() {\n        return escapeCharacter;\n    }\n\n    /**\n     * Returns a copy of the header array.\n     *\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file\n     */\n    public String[] getHeader() {\n        return header != null ? header.clone() : null;\n    }\n\n    /**\n     * Returns a copy of the header comment array.\n     *\n     * @return a copy of the header comment array; {@code null} if disabled.\n     */\n    public String[] getHeaderComments() {\n        return headerComments != null ? headerComments.clone() : null;\n    }\n\n    /**\n     * Specifies whether empty lines between records are ignored when parsing input.\n     *\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty\n     *         records.\n     */\n    public boolean getIgnoreEmptyLines() {\n        return ignoreEmptyLines;\n    }\n\n    /**\n     * Specifies whether header names will be accessed ignoring case.\n     *\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\n     * @since 1.3\n     */\n    public boolean getIgnoreHeaderCase() {\n        return ignoreHeaderCase;\n    }\n\n    /**\n     * Specifies whether spaces around values are ignored when parsing input.\n     *\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value.\n     */\n    public boolean getIgnoreSurroundingSpaces() {\n        return ignoreSurroundingSpaces;\n    }\n\n    /**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */\n    public String getNullString() {\n        return nullString;\n    }\n\n    /**\n     * Returns the character used to encapsulate values containing special characters.\n     *\n     * @return the quoteChar character, may be {@code null}\n     */\n    public Character getQuoteCharacter() {\n        return quoteCharacter;\n    }\n\n    /**\n     * Returns the quote policy output fields.\n     *\n     * @return the quote policy\n     */\n    public QuoteMode getQuoteMode() {\n        return quoteMode;\n    }\n\n    /**\n     * Returns the record separator delimiting output records.\n     *\n     * @return the record separator\n     */\n    public String getRecordSeparator() {\n        return recordSeparator;\n    }\n\n    /**\n     * Returns whether to skip the header record.\n     *\n     * @return whether to skip the header record.\n     */\n    public boolean getSkipHeaderRecord() {\n        return skipHeaderRecord;\n    }\n\n    /**\n     * Returns whether to add a trailing delimiter.\n     *\n     * @return whether to add a trailing delimiter.\n     * @since 1.3\n     */\n    public boolean getTrailingDelimiter() {\n        return trailingDelimiter;\n    }\n\n    /**\n     * Returns whether to trim leading and trailing blanks.\n     *\n     * @return whether to trim leading and trailing blanks.\n     */\n    public boolean getTrim() {\n        return trim;\n    }\n\n    /**\n     * Returns whether to flush on close.\n     *\n     * @return whether to flush on close.\n     * @since 1.6\n     */\n    public boolean getAutoFlush() {\n        return autoFlush;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n\n        result = prime * result + delimiter;\n        result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n        result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n        result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n        result = prime * result + (ignoreHeaderCase ? 1231 : 1237);\n        result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n        result = prime * result + (skipHeaderRecord ? 1231 : 1237);\n        result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode());\n        result = prime * result + Arrays.hashCode(header);\n        return result;\n    }\n\n    /**\n     * Specifies whether comments are supported by this format.\n     *\n     * Note that the comment introducer character is only recognized at the start of a line.\n     *\n     * @return {@code true} is comments are supported, {@code false} otherwise\n     */\n    public boolean isCommentMarkerSet() {\n        return commentMarker != null;\n    }\n\n    /**\n     * Returns whether escape are being processed.\n     *\n     * @return {@code true} if escapes are processed\n     */\n    public boolean isEscapeCharacterSet() {\n        return escapeCharacter != null;\n    }\n\n    /**\n     * Returns whether a nullString has been defined.\n     *\n     * @return {@code true} if a nullString is defined\n     */\n    public boolean isNullStringSet() {\n        return nullString != null;\n    }\n\n    /**\n     * Returns whether a quoteChar has been defined.\n     *\n     * @return {@code true} if a quoteChar is defined\n     */\n    public boolean isQuoteCharacterSet() {\n        return quoteCharacter != null;\n    }\n\n    /**\n     * Parses the specified content.\n     *\n     * <p>\n     * See also the various static parse methods on {@link CSVParser}.\n     * </p>\n     *\n     * @param in\n     *            the input stream\n     * @return a parser over a stream of {@link CSVRecord}s.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public CSVParser parse(final Reader in) throws IOException {\n        return new CSVParser(in, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     */\n    public CSVPrinter print(final Appendable out) throws IOException {\n        return new CSVPrinter(out, this);\n    }\n\n    /**\n     * Prints to the {@link System#out}.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @return a printer to {@link System#out}.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter printer() throws IOException {\n        return new CSVPrinter(System.out, this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVPrinter print(final File out, final Charset charset) throws IOException {\n        // The writer will be closed when close() is called.\n        return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this);\n    }\n\n    /**\n     * Prints to the specified output.\n     *\n     * <p>\n     * See also {@link CSVPrinter}.\n     * </p>\n     *\n     * @param out\n     *            the output.\n     * @param charset\n     *            A charset.\n     * @return a printer to an output.\n     * @throws IOException\n     *             thrown if the optional header cannot be printed.\n     * @since 1.5\n     */\n    public CSVPrinter print(final Path out, final Charset charset) throws IOException {\n        return print(Files.newBufferedWriter(out, charset));\n    }\n\n    /**\n     * Prints the {@code value} as the next value on the line to {@code out}. The value will be escaped or encapsulated\n     * as needed. Useful when one wants to avoid creating CSVPrinters.\n     *\n     * @param value\n     *            value to output.\n     * @param out\n     *            where to print the value.\n     * @param newRecord\n     *            if this a new record.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException {\n        // null values are considered empty\n        // Only call CharSequence.toString() if you have to, helps GC-free use cases.\n        CharSequence charSequence;\n        if (value == null) {\n            // https://issues.apache.org/jira/browse/CSV-203\n            if (null == nullString) {\n                charSequence = EMPTY;\n            } else {\n                if (QuoteMode.ALL == quoteMode) {\n                    charSequence = quoteCharacter + nullString + quoteCharacter;\n                } else {\n                    charSequence = nullString;\n                }\n            }\n        } else {\n            charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString();\n        }\n        charSequence = getTrim() ? trim(charSequence) : charSequence;\n        this.print(value, charSequence, 0, charSequence.length(), out, newRecord);\n    }\n\n    private void print(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        if (!newRecord) {\n            out.append(getDelimiter());\n        }\n        if (object == null) {\n            out.append(value);\n        } else if (isQuoteCharacterSet()) {\n            // the original object is needed so can check for Number\n            printAndQuote(object, value, offset, len, out, newRecord);\n        } else if (isEscapeCharacterSet()) {\n            printAndEscape(value, offset, len, out);\n        } else {\n            out.append(value, offset, offset + len);\n        }\n    }\n\n    /*\n     * Note: must only be called if escaping is enabled, otherwise will generate NPE\n     */\n    private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)\n            throws IOException {\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delim = getDelimiter();\n        final char escape = getEscapeCharacter().charValue();\n\n        while (pos < end) {\n            char c = value.charAt(pos);\n            if (c == CR || c == LF || c == delim || c == escape) {\n                // write out segment up until this char\n                if (pos > start) {\n                    out.append(value, start, pos);\n                }\n                if (c == LF) {\n                    c = 'n';\n                } else if (c == CR) {\n                    c = 'r';\n                }\n\n                out.append(escape);\n                out.append(c);\n\n                start = pos + 1; // start on the current char after this one\n            }\n\n            pos++;\n        }\n\n        // write last segment\n        if (pos > start) {\n            out.append(value, start, pos);\n        }\n    }\n\n    /*\n     * Note: must only be called if quoting is enabled, otherwise will generate NPE\n     */\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        if (!quote) {\n            // no encapsulation needed - write out the original value\n            out.append(value, start, end);\n            return;\n        }\n\n        // we hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: pos should be positioned on the first character that caused\n        // the need for encapsulation.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point\n\n                // add 1 to the length to write out the encapsulator also\n                out.append(value, start, pos + 1);\n                // put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment\n        out.append(value, start, pos);\n        out.append(quoteChar);\n    }\n\n    /**\n     * Outputs the trailing delimiter (if set) followed by the record separator (if set).\n     *\n     * @param out\n     *            where to write\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.4\n     */\n    public void println(final Appendable out) throws IOException {\n        if (getTrailingDelimiter()) {\n            out.append(getDelimiter());\n        }\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n    }\n\n    /**\n     * Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the\n     * record separator.\n     *\n     * <p>\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record\n     * separator to the output after printing the record, so there is no need to call {@link #println(Appendable)}.\n     * </p>\n     *\n     * @param out\n     *            where to write.\n     * @param values\n     *            values to output.\n     * @throws IOException\n     *             If an I/O error occurs.\n     * @since 1.4\n     */\n    public void printRecord(final Appendable out, final Object... values) throws IOException {\n        for (int i = 0; i < values.length; i++) {\n            print(values[i], out, i == 0);\n        }\n        println(out);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }\n\n    private String[] toStringArray(final Object[] values) {\n        if (values == null) {\n            return null;\n        }\n        final String[] strings = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            final Object value = values[i];\n            strings[i] = value == null ? null : value.toString();\n        }\n        return strings;\n    }\n\n    private CharSequence trim(final CharSequence charSequence) {\n        if (charSequence instanceof String) {\n            return ((String) charSequence).trim();\n        }\n        final int count = charSequence.length();\n        int len = count;\n        int pos = 0;\n\n        while (pos < len && charSequence.charAt(pos) <= SP) {\n            pos++;\n        }\n        while (pos < len && charSequence.charAt(len - 1) <= SP) {\n            len--;\n        }\n        return pos > 0 || len < count ? charSequence.subSequence(pos, len) : charSequence;\n    }\n\n    /**\n     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n     *\n     * @throws IllegalArgumentException\n     */\n    private void validate() throws IllegalArgumentException {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n\n        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n        }\n\n        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n        }\n\n        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n            throw new IllegalArgumentException(\n                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n        }\n\n        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n        }\n\n        // validate header\n        if (header != null) {\n            final Set<String> dupCheck = new HashSet<>();\n            for (final String hdr : header) {\n                if (!dupCheck.add(hdr)) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to {@code true}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     * @see #withAllowMissingColumnNames(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withAllowMissingColumnNames() {\n        return this.withAllowMissingColumnNames(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\n     *\n     * @param allowMissingColumnNames\n     *            the missing column names behavior, {@code true} to allow missing column names in the header line,\n     *            {@code false} to cause an {@link IllegalArgumentException} to be thrown.\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n     */\n    public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final char commentMarker) {\n        return withCommentMarker(Character.valueOf(commentMarker));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\n     *\n     * Note that the comment start character is only recognized at the start of a line.\n     *\n     * @param commentMarker\n     *            the comment start marker, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withCommentMarker(final Character commentMarker) {\n        if (isLineBreak(commentMarker)) {\n            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the delimiter of the format set to the specified character.\n     *\n     * @param delimiter\n     *            the delimiter character\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withDelimiter(final char delimiter) {\n        if (isLineBreak(delimiter)) {\n            throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character\n     * @return A new CSVFormat that is equal to his but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final char escape) {\n        return withEscape(Character.valueOf(escape));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the escape character of the format set to the specified character.\n     *\n     * @param escape\n     *            the escape character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withEscape(final Character escape) {\n        if (isLineBreak(escape)) {\n            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} using the first record as header.\n     *\n     * <p>\n     * Calling this method is equivalent to calling:\n     * </p>\n     *\n     * <pre>\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\n     * </pre>\n     *\n     * @return A new CSVFormat that is equal to this but using the first record as header.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.3\n     */\n    public CSVFormat withFirstRecordAsHeader() {\n        return withHeader().withSkipHeaderRecord();\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format defined by the enum class.\n     *\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     * public enum Header {\n     *     Name, Email, Phone\n     * }\n     *\n     * CSVFormat format = aformat.withHeader(Header.class);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param headerEnum\n     *            the enum defining the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withHeader(String...)\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {\n        String[] header = null;\n        if (headerEnum != null) {\n            final Enum<?>[] enumValues = headerEnum.getEnumConstants();\n            header = new String[enumValues.length];\n            for (int i = 0; i < enumValues.length; i++) {\n                header[i] = enumValues[i].name();\n            }\n        }\n        return withHeader(header);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(resultSet);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param resultSet\n     *            the resultSet for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSet resultSet) throws SQLException {\n        return withHeader(resultSet != null ? resultSet.getMetaData() : null);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set from the result set metadata. The header can\n     * either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(metaData);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param metaData\n     *            the metaData for the header, {@code null} if disabled, empty if parsed automatically, user specified\n     *            otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @throws SQLException\n     *             SQLException if a database access error occurs or this method is called on a closed result set.\n     * @since 1.1\n     */\n    public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException {\n        String[] labels = null;\n        if (metaData != null) {\n            final int columnCount = metaData.getColumnCount();\n            labels = new String[columnCount];\n            for (int i = 0; i < columnCount; i++) {\n                labels[i] = metaData.getColumnLabel(i + 1);\n            }\n        }\n        return withHeader(labels);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header of the format set to the given values. The header can either be\n     * parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();\n     * </pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n     * </pre>\n     * <p>\n     * The header is also used by the {@link CSVPrinter}.\n     * </p>\n     *\n     * @param header\n     *            the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */\n    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will\n     * be printed first, before the headers. This setting is ignored by the parser.\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV 1.1.&quot;, new Date());\n     * </pre>\n     *\n     * @param headerComments\n     *            the headerComments which will be printed by the Printer before the actual CSV data.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withHeaderComments(final Object... headerComments) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     * @since {@link #withIgnoreEmptyLines(boolean)}\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreEmptyLines() {\n        return this.withIgnoreEmptyLines(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\n     *\n     * @param ignoreEmptyLines\n     *            the empty line skipping behavior, {@code true} to ignore the empty lines between the records,\n     *            {@code false} to translate empty lines to empty records.\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n     */\n    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the header ignore case behavior set to {@code true}.\n     *\n     * @return A new CSVFormat that will ignore case header name.\n     * @see #withIgnoreHeaderCase(boolean)\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase() {\n        return this.withIgnoreHeaderCase(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether header names should be accessed ignoring case.\n     *\n     * @param ignoreHeaderCase\n     *            the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as\n     *            is.\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\n     * @since 1.3\n     */\n    public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     * @see #withIgnoreSurroundingSpaces(boolean)\n     * @since 1.1\n     */\n    public CSVFormat withIgnoreSurroundingSpaces() {\n        return this.withIgnoreSurroundingSpaces(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the trimming behavior of the format set to the given value.\n     *\n     * @param ignoreSurroundingSpaces\n     *            the trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the\n     *            spaces as is.\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n     */\n    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with conversions to and from null for strings on input and output.\n     * <ul>\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @param nullString\n     *            the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     *\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n     */\n    public CSVFormat withNullString(final String nullString) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final char quoteChar) {\n        return withQuote(Character.valueOf(quoteChar));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\n     *\n     * @param quoteChar\n     *            the quoteChar character, use {@code null} to disable\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\n     * @throws IllegalArgumentException\n     *             thrown if the specified character is a line break\n     */\n    public CSVFormat withQuote(final Character quoteChar) {\n        if (isLineBreak(quoteChar)) {\n            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n        }\n        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces,\n                ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord,\n                allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\n     *\n     * @param quoteModePolicy\n     *            the quote policy to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\n     */\n    public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified character.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     */\n    public CSVFormat withRecordSeparator(final char recordSeparator) {\n        return withRecordSeparator(String.valueOf(recordSeparator));\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with the record separator of the format set to the specified String.\n     *\n     * <p>\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently\n     * only works for inputs with '\\n', '\\r' and \"\\r\\n\"\n     * </p>\n     *\n     * @param recordSeparator\n     *            the record separator to use for output.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\n     * @throws IllegalArgumentException\n     *             if recordSeparator is none of CR, LF or CRLF\n     */\n    public CSVFormat withRecordSeparator(final String recordSeparator) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with skipping the header record set to {@code true}.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withSkipHeaderRecord(boolean)\n     * @see #withHeader(String...)\n     * @since 1.1\n     */\n    public CSVFormat withSkipHeaderRecord() {\n        return this.withSkipHeaderRecord(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to skip the header record.\n     *\n     * @param skipHeaderRecord\n     *            whether to skip the header record.\n     *\n     * @return A new CSVFormat that is equal to this but with the the specified skipHeaderRecord setting.\n     * @see #withHeader(String...)\n     */\n    public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter() {\n        return withTrailingDelimiter(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to add a trailing delimiter.\n     *\n     * @param trailingDelimiter\n     *            whether to add a trailing delimiter.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the trim setting on.\n     * @since 1.3\n     */\n    public CSVFormat withTrim() {\n        return withTrim(true);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to trim leading and trailing blanks.\n     *\n     * @param trim\n     *            whether to trim leading and trailing blanks.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\n     * @since 1.3\n     */\n    public CSVFormat withTrim(final boolean trim) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n                skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n\n    /**\n     * Returns a new {@code CSVFormat} with whether to flush on close.\n     *\n     * @param autoFlush\n     *            whether to flush on close.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\n     * @since 1.6\n     */\n    public CSVFormat withAutoFlush(final boolean autoFlush) {\n        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n            ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header,\n            skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush);\n    }\n}\n"}]}
{"project": "Csv", "bug_id": 16, "classes_modified": [{"class_name": "org.apache.commons.csv.CSVParser", "buggy_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n    }\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.csv;\n\nimport static org.apache.commons.csv.Token.Type.TOKEN;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\n/**\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n */\npublic final class CSVParser implements Iterable<CSVRecord>, Closeable {\n\n    /**\n     * Creates a parser for the given {@link File}.\n     *\n     * @param file\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(file, \"file\");\n        Assertions.notNull(format, \"format\");\n        return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}.\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param inputStream\n     *            an InputStream containing CSV-formatted input. Must not be null.\n     * @param charset\n     *            a Charset.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    @SuppressWarnings(\"resource\")\n    public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format)\n            throws IOException {\n        Assertions.notNull(inputStream, \"inputStream\");\n        Assertions.notNull(format, \"format\");\n        return parse(new InputStreamReader(inputStream, charset), format);\n    }\n\n    /**\n     * Creates a parser for the given {@link Path}.\n     *\n     * @param path\n     *            a CSV file. Must not be null.\n     * @param charset\n     *            A Charset\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either file or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     * @since 1.5\n     */\n    public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(path, \"path\");\n        Assertions.notNull(format, \"format\");\n        return parse(Files.newBufferedReader(path, charset), format);\n    }\n\n    /**\n     * Creates a CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new CSVParser configured with the given reader and format.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.5\n     */\n    public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException {\n        return new CSVParser(reader, format);\n    }\n\n    /**\n     * Creates a parser for the given {@link String}.\n     *\n     * @param string\n     *            a CSV string. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either string or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\n        Assertions.notNull(string, \"string\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new StringReader(string), format);\n    }\n\n    /**\n     * Creates a parser for the given URL.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException {\n        Assertions.notNull(url, \"url\");\n        Assertions.notNull(charset, \"charset\");\n        Assertions.notNull(format, \"format\");\n\n        return new CSVParser(new InputStreamReader(url.openStream(), charset), format);\n    }\n\n    // the following objects are shared to reduce garbage\n\n    private final CSVFormat format;\n\n    /** A mapping of column names to column indices */\n    private final Map<String, Integer> headerMap;\n\n    private final Lexer lexer;\n\n    private final CSVRecordIterator csvRecordIterator;\n    \n    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n    private final List<String> recordList = new ArrayList<>();\n\n    /**\n     * The next record number to assign.\n     */\n    private long recordNumber;\n\n    /**\n     * Lexer offset when the parser does not start parsing at the beginning of the source. Usually used in combination\n     * with {@link #recordNumber}.\n     */\n    private final long characterOffset;\n\n    private final Token reusableToken = new Token();\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     */\n    public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n        this(reader, format, 0, 1);\n    }\n\n    /**\n     * Customized CSV parser using the given {@link CSVFormat}\n     *\n     * <p>\n     * If you do not read all records from the given {@code reader}, you should call {@link #close()} on the parser,\n     * unless you close the {@code reader}.\n     * </p>\n     *\n     * @param reader\n     *            a Reader containing CSV-formatted input. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @param characterOffset\n     *            Lexer offset when the parser does not start parsing at the beginning of the source.\n     * @param recordNumber\n     *            The next record number to assign\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either reader or format are null.\n     * @throws IOException\n     *             If there is a problem reading the header or skipping the first record\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\")\n    public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n            throws IOException {\n        Assertions.notNull(reader, \"reader\");\n        Assertions.notNull(format, \"format\");\n\n        this.format = format;\n        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final String input = this.reusableToken.content.toString();\n        final String inputClean = this.format.getTrim() ? input.trim() : input;\n        if (lastRecord && inputClean.isEmpty() && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    /**\n     * Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    @Override\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5\n     */\n    public String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        CSVRecord rec;\n        final List<CSVRecord> records = new ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        }\n        return records;\n    }\n\n    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = this.format.getIgnoreHeaderCase() ?\n                    new TreeMap<String, Integer>(String.CASE_INSENSITIVE_ORDER) :\n                    new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || !this.format.getAllowMissingColumnNames())) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    /**\n     * Gets whether this parser is closed.\n     *\n     * @return whether this parser is closed.\n     */\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     */\n    @Override\n    public Iterator<CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n    \n    class CSVRecordIterator implements Iterator<CSVRecord> {\n        private CSVRecord current;\n  \n        private CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final IOException e) {\n                throw new IllegalStateException(\n                        e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n            }\n        }\n  \n        @Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n  \n            return this.current != null;\n        }\n  \n        @Override\n        public CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new NoSuchElementException(\"CSVParser has been closed\");\n            }\n            CSVRecord next = this.current;\n            this.current = null;\n  \n            if (next == null) {\n                // hasNext() wasn't called before\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n  \n            return next;\n        }\n  \n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    };\n\n    /**\n     * Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    CSVRecord nextRecord() throws IOException {\n        CSVRecord result = null;\n        this.recordList.clear();\n        StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n            case TOKEN:\n                this.addRecordValue(false);\n                break;\n            case EORECORD:\n                this.addRecordValue(true);\n                break;\n            case EOF:\n                if (this.reusableToken.isReady) {\n                    this.addRecordValue(true);\n                }\n                break;\n            case INVALID:\n                throw new IOException(\"(line \" + this.getCurrentLineNumber() + \") invalid parse sequence\");\n            case COMMENT: // Ignored currently\n                if (sb == null) { // first comment for this record\n                    sb = new StringBuilder();\n                } else {\n                    sb.append(Constants.LF);\n                }\n                sb.append(this.reusableToken.content);\n                this.reusableToken.type = TOKEN; // Read another token\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == TOKEN);\n\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final String comment = sb == null ? null : sb.toString();\n            result = new CSVRecord(this.recordList.toArray(new String[this.recordList.size()]), this.headerMap, comment,\n                    this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n\n}\n"}]}
