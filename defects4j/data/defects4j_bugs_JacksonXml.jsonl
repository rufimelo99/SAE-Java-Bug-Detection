{"project": "JacksonXml", "bug_id": 1, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    /**\n     * The default name placeholder for XML text segments is empty\n     * String (\"\").\n     */\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n    /**\n     * Enumeration that defines all togglable features for XML parsers.\n     * None defined so far (2.6), so just a placeholder.\n     */\n    public enum Feature implements FormatFeature\n    {\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /**\n     * In cases where a start element has both attributes and non-empty textual\n     * value, we have to create a bogus property; we will use this as\n     * the property name.\n     *<p>\n     * Name used for pseudo-property used for returning XML Text value (which does\n     * not have actual element name to use). Defaults to empty String, but\n     * may be changed for interoperability reasons: JAXB, for example, uses\n     * \"value\" as name.\n     * \n     * @since 2.1\n     */\n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link FromXmlParser.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    protected ObjectCodec _objectCodec;\n\n    /*\n    /**********************************************************\n    /* I/O state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected XmlReadContext _parsingContext;\n\n    protected final XmlTokenStream _xmlTokens;\n    /**\n     * \n     * We need special handling to keep track of whether a value\n     * may be exposed as simple leaf value.\n     */\n    protected boolean _mayBeLeaf;\n\n    protected JsonToken _nextToken;\n\n    protected String _currText;\n\n    protected Set<String> _namesToWrap;\n\n    /*\n    /**********************************************************\n    /* Parsing state, parsed values\n    /**********************************************************\n     */\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder = null;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamReader xmlReader)\n    {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        // and thereby start a scope\n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /*                                                                                       \n    /**********************************************************                              \n    /* FormatFeature support                                                                             \n    /**********************************************************                              \n     */\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal API\n    /**********************************************************\n     */\n\n    /**\n     * Method that may be called to indicate that specified names\n     * (only local parts retained currently: this may be changed in\n     * future) should be considered \"auto-wrapping\", meaning that\n     * they will be doubled to contain two opening elements, two\n     * matching closing elements. This is needed for supporting\n     * handling of so-called \"unwrapped\" array types, something\n     * XML mappings like JAXB often use.\n     *<p>\n     * NOTE: this method is considered part of internal implementation\n     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n     * between minor versions (it is however expected not to change in\n     * patch versions). So if you have to use it, be prepared for\n     * possible additional work.\n     * \n     * @since 2.1\n     */\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            _nextToken = null;\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    // DEBUGGING\n/*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n            switch (t) {\n            case FIELD_NAME:\n                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n                break;\n            case VALUE_STRING:\n                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n                break;\n            default:\n                System.out.println(\"JsonToken: \"+t);\n            }\n        }\n        return t;\n    }\n*/\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                /* One more refinement (pronunced like \"hack\") is that if\n                 * we had an empty String (or all white space), and we are\n                 * deserializing an array, we better hide the empty text.\n                 */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        // should never get here\n        _throwInternal();\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            // the interesting case; may be able to convert certain kinds of\n            // elements (specifically, ones with attributes, CDATA only content)\n            // into VALUE_STRING\n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    // need to convert token, as well as \"undo\" START_OBJECT\n                    // note: Should NOT update context, because we will still be getting\n                    // matching END_OBJECT, which will undo contexts properly\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    /* One more thing: must explicitly skip the END_OBJECT that\n                     * would follow.\n                     */\n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    /**\n     * XML input actually would offer access to character arrays; but since\n     * we must coalesce things it cannot really be exposed.\n     */\n    @Override\n    public boolean hasTextCharacters()\n    {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    /*\n    /**********************************************************\n    /* Numeric accessors\n    /**********************************************************\n     */\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method impls for stuff from JsonParser\n    /**********************************************************\n     */\n\n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * parser.\n     */\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    /**\n     * The default name placeholder for XML text segments is empty\n     * String (\"\").\n     */\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n    /**\n     * Enumeration that defines all togglable features for XML parsers.\n     * None defined so far (2.6), so just a placeholder.\n     */\n    public enum Feature implements FormatFeature\n    {\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /**\n     * In cases where a start element has both attributes and non-empty textual\n     * value, we have to create a bogus property; we will use this as\n     * the property name.\n     *<p>\n     * Name used for pseudo-property used for returning XML Text value (which does\n     * not have actual element name to use). Defaults to empty String, but\n     * may be changed for interoperability reasons: JAXB, for example, uses\n     * \"value\" as name.\n     * \n     * @since 2.1\n     */\n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link FromXmlParser.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    protected ObjectCodec _objectCodec;\n\n    /*\n    /**********************************************************\n    /* I/O state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected XmlReadContext _parsingContext;\n\n    protected final XmlTokenStream _xmlTokens;\n    /**\n     * \n     * We need special handling to keep track of whether a value\n     * may be exposed as simple leaf value.\n     */\n    protected boolean _mayBeLeaf;\n\n    protected JsonToken _nextToken;\n\n    protected String _currText;\n\n    protected Set<String> _namesToWrap;\n\n    /*\n    /**********************************************************\n    /* Parsing state, parsed values\n    /**********************************************************\n     */\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder = null;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamReader xmlReader)\n    {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        // and thereby start a scope\n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /*                                                                                       \n    /**********************************************************                              \n    /* FormatFeature support                                                                             \n    /**********************************************************                              \n     */\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal API\n    /**********************************************************\n     */\n\n    /**\n     * Method that may be called to indicate that specified names\n     * (only local parts retained currently: this may be changed in\n     * future) should be considered \"auto-wrapping\", meaning that\n     * they will be doubled to contain two opening elements, two\n     * matching closing elements. This is needed for supporting\n     * handling of so-called \"unwrapped\" array types, something\n     * XML mappings like JAXB often use.\n     *<p>\n     * NOTE: this method is considered part of internal implementation\n     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n     * between minor versions (it is however expected not to change in\n     * patch versions). So if you have to use it, be prepared for\n     * possible additional work.\n     * \n     * @since 2.1\n     */\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            _nextToken = null;\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    // DEBUGGING\n/*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n            switch (t) {\n            case FIELD_NAME:\n                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n                break;\n            case VALUE_STRING:\n                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n                break;\n            default:\n                System.out.println(\"JsonToken: \"+t);\n            }\n        }\n        return t;\n    }\n*/\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple, except that if this is a leaf, need to suppress end:\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                if (_parsingContext.inArray()) {\n                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                    //    expose as empty Object, not null\n                    _nextToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                /* One more refinement (pronunced like \"hack\") is that if\n                 * we had an empty String (or all white space), and we are\n                 * deserializing an array, we better hide the empty text.\n                 */\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n                if (_parsingContext.inArray()) {\n                    if (_isEmpty(_currText)) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null (or, worse, as used to\n                        //    be done, by swallowing the token)\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                // [dataformat-xml#177]: empty text may also need to be skipped\n                if (_parsingContext.inObject()\n                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            // If not a leaf (or otherwise ignorable), need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        case XmlTokenStream.XML_END:\n            return (_currToken = null);\n        }\n        \n        // should never get here\n        _throwInternal();\n        return null;\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n            \n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            // the interesting case; may be able to convert certain kinds of\n            // elements (specifically, ones with attributes, CDATA only content)\n            // into VALUE_STRING\n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    // need to convert token, as well as \"undo\" START_OBJECT\n                    // note: Should NOT update context, because we will still be getting\n                    // matching END_OBJECT, which will undo contexts properly\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    /* One more thing: must explicitly skip the END_OBJECT that\n                     * would follow.\n                     */\n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    /**\n     * XML input actually would offer access to character arrays; but since\n     * we must coalesce things it cannot really be exposed.\n     */\n    @Override\n    public boolean hasTextCharacters()\n    {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    /*\n    /**********************************************************\n    /* Numeric accessors\n    /**********************************************************\n     */\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method impls for stuff from JsonParser\n    /**********************************************************\n     */\n\n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * parser.\n     */\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"}]}
{"project": "JacksonXml", "bug_id": 2, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.XMLStreamLocation2;\nimport org.codehaus.stax2.XMLStreamReader2;\nimport org.codehaus.stax2.ri.Stax2ReaderAdapter;\n\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n * abstract out all irrelevant details, and to expose equivalent of flat token\n * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n * content) all of which is just to simplify\n * actual higher-level conversion to JSON tokens\n */\npublic class XmlTokenStream\n{\n    // // // main token states:\n    \n    public final static int XML_START_ELEMENT = 1;\n    public final static int XML_END_ELEMENT = 2;\n    public final static int XML_ATTRIBUTE_NAME = 3;\n    public final static int XML_ATTRIBUTE_VALUE = 4;\n    public final static int XML_TEXT = 5;\n    public final static int XML_END = 6;\n\n    // // // token replay states\n\n    private final static int REPLAY_START_DUP = 1;\n    private final static int REPLAY_END = 2;\n    private final static int REPLAY_START_DELAYED = 3;\n    \n    /*\n    /**********************************************************************\n    /* Configuration\n    /**********************************************************************\n     */\n\n    final protected XMLStreamReader2 _xmlReader;\n\n    final protected Object _sourceReference;\n    \n    /*\n    /**********************************************************************\n    /* Parsing state\n    /**********************************************************************\n     */\n\n    protected int _currentState;\n\n    protected int _attributeCount;\n\n    /**\n     * If true we have a START_ELEMENT with mixed text\n     *\n     * @since 2.8\n     */\n\n    /**\n     * Index of the next attribute of the current START_ELEMENT\n     * to return (as field name and value pair), if any; -1\n     * when no attributes to return\n     */\n    protected int _nextAttributeIndex = 0;\n\n    protected String _localName;\n\n    protected String _namespaceURI;\n\n    protected String _textValue;\n    \n    /*\n    /**********************************************************************\n    /* State for handling virtual wrapping\n    /**********************************************************************\n     */\n    \n    /**\n     * Flag used to indicate that given element should be \"replayed\".\n     */\n    protected int _repeatElement;\n\n    /**\n     * Wrapping state, if any active (null if none)\n     */\n    protected ElementWrapper _currentWrapper;\n\n    /**\n     * In cases where we need to 'inject' a virtual END_ELEMENT, we may also\n     * need to restore START_ELEMENT afterwards; if so, this is where names\n     * are held.\n     */\n    protected String _nextLocalName;\n    protected String _nextNamespaceURI;\n    \n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n    {\n        _sourceReference = sourceRef;\n        // Let's ensure we point to START_ELEMENT...\n        if (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n                    +XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n        }\n        _xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n        _currentState = XML_START_ELEMENT;\n        _localName = _xmlReader.getLocalName();\n        _namespaceURI = _xmlReader.getNamespaceURI();\n        _attributeCount = _xmlReader.getAttributeCount();\n    }\n\n    public XMLStreamReader2 getXmlReader() {\n        return _xmlReader;\n    }\n\n    /*\n    /**********************************************************************\n    /* Public API\n    /**********************************************************************\n     */\n\n    // DEBUGGING\n    /*\n    public int next() throws IOException \n    {\n        int n = next0();\n        switch (n) {\n        case XML_START_ELEMENT: \n            System.out.println(\" XML-token: XML_START_ELEMENT '\"+_localName+\"'\");\n            break;\n        case XML_END_ELEMENT: \n            System.out.println(\" XML-token: XML_END_ELEMENT '\"+_localName+\"'\");\n            break;\n        case XML_ATTRIBUTE_NAME: \n            System.out.println(\" XML-token: XML_ATTRIBUTE_NAME '\"+_localName+\"'\");\n            break;\n        case XML_ATTRIBUTE_VALUE: \n            System.out.println(\" XML-token: XML_ATTRIBUTE_VALUE '\"+_textValue+\"'\");\n            break;\n        case XML_TEXT: \n            System.out.println(\" XML-token: XML_TEXT '\"+_textValue+\"'\");\n            break;\n        case XML_END: \n            System.out.println(\" XML-token: XML_END\");\n            break;\n        default:\n            throw new IllegalStateException();\n        }\n        return n;\n    }\n    */\n\n    public int next() throws IOException \n    {\n        if (_repeatElement != 0) {\n            return (_currentState = _handleRepeatElement());\n        }\n        try {\n            return _next();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n            return -1;\n        }\n    }\n    \n    public void skipEndElement() throws IOException\n    {\n        int type = next();\n        if (type != XML_END_ELEMENT) {\n            throw new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n        }\n    }\n\n    public int getCurrentToken() { return _currentState; }\n\n    public String getText() { return _textValue; }\n    public String getLocalName() { return _localName; }\n    public String getNamespaceURI() { return _namespaceURI; }\n    public boolean hasAttributes() {\n        return (_currentState == XML_START_ELEMENT) && (_attributeCount > 0);\n    }\n    \n    public void closeCompletely() throws IOException\n    {\n        try {\n            _xmlReader.closeCompletely();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        try {\n            _xmlReader.close();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    public JsonLocation getCurrentLocation() {\n        return _extractLocation(_xmlReader.getLocationInfo().getCurrentLocation());\n    }\n    public JsonLocation getTokenLocation() {\n        return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal API: more esoteric methods\n    /**********************************************************************\n     */\n    \n    /**\n     * Method used to add virtual wrapping, which just duplicates START_ELEMENT\n     * stream points to, and its matching closing element.\n     * \n     * @since 2.1\n     */\n    protected void repeatStartElement()\n    {\n//System.out.println(\" -> repeatStartElement for \"+_localName);        \n        // sanity check: can only be used when just returned START_ELEMENT:\n        if (_currentState != XML_START_ELEMENT) {\n            throw new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n                    +XML_START_ELEMENT+\") but \"+_currentState);\n        }\n        // Important: add wrapper, to keep track...\n        if (_currentWrapper == null) {\n            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n        } else {\n            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n        }\n        _repeatElement = REPLAY_START_DUP;\n    }\n\n    /**\n     * Method called to skip any attributes current START_ELEMENT may have,\n     * so that they are not returned as token.\n     * \n     * @since 2.1\n     */\n    protected void skipAttributes()\n    {\n        if (_currentState == XML_ATTRIBUTE_NAME) {\n            _attributeCount = 0;\n            _currentState = XML_START_ELEMENT;\n        } else if (_currentState == XML_START_ELEMENT) {\n            /* 06-Jan-2012, tatu: As per [#47] it looks like we should NOT do anything\n             *   in this particular case, because it occurs when original element had\n             *   no attributes and we now point to the first child element.\n             */\n//              _attributeCount = 0;\n        } else if (_currentState == XML_TEXT) {\n            ; // nothing to do... is it even legal?\n        } else {\n            throw new IllegalStateException(\"Current state not XML_START_ELEMENT or XML_ATTRIBUTE_NAME (\"\n                    +XML_START_ELEMENT+\") but \"+_currentState);\n        }\n    }\n\n    protected String convertToString() throws IOException\n    {\n        // only applicable to cases where START_OBJECT was induced by attributes\n        if (_currentState != XML_ATTRIBUTE_NAME || _nextAttributeIndex != 0) {\n            return null;\n        }\n        try {\n            String text = _collectUntilTag();\n            // 23-Dec-2015, tatu: Used to require text not to be null, but as per\n            //   [dataformat-xml#167], empty tag does count\n            if (_xmlReader.getEventType() == XMLStreamReader.END_ELEMENT) {\n                if (text == null) {\n                    text = \"\";\n                }\n                if (_currentWrapper != null) {\n                    _currentWrapper = _currentWrapper.getParent();\n                }\n                // just for diagnostics, reset to element name (from first attribute name)\n                _localName = _xmlReader.getLocalName();\n                _namespaceURI = _xmlReader.getNamespaceURI();\n                _attributeCount = 0;\n                _currentState = XML_TEXT;\n                _textValue = text;\n                return text;\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n        // Anything to do in failed case? Roll back whatever we found or.. ?\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, parsing\n    /**********************************************************************\n     */\n\n    private final int _next() throws XMLStreamException\n    {\n        switch (_currentState) {\n        case XML_ATTRIBUTE_VALUE:\n            ++_nextAttributeIndex;\n            // fall through\n        case XML_START_ELEMENT: // attributes to return?\n            if (_nextAttributeIndex < _attributeCount) {\n                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n                return (_currentState = XML_ATTRIBUTE_NAME);\n            }\n            // otherwise need to find START/END_ELEMENT or text\n            String text = _collectUntilTag();\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n                    return _initStartElement();\n            }\n            // For END_ELEMENT we will return text, if any\n            if (text != null) {\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            return _handleEndElement();\n\n        case XML_ATTRIBUTE_NAME:\n            // if we just returned name, will need to just send value next\n            return (_currentState = XML_ATTRIBUTE_VALUE);\n        case XML_TEXT:\n            // mixed text with other elements\n            // text followed by END_ELEMENT\n            return _handleEndElement();\n        case XML_END:\n            return XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n        }\n\n        // Ok: must be END_ELEMENT; see what tag we get (or end)\n        switch (_skipUntilTag()) {\n        case XMLStreamConstants.END_DOCUMENT:\n            return (_currentState = XML_END);\n        case XMLStreamConstants.END_ELEMENT:\n            return _handleEndElement();\n        }\n        // START_ELEMENT...\n        return _initStartElement();\n    }\n    \n    private final String _collectUntilTag() throws XMLStreamException\n    {\n        String text = null;\n        while (true) {\n            switch (_xmlReader.next()) {\n            case XMLStreamConstants.START_ELEMENT:\n            case XMLStreamConstants.END_ELEMENT:\n            case XMLStreamConstants.END_DOCUMENT:\n                return text;\n                // note: SPACE is ignorable (and seldom seen), not to be included\n            case XMLStreamConstants.CHARACTERS:\n            case XMLStreamConstants.CDATA:\n                if (text == null) {\n                    text = _xmlReader.getText();\n                } else { // can be optimized in future, if need be:\n                    text += _xmlReader.getText();\n                }\n                break;\n            default:\n                // any other type (proc instr, comment etc) is just ignored\n            }\n        }\n    }\n\n    private final int _skipUntilTag() throws XMLStreamException\n    {\n        while (_xmlReader.hasNext()) {\n            int type;\n            switch (type = _xmlReader.next()) {\n            case XMLStreamConstants.START_ELEMENT:\n            case XMLStreamConstants.END_ELEMENT:\n            case XMLStreamConstants.END_DOCUMENT:\n                return type;\n            default:\n                // any other type (proc instr, comment etc) is just ignored\n            }\n        }\n        throw new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n    }\n    \n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n    \n    private final int _initStartElement() throws XMLStreamException\n    {\n        final String ns = _xmlReader.getNamespaceURI();\n        final String localName = _xmlReader.getLocalName();\n        _attributeCount = _xmlReader.getAttributeCount();\n        _nextAttributeIndex = 0;\n\n        /* Support for virtual wrapping: in wrapping, may either\n         * create a new wrapper scope (if in sub-tree, or matches\n         * wrapper element itself), or implicitly close existing\n         * scope.\n         */\n        if (_currentWrapper != null) {\n            if (_currentWrapper.matchesWrapper(localName, ns)) {\n                _currentWrapper = _currentWrapper.intermediateWrapper();\n            } else {\n                // implicit end is more interesting:\n                _localName = _currentWrapper.getWrapperLocalName();\n                _namespaceURI = _currentWrapper.getWrapperNamespace();\n                _currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n                // Important! We also need to restore the START_ELEMENT, so:\n                _nextLocalName = localName;\n                _nextNamespaceURI = ns;\n                _repeatElement = REPLAY_START_DELAYED;\n                return (_currentState = XML_END_ELEMENT);\n            }\n        }\n        _localName = localName;\n        _namespaceURI = ns;\n        return (_currentState = XML_START_ELEMENT);\n    }\n\n    /**\n     * Method called to handle details of repeating \"virtual\"\n     * start/end elements, needed for handling 'unwrapped' lists.\n     */\n    protected int _handleRepeatElement() throws IOException \n    {\n        int type = _repeatElement;\n        _repeatElement = 0;\n        if (type == REPLAY_START_DUP) {\n//System.out.println(\"handleRepeat for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n            // important: add the virtual element second time, but not with name to match\n            _currentWrapper = _currentWrapper.intermediateWrapper();\n            return XML_START_ELEMENT;\n        }\n        if (type == REPLAY_END) {\n//System.out.println(\"handleRepeat for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n            _localName = _xmlReader.getLocalName();\n            _namespaceURI = _xmlReader.getNamespaceURI();\n            if (_currentWrapper != null) {\n                _currentWrapper = _currentWrapper.getParent();\n            }\n            return XML_END_ELEMENT;\n        }\n        if (type == REPLAY_START_DELAYED) {\n            if (_currentWrapper != null) {\n                _currentWrapper = _currentWrapper.intermediateWrapper();\n            }\n            _localName = _nextLocalName;\n            _namespaceURI = _nextNamespaceURI;\n            _nextLocalName = null;\n            _nextNamespaceURI = null;\n            \n//System.out.println(\"handleRepeat for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n\n            return XML_START_ELEMENT;\n        }\n        throw new IllegalStateException(\"Unrecognized type to repeat: \"+type);\n    }\n    \n    private final int _handleEndElement()\n    {\n        if (_currentWrapper != null) {\n            ElementWrapper w = _currentWrapper;\n            // important: if we close the scope, must duplicate END_ELEMENT as well\n            if (w.isMatching()) {\n                _repeatElement = REPLAY_END;\n                _localName = w.getWrapperLocalName();\n                _namespaceURI = w.getWrapperNamespace();\n                _currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n            } else {\n                _currentWrapper = _currentWrapper.getParent();\n            }\n        }\n        return (_currentState = XML_END_ELEMENT);\n    }\n    \n    private JsonLocation _extractLocation(XMLStreamLocation2 location)\n    {\n        if (location == null) { // just for impls that might pass null...\n            return new JsonLocation(_sourceReference, -1, -1, -1);\n        }\n        return new JsonLocation(_sourceReference,\n                location.getCharacterOffset(),\n                location.getLineNumber(),\n                location.getColumnNumber());\n    }\n\n\n    \n    // for DEBUGGING\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(Token stream:\");\n        sb.append(\" state=\").append(_currentState);\n        sb.append(\" attr#=\").append(_attributeCount);\n        sb.append(\" nextAttr#=\").append(_nextAttributeIndex);\n        sb.append(\" name=\").append(_localName);\n        sb.append(\" text=\").append(_textValue);\n        sb.append(\" repeat?=\").append(_repeatElement);\n        sb.append(\" wrapper=[\").append(_currentWrapper);\n        sb.append(\"] repeatElement=\").append(_repeatElement);\n        sb.append(\" nextName=\").append(_nextLocalName);\n        sb.append(\")\");\n        return sb.toString();\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.XMLStreamLocation2;\nimport org.codehaus.stax2.XMLStreamReader2;\nimport org.codehaus.stax2.ri.Stax2ReaderAdapter;\n\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n * abstract out all irrelevant details, and to expose equivalent of flat token\n * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n * content) all of which is just to simplify\n * actual higher-level conversion to JSON tokens\n */\npublic class XmlTokenStream\n{\n    // // // main token states:\n    \n    public final static int XML_START_ELEMENT = 1;\n    public final static int XML_END_ELEMENT = 2;\n    public final static int XML_ATTRIBUTE_NAME = 3;\n    public final static int XML_ATTRIBUTE_VALUE = 4;\n    public final static int XML_TEXT = 5;\n    public final static int XML_END = 6;\n\n    // // // token replay states\n\n    private final static int REPLAY_START_DUP = 1;\n    private final static int REPLAY_END = 2;\n    private final static int REPLAY_START_DELAYED = 3;\n    \n    /*\n    /**********************************************************************\n    /* Configuration\n    /**********************************************************************\n     */\n\n    final protected XMLStreamReader2 _xmlReader;\n\n    final protected Object _sourceReference;\n    \n    /*\n    /**********************************************************************\n    /* Parsing state\n    /**********************************************************************\n     */\n\n    protected int _currentState;\n\n    protected int _attributeCount;\n\n    /**\n     * If true we have a START_ELEMENT with mixed text\n     *\n     * @since 2.8\n     */\n    protected boolean _mixedText;\n\n    /**\n     * Index of the next attribute of the current START_ELEMENT\n     * to return (as field name and value pair), if any; -1\n     * when no attributes to return\n     */\n    protected int _nextAttributeIndex = 0;\n\n    protected String _localName;\n\n    protected String _namespaceURI;\n\n    protected String _textValue;\n    \n    /*\n    /**********************************************************************\n    /* State for handling virtual wrapping\n    /**********************************************************************\n     */\n    \n    /**\n     * Flag used to indicate that given element should be \"replayed\".\n     */\n    protected int _repeatElement;\n\n    /**\n     * Wrapping state, if any active (null if none)\n     */\n    protected ElementWrapper _currentWrapper;\n\n    /**\n     * In cases where we need to 'inject' a virtual END_ELEMENT, we may also\n     * need to restore START_ELEMENT afterwards; if so, this is where names\n     * are held.\n     */\n    protected String _nextLocalName;\n    protected String _nextNamespaceURI;\n    \n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n    {\n        _sourceReference = sourceRef;\n        // Let's ensure we point to START_ELEMENT...\n        if (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n                    +XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n        }\n        _xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n        _currentState = XML_START_ELEMENT;\n        _localName = _xmlReader.getLocalName();\n        _namespaceURI = _xmlReader.getNamespaceURI();\n        _attributeCount = _xmlReader.getAttributeCount();\n    }\n\n    public XMLStreamReader2 getXmlReader() {\n        return _xmlReader;\n    }\n\n    /*\n    /**********************************************************************\n    /* Public API\n    /**********************************************************************\n     */\n\n    // DEBUGGING\n    /*\n    public int next() throws IOException \n    {\n        int n = next0();\n        switch (n) {\n        case XML_START_ELEMENT: \n            System.out.println(\" XML-token: XML_START_ELEMENT '\"+_localName+\"'\");\n            break;\n        case XML_END_ELEMENT: \n            System.out.println(\" XML-token: XML_END_ELEMENT '\"+_localName+\"'\");\n            break;\n        case XML_ATTRIBUTE_NAME: \n            System.out.println(\" XML-token: XML_ATTRIBUTE_NAME '\"+_localName+\"'\");\n            break;\n        case XML_ATTRIBUTE_VALUE: \n            System.out.println(\" XML-token: XML_ATTRIBUTE_VALUE '\"+_textValue+\"'\");\n            break;\n        case XML_TEXT: \n            System.out.println(\" XML-token: XML_TEXT '\"+_textValue+\"'\");\n            break;\n        case XML_END: \n            System.out.println(\" XML-token: XML_END\");\n            break;\n        default:\n            throw new IllegalStateException();\n        }\n        return n;\n    }\n    */\n\n    public int next() throws IOException \n    {\n        if (_repeatElement != 0) {\n            return (_currentState = _handleRepeatElement());\n        }\n        try {\n            return _next();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n            return -1;\n        }\n    }\n    \n    public void skipEndElement() throws IOException\n    {\n        int type = next();\n        if (type != XML_END_ELEMENT) {\n            throw new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n        }\n    }\n\n    public int getCurrentToken() { return _currentState; }\n\n    public String getText() { return _textValue; }\n    public String getLocalName() { return _localName; }\n    public String getNamespaceURI() { return _namespaceURI; }\n    public boolean hasAttributes() {\n        return (_currentState == XML_START_ELEMENT) && (_attributeCount > 0);\n    }\n    \n    public void closeCompletely() throws IOException\n    {\n        try {\n            _xmlReader.closeCompletely();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    public void close() throws IOException\n    {\n        try {\n            _xmlReader.close();\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    public JsonLocation getCurrentLocation() {\n        return _extractLocation(_xmlReader.getLocationInfo().getCurrentLocation());\n    }\n    public JsonLocation getTokenLocation() {\n        return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal API: more esoteric methods\n    /**********************************************************************\n     */\n    \n    /**\n     * Method used to add virtual wrapping, which just duplicates START_ELEMENT\n     * stream points to, and its matching closing element.\n     * \n     * @since 2.1\n     */\n    protected void repeatStartElement()\n    {\n//System.out.println(\" -> repeatStartElement for \"+_localName);        \n        // sanity check: can only be used when just returned START_ELEMENT:\n        if (_currentState != XML_START_ELEMENT) {\n            throw new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n                    +XML_START_ELEMENT+\") but \"+_currentState);\n        }\n        // Important: add wrapper, to keep track...\n        if (_currentWrapper == null) {\n            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper, _localName, _namespaceURI);\n        } else {\n            _currentWrapper = ElementWrapper.matchingWrapper(_currentWrapper.getParent(), _localName, _namespaceURI);\n        }\n        _repeatElement = REPLAY_START_DUP;\n    }\n\n    /**\n     * Method called to skip any attributes current START_ELEMENT may have,\n     * so that they are not returned as token.\n     * \n     * @since 2.1\n     */\n    protected void skipAttributes()\n    {\n        if (_currentState == XML_ATTRIBUTE_NAME) {\n            _attributeCount = 0;\n            _currentState = XML_START_ELEMENT;\n        } else if (_currentState == XML_START_ELEMENT) {\n            /* 06-Jan-2012, tatu: As per [#47] it looks like we should NOT do anything\n             *   in this particular case, because it occurs when original element had\n             *   no attributes and we now point to the first child element.\n             */\n//              _attributeCount = 0;\n        } else if (_currentState == XML_TEXT) {\n            ; // nothing to do... is it even legal?\n        } else {\n            throw new IllegalStateException(\"Current state not XML_START_ELEMENT or XML_ATTRIBUTE_NAME (\"\n                    +XML_START_ELEMENT+\") but \"+_currentState);\n        }\n    }\n\n    protected String convertToString() throws IOException\n    {\n        // only applicable to cases where START_OBJECT was induced by attributes\n        if (_currentState != XML_ATTRIBUTE_NAME || _nextAttributeIndex != 0) {\n            return null;\n        }\n        try {\n            String text = _collectUntilTag();\n            // 23-Dec-2015, tatu: Used to require text not to be null, but as per\n            //   [dataformat-xml#167], empty tag does count\n            if (_xmlReader.getEventType() == XMLStreamReader.END_ELEMENT) {\n                if (text == null) {\n                    text = \"\";\n                }\n                if (_currentWrapper != null) {\n                    _currentWrapper = _currentWrapper.getParent();\n                }\n                // just for diagnostics, reset to element name (from first attribute name)\n                _localName = _xmlReader.getLocalName();\n                _namespaceURI = _xmlReader.getNamespaceURI();\n                _attributeCount = 0;\n                _currentState = XML_TEXT;\n                _textValue = text;\n                return text;\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwXmlAsIOException(e);\n        }\n        // Anything to do in failed case? Roll back whatever we found or.. ?\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, parsing\n    /**********************************************************************\n     */\n\n    private final int _next() throws XMLStreamException\n    {\n        switch (_currentState) {\n        case XML_ATTRIBUTE_VALUE:\n            ++_nextAttributeIndex;\n            // fall through\n        case XML_START_ELEMENT: // attributes to return?\n            if (_nextAttributeIndex < _attributeCount) {\n                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n                return (_currentState = XML_ATTRIBUTE_NAME);\n            }\n            // otherwise need to find START/END_ELEMENT or text\n            String text = _collectUntilTag();\n            final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT;\n            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n            if (startElementNext) {\n                if (text == null || _allWs(text)) {\n                    _mixedText = false;\n                    return _initStartElement();\n                }\n                _mixedText = true;\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            // For END_ELEMENT we will return text, if any\n            if (text != null) {\n                _mixedText = false;\n                _textValue = text;\n                return (_currentState = XML_TEXT);\n            }\n            _mixedText = false;\n            return _handleEndElement();\n\n        case XML_ATTRIBUTE_NAME:\n            // if we just returned name, will need to just send value next\n            return (_currentState = XML_ATTRIBUTE_VALUE);\n        case XML_TEXT:\n            // mixed text with other elements\n            if (_mixedText){\n                _mixedText = false;\n                return _initStartElement();\n            }\n            // text followed by END_ELEMENT\n            return _handleEndElement();\n        case XML_END:\n            return XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n        }\n\n        // Ok: must be END_ELEMENT; see what tag we get (or end)\n        switch (_skipUntilTag()) {\n        case XMLStreamConstants.END_DOCUMENT:\n            return (_currentState = XML_END);\n        case XMLStreamConstants.END_ELEMENT:\n            return _handleEndElement();\n        }\n        // START_ELEMENT...\n        return _initStartElement();\n    }\n    \n    private final String _collectUntilTag() throws XMLStreamException\n    {\n        String text = null;\n        while (true) {\n            switch (_xmlReader.next()) {\n            case XMLStreamConstants.START_ELEMENT:\n            case XMLStreamConstants.END_ELEMENT:\n            case XMLStreamConstants.END_DOCUMENT:\n                return text;\n                // note: SPACE is ignorable (and seldom seen), not to be included\n            case XMLStreamConstants.CHARACTERS:\n            case XMLStreamConstants.CDATA:\n                if (text == null) {\n                    text = _xmlReader.getText();\n                } else { // can be optimized in future, if need be:\n                    text += _xmlReader.getText();\n                }\n                break;\n            default:\n                // any other type (proc instr, comment etc) is just ignored\n            }\n        }\n    }\n\n    private final int _skipUntilTag() throws XMLStreamException\n    {\n        while (_xmlReader.hasNext()) {\n            int type;\n            switch (type = _xmlReader.next()) {\n            case XMLStreamConstants.START_ELEMENT:\n            case XMLStreamConstants.END_ELEMENT:\n            case XMLStreamConstants.END_DOCUMENT:\n                return type;\n            default:\n                // any other type (proc instr, comment etc) is just ignored\n            }\n        }\n        throw new IllegalStateException(\"Expected to find a tag, instead reached end of input\");\n    }\n    \n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n    \n    private final int _initStartElement() throws XMLStreamException\n    {\n        final String ns = _xmlReader.getNamespaceURI();\n        final String localName = _xmlReader.getLocalName();\n        _attributeCount = _xmlReader.getAttributeCount();\n        _nextAttributeIndex = 0;\n\n        /* Support for virtual wrapping: in wrapping, may either\n         * create a new wrapper scope (if in sub-tree, or matches\n         * wrapper element itself), or implicitly close existing\n         * scope.\n         */\n        if (_currentWrapper != null) {\n            if (_currentWrapper.matchesWrapper(localName, ns)) {\n                _currentWrapper = _currentWrapper.intermediateWrapper();\n            } else {\n                // implicit end is more interesting:\n                _localName = _currentWrapper.getWrapperLocalName();\n                _namespaceURI = _currentWrapper.getWrapperNamespace();\n                _currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" START_ELEMENT (\"+localName+\") not matching '\"+_localName+\"'; add extra XML-END-ELEMENT!\");\n                // Important! We also need to restore the START_ELEMENT, so:\n                _nextLocalName = localName;\n                _nextNamespaceURI = ns;\n                _repeatElement = REPLAY_START_DELAYED;\n                return (_currentState = XML_END_ELEMENT);\n            }\n        }\n        _localName = localName;\n        _namespaceURI = ns;\n        return (_currentState = XML_START_ELEMENT);\n    }\n\n    /**\n     * Method called to handle details of repeating \"virtual\"\n     * start/end elements, needed for handling 'unwrapped' lists.\n     */\n    protected int _handleRepeatElement() throws IOException \n    {\n        int type = _repeatElement;\n        _repeatElement = 0;\n        if (type == REPLAY_START_DUP) {\n//System.out.println(\"handleRepeat for START_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n            // important: add the virtual element second time, but not with name to match\n            _currentWrapper = _currentWrapper.intermediateWrapper();\n            return XML_START_ELEMENT;\n        }\n        if (type == REPLAY_END) {\n//System.out.println(\"handleRepeat for END_ELEMENT: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n            _localName = _xmlReader.getLocalName();\n            _namespaceURI = _xmlReader.getNamespaceURI();\n            if (_currentWrapper != null) {\n                _currentWrapper = _currentWrapper.getParent();\n            }\n            return XML_END_ELEMENT;\n        }\n        if (type == REPLAY_START_DELAYED) {\n            if (_currentWrapper != null) {\n                _currentWrapper = _currentWrapper.intermediateWrapper();\n            }\n            _localName = _nextLocalName;\n            _namespaceURI = _nextNamespaceURI;\n            _nextLocalName = null;\n            _nextNamespaceURI = null;\n            \n//System.out.println(\"handleRepeat for START_DELAYED: \"+_localName+\" (\"+_xmlReader.getLocalName()+\")\");\n\n            return XML_START_ELEMENT;\n        }\n        throw new IllegalStateException(\"Unrecognized type to repeat: \"+type);\n    }\n    \n    private final int _handleEndElement()\n    {\n        if (_currentWrapper != null) {\n            ElementWrapper w = _currentWrapper;\n            // important: if we close the scope, must duplicate END_ELEMENT as well\n            if (w.isMatching()) {\n                _repeatElement = REPLAY_END;\n                _localName = w.getWrapperLocalName();\n                _namespaceURI = w.getWrapperNamespace();\n                _currentWrapper = _currentWrapper.getParent();\n//System.out.println(\" IMPLICIT requestRepeat of END_ELEMENT '\"+_localName);\n            } else {\n                _currentWrapper = _currentWrapper.getParent();\n            }\n        }\n        return (_currentState = XML_END_ELEMENT);\n    }\n    \n    private JsonLocation _extractLocation(XMLStreamLocation2 location)\n    {\n        if (location == null) { // just for impls that might pass null...\n            return new JsonLocation(_sourceReference, -1, -1, -1);\n        }\n        return new JsonLocation(_sourceReference,\n                location.getCharacterOffset(),\n                location.getLineNumber(),\n                location.getColumnNumber());\n    }\n\n\n    protected boolean _allWs(String str)\n    {\n        final int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    // for DEBUGGING\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(Token stream:\");\n        sb.append(\" state=\").append(_currentState);\n        sb.append(\" attr#=\").append(_attributeCount);\n        sb.append(\" nextAttr#=\").append(_nextAttributeIndex);\n        sb.append(\" name=\").append(_localName);\n        sb.append(\" text=\").append(_textValue);\n        sb.append(\" repeat?=\").append(_repeatElement);\n        sb.append(\" wrapper=[\").append(_currentWrapper);\n        sb.append(\"] repeatElement=\").append(_repeatElement);\n        sb.append(\" nextName=\").append(_nextLocalName);\n        sb.append(\")\");\n        return sb.toString();\n    }\n}\n"}]}
{"project": "JacksonXml", "bug_id": 3, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    /**\n     * The default name placeholder for XML text segments is empty\n     * String (\"\").\n     */\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n    /**\n     * Enumeration that defines all togglable features for XML parsers.\n     * None defined so far (2.6), so just a placeholder.\n     */\n    public enum Feature implements FormatFeature\n    {\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /**\n     * In cases where a start element has both attributes and non-empty textual\n     * value, we have to create a bogus property; we will use this as\n     * the property name.\n     *<p>\n     * Name used for pseudo-property used for returning XML Text value (which does\n     * not have actual element name to use). Defaults to empty String, but\n     * may be changed for interoperability reasons: JAXB, for example, uses\n     * \"value\" as name.\n     * \n     * @since 2.1\n     */\n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link FromXmlParser.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    protected ObjectCodec _objectCodec;\n\n    /*\n    /**********************************************************\n    /* I/O state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected XmlReadContext _parsingContext;\n\n    protected final XmlTokenStream _xmlTokens;\n    /**\n     * \n     * We need special handling to keep track of whether a value\n     * may be exposed as simple leaf value.\n     */\n    protected boolean _mayBeLeaf;\n\n    protected JsonToken _nextToken;\n\n    protected String _currText;\n\n    protected Set<String> _namesToWrap;\n\n    /*\n    /**********************************************************\n    /* Parsing state, parsed values\n    /**********************************************************\n     */\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder = null;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamReader xmlReader)\n    {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        // and thereby start a scope\n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /*                                                                                       \n    /**********************************************************                              \n    /* FormatFeature support                                                                             \n    /**********************************************************                              \n     */\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal API\n    /**********************************************************\n     */\n\n    /**\n     * Method that may be called to indicate that specified names\n     * (only local parts retained currently: this may be changed in\n     * future) should be considered \"auto-wrapping\", meaning that\n     * they will be doubled to contain two opening elements, two\n     * matching closing elements. This is needed for supporting\n     * handling of so-called \"unwrapped\" array types, something\n     * XML mappings like JAXB often use.\n     *<p>\n     * NOTE: this method is considered part of internal implementation\n     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n     * between minor versions (it is however expected not to change in\n     * patch versions). So if you have to use it, be prepared for\n     * possible additional work.\n     * \n     * @since 2.1\n     */\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\n            if (_nextToken == JsonToken.END_OBJECT) {\n                _nextToken = JsonToken.END_ARRAY;\n            } else {\n                _nextToken = null;\n            }\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    // DEBUGGING\n    /*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n            switch (t) {\n            case FIELD_NAME:\n                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n                break;\n            case VALUE_STRING:\n                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n                break;\n            default:\n                System.out.println(\"JsonToken: \"+t);\n            }\n        }\n        return t;\n    }\n\n//    public JsonToken nextToken0() throws IOException\n */\n\n    \n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            break;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            // the interesting case; may be able to convert certain kinds of\n            // elements (specifically, ones with attributes, CDATA only content)\n            // into VALUE_STRING\n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    // need to convert token, as well as \"undo\" START_OBJECT\n                    // note: Should NOT update context, because we will still be getting\n                    // matching END_OBJECT, which will undo contexts properly\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    /* One more thing: must explicitly skip the END_OBJECT that\n                     * would follow.\n                     */\n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    /**\n     * XML input actually would offer access to character arrays; but since\n     * we must coalesce things it cannot really be exposed.\n     */\n    @Override\n    public boolean hasTextCharacters()\n    {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    /*\n    /**********************************************************\n    /* Numeric accessors\n    /**********************************************************\n     */\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method impls for stuff from JsonParser\n    /**********************************************************\n     */\n\n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * parser.\n     */\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.deser;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserMinimalBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.ByteArrayBuilder;\nimport com.fasterxml.jackson.dataformat.xml.PackageVersion;\nimport com.fasterxml.jackson.dataformat.xml.XmlMapper;\n\n/**\n * {@link JsonParser} implementation that exposes XML structure as\n * set of JSON events that can be used for data binding.\n */\npublic class FromXmlParser\n    extends ParserMinimalBase\n{\n    /**\n     * The default name placeholder for XML text segments is empty\n     * String (\"\").\n     */\n    public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n    /**\n     * Enumeration that defines all togglable features for XML parsers.\n     * None defined so far (2.6), so just a placeholder.\n     */\n    public enum Feature implements FormatFeature\n    {\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n        \n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n        \n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /**\n     * In cases where a start element has both attributes and non-empty textual\n     * value, we have to create a bogus property; we will use this as\n     * the property name.\n     *<p>\n     * Name used for pseudo-property used for returning XML Text value (which does\n     * not have actual element name to use). Defaults to empty String, but\n     * may be changed for interoperability reasons: JAXB, for example, uses\n     * \"value\" as name.\n     * \n     * @since 2.1\n     */\n    protected String _cfgNameForTextElement = DEFAULT_UNNAMED_TEXT_PROPERTY;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link FromXmlParser.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    protected ObjectCodec _objectCodec;\n\n    /*\n    /**********************************************************\n    /* I/O state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates whether parser is closed or not. Gets\n     * set when parser is either closed by explicit call\n     * ({@link #close}) or when end-of-input is reached.\n     */\n    protected boolean _closed;\n\n    final protected IOContext _ioContext;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Information about parser context, context in which\n     * the next token is to be parsed (root, array, object).\n     */\n    protected XmlReadContext _parsingContext;\n\n    protected final XmlTokenStream _xmlTokens;\n    /**\n     * \n     * We need special handling to keep track of whether a value\n     * may be exposed as simple leaf value.\n     */\n    protected boolean _mayBeLeaf;\n\n    protected JsonToken _nextToken;\n\n    protected String _currText;\n\n    protected Set<String> _namesToWrap;\n\n    /*\n    /**********************************************************\n    /* Parsing state, parsed values\n    /**********************************************************\n     */\n\n    /**\n     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n     * we better reuse it for remainder of content.\n     */\n    protected ByteArrayBuilder _byteArrayBuilder = null;\n\n    /**\n     * We will hold on to decoded binary data, for duration of\n     * current event, so that multiple calls to\n     * {@link #getBinaryValue} will not need to decode data more\n     * than once.\n     */\n    protected byte[] _binaryValue;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamReader xmlReader)\n    {\n        super(genericParserFeatures);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _objectCodec = codec;\n        _parsingContext = XmlReadContext.createRootContext(-1, -1);\n        // and thereby start a scope\n        _nextToken = JsonToken.START_OBJECT;\n        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n    \n    @Override\n    public ObjectCodec getCodec() {\n        return _objectCodec;\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        _objectCodec = c;\n    }\n\n    /**\n     * @since 2.1\n     */\n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n    \n    /**\n     * XML format does require support from custom {@link ObjectCodec}\n     * (that is, {@link XmlMapper}), so need to return true here.\n     * \n     * @return True since XML format does require support from codec\n     */\n    @Override\n    public boolean requiresCustomCodec() {\n        return true;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public FromXmlParser enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public FromXmlParser disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public FromXmlParser configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    /*                                                                                       \n    /**********************************************************                              \n    /* FormatFeature support                                                                             \n    /**********************************************************                              \n     */\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override\n    public JsonParser overrideFormatFeatures(int values, int mask) {\n        _formatFeatures = (_formatFeatures & ~mask) | (values & mask);\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamReader getStaxReader() {\n        return _xmlTokens.getXmlReader();\n    }\n\n    /*\n    /**********************************************************\n    /* Internal API\n    /**********************************************************\n     */\n\n    /**\n     * Method that may be called to indicate that specified names\n     * (only local parts retained currently: this may be changed in\n     * future) should be considered \"auto-wrapping\", meaning that\n     * they will be doubled to contain two opening elements, two\n     * matching closing elements. This is needed for supporting\n     * handling of so-called \"unwrapped\" array types, something\n     * XML mappings like JAXB often use.\n     *<p>\n     * NOTE: this method is considered part of internal implementation\n     * interface, and it is <b>NOT</b> guaranteed to remain unchanged\n     * between minor versions (it is however expected not to change in\n     * patch versions). So if you have to use it, be prepared for\n     * possible additional work.\n     * \n     * @since 2.1\n     */\n    public void addVirtualWrapping(Set<String> namesToWrap)\n    {\n        /* 17-Sep-2012, tatu: Not 100% sure why, but this is necessary to avoid\n         *   problems with Lists-in-Lists properties\n         */\n        String name = _xmlTokens.getLocalName();\n        if (name != null && namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _namesToWrap = namesToWrap;\n        _parsingContext.setNamesToWrap(namesToWrap);\n    }\n\n    /*\n    /**********************************************************\n    /* JsonParser impl\n    /**********************************************************\n     */\n    \n    /**\n     * Method that can be called to get the name associated with\n     * the current event.\n     */\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n    @Override\n    public void overrideCurrentName(String name)\n    {\n        // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n        XmlReadContext ctxt = _parsingContext;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            ctxt = ctxt.getParent();\n        }\n        ctxt.setCurrentName(name);\n    }\n    \n    @Override\n    public void close() throws IOException\n    {\n        if (!_closed) {\n            _closed = true;\n            try {\n                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n                    _xmlTokens.closeCompletely();\n                } else {\n                    _xmlTokens.close();\n                }\n            } finally {\n                // as per [JACKSON-324], do in finally block\n                // Also, internal buffer(s) can now be released as well\n                _releaseBuffers();\n            }\n        }\n    }\n\n    @Override\n    public boolean isClosed() { return _closed; }\n\n    @Override\n    public XmlReadContext getParsingContext() {\n        return _parsingContext;\n    }\n\n    /**\n     * Method that return the <b>starting</b> location of the current\n     * token; that is, position of the first character from input\n     * that starts the current token.\n     */\n    @Override\n    public JsonLocation getTokenLocation() {\n        return _xmlTokens.getTokenLocation();\n    }\n\n    /**\n     * Method that returns location of the last processed character;\n     * usually for error reporting purposes\n     */\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return _xmlTokens.getCurrentLocation();\n    }\n\n    /**\n     * Since xml representation can not really distinguish between array\n     * and object starts (both are represented with elements), this method\n     * is overridden and taken to mean that expecation is that the current\n     * start element is to mean 'start array', instead of default of\n     * 'start object'.\n     */\n    @Override\n    public boolean isExpectedStartArrayToken()\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.START_OBJECT) {        \t\n            _currToken = JsonToken.START_ARRAY;\n            // Ok: must replace current context with array as well\n            _parsingContext.convertToArray();\n//System.out.println(\" isExpectedArrayStart: OBJ->Array, wraps now: \"+_parsingContext.getNamesToWrap());\n            // And just in case a field name was to be returned, wipe it\n            // 06-Jan-2015, tatu: Actually, could also be empty Object buffered; if so, convert...\n            if (_nextToken == JsonToken.END_OBJECT) {\n                _nextToken = JsonToken.END_ARRAY;\n            } else {\n                _nextToken = null;\n            }\n            // and last thing, [dataformat-xml#33], better ignore attributes\n            _xmlTokens.skipAttributes();\n            return true;\n        }\n//System.out.println(\" isExpectedArrayStart?: t=\"+t);\n        return (t == JsonToken.START_ARRAY);\n    }\n\n    // DEBUGGING\n    /*\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        JsonToken t = nextToken0();\n        if (t != null) {\n            switch (t) {\n            case FIELD_NAME:\n                System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\");\n                break;\n            case VALUE_STRING:\n                System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\");\n                break;\n            default:\n                System.out.println(\"JsonToken: \"+t);\n            }\n        }\n        return t;\n    }\n\n//    public JsonToken nextToken0() throws IOException\n */\n\n    \n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Overrides of specialized nextXxx() methods\n    /**********************************************************\n     */\n\n    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = _xmlTokens.getText());\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n\n\n    private void _updateState(JsonToken t)\n    {\n        switch (t) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default:\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override\n    public String getText() throws IOException\n    {\n        if (_currToken == null) {\n            return null;\n        }\n        switch (_currToken) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        default:\n            return _currToken.asString();\n        }\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException {\n        return getValueAsString(null);\n    }\n\n    @Override\n    public String getValueAsString(String defValue) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == null) {\n            return null;\n        }\n        switch (t) {\n        case FIELD_NAME:\n            return getCurrentName();\n        case VALUE_STRING:\n            return _currText;\n        case START_OBJECT:\n            // the interesting case; may be able to convert certain kinds of\n            // elements (specifically, ones with attributes, CDATA only content)\n            // into VALUE_STRING\n            {\n                String str = _xmlTokens.convertToString();\n                if (str != null) {\n                    // need to convert token, as well as \"undo\" START_OBJECT\n                    // note: Should NOT update context, because we will still be getting\n                    // matching END_OBJECT, which will undo contexts properly\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    _currToken = JsonToken.VALUE_STRING;\n                    _nextToken = null;\n                    /* One more thing: must explicitly skip the END_OBJECT that\n                     * would follow.\n                     */\n                    _xmlTokens.skipEndElement();\n                    return (_currText = str);\n                }\n                \n            }\n            return null;\n        default:\n            if (_currToken.isScalarValue()) {\n                return _currToken.asString();\n            }\n        }\n        return defValue;\n    }\n    \n    @Override\n    public char[] getTextCharacters() throws IOException {\n        String text = getText();\n        return (text == null)  ? null : text.toCharArray();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        String text = getText();\n        return (text == null)  ? 0 : text.length();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return 0;\n    }\n\n    /**\n     * XML input actually would offer access to character arrays; but since\n     * we must coalesce things it cannot really be exposed.\n     */\n    @Override\n    public boolean hasTextCharacters()\n    {\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, binary\n    /**********************************************************\n     */\n\n    @Override\n    public Object getEmbeddedObject() throws IOException {\n        // no way to embed POJOs for now...\n        return null;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if (_currToken != JsonToken.VALUE_STRING &&\n                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        /* To ensure that we won't see inconsistent data, better clear up\n         * state...\n         */\n        if (_binaryValue == null) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n        }        \n        return _binaryValue;\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n        final String str = getText();\n        _decodeBase64(str, builder, b64variant);\n        return builder.toByteArray();\n    }\n    \n    /*\n    /**********************************************************\n    /* Numeric accessors\n    /**********************************************************\n     */\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public NumberType getNumberType() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method impls for stuff from JsonParser\n    /**********************************************************\n     */\n\n    /**\n     * Method called when an EOF is encountered between tokens.\n     * If so, it may be a legitimate EOF, but only iff there\n     * is no open non-root context.\n     */\n    @Override\n    protected void _handleEOF() throws JsonParseException\n    {\n        if (!_parsingContext.inRoot()) {\n            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * parser.\n     */\n    protected void _releaseBuffers() throws IOException {\n        // anything we can/must release? Underlying parser should do all of it, for now?\n    }\n\n    protected ByteArrayBuilder _getByteArrayBuilder()\n    {\n        if (_byteArrayBuilder == null) {\n            _byteArrayBuilder = new ByteArrayBuilder();\n        } else {\n            _byteArrayBuilder.reset();\n        }\n        return _byteArrayBuilder;\n    }\n\n    protected boolean _isEmpty(String str)\n    {\n        int len = (str == null) ? 0 : str.length();\n        if (len > 0) {\n            for (int i = 0; i < len; ++i) {\n                if (str.charAt(i) > ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"}]}
{"project": "JacksonXml", "bug_id": 4, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.IOException;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.SerializationConfig;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n\n/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    // As of 2.7\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n        throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n\n        final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // no wrapping for IO (and derived)\n            throw ioe;\n        } catch (Exception e) { // but others do need to be, to get path etc\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n    \n    // @since 2.1\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n            JsonSerializer<Object> ser) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // no wrapping for IO (and derived)\n            throw ioe;\n        } catch (Exception e) { // but others do need to be, to get path etc\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n        }\n        super.serializeValue(jgen, null);\n    }\n    \n    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        xgen.writeStartObject();\n        // Could repeat root name, but what's the point? How to customize?\n        xgen.writeFieldName(\"item\");\n    }    \n\n    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        /* 28-Nov-2012, tatu: We should only initialize the root\n         *  name if no name has been set, as per [dataformat-xml#42],\n         *  to allow for custom serializers to work.\n         */\n        if (!xgen.setNextNameIfMissing(rootName)) {\n            // however, if we are root, we... insist\n            if (xgen.inRoot()) {\n                xgen.setNextName(rootName);\n            }\n        }\n        xgen.initGenerator();\n        String ns = rootName.getNamespaceURI();\n        /* [dataformat-xml#26] If we just try writing root element with namespace,\n         * we will get an explicit prefix. But we'd rather use the default\n         * namespace, so let's try to force that.\n         */\n        if (ns != null && ns.length() > 0) {\n            try {\n                xgen.getStaxWriter().setDefaultNamespace(ns);\n            } catch (XMLStreamException e) {\n                StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n    }\n\n    protected QName _rootNameFromConfig()\n    {\n        PropertyName name = _config.getFullRootName();\n        if (name == null) {\n            return null;\n        }\n        String ns = name.getNamespace();\n        if (ns == null || ns.isEmpty()) {\n            return new QName(name.getSimpleName());\n        }\n        return new QName(ns, name.getSimpleName());\n    }\n\n    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n        throws JsonMappingException\n    {\n        // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n        if (!(gen instanceof ToXmlGenerator)) {\n            // but verify\n            if (!(gen instanceof TokenBuffer)) {\n                throw JsonMappingException.from(gen,\n                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n            }\n            return null;\n        }\n        return (ToXmlGenerator) gen;\n    }    \n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.IOException;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.SerializationConfig;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n\n/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    // As of 2.7\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n        throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n\n        final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // no wrapping for IO (and derived)\n            throw ioe;\n        } catch (Exception e) { // but others do need to be, to get path etc\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n    \n    // @since 2.1\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n            JsonSerializer<Object> ser) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // no wrapping for IO (and derived)\n            throw ioe;\n        } catch (Exception e) { // but others do need to be, to get path etc\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        QName rootName = _rootNameFromConfig();\n        if (rootName == null) {\n            rootName = ROOT_NAME_FOR_NULL;\n        }\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, rootName);\n        }\n        super.serializeValue(jgen, null);\n    }\n    \n    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        xgen.writeStartObject();\n        // Could repeat root name, but what's the point? How to customize?\n        xgen.writeFieldName(\"item\");\n    }    \n\n    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        /* 28-Nov-2012, tatu: We should only initialize the root\n         *  name if no name has been set, as per [dataformat-xml#42],\n         *  to allow for custom serializers to work.\n         */\n        if (!xgen.setNextNameIfMissing(rootName)) {\n            // however, if we are root, we... insist\n            if (xgen.inRoot()) {\n                xgen.setNextName(rootName);\n            }\n        }\n        xgen.initGenerator();\n        String ns = rootName.getNamespaceURI();\n        /* [dataformat-xml#26] If we just try writing root element with namespace,\n         * we will get an explicit prefix. But we'd rather use the default\n         * namespace, so let's try to force that.\n         */\n        if (ns != null && ns.length() > 0) {\n            try {\n                xgen.getStaxWriter().setDefaultNamespace(ns);\n            } catch (XMLStreamException e) {\n                StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n    }\n\n    protected QName _rootNameFromConfig()\n    {\n        PropertyName name = _config.getFullRootName();\n        if (name == null) {\n            return null;\n        }\n        String ns = name.getNamespace();\n        if (ns == null || ns.isEmpty()) {\n            return new QName(name.getSimpleName());\n        }\n        return new QName(ns, name.getSimpleName());\n    }\n\n    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n        throws JsonMappingException\n    {\n        // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n        if (!(gen instanceof ToXmlGenerator)) {\n            // but verify\n            if (!(gen instanceof TokenBuffer)) {\n                throw JsonMappingException.from(gen,\n                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n            }\n            return null;\n        }\n        return (ToXmlGenerator) gen;\n    }    \n}\n"}]}
{"project": "JacksonXml", "bug_id": 5, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.IOException;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.SerializationConfig;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n\n/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    // As of 2.7\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            throw _wrapAsIOE(gen, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    // @since 2.1\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n            JsonSerializer<Object> ser) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) { // but others do need to be, to get path etc\n            throw _wrapAsIOE(gen, e);\n        }\n        // end of super-class implementation\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        QName rootName = _rootNameFromConfig();\n        if (rootName == null) {\n            rootName = ROOT_NAME_FOR_NULL;\n        }\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, rootName);\n        }\n        super.serializeValue(jgen, null);\n    }\n    \n    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        xgen.writeStartObject();\n        // Could repeat root name, but what's the point? How to customize?\n        xgen.writeFieldName(\"item\");\n    }    \n\n    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        /* 28-Nov-2012, tatu: We should only initialize the root\n         *  name if no name has been set, as per [dataformat-xml#42],\n         *  to allow for custom serializers to work.\n         */\n        if (!xgen.setNextNameIfMissing(rootName)) {\n            // however, if we are root, we... insist\n            if (xgen.inRoot()) {\n                xgen.setNextName(rootName);\n            }\n        }\n        xgen.initGenerator();\n        String ns = rootName.getNamespaceURI();\n        /* [dataformat-xml#26] If we just try writing root element with namespace,\n         * we will get an explicit prefix. But we'd rather use the default\n         * namespace, so let's try to force that.\n         */\n        if (ns != null && ns.length() > 0) {\n            try {\n                xgen.getStaxWriter().setDefaultNamespace(ns);\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, xgen);\n            }\n        }\n    }\n\n    protected QName _rootNameFromConfig()\n    {\n        PropertyName name = _config.getFullRootName();\n        if (name == null) {\n            return null;\n        }\n        String ns = name.getNamespace();\n        if (ns == null || ns.isEmpty()) {\n            return new QName(name.getSimpleName());\n        }\n        return new QName(ns, name.getSimpleName());\n    }\n\n    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n        throws JsonMappingException\n    {\n        // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n        if (!(gen instanceof ToXmlGenerator)) {\n            // but verify\n            if (!(gen instanceof TokenBuffer)) {\n                throw JsonMappingException.from(gen,\n                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n            }\n            return null;\n        }\n        return (ToXmlGenerator) gen;\n    }    \n\n    protected IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.IOException;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.SerializationConfig;\nimport com.fasterxml.jackson.databind.ser.SerializerFactory;\nimport com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\nimport com.fasterxml.jackson.databind.util.TokenBuffer;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\nimport com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n\n/**\n * We need to override some parts of\n * {@link com.fasterxml.jackson.databind.SerializerProvider}\n * implementation to handle oddities of XML output, like \"extra\" root element.\n */\npublic class XmlSerializerProvider extends DefaultSerializerProvider\n{\n    // As of 2.7\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = new XmlRootNameLookup();\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            throw _wrapAsIOE(gen, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    // @since 2.1\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n            JsonSerializer<Object> ser) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(rootType, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(rootType);\n            if (asArray) {\n                _startRootArray(xgen, rootName);\n            }\n        }\n        if (ser == null) {\n            ser = findTypedValueSerializer(rootType, true, null);\n        }\n        // From super-class implementation\n        try {\n            ser.serialize(value, gen, this);\n        } catch (Exception e) { // but others do need to be, to get path etc\n            throw _wrapAsIOE(gen, e);\n        }\n        // end of super-class implementation\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }\n\n    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n    {\n        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n        //    configured root name...\n        QName rootName = _rootNameFromConfig();\n        if (rootName == null) {\n            rootName = ROOT_NAME_FOR_NULL;\n        }\n        if (jgen instanceof ToXmlGenerator) {\n            _initWithRootName((ToXmlGenerator) jgen, rootName);\n        }\n        super.serializeValue(jgen, null);\n    }\n    \n    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        xgen.writeStartObject();\n        // Could repeat root name, but what's the point? How to customize?\n        xgen.writeFieldName(\"item\");\n    }    \n\n    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n    {\n        /* 28-Nov-2012, tatu: We should only initialize the root\n         *  name if no name has been set, as per [dataformat-xml#42],\n         *  to allow for custom serializers to work.\n         */\n        if (!xgen.setNextNameIfMissing(rootName)) {\n            // however, if we are root, we... insist\n            if (xgen.inRoot()) {\n                xgen.setNextName(rootName);\n            }\n        }\n        xgen.initGenerator();\n        String ns = rootName.getNamespaceURI();\n        /* [dataformat-xml#26] If we just try writing root element with namespace,\n         * we will get an explicit prefix. But we'd rather use the default\n         * namespace, so let's try to force that.\n         */\n        if (ns != null && ns.length() > 0) {\n            try {\n                xgen.getStaxWriter().setDefaultNamespace(ns);\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, xgen);\n            }\n        }\n    }\n\n    protected QName _rootNameFromConfig()\n    {\n        PropertyName name = _config.getFullRootName();\n        if (name == null) {\n            return null;\n        }\n        String ns = name.getNamespace();\n        if (ns == null || ns.isEmpty()) {\n            return new QName(name.getSimpleName());\n        }\n        return new QName(ns, name.getSimpleName());\n    }\n\n    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n        throws JsonMappingException\n    {\n        // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n        if (!(gen instanceof ToXmlGenerator)) {\n            // but verify\n            if (!(gen instanceof TokenBuffer)) {\n                throw JsonMappingException.from(gen,\n                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n            }\n            return null;\n        }\n        return (ToXmlGenerator) gen;\n    }    \n\n    protected IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n        if (e instanceof IOException) {\n            return (IOException) e;\n        }\n        String msg = e.getMessage();\n        if (msg == null) {\n            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n        }\n        return new JsonMappingException(g, msg, e);\n    }\n}\n"}]}
{"project": "JacksonXml", "bug_id": 6, "classes_modified": [{"class_name": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator", "buggy_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport org.codehaus.stax2.XMLStreamWriter2;\nimport org.codehaus.stax2.ri.Stax2WriterAdapter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.GeneratorBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.dataformat.xml.XmlPrettyPrinter;\nimport com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n * Operation requires calling code (usually either standard Jackson serializers,\n * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n * additional configuration calls beyond regular {@link JsonGenerator} API,\n * mostly to pass namespace information.\n */\npublic final class ToXmlGenerator\n    extends GeneratorBase\n{\n    /**\n     * If we support optional definition of element names, this is the element\n     * name to use...\n     */\n    protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n    \n    /**\n     * Enumeration that defines all togglable extra XML-specific features\n     */\n    public enum Feature implements FormatFeature\n    {\n        /**\n         * Feature that controls whether XML declaration should be written before\n         * when generator is initialized (true) or not (false)\n         */\n        WRITE_XML_DECLARATION(false),\n\n        /**\n         * Feature that controls whether output should be done as XML 1.1; if so,\n         * certain aspects may differ from default (1.0) processing: for example,\n         * XML declaration will be automatically added (regardless of setting\n         * <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n         * control characters (Ascii codes 0 through 31) as well as additional linefeeds\n         * and name characters.\n         */\n        WRITE_XML_1_1(false)\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n\n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n\n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    final protected XMLStreamWriter2 _xmlWriter;\n\n    final protected XMLStreamWriter _originalXmlWriter;\n    \n    /**\n     * Marker flag set if the underlying stream writer has to emulate\n     * Stax2 API: this is problematic if trying to use {@link #writeRaw} calls.\n     */\n    final protected boolean _stax2Emulation;\n    \n    final protected IOContext _ioContext;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link ToXmlGenerator.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    /**\n     * We may need to use XML-specific indentation as well\n     */\n    protected XmlPrettyPrinter _xmlPrettyPrinter;\n    \n    /*\n    /**********************************************************\n    /* XML Output state\n    /**********************************************************\n     */\n\n    /**\n     * Marker set when {@link #initGenerator()} has been called or not.\n     * \n     * @since 2.2\n     */\n    protected boolean _initialized;\n    \n    /**\n     * Element or attribute name to use for next output call.\n     * Assigned by either code that initiates serialization\n     * or bean serializer.\n     */\n    protected QName _nextName = null;\n\n    /**\n     * Marker flag that indicates whether next name to write\n     * implies an attribute (true) or element (false)\n     */\n    protected boolean _nextIsAttribute = false;\n\n    /**\n     * Marker flag used to indicate that the next write of a (property)\n     * value should be done without using surrounding start/end\n     * elements. Flag is to be cleared once unwrapping has been triggered\n     * once.\n     */\n    protected boolean _nextIsUnwrapped = false;\n\n    /**\n     * Marker flag used to indicate that the next write of a (property)\n     * value should be as CData\n     */\n    protected boolean _nextIsCData = false;\n    \n    /**\n     * To support proper serialization of arrays it is necessary to keep\n     * stack of element names, so that we can \"revert\" to earlier \n     */\n    protected LinkedList<QName> _elementNameStack = new LinkedList<QName>();\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamWriter sw)\n    {\n        super(stdFeatures, codec);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _originalXmlWriter = sw;\n        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n        _stax2Emulation = (_xmlWriter != sw);\n        _xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n        \t\t(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n    }\n\n    /**\n     * Method called before writing any other output, to optionally\n     * output XML declaration.\n     */\n    public void initGenerator()  throws IOException\n    {\n        if (_initialized) {\n            return;\n        }\n        _initialized = true;\n        try {\n            if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n            } else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n            } else {\n                return;\n            }\n            // as per [dataformat-xml#172], try adding indentation\n            if (_xmlPrettyPrinter != null) {\n                // ... but only if it is likely to succeed:\n                if (!_stax2Emulation) {\n                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods, configuration\n    /**********************************************************\n     */\n\n    @Override\n    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultXmlPrettyPrinter();\n    }\n\n    @Override\n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        _xmlPrettyPrinter = (pp instanceof XmlPrettyPrinter) ?\n               (XmlPrettyPrinter) pp : null;\n        return this;\n    }\n\n    @Override\n    public Object getOutputTarget() {\n        // Stax2 does not expose underlying target, so best we can do is to return\n        // the Stax XMLStreamWriter instance:\n        return _originalXmlWriter;\n    }\n\n    /**\n     * Stax2 does not expose buffered content amount, so we can only return\n     * <code>-1</code> from here\n     */\n    @Override\n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override // since 2.7\n    public JsonGenerator overrideFormatFeatures(int values, int mask)\n    {\n        int oldF = _formatFeatures;\n        int newF = (_formatFeatures & ~mask) | (values & mask);\n\n        if (oldF != newF) {\n            _formatFeatures = newF;\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public ToXmlGenerator enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public ToXmlGenerator disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public ToXmlGenerator configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    @Override\n    public boolean canWriteFormattedNumbers() { return true; }\n\n    // @since 2.7.5\n    public boolean inRoot() {\n        return _writeContext.inRoot();\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamWriter getStaxWriter() {\n        return _xmlWriter;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, passing XML specific settings\n    /**********************************************************\n     */\n\n    public void setNextIsAttribute(boolean isAttribute)\n    {\n        _nextIsAttribute = isAttribute;\n    }\n\n    public void setNextIsUnwrapped(boolean isUnwrapped)\n    {\n        _nextIsUnwrapped = isUnwrapped;\n    }\n\n    public void setNextIsCData(boolean isCData)\n    {\n        _nextIsCData = isCData;\n    }\n    \n    public final void setNextName(QName name)\n    {\n        _nextName = name;\n    }\n\n    /**\n     * Method that does same as {@link #setNextName}, unless\n     * a name has already been set.\n     * \n     * @since 2.1.2\n     */\n    public final boolean setNextNameIfMissing(QName name)\n    {\n        if (_nextName == null) {\n            _nextName = name;\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Methdod called when a structured (collection, array, map) is being\n     * output.\n     * \n     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n     * @param wrappedName Element used around individual content items (can not\n     *   be null)\n     */\n    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeStartElement(_xmlWriter,\n                            wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                } else {\n                    _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n        this.setNextName(wrappedName);\n    }\n\n    /**\n     * Method called after a structured collection output has completed\n     */\n    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        // First: wrapper to close?\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeEndElement(_xmlWriter, _writeContext.getEntryCount());\n                } else {\n                    _xmlWriter.writeEndElement();\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n    }\n\n    /**\n     * Trivial helper method called when to add a replicated wrapper name\n     * \n     * @since 2.2\n     */\n    public void writeRepeatedFieldName() throws IOException\n    {\n        if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator method overrides\n    /**********************************************************\n     */\n    \n    /* Most overrides in this section are just to make methods final,\n     * to allow better inlining...\n     */\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        // Should this ever get called?\n        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n        setNextName(new QName(ns, name));\n    }\n    \n    @Override\n    public final void writeStringField(String fieldName, String value) throws IOException\n    {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    // 03-Aug-2017, tatu: We could use this as mentioned in comment below BUT\n    //    since there is no counterpart for deserialization this will not\n    //    help us. Approaches that could/would help probably require different\n    //    handling...\n    //\n    //    See [dataformat-xml#4] for more context.\n    \n    /*\n    // @since 2.9\n    public WritableTypeId writeTypePrefix(WritableTypeId typeIdDef) throws IOException\n    {\n        // 03-Aug-2017, tatu: Due to XML oddities, we do need to massage things\n        //     a bit: specifically, change WRAPPER_ARRAY into WRAPPER_OBJECT, always\n        if (typeIdDef.include == WritableTypeId.Inclusion.WRAPPER_ARRAY) {\n            typeIdDef.include = WritableTypeId.Inclusion.WRAPPER_OBJECT;\n        }\n        return super.writeTypePrefix(typeIdDef);\n    }\n    */\n\n    /*\n    /**********************************************************\n    /* JsonGenerator output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            // nothing to do here; no-operation\n        }\n    }\n    \n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not Array but \"+_writeContext.typeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            // nothing to do here; no-operation\n        }\n        _writeContext = _writeContext.getParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            _handleStartObject();\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n        }\n        _writeContext = _writeContext.getParent();\n        if (_cfgPrettyPrinter != null) {\n            // as per [Issue#45], need to suppress indentation if only attributes written:\n            int count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n            _cfgPrettyPrinter.writeEndObject(this, count);\n        } else {\n            _handleEndObject();\n        }\n    }\n\n    // note: public just because pretty printer needs to make a callback\n    public final void _handleStartObject() throws IOException\n    {\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        // Need to keep track of names to make Lists work correctly\n        _elementNameStack.addLast(_nextName);\n        try {\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    // note: public just because pretty printer needs to make a callback\n    public final void _handleEndObject() throws IOException\n    {\n        // We may want to repeat same element, so:\n        if (_elementNameStack.isEmpty()) {\n            throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n        }\n        _nextName = _elementNameStack.removeLast();\n        try {\n            // note: since attributes don't nest, can only have one attribute active, so:\n            _nextIsAttribute = false;\n            _xmlWriter.writeEndElement();\n            // [databind-xml#172]: possibly also need indentation\n            if (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n                // ... but only if it is likely to succeed:\n                if (!_stax2Emulation) {\n                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        writeFieldName(name.getValue());\n    }\n    \n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) { // must write attribute name and value with one call\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else if (checkNextIsUnwrapped()) {\n                // [Issue#56] Should figure out how to prevent indentation for end element\n                //   but for now, let's just make sure structure is correct\n                //if (_xmlPrettyPrinter != null) { ... }\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n                _xmlWriter.writeEndElement();\n            } \n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }    \n    \n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, offset, len, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text.substring(offset, offset + len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        _verifyValueWrite(\"write raw value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException\n    {\n        writeRaw(String.valueOf(c));\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n    \t\tbyte[] data, int offset, int len) throws IOException\n    {\n        if (data == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write Binary value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                // Stax2 API only has 'full buffer' write method:\n                byte[] fullBuffer = toFullBuffer(data, offset, len);\n                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeBinary(data, offset, len);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            data, offset, len);\n                } else {\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                    _xmlWriter.writeBinary(data, offset, len);\n                    _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n                // Stax2 API only has 'full buffer' write method:\n              // should we consider pretty-printing or not?\n\n\n\n        // base64 encodes up to 3 bytes into a 4 bytes string\n\n        // we still have < 3 bytes in the buffer\n\n    \n    private byte[] toFullBuffer(byte[] data, int offset, int len)\n    {\n        // might already be ok:\n        if (offset == 0 && len == data.length) {\n            return data;\n        }\n        byte[] result = new byte[len];\n        if (len > 0) {\n            System.arraycopy(data, offset, result, 0, len);\n        }\n        return result;\n    }\n\n\n\n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBoolean(boolean value) throws IOException\n    {\n        _verifyValueWrite(\"write boolean value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeBoolean(value);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tvalue);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeBoolean(value);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(\"write null value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        // !!! TODO: proper use of 'xsd:isNil' ?\n        try {\n            if (_nextIsAttribute) {\n                /* With attributes, best just leave it out, right? (since there's no way\n                 * to use 'xsi:nil')\n                 */\n            } else if (checkNextIsUnwrapped()) {\n            \t// as with above, best left unwritten?\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                } else {\n\t            \t_xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeInt(i);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\ti);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeInt(i);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeLong(l);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tl);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeLong(l);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeDouble(d);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\td);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeDouble(d);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeFloat(f);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tf);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeFloat(f);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException\n    {\n        if (dec == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        boolean usePlain = isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        try {\n            if (_nextIsAttribute) {\n                if (usePlain) {\n                    _xmlWriter.writeAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            dec.toPlainString());\n                } else {\n                    _xmlWriter.writeDecimalAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n                }\n            } else if (checkNextIsUnwrapped()) {\n                if (usePlain) {\n                    _xmlWriter.writeCharacters(dec.toPlainString());\n                } else {\n                    _xmlWriter.writeDecimal(dec);\n                }\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tdec);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                if (usePlain) {\n                         _xmlWriter.writeCharacters(dec.toPlainString());\n\t                } else {\n                         _xmlWriter.writeDecimal(dec);\n\t                }\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeIntegerAttribute(\"\",\n                \t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeInteger(value);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tvalue);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeInteger(value);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException\n    {\n        writeString(encodedValue);\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations, overrides for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n            try {\n                _xmlWriter.flush();\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n//        boolean wasClosed = _closed;\n        super.close();\n\n        // First: let's see that we still have buffers...\n        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            try {\n                while (true) {\n\t\t    /* 28-May-2016, tatu: To work around incompatibility introduced by\n\t\t     *     `jackson-core` 2.8 where return type of `getOutputContext()`\n\t\t     *     changed, let's do direct access here.\n\t\t     */\n//                    JsonStreamContext ctxt = getOutputContext();\n\t\t    JsonStreamContext ctxt = _writeContext;\n                    if (ctxt.inArray()) {\n                        writeEndArray();\n                    } else if (ctxt.inObject()) {\n                        writeEndObject();\n                    } else {\n                        break;\n                    }\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n                 *   hit by this as a collateral problem in some cases. Yuck.\n                 */\n                throw new JsonGenerationException(e, this);\n            }\n        }\n        try {\n            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n                _xmlWriter.closeCompletely();\n            } else {\n                _xmlWriter.close();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        // Nothing to do here, as we have no buffers\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to see if unwrapping is required; and if so,\n     * clear the flag (so further calls will return 'false' unless\n     * state is re-set)\n     */\n    protected boolean checkNextIsUnwrapped()\n    {\n        if (_nextIsUnwrapped) {\n    \t\t    _nextIsUnwrapped = false;\n    \t\t    return true;\n        }\n        return false;\n    }\n    \n    protected void handleMissingName() {\n        throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n    }\n\n    /**\n     * Method called in case access to native Stax2 API implementation is required.\n     */\n    protected void  _reportUnimplementedStax2(String missingMethod) throws IOException\n    {\n        throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \"\n                +_originalXmlWriter.getClass().getName()\n                +\") does not implement Stax2 API natively and is missing method '\"\n                +missingMethod+\"': this breaks functionality such as indentation that relies on it. \"\n                +\"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\",\n                this);\n    }\n}\n", "fixed_version": "package com.fasterxml.jackson.dataformat.xml.ser;\n\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamWriter;\n\nimport org.codehaus.stax2.XMLStreamWriter2;\nimport org.codehaus.stax2.ri.Stax2WriterAdapter;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.GeneratorBase;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.json.JsonWriteContext;\nimport com.fasterxml.jackson.dataformat.xml.XmlPrettyPrinter;\nimport com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n/**\n * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n * Operation requires calling code (usually either standard Jackson serializers,\n * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n * additional configuration calls beyond regular {@link JsonGenerator} API,\n * mostly to pass namespace information.\n */\npublic final class ToXmlGenerator\n    extends GeneratorBase\n{\n    /**\n     * If we support optional definition of element names, this is the element\n     * name to use...\n     */\n    protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n    \n    /**\n     * Enumeration that defines all togglable extra XML-specific features\n     */\n    public enum Feature implements FormatFeature\n    {\n        /**\n         * Feature that controls whether XML declaration should be written before\n         * when generator is initialized (true) or not (false)\n         */\n        WRITE_XML_DECLARATION(false),\n\n        /**\n         * Feature that controls whether output should be done as XML 1.1; if so,\n         * certain aspects may differ from default (1.0) processing: for example,\n         * XML declaration will be automatically added (regardless of setting\n         * <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n         * control characters (Ascii codes 0 through 31) as well as additional linefeeds\n         * and name characters.\n         */\n        WRITE_XML_1_1(false)\n        ;\n\n        final boolean _defaultState;\n        final int _mask;\n\n        /**\n         * Method that calculates bit set (flags) of all features that\n         * are enabled by default.\n         */\n        public static int collectDefaults()\n        {\n            int flags = 0;\n            for (Feature f : values()) {\n                if (f.enabledByDefault()) {\n                    flags |= f.getMask();\n                }\n            }\n            return flags;\n        }\n\n        private Feature(boolean defaultState) {\n            _defaultState = defaultState;\n            _mask = (1 << ordinal());\n        }\n\n        @Override public boolean enabledByDefault() { return _defaultState; }\n        @Override public int getMask() { return _mask; }\n        @Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n    }\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    final protected XMLStreamWriter2 _xmlWriter;\n\n    final protected XMLStreamWriter _originalXmlWriter;\n    \n    /**\n     * Marker flag set if the underlying stream writer has to emulate\n     * Stax2 API: this is problematic if trying to use {@link #writeRaw} calls.\n     */\n    final protected boolean _stax2Emulation;\n    \n    final protected IOContext _ioContext;\n\n    /**\n     * Bit flag composed of bits that indicate which\n     * {@link ToXmlGenerator.Feature}s\n     * are enabled.\n     */\n    protected int _formatFeatures;\n\n    /**\n     * We may need to use XML-specific indentation as well\n     */\n    protected XmlPrettyPrinter _xmlPrettyPrinter;\n    \n    /*\n    /**********************************************************\n    /* XML Output state\n    /**********************************************************\n     */\n\n    /**\n     * Marker set when {@link #initGenerator()} has been called or not.\n     * \n     * @since 2.2\n     */\n    protected boolean _initialized;\n    \n    /**\n     * Element or attribute name to use for next output call.\n     * Assigned by either code that initiates serialization\n     * or bean serializer.\n     */\n    protected QName _nextName = null;\n\n    /**\n     * Marker flag that indicates whether next name to write\n     * implies an attribute (true) or element (false)\n     */\n    protected boolean _nextIsAttribute = false;\n\n    /**\n     * Marker flag used to indicate that the next write of a (property)\n     * value should be done without using surrounding start/end\n     * elements. Flag is to be cleared once unwrapping has been triggered\n     * once.\n     */\n    protected boolean _nextIsUnwrapped = false;\n\n    /**\n     * Marker flag used to indicate that the next write of a (property)\n     * value should be as CData\n     */\n    protected boolean _nextIsCData = false;\n    \n    /**\n     * To support proper serialization of arrays it is necessary to keep\n     * stack of element names, so that we can \"revert\" to earlier \n     */\n    protected LinkedList<QName> _elementNameStack = new LinkedList<QName>();\n    \n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\n            ObjectCodec codec, XMLStreamWriter sw)\n    {\n        super(stdFeatures, codec);\n        _formatFeatures = xmlFeatures;\n        _ioContext = ctxt;\n        _originalXmlWriter = sw;\n        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n        _stax2Emulation = (_xmlWriter != sw);\n        _xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n        \t\t(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n    }\n\n    /**\n     * Method called before writing any other output, to optionally\n     * output XML declaration.\n     */\n    public void initGenerator()  throws IOException\n    {\n        if (_initialized) {\n            return;\n        }\n        _initialized = true;\n        try {\n            if (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n            } else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n            } else {\n                return;\n            }\n            // as per [dataformat-xml#172], try adding indentation\n            if (_xmlPrettyPrinter != null) {\n                // ... but only if it is likely to succeed:\n                if (!_stax2Emulation) {\n                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Overridden methods, configuration\n    /**********************************************************\n     */\n\n    @Override\n    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n        return new DefaultXmlPrettyPrinter();\n    }\n\n    @Override\n    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n        _cfgPrettyPrinter = pp;\n        _xmlPrettyPrinter = (pp instanceof XmlPrettyPrinter) ?\n               (XmlPrettyPrinter) pp : null;\n        return this;\n    }\n\n    @Override\n    public Object getOutputTarget() {\n        // Stax2 does not expose underlying target, so best we can do is to return\n        // the Stax XMLStreamWriter instance:\n        return _originalXmlWriter;\n    }\n\n    /**\n     * Stax2 does not expose buffered content amount, so we can only return\n     * <code>-1</code> from here\n     */\n    @Override\n    public int getOutputBuffered() {\n        return -1;\n    }\n\n    @Override\n    public int getFormatFeatures() {\n        return _formatFeatures;\n    }\n\n    @Override // since 2.7\n    public JsonGenerator overrideFormatFeatures(int values, int mask)\n    {\n        int oldF = _formatFeatures;\n        int newF = (_formatFeatures & ~mask) | (values & mask);\n\n        if (oldF != newF) {\n            _formatFeatures = newF;\n        }\n        return this;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, configuration\n    /**********************************************************\n     */\n\n    public ToXmlGenerator enable(Feature f) {\n        _formatFeatures |= f.getMask();\n        return this;\n    }\n\n    public ToXmlGenerator disable(Feature f) {\n        _formatFeatures &= ~f.getMask();\n        return this;\n    }\n\n    public final boolean isEnabled(Feature f) {\n        return (_formatFeatures & f.getMask()) != 0;\n    }\n\n    public ToXmlGenerator configure(Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    @Override\n    public boolean canWriteFormattedNumbers() { return true; }\n\n    // @since 2.7.5\n    public boolean inRoot() {\n        return _writeContext.inRoot();\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API, access to some internal components\n    /**********************************************************\n     */\n\n    /**\n     * Method that allows application direct access to underlying\n     * Stax {@link XMLStreamWriter}. Note that use of writer is\n     * discouraged, and may interfere with processing of this writer;\n     * however, occasionally it may be necessary.\n     *<p>\n     * Note: writer instance will always be of type\n     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n     * Typed Access API) so upcasts are safe.\n     */\n    public XMLStreamWriter getStaxWriter() {\n        return _xmlWriter;\n    }\n    \n    /*\n    /**********************************************************\n    /* Extended API, passing XML specific settings\n    /**********************************************************\n     */\n\n    public void setNextIsAttribute(boolean isAttribute)\n    {\n        _nextIsAttribute = isAttribute;\n    }\n\n    public void setNextIsUnwrapped(boolean isUnwrapped)\n    {\n        _nextIsUnwrapped = isUnwrapped;\n    }\n\n    public void setNextIsCData(boolean isCData)\n    {\n        _nextIsCData = isCData;\n    }\n    \n    public final void setNextName(QName name)\n    {\n        _nextName = name;\n    }\n\n    /**\n     * Method that does same as {@link #setNextName}, unless\n     * a name has already been set.\n     * \n     * @since 2.1.2\n     */\n    public final boolean setNextNameIfMissing(QName name)\n    {\n        if (_nextName == null) {\n            _nextName = name;\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Methdod called when a structured (collection, array, map) is being\n     * output.\n     * \n     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n     * @param wrappedName Element used around individual content items (can not\n     *   be null)\n     */\n    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeStartElement(_xmlWriter,\n                            wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                } else {\n                    _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n        this.setNextName(wrappedName);\n    }\n\n    /**\n     * Method called after a structured collection output has completed\n     */\n    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException\n    {\n        // First: wrapper to close?\n        if (wrapperName != null) {\n            try {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeEndElement(_xmlWriter, _writeContext.getEntryCount());\n                } else {\n                    _xmlWriter.writeEndElement();\n                }\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n    }\n\n    /**\n     * Trivial helper method called when to add a replicated wrapper name\n     * \n     * @since 2.2\n     */\n    public void writeRepeatedFieldName() throws IOException\n    {\n        if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* JsonGenerator method overrides\n    /**********************************************************\n     */\n    \n    /* Most overrides in this section are just to make methods final,\n     * to allow better inlining...\n     */\n\n    @Override\n    public final void writeFieldName(String name) throws IOException\n    {\n        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n            _reportError(\"Can not write a field name, expecting a value\");\n        }\n        // Should this ever get called?\n        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n        setNextName(new QName(ns, name));\n    }\n    \n    @Override\n    public final void writeStringField(String fieldName, String value) throws IOException\n    {\n        writeFieldName(fieldName);\n        writeString(value);\n    }\n\n    // 03-Aug-2017, tatu: We could use this as mentioned in comment below BUT\n    //    since there is no counterpart for deserialization this will not\n    //    help us. Approaches that could/would help probably require different\n    //    handling...\n    //\n    //    See [dataformat-xml#4] for more context.\n    \n    /*\n    // @since 2.9\n    public WritableTypeId writeTypePrefix(WritableTypeId typeIdDef) throws IOException\n    {\n        // 03-Aug-2017, tatu: Due to XML oddities, we do need to massage things\n        //     a bit: specifically, change WRAPPER_ARRAY into WRAPPER_OBJECT, always\n        if (typeIdDef.include == WritableTypeId.Inclusion.WRAPPER_ARRAY) {\n            typeIdDef.include = WritableTypeId.Inclusion.WRAPPER_OBJECT;\n        }\n        return super.writeTypePrefix(typeIdDef);\n    }\n    */\n\n    /*\n    /**********************************************************\n    /* JsonGenerator output method implementations, structural\n    /**********************************************************\n     */\n\n    @Override\n    public final void writeStartArray() throws IOException\n    {\n        _verifyValueWrite(\"start an array\");\n        _writeContext = _writeContext.createChildArrayContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartArray(this);\n        } else {\n            // nothing to do here; no-operation\n        }\n    }\n    \n    @Override\n    public final void writeEndArray() throws IOException\n    {\n        if (!_writeContext.inArray()) {\n            _reportError(\"Current context not Array but \"+_writeContext.typeDesc());\n        }\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n        } else {\n            // nothing to do here; no-operation\n        }\n        _writeContext = _writeContext.getParent();\n    }\n\n    @Override\n    public final void writeStartObject() throws IOException\n    {\n        _verifyValueWrite(\"start an object\");\n        _writeContext = _writeContext.createChildObjectContext();\n        if (_cfgPrettyPrinter != null) {\n            _cfgPrettyPrinter.writeStartObject(this);\n        } else {\n            _handleStartObject();\n        }\n    }\n\n    @Override\n    public final void writeEndObject() throws IOException\n    {\n        if (!_writeContext.inObject()) {\n            _reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n        }\n        _writeContext = _writeContext.getParent();\n        if (_cfgPrettyPrinter != null) {\n            // as per [Issue#45], need to suppress indentation if only attributes written:\n            int count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n            _cfgPrettyPrinter.writeEndObject(this, count);\n        } else {\n            _handleEndObject();\n        }\n    }\n\n    // note: public just because pretty printer needs to make a callback\n    public final void _handleStartObject() throws IOException\n    {\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        // Need to keep track of names to make Lists work correctly\n        _elementNameStack.addLast(_nextName);\n        try {\n            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    // note: public just because pretty printer needs to make a callback\n    public final void _handleEndObject() throws IOException\n    {\n        // We may want to repeat same element, so:\n        if (_elementNameStack.isEmpty()) {\n            throw new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n        }\n        _nextName = _elementNameStack.removeLast();\n        try {\n            // note: since attributes don't nest, can only have one attribute active, so:\n            _nextIsAttribute = false;\n            _xmlWriter.writeEndElement();\n            // [databind-xml#172]: possibly also need indentation\n            if (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n                // ... but only if it is likely to succeed:\n                if (!_stax2Emulation) {\n                    _xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, textual\n    /**********************************************************\n     */\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException\n    {\n        writeFieldName(name.getValue());\n    }\n    \n    @Override\n    public void writeString(String text) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) { // must write attribute name and value with one call\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else if (checkNextIsUnwrapped()) {\n                // [Issue#56] Should figure out how to prevent indentation for end element\n                //   but for now, let's just make sure structure is correct\n                //if (_xmlPrettyPrinter != null) { ... }\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text);\n                } else {\n                    _xmlWriter.writeCharacters(text);\n                }\n                _xmlWriter.writeEndElement();\n            } \n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }    \n    \n    @Override\n    public void writeString(char[] text, int offset, int len) throws IOException\n    {\n        _verifyValueWrite(\"write String value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n            } else if (_xmlPrettyPrinter != null) {\n                _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                        _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                        text, offset, len, _nextIsCData);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                if(_nextIsCData) {\n                    _xmlWriter.writeCData(text, offset, len);\n                } else {\n                    _xmlWriter.writeCharacters(text, offset, len);\n                }\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeString(SerializableString text) throws IOException {\n        writeString(text.getValue());\n    }\n    \n    @Override\n    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n    {\n        // could add support for this case if we really want it (and can make Stax2 support it)\n        _reportUnsupportedOperation();\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, unprocessed (\"raw\")\n    /**********************************************************\n     */\n\n    @Override\n    public void writeRawValue(String text) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(String text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        try {\n            _verifyValueWrite(\"write raw value\");\n            if (_nextName == null) {\n                handleMissingName();\n            }\n\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text.substring(offset, offset + len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRawValue\");\n        }\n        _verifyValueWrite(\"write raw value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n            } else {\n                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                _xmlWriter.writeRaw(text, offset, len);\n                _xmlWriter.writeEndElement();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRawValue(SerializableString text) throws IOException {\n        _reportUnsupportedOperation();\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(String text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char[] text, int offset, int len) throws IOException\n    {\n        // [dataformat-xml#39]\n        if (_stax2Emulation) {\n            _reportUnimplementedStax2(\"writeRaw\");\n        }\n        try {\n            _xmlWriter.writeRaw(text, offset, len);\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeRaw(char c) throws IOException\n    {\n        writeRaw(String.valueOf(c));\n    }\n    \n    /*\n    /**********************************************************\n    /* Output method implementations, base64-encoded binary\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBinary(Base64Variant b64variant,\n    \t\tbyte[] data, int offset, int len) throws IOException\n    {\n        if (data == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write Binary value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                // Stax2 API only has 'full buffer' write method:\n                byte[] fullBuffer = toFullBuffer(data, offset, len);\n                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeBinary(data, offset, len);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            data, offset, len);\n                } else {\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                    _xmlWriter.writeBinary(data, offset, len);\n                    _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException\n    {\n        if (data == null) {\n            writeNull();\n            return 0;\n        }\n        _verifyValueWrite(\"write Binary value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                // Stax2 API only has 'full buffer' write method:\n                byte[] fullBuffer = toFullBuffer(data, dataLength);\n                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n            } else if (checkNextIsUnwrapped()) {\n              // should we consider pretty-printing or not?\n                writeStreamAsBinary(data, dataLength);\n\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            toFullBuffer(data, dataLength), 0, dataLength);\n                } else {\n                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                    writeStreamAsBinary(data, dataLength);\n                    _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n\n        return dataLength;\n    }\n\n    private void writeStreamAsBinary(InputStream data, int len) throws IOException, XMLStreamException \n    {\n        // base64 encodes up to 3 bytes into a 4 bytes string\n        byte[] tmp = new byte[3];\n        int offset = 0;\n        int read;\n        while((read = data.read(tmp, offset, Math.min(3 - offset, len))) != -1) {\n            offset += read;\n            len -= read;\n            if(offset == 3) {\n                offset = 0;\n                _xmlWriter.writeBinary(tmp, 0, 3);\n            }\n            if (len == 0) {\n                break;\n            }\n        }\n\n        // we still have < 3 bytes in the buffer\n        if(offset > 0) {\n            _xmlWriter.writeBinary(tmp, 0, offset);\n        }\n    }\n\n    \n    private byte[] toFullBuffer(byte[] data, int offset, int len)\n    {\n        // might already be ok:\n        if (offset == 0 && len == data.length) {\n            return data;\n        }\n        byte[] result = new byte[len];\n        if (len > 0) {\n            System.arraycopy(data, offset, result, 0, len);\n        }\n        return result;\n    }\n\n    private byte[] toFullBuffer(InputStream data, final int len) throws IOException \n    {\n        byte[] result = new byte[len];\n        int offset = 0;\n\n        for (; offset < len; ) {\n            int count = data.read(result, offset, len - offset);\n            if (count < 0) {\n                _reportError(\"Too few bytes available: missing \"+(len - offset)+\" bytes (out of \"+len+\")\");\n            }\n            offset += count;\n        }\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Output method implementations, primitive\n    /**********************************************************\n     */\n\n    @Override\n    public void writeBoolean(boolean value) throws IOException\n    {\n        _verifyValueWrite(\"write boolean value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeBoolean(value);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tvalue);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeBoolean(value);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNull() throws IOException\n    {\n        _verifyValueWrite(\"write null value\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        // !!! TODO: proper use of 'xsd:isNil' ?\n        try {\n            if (_nextIsAttribute) {\n                /* With attributes, best just leave it out, right? (since there's no way\n                 * to use 'xsi:nil')\n                 */\n            } else if (checkNextIsUnwrapped()) {\n            \t// as with above, best left unwritten?\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                } else {\n\t            \t_xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(int i) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n            } else if (checkNextIsUnwrapped()) {\n            \t// should we consider pretty-printing or not?\n                _xmlWriter.writeInt(i);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\ti);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeInt(i);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(long l) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeLong(l);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tl);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeLong(l);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(double d) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeDouble(d);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\td);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeDouble(d);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(float f) throws IOException\n    {\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeFloat(f);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tf);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeFloat(f);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigDecimal dec) throws IOException\n    {\n        if (dec == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        boolean usePlain = isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n        try {\n            if (_nextIsAttribute) {\n                if (usePlain) {\n                    _xmlWriter.writeAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                            dec.toPlainString());\n                } else {\n                    _xmlWriter.writeDecimalAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n                }\n            } else if (checkNextIsUnwrapped()) {\n                if (usePlain) {\n                    _xmlWriter.writeCharacters(dec.toPlainString());\n                } else {\n                    _xmlWriter.writeDecimal(dec);\n                }\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tdec);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                if (usePlain) {\n                         _xmlWriter.writeCharacters(dec.toPlainString());\n\t                } else {\n                         _xmlWriter.writeDecimal(dec);\n\t                }\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(BigInteger value) throws IOException\n    {\n        if (value == null) {\n            writeNull();\n            return;\n        }\n        _verifyValueWrite(\"write number\");\n        if (_nextName == null) {\n            handleMissingName();\n        }\n        try {\n            if (_nextIsAttribute) {\n                _xmlWriter.writeIntegerAttribute(\"\",\n                \t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n            } else if (checkNextIsUnwrapped()) {\n                _xmlWriter.writeInteger(value);\n            } else {\n                if (_xmlPrettyPrinter != null) {\n                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                \t\t\tvalue);\n                } else {\n\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n\t                _xmlWriter.writeInteger(value);\n\t                _xmlWriter.writeEndElement();\n                }\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException\n    {\n        writeString(encodedValue);\n    }\n\n    /*\n    /**********************************************************\n    /* Implementations, overrides for other methods\n    /**********************************************************\n     */\n\n    @Override\n    protected final void _verifyValueWrite(String typeMsg) throws IOException\n    {\n        int status = _writeContext.writeValue();\n        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level output handling\n    /**********************************************************\n     */\n\n    @Override\n    public void flush() throws IOException\n    {\n        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n            try {\n                _xmlWriter.flush();\n            } catch (XMLStreamException e) {\n                StaxUtil.throwAsGenerationException(e, this);\n            }\n        }\n    }\n\n    @Override\n    public void close() throws IOException\n    {\n//        boolean wasClosed = _closed;\n        super.close();\n\n        // First: let's see that we still have buffers...\n        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n            try {\n                while (true) {\n\t\t    /* 28-May-2016, tatu: To work around incompatibility introduced by\n\t\t     *     `jackson-core` 2.8 where return type of `getOutputContext()`\n\t\t     *     changed, let's do direct access here.\n\t\t     */\n//                    JsonStreamContext ctxt = getOutputContext();\n\t\t    JsonStreamContext ctxt = _writeContext;\n                    if (ctxt.inArray()) {\n                        writeEndArray();\n                    } else if (ctxt.inObject()) {\n                        writeEndObject();\n                    } else {\n                        break;\n                    }\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n                 *   hit by this as a collateral problem in some cases. Yuck.\n                 */\n                throw new JsonGenerationException(e, this);\n            }\n        }\n        try {\n            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n                _xmlWriter.closeCompletely();\n            } else {\n                _xmlWriter.close();\n            }\n        } catch (XMLStreamException e) {\n            StaxUtil.throwAsGenerationException(e, this);\n        }\n    }\n\n    @Override\n    protected void _releaseBuffers() {\n        // Nothing to do here, as we have no buffers\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * Method called to see if unwrapping is required; and if so,\n     * clear the flag (so further calls will return 'false' unless\n     * state is re-set)\n     */\n    protected boolean checkNextIsUnwrapped()\n    {\n        if (_nextIsUnwrapped) {\n    \t\t    _nextIsUnwrapped = false;\n    \t\t    return true;\n        }\n        return false;\n    }\n    \n    protected void handleMissingName() {\n        throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n    }\n\n    /**\n     * Method called in case access to native Stax2 API implementation is required.\n     */\n    protected void  _reportUnimplementedStax2(String missingMethod) throws IOException\n    {\n        throw new JsonGenerationException(\"Underlying Stax XMLStreamWriter (of type \"\n                +_originalXmlWriter.getClass().getName()\n                +\") does not implement Stax2 API natively and is missing method '\"\n                +missingMethod+\"': this breaks functionality such as indentation that relies on it. \"\n                +\"You need to upgrade to using compliant Stax implementation like Woodstox or Aalto\",\n                this);\n    }\n}\n"}]}
