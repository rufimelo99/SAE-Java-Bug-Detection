{"project": "Chart", "bug_id": 1, "classes_modified": [{"class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2010, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------------------------\n * AbstractCategoryItemRenderer.java\n * ---------------------------------\n * (C) Copyright 2002-2010, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Richard Atkinson;\n *                   Peter Kolb (patch 2497611);\n *\n * Changes:\n * --------\n * 29-May-2002 : Version 1 (DG);\n * 06-Jun-2002 : Added accessor methods for the tool tip generator (DG);\n * 11-Jun-2002 : Made constructors protected (DG);\n * 26-Jun-2002 : Added axis to initialise method (DG);\n * 05-Aug-2002 : Added urlGenerator member variable plus accessors (RA);\n * 22-Aug-2002 : Added categoriesPaint attribute, based on code submitted by\n *               Janet Banks.  This can be used when there is only one series,\n *               and you want each category item to have a different color (DG);\n * 01-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 29-Oct-2002 : Fixed bug where background image for plot was not being\n *               drawn (DG);\n * 05-Nov-2002 : Replaced references to CategoryDataset with TableDataset (DG);\n * 26-Nov 2002 : Replaced the isStacked() method with getRangeType() (DG);\n * 09-Jan-2003 : Renamed grid-line methods (DG);\n * 17-Jan-2003 : Moved plot classes into separate package (DG);\n * 25-Mar-2003 : Implemented Serializable (DG);\n * 12-May-2003 : Modified to take into account the plot orientation (DG);\n * 12-Aug-2003 : Very minor javadoc corrections (DB)\n * 13-Aug-2003 : Implemented Cloneable (DG);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 05-Nov-2003 : Fixed marker rendering bug (833623) (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 11-Feb-2004 : Modified labelling for markers (DG);\n * 12-Feb-2004 : Updated clone() method (DG);\n * 15-Apr-2004 : Created a new CategoryToolTipGenerator interface (DG);\n * 05-May-2004 : Fixed bug (948310) where interval markers extend outside axis\n *               range (DG);\n * 14-Jun-2004 : Fixed bug in drawRangeMarker() method - now uses 'paint' and\n *               'stroke' rather than 'outlinePaint' and 'outlineStroke' (DG);\n * 15-Jun-2004 : Interval markers can now use GradientPaint (DG);\n * 30-Sep-2004 : Moved drawRotatedString() from RefineryUtilities\n *               --> TextUtilities (DG);\n * 01-Oct-2004 : Fixed bug 1029697, problem with label alignment in\n *               drawRangeMarker() method (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() (DG);\n * 21-Jan-2005 : Modified return type of calculateRangeMarkerTextAnchorPoint()\n *               method (DG);\n * 08-Mar-2005 : Fixed positioning of marker labels (DG);\n * 20-Apr-2005 : Added legend label, tooltip and URL generators (DG);\n * 01-Jun-2005 : Handle one dimension of the marker label adjustment\n *               automatically (DG);\n * 09-Jun-2005 : Added utility method for adding an item entity (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 01-Mar-2006 : Updated getLegendItems() to check seriesVisibleInLegend\n *               flags (DG);\n * 20-Jul-2006 : Set dataset and series indices in LegendItem (DG);\n * 23-Oct-2006 : Draw outlines for interval markers (DG);\n * 24-Oct-2006 : Respect alpha setting in markers, as suggested by Sergei\n *               Ivanov in patch 1567843 (DG);\n * 30-Nov-2006 : Added a check for series visibility in the getLegendItem()\n *               method (DG);\n * 07-Dec-2006 : Fix for equals() method (DG);\n * 22-Feb-2007 : Added createState() method (DG);\n * 01-Mar-2007 : Fixed interval marker drawing (patch 1670686 thanks to\n *               Sergei Ivanov) (DG);\n * 20-Apr-2007 : Updated getLegendItem() for renderer change, and deprecated\n *               itemLabelGenerator, toolTipGenerator and itemURLGenerator\n *               override fields (DG);\n * 18-May-2007 : Set dataset and seriesKey for LegendItem (DG);\n * 20-Jun-2007 : Removed deprecated code and removed JCommon dependencies (DG);\n * 27-Jun-2007 : Added some new methods with 'notify' argument, renamed\n *               methods containing 'ItemURL' to just 'URL' (DG);\n * 06-Jul-2007 : Added annotation support (DG);\n * 17-Jun-2008 : Apply legend shape, font and paint attributes (DG);\n * 26-Jun-2008 : Added crosshair support (DG);\n * 25-Nov-2008 : Fixed bug in findRangeBounds() method (DG);\n * 14-Jan-2009 : Update initialise() to store visible series indices (PK);\n * 21-Jan-2009 : Added drawRangeLine() method (DG);\n * 28-Jan-2009 : Updated for changes to CategoryItemRenderer interface (DG);\n * 27-Mar-2009 : Added new findRangeBounds() method to account for hidden\n *               series (DG);\n * 01-Apr-2009 : Added new addEntity() method (DG);\n * 09-Feb-2010 : Fixed bug 2947660 (DG);\n *\n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.RenderingSource;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.CategoryItemEntity;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.labels.CategoryItemLabelGenerator;\nimport org.jfree.chart.labels.CategorySeriesLabelGenerator;\nimport org.jfree.chart.labels.CategoryToolTipGenerator;\nimport org.jfree.chart.labels.ItemLabelPosition;\nimport org.jfree.chart.labels.StandardCategorySeriesLabelGenerator;\nimport org.jfree.chart.plot.CategoryCrosshairState;\nimport org.jfree.chart.plot.CategoryMarker;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.DrawingSupplier;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.PlotRenderingInfo;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.renderer.AbstractRenderer;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.CategoryURLGenerator;\nimport org.jfree.chart.util.GradientPaintTransformer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.LengthAdjustmentType;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryDatasetSelectionState;\nimport org.jfree.data.category.SelectableCategoryDataset;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * An abstract base class that you can use to implement a new\n * {@link CategoryItemRenderer}.  When you create a new\n * {@link CategoryItemRenderer} you are not required to extend this class,\n * but it makes the job easier.\n */\npublic abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n        implements CategoryItemRenderer, Cloneable, PublicCloneable,\n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 1247553218442497391L;\n\n    /** The plot that the renderer is assigned to. */\n    private CategoryPlot plot;\n\n    /** A list of item label generators (one per series). */\n    private ObjectList itemLabelGeneratorList;\n\n    /** The base item label generator. */\n    private CategoryItemLabelGenerator baseItemLabelGenerator;\n\n    /** A list of tool tip generators (one per series). */\n    private ObjectList toolTipGeneratorList;\n\n    /** The base tool tip generator. */\n    private CategoryToolTipGenerator baseToolTipGenerator;\n\n    /** A list of label generators (one per series). */\n    private ObjectList urlGeneratorList;\n\n    /** The base label generator. */\n    private CategoryURLGenerator baseURLGenerator;\n\n    /** The legend item label generator. */\n    private CategorySeriesLabelGenerator legendItemLabelGenerator;\n\n    /** The legend item tool tip generator. */\n    private CategorySeriesLabelGenerator legendItemToolTipGenerator;\n\n    /** The legend item URL generator. */\n    private CategorySeriesLabelGenerator legendItemURLGenerator;\n\n    /**\n     * Annotations to be drawn in the background layer ('underneath' the data\n     * items).\n     *\n     * @since 1.2.0\n     */\n    private List backgroundAnnotations;\n\n    /**\n     * Annotations to be drawn in the foreground layer ('on top' of the data\n     * items).\n     *\n     * @since 1.2.0\n     */\n    private List foregroundAnnotations;\n\n    /** The number of rows in the dataset (temporary record). */\n    private transient int rowCount;\n\n    /** The number of columns in the dataset (temporary record). */\n    private transient int columnCount;\n\n    /**\n     * Creates a new renderer with no tool tip generator and no URL generator.\n     * The defaults (no tool tip or URL generators) have been chosen to\n     * minimise the processing required to generate a default chart.  If you\n     * require tool tips or URLs, then you can easily add the required\n     * generators.\n     */\n    protected AbstractCategoryItemRenderer() {\n        this.itemLabelGeneratorList = new ObjectList();\n        this.toolTipGeneratorList = new ObjectList();\n        this.urlGeneratorList = new ObjectList();\n        this.legendItemLabelGenerator\n                = new StandardCategorySeriesLabelGenerator();\n        this.backgroundAnnotations = new ArrayList();\n        this.foregroundAnnotations = new ArrayList();\n    }\n\n    /**\n     * Returns the number of passes through the dataset required by the\n     * renderer.  This method returns <code>1</code>, subclasses should\n     * override if they need more passes.\n     *\n     * @return The pass count.\n     */\n    public int getPassCount() {\n        return 1;\n    }\n\n    /**\n     * Returns the plot that the renderer has been assigned to (where\n     * <code>null</code> indicates that the renderer is not currently assigned\n     * to a plot).\n     *\n     * @return The plot (possibly <code>null</code>).\n     *\n     * @see #setPlot(CategoryPlot)\n     */\n    public CategoryPlot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Sets the plot that the renderer has been assigned to.  This method is\n     * usually called by the {@link CategoryPlot}, in normal usage you\n     * shouldn't need to call this method directly.\n     *\n     * @param plot  the plot (<code>null</code> not permitted).\n     *\n     * @see #getPlot()\n     */\n    public void setPlot(CategoryPlot plot) {\n        if (plot == null) {\n            throw new IllegalArgumentException(\"Null 'plot' argument.\");\n        }\n        this.plot = plot;\n    }\n\n    // ITEM LABEL GENERATOR\n\n    /**\n     * Returns the item label generator for a data item.  This implementation\n     * returns the series item label generator if one is defined, otherwise\n     * it returns the default item label generator (which may be\n     * <code>null</code>).\n     *\n     * @param row  the row index (zero based).\n     * @param column  the column index (zero based).\n     * @param selected  is the item selected?\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public CategoryItemLabelGenerator getItemLabelGenerator(int row,\n            int column, boolean selected) {\n        CategoryItemLabelGenerator generator = (CategoryItemLabelGenerator)\n                this.itemLabelGeneratorList.get(row);\n        if (generator == null) {\n            generator = this.baseItemLabelGenerator;\n        }\n        return generator;\n    }\n\n    /**\n     * Returns the item label generator for a series.\n     *\n     * @param series  the series index (zero based).\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @see #setSeriesItemLabelGenerator(int, CategoryItemLabelGenerator)\n     */\n    public CategoryItemLabelGenerator getSeriesItemLabelGenerator(int series) {\n        return (CategoryItemLabelGenerator) this.itemLabelGeneratorList.get(\n                series);\n    }\n\n    /**\n     * Sets the item label generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getSeriesItemLabelGenerator(int)\n     */\n    public void setSeriesItemLabelGenerator(int series,\n            CategoryItemLabelGenerator generator) {\n        setSeriesItemLabelGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the item label generator for a series and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesItemLabelGenerator(int)\n     */\n    public void setSeriesItemLabelGenerator(int series,\n            CategoryItemLabelGenerator generator, boolean notify) {\n        this.itemLabelGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base item label generator.\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @see #setBaseItemLabelGenerator(CategoryItemLabelGenerator)\n     */\n    public CategoryItemLabelGenerator getBaseItemLabelGenerator() {\n        return this.baseItemLabelGenerator;\n    }\n\n    /**\n     * Sets the base item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getBaseItemLabelGenerator()\n     */\n    public void setBaseItemLabelGenerator(\n            CategoryItemLabelGenerator generator) {\n        setBaseItemLabelGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base item label generator and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getBaseItemLabelGenerator()\n     */\n    public void setBaseItemLabelGenerator(\n            CategoryItemLabelGenerator generator, boolean notify) {\n        this.baseItemLabelGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // TOOL TIP GENERATOR\n\n    /**\n     * Returns the tool tip generator that should be used for the specified\n     * item.  You can override this method if you want to return a different\n     * generator per item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public CategoryToolTipGenerator getToolTipGenerator(int row, int column,\n            boolean selected) {\n\n        CategoryToolTipGenerator result = null;\n        result = getSeriesToolTipGenerator(row);\n        if (result == null) {\n            result = this.baseToolTipGenerator;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the tool tip generator for the specified series (a \"layer 1\"\n     * generator).\n     *\n     * @param series  the series index (zero-based).\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setSeriesToolTipGenerator(int, CategoryToolTipGenerator)\n     */\n    public CategoryToolTipGenerator getSeriesToolTipGenerator(int series) {\n        return (CategoryToolTipGenerator) this.toolTipGeneratorList.get(series);\n    }\n\n    /**\n     * Sets the tool tip generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero-based).\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getSeriesToolTipGenerator(int)\n     */\n    public void setSeriesToolTipGenerator(int series,\n            CategoryToolTipGenerator generator) {\n        setSeriesToolTipGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the tool tip generator for a series and sends a\n     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param series  the series index (zero-based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesToolTipGenerator(int)\n     */\n    public void setSeriesToolTipGenerator(int series,\n            CategoryToolTipGenerator generator, boolean notify) {\n        this.toolTipGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base tool tip generator (the \"layer 2\" generator).\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setBaseToolTipGenerator(CategoryToolTipGenerator)\n     */\n    public CategoryToolTipGenerator getBaseToolTipGenerator() {\n        return this.baseToolTipGenerator;\n    }\n\n    /**\n     * Sets the base tool tip generator and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getBaseToolTipGenerator()\n     */\n    public void setBaseToolTipGenerator(CategoryToolTipGenerator generator) {\n        setBaseToolTipGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base tool tip generator and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getBaseToolTipGenerator()\n     */\n    public void setBaseToolTipGenerator(CategoryToolTipGenerator generator,\n            boolean notify) {\n        this.baseToolTipGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // URL GENERATOR\n\n    /**\n     * Returns the URL generator for a data item.\n     *\n     * @param row  the row index (zero based).\n     * @param column  the column index (zero based).\n     * @param selected  is the item selected?\n     *\n     * @return The URL generator.\n     *\n     * @since 1.2.0\n     */\n    public CategoryURLGenerator getURLGenerator(int row, int column, boolean\n            selected) {\n        CategoryURLGenerator generator\n                = (CategoryURLGenerator) this.urlGeneratorList.get(row);\n        if (generator == null) {\n            generator = this.baseURLGenerator;\n        }\n        return generator;\n    }\n\n    /**\n     * Returns the URL generator for a series.\n     *\n     * @param series  the series index (zero based).\n     *\n     * @return The URL generator for the series.\n     *\n     * @see #setSeriesURLGenerator(int, CategoryURLGenerator)\n     */\n    public CategoryURLGenerator getSeriesURLGenerator(int series) {\n        return (CategoryURLGenerator) this.urlGeneratorList.get(series);\n    }\n\n    /**\n     * Sets the URL generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator.\n     *\n     * @see #getSeriesURLGenerator(int)\n     */\n    public void setSeriesURLGenerator(int series,\n            CategoryURLGenerator generator) {\n        setSeriesURLGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the URL generator for a series and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesURLGenerator(int)\n     */\n    public void setSeriesURLGenerator(int series,\n            CategoryURLGenerator generator, boolean notify) {\n        this.urlGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base item URL generator.\n     *\n     * @return The item URL generator.\n     *\n     * @see #setBaseURLGenerator(CategoryURLGenerator)\n     */\n    public CategoryURLGenerator getBaseURLGenerator() {\n        return this.baseURLGenerator;\n    }\n\n    /**\n     * Sets the base item URL generator.\n     *\n     * @param generator  the item URL generator.\n     *\n     * @see #getBaseURLGenerator()\n     */\n    public void setBaseURLGenerator(CategoryURLGenerator generator) {\n        setBaseURLGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base item URL generator.\n     *\n     * @param generator  the item URL generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getBaseURLGenerator()\n     *\n     * @since 1.2.0\n     */\n    public void setBaseURLGenerator(CategoryURLGenerator generator,\n            boolean notify) {\n        this.baseURLGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // ANNOTATIONS\n\n    /**\n     * Adds an annotation and sends a {@link RendererChangeEvent} to all\n     * registered listeners.  The annotation is added to the foreground\n     * layer.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @since 1.2.0\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n        // defer argument checking\n        addAnnotation(annotation, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds an annotation to the specified layer.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     *\n     * @since 1.2.0\n     */\n    public void addAnnotation(CategoryAnnotation annotation, Layer layer) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        if (layer.equals(Layer.FOREGROUND)) {\n            this.foregroundAnnotations.add(annotation);\n            notifyListeners(new RendererChangeEvent(this));\n        }\n        else if (layer.equals(Layer.BACKGROUND)) {\n            this.backgroundAnnotations.add(annotation);\n            notifyListeners(new RendererChangeEvent(this));\n        }\n        else {\n            // should never get here\n            throw new RuntimeException(\"Unknown layer.\");\n        }\n    }\n    /**\n     * Removes the specified annotation and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation to remove (<code>null</code> not\n     *                    permitted).\n     *\n     * @return A boolean to indicate whether or not the annotation was\n     *         successfully removed.\n     *\n     * @since 1.2.0\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        boolean removed = this.foregroundAnnotations.remove(annotation);\n        removed = removed & this.backgroundAnnotations.remove(annotation);\n        notifyListeners(new RendererChangeEvent(this));\n        return removed;\n    }\n\n    /**\n     * Removes all annotations and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @since 1.2.0\n     */\n    public void removeAnnotations() {\n        this.foregroundAnnotations.clear();\n        this.backgroundAnnotations.clear();\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public void setLegendItemToolTipGenerator(\n            CategorySeriesLabelGenerator generator) {\n        this.legendItemToolTipGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item URL generator.\n     *\n     * @return The URL generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemURLGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemURLGenerator() {\n        return this.legendItemURLGenerator;\n    }\n\n    /**\n     * Sets the legend item URL generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getLegendItemURLGenerator()\n     */\n    public void setLegendItemURLGenerator(\n            CategorySeriesLabelGenerator generator) {\n        this.legendItemURLGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the number of rows in the dataset.  This value is updated in the\n     * {@link AbstractCategoryItemRenderer#initialise} method.\n     *\n     * @return The row count.\n     */\n    public int getRowCount() {\n        return this.rowCount;\n    }\n\n    /**\n     * Returns the number of columns in the dataset.  This value is updated in\n     * the {@link AbstractCategoryItemRenderer#initialise} method.\n     *\n     * @return The column count.\n     */\n    public int getColumnCount() {\n        return this.columnCount;\n    }\n\n    /**\n     * Creates a new state instance---this method is called from the\n     * {@link #initialise(Graphics2D, Rectangle2D, CategoryPlot, int,\n     * PlotRenderingInfo)} method.  Subclasses can override this method if\n     * they need to use a subclass of {@link CategoryItemRendererState}.\n     *\n     * @param info  collects plot rendering info (<code>null</code> permitted).\n     *\n     * @return The new state instance (never <code>null</code>).\n     *\n     * @since 1.0.5\n     */\n    protected CategoryItemRendererState createState(PlotRenderingInfo info) {\n        CategoryItemRendererState state = new CategoryItemRendererState(info);\n        int[] visibleSeriesTemp = new int[this.rowCount];\n        int visibleSeriesCount = 0;\n        for (int row = 0; row < this.rowCount; row++) {\n            if (isSeriesVisible(row)) {\n                visibleSeriesTemp[visibleSeriesCount] = row;\n                visibleSeriesCount++;\n            }\n        }\n        int[] visibleSeries = new int[visibleSeriesCount];\n        System.arraycopy(visibleSeriesTemp, 0, visibleSeries, 0,\n                visibleSeriesCount);\n        state.setVisibleSeriesArray(visibleSeries);\n        return state;\n    }\n\n    /**\n     * Initialises the renderer and returns a state object that will be used\n     * for the remainder of the drawing process for a single chart.  The state\n     * object allows for the fact that the renderer may be used simultaneously\n     * by multiple threads (each thread will work with a separate state object).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param info  an object for returning information about the structure of\n     *              the plot (<code>null</code> permitted).\n     *\n     * @return The renderer state.\n     */\n    public CategoryItemRendererState initialise(Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryDataset dataset,\n            PlotRenderingInfo info) {\n\n        setPlot(plot);\n        if (dataset != null) {\n            this.rowCount = dataset.getRowCount();\n            this.columnCount = dataset.getColumnCount();\n        }\n        else {\n            this.rowCount = 0;\n            this.columnCount = 0;\n        }\n        CategoryItemRendererState state = createState(info);\n\n        // determine if there is any selection state for the dataset\n        CategoryDatasetSelectionState selectionState = null;\n        if (dataset instanceof SelectableCategoryDataset) {\n            SelectableCategoryDataset scd = (SelectableCategoryDataset) dataset;\n            selectionState = scd.getSelectionState();\n        }\n        // if the selection state is still null, go to the selection source\n        // and ask if it has state...\n        if (selectionState == null && info != null) {\n            ChartRenderingInfo cri = info.getOwner();\n            if (cri != null) {\n                RenderingSource rs = cri.getRenderingSource();\n                selectionState = (CategoryDatasetSelectionState)\n                        rs.getSelectionState(dataset);\n            }\n        }\n        state.setSelectionState(selectionState);\n\n        return state;\n    }\n\n    /**\n     * Returns the range of values the renderer requires to display all the\n     * items from the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The range (or <code>null</code> if the dataset is\n     *         <code>null</code> or empty).\n     */\n    public Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, false);\n    }\n\n    /**\n     * Returns the range of values the renderer requires to display all the\n     * items from the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param includeInterval  include the y-interval if the dataset has one.\n     *\n     * @return The range (<code>null</code> if the dataset is <code>null</code>\n     *         or empty).\n     *\n     * @since 1.0.13\n     */\n    protected Range findRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            return null;\n        }\n        if (getDataBoundsIncludesVisibleSeriesOnly()) {\n            List visibleSeriesKeys = new ArrayList();\n            int seriesCount = dataset.getRowCount();\n            for (int s = 0; s < seriesCount; s++) {\n                if (isSeriesVisible(s)) {\n                    visibleSeriesKeys.add(dataset.getRowKey(s));\n                }\n            }\n            return DatasetUtilities.findRangeBounds(dataset,\n                    visibleSeriesKeys, includeInterval);\n        }\n        else {\n            return DatasetUtilities.findRangeBounds(dataset, includeInterval);\n        }\n    }\n\n    /**\n     * Returns the Java2D coordinate for the middle of the specified data item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param dataset  the dataset.\n     * @param axis  the axis.\n     * @param area  the data area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The Java2D coordinate for the middle of the item.\n     *\n     * @since 1.0.11\n     */\n    public double getItemMiddle(Comparable rowKey, Comparable columnKey,\n            CategoryDataset dataset, CategoryAxis axis, Rectangle2D area,\n            RectangleEdge edge) {\n        return axis.getCategoryMiddle(columnKey, dataset.getColumnKeys(), area,\n                edge);\n    }\n\n    /**\n     * Draws a background for the data area.  The default implementation just\n     * gets the plot to draw the background, but some renderers will override\n     * this behaviour.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     */\n    public void drawBackground(Graphics2D g2,\n                               CategoryPlot plot,\n                               Rectangle2D dataArea) {\n\n        plot.drawBackground(g2, dataArea);\n\n    }\n\n    /**\n     * Draws an outline for the data area.  The default implementation just\n     * gets the plot to draw the outline, but some renderers will override this\n     * behaviour.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     */\n    public void drawOutline(Graphics2D g2,\n                            CategoryPlot plot,\n                            Rectangle2D dataArea) {\n\n        plot.drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws a grid line against the domain axis.\n     * <P>\n     * Note that this default implementation assumes that the horizontal axis\n     * is the domain axis. If this is not the case, you will need to override\n     * this method.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the area for plotting data (not yet adjusted for any\n     *                  3D effect).\n     * @param value  the Java2D value at which the grid line should be drawn.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #drawRangeGridline(Graphics2D, CategoryPlot, ValueAxis,\n     *     Rectangle2D, double)\n     *\n     * @since 1.2.0\n     */\n    public void drawDomainLine(Graphics2D g2, CategoryPlot plot,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        Line2D line = null;\n        PlotOrientation orientation = plot.getOrientation();\n\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(dataArea.getMinX(), value,\n                    dataArea.getMaxX(), value);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(value, dataArea.getMinY(), value,\n                    dataArea.getMaxY());\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a line perpendicular to the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param axis  the value axis.\n     * @param dataArea  the area for plotting data (not yet adjusted for any 3D\n     *                  effect).\n     * @param value  the value at which the grid line should be drawn.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #drawRangeGridline\n     *\n     * @since 1.0.13\n     */\n    public void drawRangeLine(Graphics2D g2, CategoryPlot plot, ValueAxis axis,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n        Range range = axis.getRange();\n        if (!range.contains(value)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        Line2D line = null;\n        double v = axis.valueToJava2D(value, dataArea, plot.getRangeAxisEdge());\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(v, dataArea.getMinY(), v,\n                    dataArea.getMaxY());\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), v,\n                    dataArea.getMaxX(), v);\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a marker for the domain axis.\n     *\n     * @param g2  the graphics device (not <code>null</code>).\n     * @param plot  the plot (not <code>null</code>).\n     * @param axis  the range axis (not <code>null</code>).\n     * @param marker  the marker to be drawn (not <code>null</code>).\n     * @param dataArea  the area inside the axes (not <code>null</code>).\n     *\n     * @see #drawRangeMarker(Graphics2D, CategoryPlot, ValueAxis, Marker,\n     *     Rectangle2D)\n     */\n    public void drawDomainMarker(Graphics2D g2,\n                                 CategoryPlot plot,\n                                 CategoryAxis axis,\n                                 CategoryMarker marker,\n                                 Rectangle2D dataArea) {\n\n        Comparable category = marker.getKey();\n        CategoryDataset dataset = plot.getDataset(plot.getIndexOf(this));\n        int columnIndex = dataset.getColumnIndex(category);\n        if (columnIndex < 0) {\n            return;\n        }\n\n        final Composite savedComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n        PlotOrientation orientation = plot.getOrientation();\n        Rectangle2D bounds = null;\n        if (marker.getDrawAsLine()) {\n            double v = axis.getCategoryMiddle(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                line = new Line2D.Double(dataArea.getMinX(), v,\n                        dataArea.getMaxX(), v);\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                line = new Line2D.Double(v, dataArea.getMinY(), v,\n                        dataArea.getMaxY());\n            }\n            g2.setPaint(marker.getPaint());\n            g2.setStroke(marker.getStroke());\n            g2.draw(line);\n            bounds = line.getBounds2D();\n        }\n        else {\n            double v0 = axis.getCategoryStart(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            double v1 = axis.getCategoryEnd(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            Rectangle2D area = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                area = new Rectangle2D.Double(dataArea.getMinX(), v0,\n                        dataArea.getWidth(), (v1 - v0));\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                area = new Rectangle2D.Double(v0, dataArea.getMinY(),\n                        (v1 - v0), dataArea.getHeight());\n            }\n            g2.setPaint(marker.getPaint());\n            g2.fill(area);\n            bounds = area;\n        }\n\n        String label = marker.getLabel();\n        RectangleAnchor anchor = marker.getLabelAnchor();\n        if (label != null) {\n            Font labelFont = marker.getLabelFont();\n            g2.setFont(labelFont);\n            g2.setPaint(marker.getLabelPaint());\n            Point2D coordinates = calculateDomainMarkerTextAnchorPoint(\n                    g2, orientation, dataArea, bounds, marker.getLabelOffset(),\n                    marker.getLabelOffsetType(), anchor);\n            TextUtilities.drawAlignedString(label, g2,\n                    (float) coordinates.getX(), (float) coordinates.getY(),\n                    marker.getLabelTextAnchor());\n        }\n        g2.setComposite(savedComposite);\n    }\n\n    /**\n     * Draws a marker for the range axis.\n     *\n     * @param g2  the graphics device (not <code>null</code>).\n     * @param plot  the plot (not <code>null</code>).\n     * @param axis  the range axis (not <code>null</code>).\n     * @param marker  the marker to be drawn (not <code>null</code>).\n     * @param dataArea  the area inside the axes (not <code>null</code>).\n     *\n     * @see #drawDomainMarker(Graphics2D, CategoryPlot, CategoryAxis,\n     *     CategoryMarker, Rectangle2D)\n     */\n    public void drawRangeMarker(Graphics2D g2,\n                                CategoryPlot plot,\n                                ValueAxis axis,\n                                Marker marker,\n                                Rectangle2D dataArea) {\n\n        if (marker instanceof ValueMarker) {\n            ValueMarker vm = (ValueMarker) marker;\n            double value = vm.getValue();\n            Range range = axis.getRange();\n\n            if (!range.contains(value)) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            PlotOrientation orientation = plot.getOrientation();\n            double v = axis.valueToJava2D(value, dataArea,\n                    plot.getRangeAxisEdge());\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                line = new Line2D.Double(v, dataArea.getMinY(), v,\n                        dataArea.getMaxY());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                line = new Line2D.Double(dataArea.getMinX(), v,\n                        dataArea.getMaxX(), v);\n            }\n\n            g2.setPaint(marker.getPaint());\n            g2.setStroke(marker.getStroke());\n            g2.draw(line);\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, line.getBounds2D(),\n                        marker.getLabelOffset(), LengthAdjustmentType.EXPAND,\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n        else if (marker instanceof IntervalMarker) {\n            IntervalMarker im = (IntervalMarker) marker;\n            double start = im.getStartValue();\n            double end = im.getEndValue();\n            Range range = axis.getRange();\n            if (!(range.intersects(start, end))) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            double start2d = axis.valueToJava2D(start, dataArea,\n                    plot.getRangeAxisEdge());\n            double end2d = axis.valueToJava2D(end, dataArea,\n                    plot.getRangeAxisEdge());\n            double low = Math.min(start2d, end2d);\n            double high = Math.max(start2d, end2d);\n\n            PlotOrientation orientation = plot.getOrientation();\n            Rectangle2D rect = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                // clip left and right bounds to data area\n                low = Math.max(low, dataArea.getMinX());\n                high = Math.min(high, dataArea.getMaxX());\n                rect = new Rectangle2D.Double(low,\n                        dataArea.getMinY(), high - low,\n                        dataArea.getHeight());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                // clip top and bottom bounds to data area\n                low = Math.max(low, dataArea.getMinY());\n                high = Math.min(high, dataArea.getMaxY());\n                rect = new Rectangle2D.Double(dataArea.getMinX(),\n                        low, dataArea.getWidth(),\n                        high - low);\n            }\n            Paint p = marker.getPaint();\n            if (p instanceof GradientPaint) {\n                GradientPaint gp = (GradientPaint) p;\n                GradientPaintTransformer t = im.getGradientPaintTransformer();\n                if (t != null) {\n                    gp = t.transform(gp, rect);\n                }\n                g2.setPaint(gp);\n            }\n            else {\n                g2.setPaint(p);\n            }\n            g2.fill(rect);\n\n            // now draw the outlines, if visible...\n            if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n                if (orientation == PlotOrientation.VERTICAL) {\n                    Line2D line = new Line2D.Double();\n                    double x0 = dataArea.getMinX();\n                    double x1 = dataArea.getMaxX();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(x0, start2d, x1, start2d);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(x0, end2d, x1, end2d);\n                        g2.draw(line);\n                    }\n                }\n                else { // PlotOrientation.HORIZONTAL\n                    Line2D line = new Line2D.Double();\n                    double y0 = dataArea.getMinY();\n                    double y1 = dataArea.getMaxY();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(start2d, y0, start2d, y1);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(end2d, y0, end2d, y1);\n                        g2.draw(line);\n                    }\n                }\n            }\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, rect,\n                        marker.getLabelOffset(), marker.getLabelOffsetType(),\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n    }\n\n    /**\n     * Calculates the (x, y) coordinates for drawing the label for a marker on\n     * the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the plot orientation.\n     * @param dataArea  the data area.\n     * @param markerArea  the rectangle surrounding the marker.\n     * @param markerOffset  the marker offset.\n     * @param labelOffsetType  the label offset type.\n     * @param anchor  the label anchor.\n     *\n     * @return The coordinates for drawing the marker label.\n     */\n    protected Point2D calculateDomainMarkerTextAnchorPoint(Graphics2D g2,\n                                      PlotOrientation orientation,\n                                      Rectangle2D dataArea,\n                                      Rectangle2D markerArea,\n                                      RectangleInsets markerOffset,\n                                      LengthAdjustmentType labelOffsetType,\n                                      RectangleAnchor anchor) {\n\n        Rectangle2D anchorRect = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    LengthAdjustmentType.CONTRACT, labelOffsetType);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    labelOffsetType, LengthAdjustmentType.CONTRACT);\n        }\n        return RectangleAnchor.coordinates(anchorRect, anchor);\n\n    }\n\n    /**\n     * Calculates the (x, y) coordinates for drawing a marker label.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the plot orientation.\n     * @param dataArea  the data area.\n     * @param markerArea  the rectangle surrounding the marker.\n     * @param markerOffset  the marker offset.\n     * @param labelOffsetType  the label offset type.\n     * @param anchor  the label anchor.\n     *\n     * @return The coordinates for drawing the marker label.\n     */\n    protected Point2D calculateRangeMarkerTextAnchorPoint(Graphics2D g2,\n                                      PlotOrientation orientation,\n                                      Rectangle2D dataArea,\n                                      Rectangle2D markerArea,\n                                      RectangleInsets markerOffset,\n                                      LengthAdjustmentType labelOffsetType,\n                                      RectangleAnchor anchor) {\n\n        Rectangle2D anchorRect = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    labelOffsetType, LengthAdjustmentType.CONTRACT);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    LengthAdjustmentType.CONTRACT, labelOffsetType);\n        }\n        return RectangleAnchor.coordinates(anchorRect, anchor);\n\n    }\n\n    /**\n     * Returns a legend item for a series.  This default implementation will\n     * return <code>null</code> if {@link #isSeriesVisible(int)} or\n     * {@link #isSeriesVisibleInLegend(int)} returns <code>false</code>.\n     *\n     * @param datasetIndex  the dataset index (zero-based).\n     * @param series  the series index (zero-based).\n     *\n     * @return The legend item (possibly <code>null</code>).\n     *\n     * @see #getLegendItems()\n     */\n    public LegendItem getLegendItem(int datasetIndex, int series) {\n\n        CategoryPlot p = getPlot();\n        if (p == null) {\n            return null;\n        }\n\n        // check that a legend item needs to be displayed...\n        if (!isSeriesVisible(series) || !isSeriesVisibleInLegend(series)) {\n            return null;\n        }\n\n        CategoryDataset dataset = p.getDataset(datasetIndex);\n        String label = this.legendItemLabelGenerator.generateLabel(dataset,\n                series);\n        String description = label;\n        String toolTipText = null;\n        if (this.legendItemToolTipGenerator != null) {\n            toolTipText = this.legendItemToolTipGenerator.generateLabel(\n                    dataset, series);\n        }\n        String urlText = null;\n        if (this.legendItemURLGenerator != null) {\n            urlText = this.legendItemURLGenerator.generateLabel(dataset,\n                    series);\n        }\n        Shape shape = lookupLegendShape(series);\n        Paint paint = lookupSeriesPaint(series);\n        Paint outlinePaint = lookupSeriesOutlinePaint(series);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(series);\n\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setLabelFont(lookupLegendTextFont(series));\n        Paint labelPaint = lookupLegendTextPaint(series);\n        if (labelPaint != null) {\n            item.setLabelPaint(labelPaint);\n        }\n        item.setSeriesKey(dataset.getRowKey(series));\n        item.setSeriesIndex(series);\n        item.setDataset(dataset);\n        item.setDatasetIndex(datasetIndex);\n        return item;\n    }\n\n    /**\n     * Tests this renderer for equality with another object.\n     *\n     * @param obj  the object.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AbstractCategoryItemRenderer)) {\n            return false;\n        }\n        AbstractCategoryItemRenderer that = (AbstractCategoryItemRenderer) obj;\n\n        if (!ObjectUtilities.equal(this.itemLabelGeneratorList,\n                that.itemLabelGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseItemLabelGenerator,\n                that.baseItemLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGeneratorList,\n                that.toolTipGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseToolTipGenerator,\n                that.baseToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGeneratorList,\n                that.urlGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseURLGenerator,\n                that.baseURLGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemLabelGenerator,\n                that.legendItemLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemToolTipGenerator,\n                that.legendItemToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemURLGenerator,\n                that.legendItemURLGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundAnnotations,\n                that.backgroundAnnotations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundAnnotations,\n                that.foregroundAnnotations)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for the renderer.\n     *\n     * @return The hash code.\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns the drawing supplier from the plot.\n     *\n     * @return The drawing supplier (possibly <code>null</code>).\n     */\n    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result = null;\n        CategoryPlot cp = getPlot();\n        if (cp != null) {\n            result = cp.getDrawingSupplier();\n        }\n        return result;\n    }\n\n    /**\n     * Considers the current (x, y) coordinate and updates the crosshair point\n     * if it meets the criteria (usually means the (x, y) coordinate is the\n     * closest to the anchor point so far).\n     *\n     * @param crosshairState  the crosshair state (<code>null</code> permitted,\n     *                        but the method does nothing in that case).\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param value  the data value.\n     * @param datasetIndex  the dataset index.\n     * @param transX  the x-value translated to Java2D space.\n     * @param transY  the y-value translated to Java2D space.\n     * @param orientation  the plot orientation (<code>null</code> not\n     *                     permitted).\n     *\n     * @since 1.0.11\n     */\n    protected void updateCrosshairValues(CategoryCrosshairState crosshairState,\n            Comparable rowKey, Comparable columnKey, double value,\n            int datasetIndex,\n            double transX, double transY, PlotOrientation orientation) {\n\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        if (crosshairState != null) {\n            if (this.plot.isRangeCrosshairLockedOnData()) {\n                // both axes\n                crosshairState.updateCrosshairPoint(rowKey, columnKey, value,\n                        datasetIndex, transX, transY, orientation);\n            }\n            else {\n                crosshairState.updateCrosshairX(rowKey, columnKey,\n                        datasetIndex, transX, orientation);\n            }\n        }\n    }\n\n    /**\n     * Draws an item label.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the orientation.\n     * @param dataset  the dataset.\n     * @param row  the row.\n     * @param column  the column.\n     * @param selected  is the item selected?\n     * @param x  the x coordinate (in Java2D space).\n     * @param y  the y coordinate (in Java2D space).\n     * @param negative  indicates a negative value (which affects the item\n     *                  label position).\n     *\n     * @since 1.2.0\n     */\n    protected void drawItemLabel(Graphics2D g2, PlotOrientation orientation,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double x, double y, boolean negative) {\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column, selected);\n        if (generator != null) {\n            Font labelFont = getItemLabelFont(row, column, selected);\n            Paint paint = getItemLabelPaint(row, column, selected);\n            g2.setFont(labelFont);\n            g2.setPaint(paint);\n            String label = generator.generateLabel(dataset, row, column);\n            ItemLabelPosition position = null;\n            if (!negative) {\n                position = getPositiveItemLabelPosition(row, column, selected);\n            }\n            else {\n                position = getNegativeItemLabelPosition(row, column, selected);\n            }\n            Point2D anchorPoint = calculateLabelAnchorPoint(\n                    position.getItemLabelAnchor(), x, y, orientation);\n            TextUtilities.drawRotatedString(label, g2,\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getTextAnchor(),\n                    position.getAngle(), position.getRotationAnchor());\n        }\n\n    }\n\n    /**\n     * Draws all the annotations for the specified layer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param layer  the layer.\n     * @param info  the plot rendering info.\n     *\n     * @since 1.2.0\n     */\n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            CategoryAxis domainAxis, ValueAxis rangeAxis, Layer layer,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = null;\n        if (layer.equals(Layer.FOREGROUND)) {\n            iterator = this.foregroundAnnotations.iterator();\n        }\n        else if (layer.equals(Layer.BACKGROUND)) {\n            iterator = this.backgroundAnnotations.iterator();\n        }\n        else {\n            // should not get here\n            throw new RuntimeException(\"Unknown layer.\");\n        }\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this.plot, dataArea, domainAxis, rangeAxis,\n                    0, info);\n        }\n\n    }\n\n    /**\n     * Returns an independent copy of the renderer.  The <code>plot</code>\n     * reference is shallow copied.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  can be thrown if one of the objects\n     *         belonging to the renderer does not support cloning (for example,\n     *         an item label generator).\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        AbstractCategoryItemRenderer clone\n                = (AbstractCategoryItemRenderer) super.clone();\n\n\n        if (this.itemLabelGeneratorList != null) {\n            clone.itemLabelGeneratorList\n                    = (ObjectList) this.itemLabelGeneratorList.clone();\n        }\n\n        if (this.baseItemLabelGenerator != null) {\n            if (this.baseItemLabelGenerator instanceof PublicCloneable) {\n                PublicCloneable pc\n                        = (PublicCloneable) this.baseItemLabelGenerator;\n                clone.baseItemLabelGenerator\n                        = (CategoryItemLabelGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"ItemLabelGenerator not cloneable.\");\n            }\n        }\n\n        if (this.toolTipGeneratorList != null) {\n            clone.toolTipGeneratorList\n                    = (ObjectList) this.toolTipGeneratorList.clone();\n        }\n\n        if (this.baseToolTipGenerator != null) {\n            if (this.baseToolTipGenerator instanceof PublicCloneable) {\n                PublicCloneable pc\n                        = (PublicCloneable) this.baseToolTipGenerator;\n                clone.baseToolTipGenerator\n                        = (CategoryToolTipGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base tool tip generator not cloneable.\");\n            }\n        }\n\n        if (this.urlGeneratorList != null) {\n            clone.urlGeneratorList = (ObjectList) this.urlGeneratorList.clone();\n        }\n\n        if (this.baseURLGenerator != null) {\n            if (this.baseURLGenerator instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) this.baseURLGenerator;\n                clone.baseURLGenerator = (CategoryURLGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base item URL generator not cloneable.\");\n            }\n        }\n\n        if (this.legendItemLabelGenerator instanceof PublicCloneable) {\n            clone.legendItemLabelGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemLabelGenerator);\n        }\n        if (this.legendItemToolTipGenerator instanceof PublicCloneable) {\n            clone.legendItemToolTipGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemToolTipGenerator);\n        }\n        if (this.legendItemURLGenerator instanceof PublicCloneable) {\n            clone.legendItemURLGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemURLGenerator);\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the domain axis that is used for the specified dataset.\n     *\n     * @param plot  the plot (<code>null</code> not permitted).\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return A domain axis.\n     */\n    protected CategoryAxis getDomainAxis(CategoryPlot plot, \n            CategoryDataset dataset) {\n        int datasetIndex = plot.indexOf(dataset);\n        return plot.getDomainAxisForDataset(datasetIndex);\n    }\n\n    /**\n     * Returns a range axis for a plot.\n     *\n     * @param plot  the plot.\n     * @param index  the axis index.\n     *\n     * @return A range axis.\n     */\n    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {\n        ValueAxis result = plot.getRangeAxis(index);\n        if (result == null) {\n            result = plot.getRangeAxis();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2010, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------------------------\n * AbstractCategoryItemRenderer.java\n * ---------------------------------\n * (C) Copyright 2002-2010, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Richard Atkinson;\n *                   Peter Kolb (patch 2497611);\n *\n * Changes:\n * --------\n * 29-May-2002 : Version 1 (DG);\n * 06-Jun-2002 : Added accessor methods for the tool tip generator (DG);\n * 11-Jun-2002 : Made constructors protected (DG);\n * 26-Jun-2002 : Added axis to initialise method (DG);\n * 05-Aug-2002 : Added urlGenerator member variable plus accessors (RA);\n * 22-Aug-2002 : Added categoriesPaint attribute, based on code submitted by\n *               Janet Banks.  This can be used when there is only one series,\n *               and you want each category item to have a different color (DG);\n * 01-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 29-Oct-2002 : Fixed bug where background image for plot was not being\n *               drawn (DG);\n * 05-Nov-2002 : Replaced references to CategoryDataset with TableDataset (DG);\n * 26-Nov 2002 : Replaced the isStacked() method with getRangeType() (DG);\n * 09-Jan-2003 : Renamed grid-line methods (DG);\n * 17-Jan-2003 : Moved plot classes into separate package (DG);\n * 25-Mar-2003 : Implemented Serializable (DG);\n * 12-May-2003 : Modified to take into account the plot orientation (DG);\n * 12-Aug-2003 : Very minor javadoc corrections (DB)\n * 13-Aug-2003 : Implemented Cloneable (DG);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 05-Nov-2003 : Fixed marker rendering bug (833623) (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 11-Feb-2004 : Modified labelling for markers (DG);\n * 12-Feb-2004 : Updated clone() method (DG);\n * 15-Apr-2004 : Created a new CategoryToolTipGenerator interface (DG);\n * 05-May-2004 : Fixed bug (948310) where interval markers extend outside axis\n *               range (DG);\n * 14-Jun-2004 : Fixed bug in drawRangeMarker() method - now uses 'paint' and\n *               'stroke' rather than 'outlinePaint' and 'outlineStroke' (DG);\n * 15-Jun-2004 : Interval markers can now use GradientPaint (DG);\n * 30-Sep-2004 : Moved drawRotatedString() from RefineryUtilities\n *               --> TextUtilities (DG);\n * 01-Oct-2004 : Fixed bug 1029697, problem with label alignment in\n *               drawRangeMarker() method (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() (DG);\n * 21-Jan-2005 : Modified return type of calculateRangeMarkerTextAnchorPoint()\n *               method (DG);\n * 08-Mar-2005 : Fixed positioning of marker labels (DG);\n * 20-Apr-2005 : Added legend label, tooltip and URL generators (DG);\n * 01-Jun-2005 : Handle one dimension of the marker label adjustment\n *               automatically (DG);\n * 09-Jun-2005 : Added utility method for adding an item entity (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 01-Mar-2006 : Updated getLegendItems() to check seriesVisibleInLegend\n *               flags (DG);\n * 20-Jul-2006 : Set dataset and series indices in LegendItem (DG);\n * 23-Oct-2006 : Draw outlines for interval markers (DG);\n * 24-Oct-2006 : Respect alpha setting in markers, as suggested by Sergei\n *               Ivanov in patch 1567843 (DG);\n * 30-Nov-2006 : Added a check for series visibility in the getLegendItem()\n *               method (DG);\n * 07-Dec-2006 : Fix for equals() method (DG);\n * 22-Feb-2007 : Added createState() method (DG);\n * 01-Mar-2007 : Fixed interval marker drawing (patch 1670686 thanks to\n *               Sergei Ivanov) (DG);\n * 20-Apr-2007 : Updated getLegendItem() for renderer change, and deprecated\n *               itemLabelGenerator, toolTipGenerator and itemURLGenerator\n *               override fields (DG);\n * 18-May-2007 : Set dataset and seriesKey for LegendItem (DG);\n * 20-Jun-2007 : Removed deprecated code and removed JCommon dependencies (DG);\n * 27-Jun-2007 : Added some new methods with 'notify' argument, renamed\n *               methods containing 'ItemURL' to just 'URL' (DG);\n * 06-Jul-2007 : Added annotation support (DG);\n * 17-Jun-2008 : Apply legend shape, font and paint attributes (DG);\n * 26-Jun-2008 : Added crosshair support (DG);\n * 25-Nov-2008 : Fixed bug in findRangeBounds() method (DG);\n * 14-Jan-2009 : Update initialise() to store visible series indices (PK);\n * 21-Jan-2009 : Added drawRangeLine() method (DG);\n * 28-Jan-2009 : Updated for changes to CategoryItemRenderer interface (DG);\n * 27-Mar-2009 : Added new findRangeBounds() method to account for hidden\n *               series (DG);\n * 01-Apr-2009 : Added new addEntity() method (DG);\n * 09-Feb-2010 : Fixed bug 2947660 (DG);\n *\n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.AlphaComposite;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.GradientPaint;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.RenderingSource;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.CategoryItemEntity;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.labels.CategoryItemLabelGenerator;\nimport org.jfree.chart.labels.CategorySeriesLabelGenerator;\nimport org.jfree.chart.labels.CategoryToolTipGenerator;\nimport org.jfree.chart.labels.ItemLabelPosition;\nimport org.jfree.chart.labels.StandardCategorySeriesLabelGenerator;\nimport org.jfree.chart.plot.CategoryCrosshairState;\nimport org.jfree.chart.plot.CategoryMarker;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.DrawingSupplier;\nimport org.jfree.chart.plot.IntervalMarker;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.plot.PlotRenderingInfo;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.jfree.chart.renderer.AbstractRenderer;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.CategoryURLGenerator;\nimport org.jfree.chart.util.GradientPaintTransformer;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.LengthAdjustmentType;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryDatasetSelectionState;\nimport org.jfree.data.category.SelectableCategoryDataset;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * An abstract base class that you can use to implement a new\n * {@link CategoryItemRenderer}.  When you create a new\n * {@link CategoryItemRenderer} you are not required to extend this class,\n * but it makes the job easier.\n */\npublic abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n        implements CategoryItemRenderer, Cloneable, PublicCloneable,\n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 1247553218442497391L;\n\n    /** The plot that the renderer is assigned to. */\n    private CategoryPlot plot;\n\n    /** A list of item label generators (one per series). */\n    private ObjectList itemLabelGeneratorList;\n\n    /** The base item label generator. */\n    private CategoryItemLabelGenerator baseItemLabelGenerator;\n\n    /** A list of tool tip generators (one per series). */\n    private ObjectList toolTipGeneratorList;\n\n    /** The base tool tip generator. */\n    private CategoryToolTipGenerator baseToolTipGenerator;\n\n    /** A list of label generators (one per series). */\n    private ObjectList urlGeneratorList;\n\n    /** The base label generator. */\n    private CategoryURLGenerator baseURLGenerator;\n\n    /** The legend item label generator. */\n    private CategorySeriesLabelGenerator legendItemLabelGenerator;\n\n    /** The legend item tool tip generator. */\n    private CategorySeriesLabelGenerator legendItemToolTipGenerator;\n\n    /** The legend item URL generator. */\n    private CategorySeriesLabelGenerator legendItemURLGenerator;\n\n    /**\n     * Annotations to be drawn in the background layer ('underneath' the data\n     * items).\n     *\n     * @since 1.2.0\n     */\n    private List backgroundAnnotations;\n\n    /**\n     * Annotations to be drawn in the foreground layer ('on top' of the data\n     * items).\n     *\n     * @since 1.2.0\n     */\n    private List foregroundAnnotations;\n\n    /** The number of rows in the dataset (temporary record). */\n    private transient int rowCount;\n\n    /** The number of columns in the dataset (temporary record). */\n    private transient int columnCount;\n\n    /**\n     * Creates a new renderer with no tool tip generator and no URL generator.\n     * The defaults (no tool tip or URL generators) have been chosen to\n     * minimise the processing required to generate a default chart.  If you\n     * require tool tips or URLs, then you can easily add the required\n     * generators.\n     */\n    protected AbstractCategoryItemRenderer() {\n        this.itemLabelGeneratorList = new ObjectList();\n        this.toolTipGeneratorList = new ObjectList();\n        this.urlGeneratorList = new ObjectList();\n        this.legendItemLabelGenerator\n                = new StandardCategorySeriesLabelGenerator();\n        this.backgroundAnnotations = new ArrayList();\n        this.foregroundAnnotations = new ArrayList();\n    }\n\n    /**\n     * Returns the number of passes through the dataset required by the\n     * renderer.  This method returns <code>1</code>, subclasses should\n     * override if they need more passes.\n     *\n     * @return The pass count.\n     */\n    public int getPassCount() {\n        return 1;\n    }\n\n    /**\n     * Returns the plot that the renderer has been assigned to (where\n     * <code>null</code> indicates that the renderer is not currently assigned\n     * to a plot).\n     *\n     * @return The plot (possibly <code>null</code>).\n     *\n     * @see #setPlot(CategoryPlot)\n     */\n    public CategoryPlot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Sets the plot that the renderer has been assigned to.  This method is\n     * usually called by the {@link CategoryPlot}, in normal usage you\n     * shouldn't need to call this method directly.\n     *\n     * @param plot  the plot (<code>null</code> not permitted).\n     *\n     * @see #getPlot()\n     */\n    public void setPlot(CategoryPlot plot) {\n        if (plot == null) {\n            throw new IllegalArgumentException(\"Null 'plot' argument.\");\n        }\n        this.plot = plot;\n    }\n\n    // ITEM LABEL GENERATOR\n\n    /**\n     * Returns the item label generator for a data item.  This implementation\n     * returns the series item label generator if one is defined, otherwise\n     * it returns the default item label generator (which may be\n     * <code>null</code>).\n     *\n     * @param row  the row index (zero based).\n     * @param column  the column index (zero based).\n     * @param selected  is the item selected?\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public CategoryItemLabelGenerator getItemLabelGenerator(int row,\n            int column, boolean selected) {\n        CategoryItemLabelGenerator generator = (CategoryItemLabelGenerator)\n                this.itemLabelGeneratorList.get(row);\n        if (generator == null) {\n            generator = this.baseItemLabelGenerator;\n        }\n        return generator;\n    }\n\n    /**\n     * Returns the item label generator for a series.\n     *\n     * @param series  the series index (zero based).\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @see #setSeriesItemLabelGenerator(int, CategoryItemLabelGenerator)\n     */\n    public CategoryItemLabelGenerator getSeriesItemLabelGenerator(int series) {\n        return (CategoryItemLabelGenerator) this.itemLabelGeneratorList.get(\n                series);\n    }\n\n    /**\n     * Sets the item label generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getSeriesItemLabelGenerator(int)\n     */\n    public void setSeriesItemLabelGenerator(int series,\n            CategoryItemLabelGenerator generator) {\n        setSeriesItemLabelGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the item label generator for a series and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesItemLabelGenerator(int)\n     */\n    public void setSeriesItemLabelGenerator(int series,\n            CategoryItemLabelGenerator generator, boolean notify) {\n        this.itemLabelGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base item label generator.\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @see #setBaseItemLabelGenerator(CategoryItemLabelGenerator)\n     */\n    public CategoryItemLabelGenerator getBaseItemLabelGenerator() {\n        return this.baseItemLabelGenerator;\n    }\n\n    /**\n     * Sets the base item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getBaseItemLabelGenerator()\n     */\n    public void setBaseItemLabelGenerator(\n            CategoryItemLabelGenerator generator) {\n        setBaseItemLabelGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base item label generator and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getBaseItemLabelGenerator()\n     */\n    public void setBaseItemLabelGenerator(\n            CategoryItemLabelGenerator generator, boolean notify) {\n        this.baseItemLabelGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // TOOL TIP GENERATOR\n\n    /**\n     * Returns the tool tip generator that should be used for the specified\n     * item.  You can override this method if you want to return a different\n     * generator per item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return The generator (possibly <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    public CategoryToolTipGenerator getToolTipGenerator(int row, int column,\n            boolean selected) {\n\n        CategoryToolTipGenerator result = null;\n        result = getSeriesToolTipGenerator(row);\n        if (result == null) {\n            result = this.baseToolTipGenerator;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the tool tip generator for the specified series (a \"layer 1\"\n     * generator).\n     *\n     * @param series  the series index (zero-based).\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setSeriesToolTipGenerator(int, CategoryToolTipGenerator)\n     */\n    public CategoryToolTipGenerator getSeriesToolTipGenerator(int series) {\n        return (CategoryToolTipGenerator) this.toolTipGeneratorList.get(series);\n    }\n\n    /**\n     * Sets the tool tip generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero-based).\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getSeriesToolTipGenerator(int)\n     */\n    public void setSeriesToolTipGenerator(int series,\n            CategoryToolTipGenerator generator) {\n        setSeriesToolTipGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the tool tip generator for a series and sends a\n     * {@link org.jfree.chart.event.RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param series  the series index (zero-based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesToolTipGenerator(int)\n     */\n    public void setSeriesToolTipGenerator(int series,\n            CategoryToolTipGenerator generator, boolean notify) {\n        this.toolTipGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base tool tip generator (the \"layer 2\" generator).\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setBaseToolTipGenerator(CategoryToolTipGenerator)\n     */\n    public CategoryToolTipGenerator getBaseToolTipGenerator() {\n        return this.baseToolTipGenerator;\n    }\n\n    /**\n     * Sets the base tool tip generator and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getBaseToolTipGenerator()\n     */\n    public void setBaseToolTipGenerator(CategoryToolTipGenerator generator) {\n        setBaseToolTipGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base tool tip generator and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getBaseToolTipGenerator()\n     */\n    public void setBaseToolTipGenerator(CategoryToolTipGenerator generator,\n            boolean notify) {\n        this.baseToolTipGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // URL GENERATOR\n\n    /**\n     * Returns the URL generator for a data item.\n     *\n     * @param row  the row index (zero based).\n     * @param column  the column index (zero based).\n     * @param selected  is the item selected?\n     *\n     * @return The URL generator.\n     *\n     * @since 1.2.0\n     */\n    public CategoryURLGenerator getURLGenerator(int row, int column, boolean\n            selected) {\n        CategoryURLGenerator generator\n                = (CategoryURLGenerator) this.urlGeneratorList.get(row);\n        if (generator == null) {\n            generator = this.baseURLGenerator;\n        }\n        return generator;\n    }\n\n    /**\n     * Returns the URL generator for a series.\n     *\n     * @param series  the series index (zero based).\n     *\n     * @return The URL generator for the series.\n     *\n     * @see #setSeriesURLGenerator(int, CategoryURLGenerator)\n     */\n    public CategoryURLGenerator getSeriesURLGenerator(int series) {\n        return (CategoryURLGenerator) this.urlGeneratorList.get(series);\n    }\n\n    /**\n     * Sets the URL generator for a series and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator.\n     *\n     * @see #getSeriesURLGenerator(int)\n     */\n    public void setSeriesURLGenerator(int series,\n            CategoryURLGenerator generator) {\n        setSeriesURLGenerator(series, generator, true);\n    }\n\n    /**\n     * Sets the URL generator for a series and, if requested, sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param series  the series index (zero based).\n     * @param generator  the generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.2.0\n     *\n     * @see #getSeriesURLGenerator(int)\n     */\n    public void setSeriesURLGenerator(int series,\n            CategoryURLGenerator generator, boolean notify) {\n        this.urlGeneratorList.set(series, generator);\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the base item URL generator.\n     *\n     * @return The item URL generator.\n     *\n     * @see #setBaseURLGenerator(CategoryURLGenerator)\n     */\n    public CategoryURLGenerator getBaseURLGenerator() {\n        return this.baseURLGenerator;\n    }\n\n    /**\n     * Sets the base item URL generator.\n     *\n     * @param generator  the item URL generator.\n     *\n     * @see #getBaseURLGenerator()\n     */\n    public void setBaseURLGenerator(CategoryURLGenerator generator) {\n        setBaseURLGenerator(generator, true);\n    }\n\n    /**\n     * Sets the base item URL generator.\n     *\n     * @param generator  the item URL generator (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getBaseURLGenerator()\n     *\n     * @since 1.2.0\n     */\n    public void setBaseURLGenerator(CategoryURLGenerator generator,\n            boolean notify) {\n        this.baseURLGenerator = generator;\n        if (notify) {\n            notifyListeners(new RendererChangeEvent(this));\n        }\n    }\n\n    // ANNOTATIONS\n\n    /**\n     * Adds an annotation and sends a {@link RendererChangeEvent} to all\n     * registered listeners.  The annotation is added to the foreground\n     * layer.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @since 1.2.0\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n        // defer argument checking\n        addAnnotation(annotation, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds an annotation to the specified layer.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     *\n     * @since 1.2.0\n     */\n    public void addAnnotation(CategoryAnnotation annotation, Layer layer) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        if (layer.equals(Layer.FOREGROUND)) {\n            this.foregroundAnnotations.add(annotation);\n            notifyListeners(new RendererChangeEvent(this));\n        }\n        else if (layer.equals(Layer.BACKGROUND)) {\n            this.backgroundAnnotations.add(annotation);\n            notifyListeners(new RendererChangeEvent(this));\n        }\n        else {\n            // should never get here\n            throw new RuntimeException(\"Unknown layer.\");\n        }\n    }\n    /**\n     * Removes the specified annotation and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation to remove (<code>null</code> not\n     *                    permitted).\n     *\n     * @return A boolean to indicate whether or not the annotation was\n     *         successfully removed.\n     *\n     * @since 1.2.0\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        boolean removed = this.foregroundAnnotations.remove(annotation);\n        removed = removed & this.backgroundAnnotations.remove(annotation);\n        notifyListeners(new RendererChangeEvent(this));\n        return removed;\n    }\n\n    /**\n     * Removes all annotations and sends a {@link RendererChangeEvent}\n     * to all registered listeners.\n     *\n     * @since 1.2.0\n     */\n    public void removeAnnotations() {\n        this.foregroundAnnotations.clear();\n        this.backgroundAnnotations.clear();\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the legend item label generator.\n     *\n     * @return The label generator (never <code>null</code>).\n     *\n     * @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }\n\n    /**\n     * Sets the legend item label generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> not permitted).\n     *\n     * @see #getLegendItemLabelGenerator()\n     */\n    public void setLegendItemLabelGenerator(\n            CategorySeriesLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendItemLabelGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item tool tip generator.\n     *\n     * @return The tool tip generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }\n\n    /**\n     * Sets the legend item tool tip generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator)\n     */\n    public void setLegendItemToolTipGenerator(\n            CategorySeriesLabelGenerator generator) {\n        this.legendItemToolTipGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend item URL generator.\n     *\n     * @return The URL generator (possibly <code>null</code>).\n     *\n     * @see #setLegendItemURLGenerator(CategorySeriesLabelGenerator)\n     */\n    public CategorySeriesLabelGenerator getLegendItemURLGenerator() {\n        return this.legendItemURLGenerator;\n    }\n\n    /**\n     * Sets the legend item URL generator and sends a\n     * {@link RendererChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     *\n     * @see #getLegendItemURLGenerator()\n     */\n    public void setLegendItemURLGenerator(\n            CategorySeriesLabelGenerator generator) {\n        this.legendItemURLGenerator = generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the number of rows in the dataset.  This value is updated in the\n     * {@link AbstractCategoryItemRenderer#initialise} method.\n     *\n     * @return The row count.\n     */\n    public int getRowCount() {\n        return this.rowCount;\n    }\n\n    /**\n     * Returns the number of columns in the dataset.  This value is updated in\n     * the {@link AbstractCategoryItemRenderer#initialise} method.\n     *\n     * @return The column count.\n     */\n    public int getColumnCount() {\n        return this.columnCount;\n    }\n\n    /**\n     * Creates a new state instance---this method is called from the\n     * {@link #initialise(Graphics2D, Rectangle2D, CategoryPlot, int,\n     * PlotRenderingInfo)} method.  Subclasses can override this method if\n     * they need to use a subclass of {@link CategoryItemRendererState}.\n     *\n     * @param info  collects plot rendering info (<code>null</code> permitted).\n     *\n     * @return The new state instance (never <code>null</code>).\n     *\n     * @since 1.0.5\n     */\n    protected CategoryItemRendererState createState(PlotRenderingInfo info) {\n        CategoryItemRendererState state = new CategoryItemRendererState(info);\n        int[] visibleSeriesTemp = new int[this.rowCount];\n        int visibleSeriesCount = 0;\n        for (int row = 0; row < this.rowCount; row++) {\n            if (isSeriesVisible(row)) {\n                visibleSeriesTemp[visibleSeriesCount] = row;\n                visibleSeriesCount++;\n            }\n        }\n        int[] visibleSeries = new int[visibleSeriesCount];\n        System.arraycopy(visibleSeriesTemp, 0, visibleSeries, 0,\n                visibleSeriesCount);\n        state.setVisibleSeriesArray(visibleSeries);\n        return state;\n    }\n\n    /**\n     * Initialises the renderer and returns a state object that will be used\n     * for the remainder of the drawing process for a single chart.  The state\n     * object allows for the fact that the renderer may be used simultaneously\n     * by multiple threads (each thread will work with a separate state object).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param info  an object for returning information about the structure of\n     *              the plot (<code>null</code> permitted).\n     *\n     * @return The renderer state.\n     */\n    public CategoryItemRendererState initialise(Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryDataset dataset,\n            PlotRenderingInfo info) {\n\n        setPlot(plot);\n        if (dataset != null) {\n            this.rowCount = dataset.getRowCount();\n            this.columnCount = dataset.getColumnCount();\n        }\n        else {\n            this.rowCount = 0;\n            this.columnCount = 0;\n        }\n        CategoryItemRendererState state = createState(info);\n\n        // determine if there is any selection state for the dataset\n        CategoryDatasetSelectionState selectionState = null;\n        if (dataset instanceof SelectableCategoryDataset) {\n            SelectableCategoryDataset scd = (SelectableCategoryDataset) dataset;\n            selectionState = scd.getSelectionState();\n        }\n        // if the selection state is still null, go to the selection source\n        // and ask if it has state...\n        if (selectionState == null && info != null) {\n            ChartRenderingInfo cri = info.getOwner();\n            if (cri != null) {\n                RenderingSource rs = cri.getRenderingSource();\n                selectionState = (CategoryDatasetSelectionState)\n                        rs.getSelectionState(dataset);\n            }\n        }\n        state.setSelectionState(selectionState);\n\n        return state;\n    }\n\n    /**\n     * Returns the range of values the renderer requires to display all the\n     * items from the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The range (or <code>null</code> if the dataset is\n     *         <code>null</code> or empty).\n     */\n    public Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, false);\n    }\n\n    /**\n     * Returns the range of values the renderer requires to display all the\n     * items from the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param includeInterval  include the y-interval if the dataset has one.\n     *\n     * @return The range (<code>null</code> if the dataset is <code>null</code>\n     *         or empty).\n     *\n     * @since 1.0.13\n     */\n    protected Range findRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            return null;\n        }\n        if (getDataBoundsIncludesVisibleSeriesOnly()) {\n            List visibleSeriesKeys = new ArrayList();\n            int seriesCount = dataset.getRowCount();\n            for (int s = 0; s < seriesCount; s++) {\n                if (isSeriesVisible(s)) {\n                    visibleSeriesKeys.add(dataset.getRowKey(s));\n                }\n            }\n            return DatasetUtilities.findRangeBounds(dataset,\n                    visibleSeriesKeys, includeInterval);\n        }\n        else {\n            return DatasetUtilities.findRangeBounds(dataset, includeInterval);\n        }\n    }\n\n    /**\n     * Returns the Java2D coordinate for the middle of the specified data item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param dataset  the dataset.\n     * @param axis  the axis.\n     * @param area  the data area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The Java2D coordinate for the middle of the item.\n     *\n     * @since 1.0.11\n     */\n    public double getItemMiddle(Comparable rowKey, Comparable columnKey,\n            CategoryDataset dataset, CategoryAxis axis, Rectangle2D area,\n            RectangleEdge edge) {\n        return axis.getCategoryMiddle(columnKey, dataset.getColumnKeys(), area,\n                edge);\n    }\n\n    /**\n     * Draws a background for the data area.  The default implementation just\n     * gets the plot to draw the background, but some renderers will override\n     * this behaviour.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     */\n    public void drawBackground(Graphics2D g2,\n                               CategoryPlot plot,\n                               Rectangle2D dataArea) {\n\n        plot.drawBackground(g2, dataArea);\n\n    }\n\n    /**\n     * Draws an outline for the data area.  The default implementation just\n     * gets the plot to draw the outline, but some renderers will override this\n     * behaviour.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     */\n    public void drawOutline(Graphics2D g2,\n                            CategoryPlot plot,\n                            Rectangle2D dataArea) {\n\n        plot.drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws a grid line against the domain axis.\n     * <P>\n     * Note that this default implementation assumes that the horizontal axis\n     * is the domain axis. If this is not the case, you will need to override\n     * this method.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the area for plotting data (not yet adjusted for any\n     *                  3D effect).\n     * @param value  the Java2D value at which the grid line should be drawn.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #drawRangeGridline(Graphics2D, CategoryPlot, ValueAxis,\n     *     Rectangle2D, double)\n     *\n     * @since 1.2.0\n     */\n    public void drawDomainLine(Graphics2D g2, CategoryPlot plot,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        Line2D line = null;\n        PlotOrientation orientation = plot.getOrientation();\n\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(dataArea.getMinX(), value,\n                    dataArea.getMaxX(), value);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(value, dataArea.getMinY(), value,\n                    dataArea.getMaxY());\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a line perpendicular to the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param axis  the value axis.\n     * @param dataArea  the area for plotting data (not yet adjusted for any 3D\n     *                  effect).\n     * @param value  the value at which the grid line should be drawn.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #drawRangeGridline\n     *\n     * @since 1.0.13\n     */\n    public void drawRangeLine(Graphics2D g2, CategoryPlot plot, ValueAxis axis,\n            Rectangle2D dataArea, double value, Paint paint, Stroke stroke) {\n\n        Range range = axis.getRange();\n        if (!range.contains(value)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        Line2D line = null;\n        double v = axis.valueToJava2D(value, dataArea, plot.getRangeAxisEdge());\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(v, dataArea.getMinY(), v,\n                    dataArea.getMaxY());\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), v,\n                    dataArea.getMaxX(), v);\n        }\n\n        g2.setPaint(paint);\n        g2.setStroke(stroke);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a marker for the domain axis.\n     *\n     * @param g2  the graphics device (not <code>null</code>).\n     * @param plot  the plot (not <code>null</code>).\n     * @param axis  the range axis (not <code>null</code>).\n     * @param marker  the marker to be drawn (not <code>null</code>).\n     * @param dataArea  the area inside the axes (not <code>null</code>).\n     *\n     * @see #drawRangeMarker(Graphics2D, CategoryPlot, ValueAxis, Marker,\n     *     Rectangle2D)\n     */\n    public void drawDomainMarker(Graphics2D g2,\n                                 CategoryPlot plot,\n                                 CategoryAxis axis,\n                                 CategoryMarker marker,\n                                 Rectangle2D dataArea) {\n\n        Comparable category = marker.getKey();\n        CategoryDataset dataset = plot.getDataset(plot.getIndexOf(this));\n        int columnIndex = dataset.getColumnIndex(category);\n        if (columnIndex < 0) {\n            return;\n        }\n\n        final Composite savedComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n        PlotOrientation orientation = plot.getOrientation();\n        Rectangle2D bounds = null;\n        if (marker.getDrawAsLine()) {\n            double v = axis.getCategoryMiddle(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                line = new Line2D.Double(dataArea.getMinX(), v,\n                        dataArea.getMaxX(), v);\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                line = new Line2D.Double(v, dataArea.getMinY(), v,\n                        dataArea.getMaxY());\n            }\n            g2.setPaint(marker.getPaint());\n            g2.setStroke(marker.getStroke());\n            g2.draw(line);\n            bounds = line.getBounds2D();\n        }\n        else {\n            double v0 = axis.getCategoryStart(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            double v1 = axis.getCategoryEnd(columnIndex,\n                    dataset.getColumnCount(), dataArea,\n                    plot.getDomainAxisEdge());\n            Rectangle2D area = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                area = new Rectangle2D.Double(dataArea.getMinX(), v0,\n                        dataArea.getWidth(), (v1 - v0));\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                area = new Rectangle2D.Double(v0, dataArea.getMinY(),\n                        (v1 - v0), dataArea.getHeight());\n            }\n            g2.setPaint(marker.getPaint());\n            g2.fill(area);\n            bounds = area;\n        }\n\n        String label = marker.getLabel();\n        RectangleAnchor anchor = marker.getLabelAnchor();\n        if (label != null) {\n            Font labelFont = marker.getLabelFont();\n            g2.setFont(labelFont);\n            g2.setPaint(marker.getLabelPaint());\n            Point2D coordinates = calculateDomainMarkerTextAnchorPoint(\n                    g2, orientation, dataArea, bounds, marker.getLabelOffset(),\n                    marker.getLabelOffsetType(), anchor);\n            TextUtilities.drawAlignedString(label, g2,\n                    (float) coordinates.getX(), (float) coordinates.getY(),\n                    marker.getLabelTextAnchor());\n        }\n        g2.setComposite(savedComposite);\n    }\n\n    /**\n     * Draws a marker for the range axis.\n     *\n     * @param g2  the graphics device (not <code>null</code>).\n     * @param plot  the plot (not <code>null</code>).\n     * @param axis  the range axis (not <code>null</code>).\n     * @param marker  the marker to be drawn (not <code>null</code>).\n     * @param dataArea  the area inside the axes (not <code>null</code>).\n     *\n     * @see #drawDomainMarker(Graphics2D, CategoryPlot, CategoryAxis,\n     *     CategoryMarker, Rectangle2D)\n     */\n    public void drawRangeMarker(Graphics2D g2,\n                                CategoryPlot plot,\n                                ValueAxis axis,\n                                Marker marker,\n                                Rectangle2D dataArea) {\n\n        if (marker instanceof ValueMarker) {\n            ValueMarker vm = (ValueMarker) marker;\n            double value = vm.getValue();\n            Range range = axis.getRange();\n\n            if (!range.contains(value)) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            PlotOrientation orientation = plot.getOrientation();\n            double v = axis.valueToJava2D(value, dataArea,\n                    plot.getRangeAxisEdge());\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                line = new Line2D.Double(v, dataArea.getMinY(), v,\n                        dataArea.getMaxY());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                line = new Line2D.Double(dataArea.getMinX(), v,\n                        dataArea.getMaxX(), v);\n            }\n\n            g2.setPaint(marker.getPaint());\n            g2.setStroke(marker.getStroke());\n            g2.draw(line);\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, line.getBounds2D(),\n                        marker.getLabelOffset(), LengthAdjustmentType.EXPAND,\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n        else if (marker instanceof IntervalMarker) {\n            IntervalMarker im = (IntervalMarker) marker;\n            double start = im.getStartValue();\n            double end = im.getEndValue();\n            Range range = axis.getRange();\n            if (!(range.intersects(start, end))) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            double start2d = axis.valueToJava2D(start, dataArea,\n                    plot.getRangeAxisEdge());\n            double end2d = axis.valueToJava2D(end, dataArea,\n                    plot.getRangeAxisEdge());\n            double low = Math.min(start2d, end2d);\n            double high = Math.max(start2d, end2d);\n\n            PlotOrientation orientation = plot.getOrientation();\n            Rectangle2D rect = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                // clip left and right bounds to data area\n                low = Math.max(low, dataArea.getMinX());\n                high = Math.min(high, dataArea.getMaxX());\n                rect = new Rectangle2D.Double(low,\n                        dataArea.getMinY(), high - low,\n                        dataArea.getHeight());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                // clip top and bottom bounds to data area\n                low = Math.max(low, dataArea.getMinY());\n                high = Math.min(high, dataArea.getMaxY());\n                rect = new Rectangle2D.Double(dataArea.getMinX(),\n                        low, dataArea.getWidth(),\n                        high - low);\n            }\n            Paint p = marker.getPaint();\n            if (p instanceof GradientPaint) {\n                GradientPaint gp = (GradientPaint) p;\n                GradientPaintTransformer t = im.getGradientPaintTransformer();\n                if (t != null) {\n                    gp = t.transform(gp, rect);\n                }\n                g2.setPaint(gp);\n            }\n            else {\n                g2.setPaint(p);\n            }\n            g2.fill(rect);\n\n            // now draw the outlines, if visible...\n            if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n                if (orientation == PlotOrientation.VERTICAL) {\n                    Line2D line = new Line2D.Double();\n                    double x0 = dataArea.getMinX();\n                    double x1 = dataArea.getMaxX();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(x0, start2d, x1, start2d);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(x0, end2d, x1, end2d);\n                        g2.draw(line);\n                    }\n                }\n                else { // PlotOrientation.HORIZONTAL\n                    Line2D line = new Line2D.Double();\n                    double y0 = dataArea.getMinY();\n                    double y1 = dataArea.getMaxY();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(start2d, y0, start2d, y1);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(end2d, y0, end2d, y1);\n                        g2.draw(line);\n                    }\n                }\n            }\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, rect,\n                        marker.getLabelOffset(), marker.getLabelOffsetType(),\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n    }\n\n    /**\n     * Calculates the (x, y) coordinates for drawing the label for a marker on\n     * the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the plot orientation.\n     * @param dataArea  the data area.\n     * @param markerArea  the rectangle surrounding the marker.\n     * @param markerOffset  the marker offset.\n     * @param labelOffsetType  the label offset type.\n     * @param anchor  the label anchor.\n     *\n     * @return The coordinates for drawing the marker label.\n     */\n    protected Point2D calculateDomainMarkerTextAnchorPoint(Graphics2D g2,\n                                      PlotOrientation orientation,\n                                      Rectangle2D dataArea,\n                                      Rectangle2D markerArea,\n                                      RectangleInsets markerOffset,\n                                      LengthAdjustmentType labelOffsetType,\n                                      RectangleAnchor anchor) {\n\n        Rectangle2D anchorRect = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    LengthAdjustmentType.CONTRACT, labelOffsetType);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    labelOffsetType, LengthAdjustmentType.CONTRACT);\n        }\n        return RectangleAnchor.coordinates(anchorRect, anchor);\n\n    }\n\n    /**\n     * Calculates the (x, y) coordinates for drawing a marker label.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the plot orientation.\n     * @param dataArea  the data area.\n     * @param markerArea  the rectangle surrounding the marker.\n     * @param markerOffset  the marker offset.\n     * @param labelOffsetType  the label offset type.\n     * @param anchor  the label anchor.\n     *\n     * @return The coordinates for drawing the marker label.\n     */\n    protected Point2D calculateRangeMarkerTextAnchorPoint(Graphics2D g2,\n                                      PlotOrientation orientation,\n                                      Rectangle2D dataArea,\n                                      Rectangle2D markerArea,\n                                      RectangleInsets markerOffset,\n                                      LengthAdjustmentType labelOffsetType,\n                                      RectangleAnchor anchor) {\n\n        Rectangle2D anchorRect = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    labelOffsetType, LengthAdjustmentType.CONTRACT);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            anchorRect = markerOffset.createAdjustedRectangle(markerArea,\n                    LengthAdjustmentType.CONTRACT, labelOffsetType);\n        }\n        return RectangleAnchor.coordinates(anchorRect, anchor);\n\n    }\n\n    /**\n     * Returns a legend item for a series.  This default implementation will\n     * return <code>null</code> if {@link #isSeriesVisible(int)} or\n     * {@link #isSeriesVisibleInLegend(int)} returns <code>false</code>.\n     *\n     * @param datasetIndex  the dataset index (zero-based).\n     * @param series  the series index (zero-based).\n     *\n     * @return The legend item (possibly <code>null</code>).\n     *\n     * @see #getLegendItems()\n     */\n    public LegendItem getLegendItem(int datasetIndex, int series) {\n\n        CategoryPlot p = getPlot();\n        if (p == null) {\n            return null;\n        }\n\n        // check that a legend item needs to be displayed...\n        if (!isSeriesVisible(series) || !isSeriesVisibleInLegend(series)) {\n            return null;\n        }\n\n        CategoryDataset dataset = p.getDataset(datasetIndex);\n        String label = this.legendItemLabelGenerator.generateLabel(dataset,\n                series);\n        String description = label;\n        String toolTipText = null;\n        if (this.legendItemToolTipGenerator != null) {\n            toolTipText = this.legendItemToolTipGenerator.generateLabel(\n                    dataset, series);\n        }\n        String urlText = null;\n        if (this.legendItemURLGenerator != null) {\n            urlText = this.legendItemURLGenerator.generateLabel(dataset,\n                    series);\n        }\n        Shape shape = lookupLegendShape(series);\n        Paint paint = lookupSeriesPaint(series);\n        Paint outlinePaint = lookupSeriesOutlinePaint(series);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(series);\n\n        LegendItem item = new LegendItem(label, description, toolTipText,\n                urlText, shape, paint, outlineStroke, outlinePaint);\n        item.setLabelFont(lookupLegendTextFont(series));\n        Paint labelPaint = lookupLegendTextPaint(series);\n        if (labelPaint != null) {\n            item.setLabelPaint(labelPaint);\n        }\n        item.setSeriesKey(dataset.getRowKey(series));\n        item.setSeriesIndex(series);\n        item.setDataset(dataset);\n        item.setDatasetIndex(datasetIndex);\n        return item;\n    }\n\n    /**\n     * Tests this renderer for equality with another object.\n     *\n     * @param obj  the object.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof AbstractCategoryItemRenderer)) {\n            return false;\n        }\n        AbstractCategoryItemRenderer that = (AbstractCategoryItemRenderer) obj;\n\n        if (!ObjectUtilities.equal(this.itemLabelGeneratorList,\n                that.itemLabelGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseItemLabelGenerator,\n                that.baseItemLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGeneratorList,\n                that.toolTipGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseToolTipGenerator,\n                that.baseToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGeneratorList,\n                that.urlGeneratorList)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.baseURLGenerator,\n                that.baseURLGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemLabelGenerator,\n                that.legendItemLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemToolTipGenerator,\n                that.legendItemToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendItemURLGenerator,\n                that.legendItemURLGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundAnnotations,\n                that.backgroundAnnotations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundAnnotations,\n                that.foregroundAnnotations)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for the renderer.\n     *\n     * @return The hash code.\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns the drawing supplier from the plot.\n     *\n     * @return The drawing supplier (possibly <code>null</code>).\n     */\n    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result = null;\n        CategoryPlot cp = getPlot();\n        if (cp != null) {\n            result = cp.getDrawingSupplier();\n        }\n        return result;\n    }\n\n    /**\n     * Considers the current (x, y) coordinate and updates the crosshair point\n     * if it meets the criteria (usually means the (x, y) coordinate is the\n     * closest to the anchor point so far).\n     *\n     * @param crosshairState  the crosshair state (<code>null</code> permitted,\n     *                        but the method does nothing in that case).\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param value  the data value.\n     * @param datasetIndex  the dataset index.\n     * @param transX  the x-value translated to Java2D space.\n     * @param transY  the y-value translated to Java2D space.\n     * @param orientation  the plot orientation (<code>null</code> not\n     *                     permitted).\n     *\n     * @since 1.0.11\n     */\n    protected void updateCrosshairValues(CategoryCrosshairState crosshairState,\n            Comparable rowKey, Comparable columnKey, double value,\n            int datasetIndex,\n            double transX, double transY, PlotOrientation orientation) {\n\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        if (crosshairState != null) {\n            if (this.plot.isRangeCrosshairLockedOnData()) {\n                // both axes\n                crosshairState.updateCrosshairPoint(rowKey, columnKey, value,\n                        datasetIndex, transX, transY, orientation);\n            }\n            else {\n                crosshairState.updateCrosshairX(rowKey, columnKey,\n                        datasetIndex, transX, orientation);\n            }\n        }\n    }\n\n    /**\n     * Draws an item label.\n     *\n     * @param g2  the graphics device.\n     * @param orientation  the orientation.\n     * @param dataset  the dataset.\n     * @param row  the row.\n     * @param column  the column.\n     * @param selected  is the item selected?\n     * @param x  the x coordinate (in Java2D space).\n     * @param y  the y coordinate (in Java2D space).\n     * @param negative  indicates a negative value (which affects the item\n     *                  label position).\n     *\n     * @since 1.2.0\n     */\n    protected void drawItemLabel(Graphics2D g2, PlotOrientation orientation,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double x, double y, boolean negative) {\n\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n                column, selected);\n        if (generator != null) {\n            Font labelFont = getItemLabelFont(row, column, selected);\n            Paint paint = getItemLabelPaint(row, column, selected);\n            g2.setFont(labelFont);\n            g2.setPaint(paint);\n            String label = generator.generateLabel(dataset, row, column);\n            ItemLabelPosition position = null;\n            if (!negative) {\n                position = getPositiveItemLabelPosition(row, column, selected);\n            }\n            else {\n                position = getNegativeItemLabelPosition(row, column, selected);\n            }\n            Point2D anchorPoint = calculateLabelAnchorPoint(\n                    position.getItemLabelAnchor(), x, y, orientation);\n            TextUtilities.drawRotatedString(label, g2,\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getTextAnchor(),\n                    position.getAngle(), position.getRotationAnchor());\n        }\n\n    }\n\n    /**\n     * Draws all the annotations for the specified layer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param layer  the layer.\n     * @param info  the plot rendering info.\n     *\n     * @since 1.2.0\n     */\n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            CategoryAxis domainAxis, ValueAxis rangeAxis, Layer layer,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = null;\n        if (layer.equals(Layer.FOREGROUND)) {\n            iterator = this.foregroundAnnotations.iterator();\n        }\n        else if (layer.equals(Layer.BACKGROUND)) {\n            iterator = this.backgroundAnnotations.iterator();\n        }\n        else {\n            // should not get here\n            throw new RuntimeException(\"Unknown layer.\");\n        }\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this.plot, dataArea, domainAxis, rangeAxis,\n                    0, info);\n        }\n\n    }\n\n    /**\n     * Returns an independent copy of the renderer.  The <code>plot</code>\n     * reference is shallow copied.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  can be thrown if one of the objects\n     *         belonging to the renderer does not support cloning (for example,\n     *         an item label generator).\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        AbstractCategoryItemRenderer clone\n                = (AbstractCategoryItemRenderer) super.clone();\n\n\n        if (this.itemLabelGeneratorList != null) {\n            clone.itemLabelGeneratorList\n                    = (ObjectList) this.itemLabelGeneratorList.clone();\n        }\n\n        if (this.baseItemLabelGenerator != null) {\n            if (this.baseItemLabelGenerator instanceof PublicCloneable) {\n                PublicCloneable pc\n                        = (PublicCloneable) this.baseItemLabelGenerator;\n                clone.baseItemLabelGenerator\n                        = (CategoryItemLabelGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"ItemLabelGenerator not cloneable.\");\n            }\n        }\n\n        if (this.toolTipGeneratorList != null) {\n            clone.toolTipGeneratorList\n                    = (ObjectList) this.toolTipGeneratorList.clone();\n        }\n\n        if (this.baseToolTipGenerator != null) {\n            if (this.baseToolTipGenerator instanceof PublicCloneable) {\n                PublicCloneable pc\n                        = (PublicCloneable) this.baseToolTipGenerator;\n                clone.baseToolTipGenerator\n                        = (CategoryToolTipGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base tool tip generator not cloneable.\");\n            }\n        }\n\n        if (this.urlGeneratorList != null) {\n            clone.urlGeneratorList = (ObjectList) this.urlGeneratorList.clone();\n        }\n\n        if (this.baseURLGenerator != null) {\n            if (this.baseURLGenerator instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) this.baseURLGenerator;\n                clone.baseURLGenerator = (CategoryURLGenerator) pc.clone();\n            }\n            else {\n                throw new CloneNotSupportedException(\n                        \"Base item URL generator not cloneable.\");\n            }\n        }\n\n        if (this.legendItemLabelGenerator instanceof PublicCloneable) {\n            clone.legendItemLabelGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemLabelGenerator);\n        }\n        if (this.legendItemToolTipGenerator instanceof PublicCloneable) {\n            clone.legendItemToolTipGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemToolTipGenerator);\n        }\n        if (this.legendItemURLGenerator instanceof PublicCloneable) {\n            clone.legendItemURLGenerator = (CategorySeriesLabelGenerator)\n                    ObjectUtilities.clone(this.legendItemURLGenerator);\n        }\n        return clone;\n    }\n\n    /**\n     * Returns the domain axis that is used for the specified dataset.\n     *\n     * @param plot  the plot (<code>null</code> not permitted).\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return A domain axis.\n     */\n    protected CategoryAxis getDomainAxis(CategoryPlot plot, \n            CategoryDataset dataset) {\n        int datasetIndex = plot.indexOf(dataset);\n        return plot.getDomainAxisForDataset(datasetIndex);\n    }\n\n    /**\n     * Returns a range axis for a plot.\n     *\n     * @param plot  the plot.\n     * @param index  the axis index.\n     *\n     * @return A range axis.\n     */\n    protected ValueAxis getRangeAxis(CategoryPlot plot, int index) {\n        ValueAxis result = plot.getRangeAxis(index);\n        if (result == null) {\n            result = plot.getRangeAxis();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a (possibly empty) collection of legend items for the series\n     * that this renderer is responsible for drawing.\n     *\n     * @return The legend item collection (never <code>null</code>).\n     *\n     * @see #getLegendItem(int, int)\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}\n"}]}
{"project": "Chart", "bug_id": 2, "classes_modified": [{"class_name": "org.jfree.data.general.DatasetUtilities", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------------\n * DatasetUtilities.java\n * ---------------------\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andrzej Porebski (bug fix);\n *                   Jonathan Nash (bug fix);\n *                   Richard Atkinson;\n *                   Andreas Schroeder;\n *                   Rafal Skalny (patch 1925366);\n *                   Jerome David (patch 2131001);\n *                   Peter Kolb (patch 2791407);\n *\n * Changes (from 18-Sep-2001)\n * --------------------------\n * 18-Sep-2001 : Added standard header and fixed DOS encoding problem (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 15-Nov-2001 : Moved to package com.jrefinery.data.* in the JCommon class\n *               library (DG);\n *               Changed to handle null values from datasets (DG);\n *               Bug fix (thanks to Andrzej Porebski) - initial value now set\n *               to positive or negative infinity when iterating (DG);\n * 22-Nov-2001 : Datasets with containing no data now return null for min and\n *               max calculations (DG);\n * 13-Dec-2001 : Extended to handle HighLowDataset and IntervalXYDataset (DG);\n * 15-Feb-2002 : Added getMinimumStackedRangeValue() and\n *               getMaximumStackedRangeValue() (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 18-Mar-2002 : Fixed bug in min/max domain calculation for datasets that\n *               implement the CategoryDataset interface AND the XYDataset\n *               interface at the same time.  Thanks to Jonathan Nash for the\n *               fix (DG);\n * 23-Apr-2002 : Added getDomainExtent() and getRangeExtent() methods (DG);\n * 13-Jun-2002 : Modified range measurements to handle\n *               IntervalCategoryDataset (DG);\n * 12-Jul-2002 : Method name change in DomainInfo interface (DG);\n * 30-Jul-2002 : Added pie dataset summation method (DG);\n * 01-Oct-2002 : Added a method for constructing an XYDataset from a Function2D\n *               instance (DG);\n * 24-Oct-2002 : Amendments required following changes to the CategoryDataset\n *               interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 04-Mar-2003 : Added isEmpty(XYDataset) method (DG);\n * 05-Mar-2003 : Added a method for creating a CategoryDataset from a\n *               KeyedValues instance (DG);\n * 15-May-2003 : Renamed isEmpty --> isEmptyOrNull (DG);\n * 25-Jun-2003 : Added limitPieDataset methods (RA);\n * 26-Jun-2003 : Modified getDomainExtent() method to accept null datasets (DG);\n * 27-Jul-2003 : Added getStackedRangeExtent(TableXYDataset data) (RA);\n * 18-Aug-2003 : getStackedRangeExtent(TableXYDataset data) now handles null\n *               values (RA);\n * 02-Sep-2003 : Added method to check for null or empty PieDataset (DG);\n * 18-Sep-2003 : Fix for bug 803660 (getMaximumRangeValue for\n *               CategoryDataset) (DG);\n * 20-Oct-2003 : Added getCumulativeRangeExtent() method (DG);\n * 09-Jan-2003 : Added argument checking code to the createCategoryDataset()\n *               method (DG);\n * 23-Mar-2004 : Fixed bug in getMaximumStackedRangeValue() method (DG);\n * 31-Mar-2004 : Exposed the extent iteration algorithms to use one of them and\n *               applied noninstantiation pattern (AS);\n * 11-May-2004 : Renamed getPieDatasetTotal --> calculatePieDatasetTotal (DG);\n * 15-Jul-2004 : Switched getX() with getXValue() and getY() with getYValue();\n * 24-Aug-2004 : Added argument checks to createCategoryDataset() method (DG);\n * 04-Oct-2004 : Renamed ArrayUtils --> ArrayUtilities (DG);\n * 06-Oct-2004 : Renamed findDomainExtent() --> findDomainBounds(),\n *               findRangeExtent() --> findRangeBounds() (DG);\n * 07-Jan-2005 : Renamed findStackedRangeExtent() --> findStackedRangeBounds(),\n *               findCumulativeRangeExtent() --> findCumulativeRangeBounds(),\n *               iterateXYRangeExtent() --> iterateXYRangeBounds(),\n *               removed deprecated methods (DG);\n * 03-Feb-2005 : The findStackedRangeBounds() methods now return null for\n *               empty datasets (DG);\n * 03-Mar-2005 : Moved createNumberArray() and createNumberArray2D() methods\n *               from DatasetUtilities --> DataUtilities (DG);\n * 22-Sep-2005 : Added new findStackedRangeBounds() method that takes base\n *               argument (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 15-Mar-2007 : Added calculateStackTotal() method (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Mar-2008 : Fixed bug in findCumulativeRangeBounds() method (DG);\n * 28-Mar-2008 : Fixed sample count in sampleFunction2D() method, renamed\n *               iterateXYRangeBounds() --> iterateRangeBounds(XYDataset), and\n *               fixed a bug in findRangeBounds(XYDataset, false) (DG);\n * 28-Mar-2008 : Applied a variation of patch 1925366 (from Rafal Skalny) for\n *               slightly more efficient iterateRangeBounds() methods (DG);\n * 08-Apr-2008 : Fixed typo in iterateRangeBounds() (DG);\n * 08-Oct-2008 : Applied patch 2131001 by Jerome David, with some modifications\n *               and additions and some new unit tests (DG);\n * 12-Feb-2009 : Added sampleFunction2DToSeries() method (DG);\n * 27-Mar-2009 : Added new methods to find domain and range bounds taking into\n *               account hidden series (DG);\n * 01-Apr-2009 : Handle a StatisticalCategoryDataset in\n *               iterateToFindRangeBounds() (DG);\n * 16-May-2009 : Patch 2791407 - fix iterateToFindRangeBounds for\n *               MultiValueCategoryDataset (PK);\n * 10-Sep-2009 : Fix bug 2849731 for IntervalCategoryDataset (DG);\n *\n */\n\npackage org.jfree.data.general;\n\nimport org.jfree.data.pie.PieDataset;\nimport org.jfree.data.pie.DefaultPieDataset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtilities;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n/**\n * A collection of useful static methods relating to datasets.\n */\npublic final class DatasetUtilities {\n\n    /**\n     * Private constructor for non-instanceability.\n     */\n    private DatasetUtilities() {\n        // now try to instantiate this ;-)\n    }\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or <code>null</code> values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param rowKey  the row key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param row  the row (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param columnKey  the column key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    /**\n     * Creates a pie dataset from a {@link CategoryDataset} by taking all the\n     * values for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param column  the column (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item with the\n     * key \"Other\".\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  a new key for the aggregated items (<code>null</code> not\n     *             permitted).\n     * @param minimumPercent  the percent threshold.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item.  The\n     * aggregated items are assigned the specified key.  Aggregation only\n     * occurs if there are at least <code>minItems</code> items to aggregate.\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  the key to represent the aggregated items.\n     * @param minimumPercent  the percent threshold (ten percent is 0.10).\n     * @param minItems  only aggregate low values if there are at least this\n     *                  many.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtilities.calculatePieDatasetTotal(source);\n\n        //  Iterate and find all keys below threshold percentThreshold\n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        //  Create new dataset with keys above threshold percentThreshold\n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    //  Do not add key to dataset\n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    //  Add key to dataset\n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        //  Add other category if applicable\n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in an\n     * array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array.\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are taken from the supplied arrays.\n     *\n     * @param rowKeys  the row keys (<code>null</code> not permitted).\n     * @param columnKeys  the column keys (<code>null</code> not permitted).\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        // check arguments...\n        if (rowKeys == null) {\n            throw new IllegalArgumentException(\"Null 'rowKeys' argument.\");\n        }\n        if (columnKeys == null) {\n            throw new IllegalArgumentException(\"Null 'columnKeys' argument.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        // now do the work...\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} by copying the data from the supplied\n     * {@link KeyedValues} instance.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param rowData  the row data (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n                                                        KeyedValues rowData) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n        }\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates an {@link XYDataset} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        // defer argument checking\n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    /**\n     * Creates an {@link XYSeries} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A series.\n     *\n     * @since 1.0.13\n     */\n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        if (f == null) {\n            throw new IllegalArgumentException(\"Null 'f' argument.\");\n        }\n        if (seriesKey == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKey' argument.\");\n        }\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  determines whether or not the x-interval is taken\n     *                         into account (only applies if the dataset is an\n     *                         {@link IntervalXYDataset}).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n                                         boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        Range result = null;\n        // if the dataset implements DomainInfo, life is easier\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the bounds of the x-values in the specified <code>dataset</code>\n     * taking into account only the visible series and including any x-interval\n     * if requested.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code>\n     *     not permitted).\n     * @param includeInterval  include the x-interval (if any)?\n     *\n     * @return The bounds (or <code>null</code> if the dataset contains no\n     *     values.\n     *\n     * @since 1.0.13\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.  If the dataset is an instance of\n     * {@link IntervalXYDataset}, the starting and ending x-values\n     * will be used for the bounds calculation.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset)} method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset, boolean)}\n     * method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys, and those items\n     * whose x-values fall within the specified range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use\n     *         {@link #iterateRangeBounds(CategoryDataset, boolean)}.\n     */\n    public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        return iterateRangeBounds(dataset, includeInterval);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null \n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * @param visibleSeriesKeys  the visible series keys.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            // handle special case of BoxAndWhiskerDataset\n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                    \tObject o = valueIterator.next();\n\t\t\t\t\t\tif (o instanceof Number){\n\t\t\t\t\t\t\tdouble v = ((Number) o).doubleValue();\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\n\t                            minimum = Math.min(minimum, v);\n\t                            maximum = Math.max(maximum, v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n               }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof StatisticalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use {@link #iterateRangeBounds(XYDataset)}.\n     */\n    public static Range iterateXYRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset);\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of x-values in the specified dataset for the\n     * data items belonging to the visible series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The x-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of y-values in the specified dataset for the\n     * data items belonging to the visible series and with x-values in the\n     * given range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The y-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n        if (xRange == null) {\n            throw new IllegalArgumentException(\"Null 'xRange' argument\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            // handle special case of BoxAndWhiskerXYDataset\n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Finds the minimum domain (or X) value for the specified dataset.  This\n     * is easy if the dataset implements the {@link DomainInfo} interface (a\n     * good idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.\n     * <p>\n     * Returns <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the maximum domain value for the specified dataset.  This is\n     * easy if the dataset implements the {@link DomainInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainUpperBound(true));\n        }\n\n        // hasn't implemented DomainInfo, so iterate...\n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(maximum);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is easy\n     * if the dataset implements the {@link RangeInfo} interface (a good idea\n     * if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range (<code>null</code> if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     *\n     * @since 1.0.5\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; // we'll set this to false if there is at\n                                     // least one non-null data item...\n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------------\n * DatasetUtilities.java\n * ---------------------\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andrzej Porebski (bug fix);\n *                   Jonathan Nash (bug fix);\n *                   Richard Atkinson;\n *                   Andreas Schroeder;\n *                   Rafal Skalny (patch 1925366);\n *                   Jerome David (patch 2131001);\n *                   Peter Kolb (patch 2791407);\n *\n * Changes (from 18-Sep-2001)\n * --------------------------\n * 18-Sep-2001 : Added standard header and fixed DOS encoding problem (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 15-Nov-2001 : Moved to package com.jrefinery.data.* in the JCommon class\n *               library (DG);\n *               Changed to handle null values from datasets (DG);\n *               Bug fix (thanks to Andrzej Porebski) - initial value now set\n *               to positive or negative infinity when iterating (DG);\n * 22-Nov-2001 : Datasets with containing no data now return null for min and\n *               max calculations (DG);\n * 13-Dec-2001 : Extended to handle HighLowDataset and IntervalXYDataset (DG);\n * 15-Feb-2002 : Added getMinimumStackedRangeValue() and\n *               getMaximumStackedRangeValue() (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 18-Mar-2002 : Fixed bug in min/max domain calculation for datasets that\n *               implement the CategoryDataset interface AND the XYDataset\n *               interface at the same time.  Thanks to Jonathan Nash for the\n *               fix (DG);\n * 23-Apr-2002 : Added getDomainExtent() and getRangeExtent() methods (DG);\n * 13-Jun-2002 : Modified range measurements to handle\n *               IntervalCategoryDataset (DG);\n * 12-Jul-2002 : Method name change in DomainInfo interface (DG);\n * 30-Jul-2002 : Added pie dataset summation method (DG);\n * 01-Oct-2002 : Added a method for constructing an XYDataset from a Function2D\n *               instance (DG);\n * 24-Oct-2002 : Amendments required following changes to the CategoryDataset\n *               interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 04-Mar-2003 : Added isEmpty(XYDataset) method (DG);\n * 05-Mar-2003 : Added a method for creating a CategoryDataset from a\n *               KeyedValues instance (DG);\n * 15-May-2003 : Renamed isEmpty --> isEmptyOrNull (DG);\n * 25-Jun-2003 : Added limitPieDataset methods (RA);\n * 26-Jun-2003 : Modified getDomainExtent() method to accept null datasets (DG);\n * 27-Jul-2003 : Added getStackedRangeExtent(TableXYDataset data) (RA);\n * 18-Aug-2003 : getStackedRangeExtent(TableXYDataset data) now handles null\n *               values (RA);\n * 02-Sep-2003 : Added method to check for null or empty PieDataset (DG);\n * 18-Sep-2003 : Fix for bug 803660 (getMaximumRangeValue for\n *               CategoryDataset) (DG);\n * 20-Oct-2003 : Added getCumulativeRangeExtent() method (DG);\n * 09-Jan-2003 : Added argument checking code to the createCategoryDataset()\n *               method (DG);\n * 23-Mar-2004 : Fixed bug in getMaximumStackedRangeValue() method (DG);\n * 31-Mar-2004 : Exposed the extent iteration algorithms to use one of them and\n *               applied noninstantiation pattern (AS);\n * 11-May-2004 : Renamed getPieDatasetTotal --> calculatePieDatasetTotal (DG);\n * 15-Jul-2004 : Switched getX() with getXValue() and getY() with getYValue();\n * 24-Aug-2004 : Added argument checks to createCategoryDataset() method (DG);\n * 04-Oct-2004 : Renamed ArrayUtils --> ArrayUtilities (DG);\n * 06-Oct-2004 : Renamed findDomainExtent() --> findDomainBounds(),\n *               findRangeExtent() --> findRangeBounds() (DG);\n * 07-Jan-2005 : Renamed findStackedRangeExtent() --> findStackedRangeBounds(),\n *               findCumulativeRangeExtent() --> findCumulativeRangeBounds(),\n *               iterateXYRangeExtent() --> iterateXYRangeBounds(),\n *               removed deprecated methods (DG);\n * 03-Feb-2005 : The findStackedRangeBounds() methods now return null for\n *               empty datasets (DG);\n * 03-Mar-2005 : Moved createNumberArray() and createNumberArray2D() methods\n *               from DatasetUtilities --> DataUtilities (DG);\n * 22-Sep-2005 : Added new findStackedRangeBounds() method that takes base\n *               argument (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 15-Mar-2007 : Added calculateStackTotal() method (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Mar-2008 : Fixed bug in findCumulativeRangeBounds() method (DG);\n * 28-Mar-2008 : Fixed sample count in sampleFunction2D() method, renamed\n *               iterateXYRangeBounds() --> iterateRangeBounds(XYDataset), and\n *               fixed a bug in findRangeBounds(XYDataset, false) (DG);\n * 28-Mar-2008 : Applied a variation of patch 1925366 (from Rafal Skalny) for\n *               slightly more efficient iterateRangeBounds() methods (DG);\n * 08-Apr-2008 : Fixed typo in iterateRangeBounds() (DG);\n * 08-Oct-2008 : Applied patch 2131001 by Jerome David, with some modifications\n *               and additions and some new unit tests (DG);\n * 12-Feb-2009 : Added sampleFunction2DToSeries() method (DG);\n * 27-Mar-2009 : Added new methods to find domain and range bounds taking into\n *               account hidden series (DG);\n * 01-Apr-2009 : Handle a StatisticalCategoryDataset in\n *               iterateToFindRangeBounds() (DG);\n * 16-May-2009 : Patch 2791407 - fix iterateToFindRangeBounds for\n *               MultiValueCategoryDataset (PK);\n * 10-Sep-2009 : Fix bug 2849731 for IntervalCategoryDataset (DG);\n *\n */\n\npackage org.jfree.data.general;\n\nimport org.jfree.data.pie.PieDataset;\nimport org.jfree.data.pie.DefaultPieDataset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtilities;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n/**\n * A collection of useful static methods relating to datasets.\n */\npublic final class DatasetUtilities {\n\n    /**\n     * Private constructor for non-instanceability.\n     */\n    private DatasetUtilities() {\n        // now try to instantiate this ;-)\n    }\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or <code>null</code> values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param rowKey  the row key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param row  the row (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param columnKey  the column key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    /**\n     * Creates a pie dataset from a {@link CategoryDataset} by taking all the\n     * values for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param column  the column (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item with the\n     * key \"Other\".\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  a new key for the aggregated items (<code>null</code> not\n     *             permitted).\n     * @param minimumPercent  the percent threshold.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item.  The\n     * aggregated items are assigned the specified key.  Aggregation only\n     * occurs if there are at least <code>minItems</code> items to aggregate.\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  the key to represent the aggregated items.\n     * @param minimumPercent  the percent threshold (ten percent is 0.10).\n     * @param minItems  only aggregate low values if there are at least this\n     *                  many.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtilities.calculatePieDatasetTotal(source);\n\n        //  Iterate and find all keys below threshold percentThreshold\n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        //  Create new dataset with keys above threshold percentThreshold\n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    //  Do not add key to dataset\n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    //  Add key to dataset\n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        //  Add other category if applicable\n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in an\n     * array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array.\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are taken from the supplied arrays.\n     *\n     * @param rowKeys  the row keys (<code>null</code> not permitted).\n     * @param columnKeys  the column keys (<code>null</code> not permitted).\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        // check arguments...\n        if (rowKeys == null) {\n            throw new IllegalArgumentException(\"Null 'rowKeys' argument.\");\n        }\n        if (columnKeys == null) {\n            throw new IllegalArgumentException(\"Null 'columnKeys' argument.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        // now do the work...\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} by copying the data from the supplied\n     * {@link KeyedValues} instance.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param rowData  the row data (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n                                                        KeyedValues rowData) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n        }\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates an {@link XYDataset} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        // defer argument checking\n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    /**\n     * Creates an {@link XYSeries} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A series.\n     *\n     * @since 1.0.13\n     */\n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        if (f == null) {\n            throw new IllegalArgumentException(\"Null 'f' argument.\");\n        }\n        if (seriesKey == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKey' argument.\");\n        }\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  determines whether or not the x-interval is taken\n     *                         into account (only applies if the dataset is an\n     *                         {@link IntervalXYDataset}).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n                                         boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        Range result = null;\n        // if the dataset implements DomainInfo, life is easier\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the bounds of the x-values in the specified <code>dataset</code>\n     * taking into account only the visible series and including any x-interval\n     * if requested.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code>\n     *     not permitted).\n     * @param includeInterval  include the x-interval (if any)?\n     *\n     * @return The bounds (or <code>null</code> if the dataset contains no\n     *     values.\n     *\n     * @since 1.0.13\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.  If the dataset is an instance of\n     * {@link IntervalXYDataset}, the starting and ending x-values\n     * will be used for the bounds calculation.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = intervalXYData.getXValue(series, item);\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset)} method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset, boolean)}\n     * method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys, and those items\n     * whose x-values fall within the specified range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use\n     *         {@link #iterateRangeBounds(CategoryDataset, boolean)}.\n     */\n    public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        return iterateRangeBounds(dataset, includeInterval);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null \n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * @param visibleSeriesKeys  the visible series keys.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            // handle special case of BoxAndWhiskerDataset\n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                    \tObject o = valueIterator.next();\n\t\t\t\t\t\tif (o instanceof Number){\n\t\t\t\t\t\t\tdouble v = ((Number) o).doubleValue();\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\n\t                            minimum = Math.min(minimum, v);\n\t                            maximum = Math.max(maximum, v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n               }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof StatisticalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use {@link #iterateRangeBounds(XYDataset)}.\n     */\n    public static Range iterateXYRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset);\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = ixyd.getYValue(series, item);\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of x-values in the specified dataset for the\n     * data items belonging to the visible series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The x-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of y-values in the specified dataset for the\n     * data items belonging to the visible series and with x-values in the\n     * given range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The y-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n        if (xRange == null) {\n            throw new IllegalArgumentException(\"Null 'xRange' argument\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            // handle special case of BoxAndWhiskerXYDataset\n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Finds the minimum domain (or X) value for the specified dataset.  This\n     * is easy if the dataset implements the {@link DomainInfo} interface (a\n     * good idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.\n     * <p>\n     * Returns <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the maximum domain value for the specified dataset.  This is\n     * easy if the dataset implements the {@link DomainInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainUpperBound(true));\n        }\n\n        // hasn't implemented DomainInfo, so iterate...\n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(maximum);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is easy\n     * if the dataset implements the {@link RangeInfo} interface (a good idea\n     * if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range (<code>null</code> if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     *\n     * @since 1.0.5\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; // we'll set this to false if there is at\n                                     // least one non-null data item...\n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 3, "classes_modified": [{"class_name": "org.jfree.data.time.TimeSeries", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2009, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors\n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented\n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for\n *               contents) made a method and added to addOrUpdate.  Made a\n *               public method to enable ageing against a specified time\n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.\n *               Modified exception message in add() method to be more\n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report\n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500\n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to\n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * 10-Jan-2008 : Fixed createCopy(RegularTimePeriod, RegularTimePeriod) (bug\n *               1864222) (DG);\n * 13-Jan-2009 : Fixed constructors so that timePeriodClass doesn't need to\n *               be specified in advance (DG);\n * 26-May-2009 : Added cache for minY and maxY values (DG);\n * 09-Jun-2009 : Ensure that TimeSeriesDataItem objects used in underlying\n *               storage are cloned to keep series isolated from external\n *               changes (DG);\n * 10-Jun-2009 : Added addOrUpdate(TimeSeriesDataItem) method (DG);\n * 31-Aug-2009 : Clear minY and maxY cache values in createCopy (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.event.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value)\n * where 'period' is some instance of a subclass of {@link RegularTimePeriod}.\n * The time series will ensure that (a) all data items have the same type of\n * period (for example, {@link Day}) and (b) that each period appears at\n * most one time in the series.\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n\n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /**\n     * The maximum age of items for the series, specified as a number of\n     * time periods.\n     */\n    private long maximumItemAge;\n\n    /**\n     * The minimum y-value in the series.\n     *\n     * @since 1.0.14\n     */\n    private double minY;\n\n    /**\n     * The maximum y-value in the series.\n     *\n     * @since 1.0.14\n     */\n    private double maxY;\n\n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is\n     * created.  Use one of the other constructors if you require a different\n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     *\n     * @since 1.0.13\n     */\n    public TimeSeries(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = null;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     *\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     *\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        // FIXME: perhaps we should clone the data list\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     *\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the FIRST element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     *\n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     *\n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This\n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically\n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     *\n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the smallest y-value in the series, ignoring any null and\n     * Double.NaN values.  This method returns Double.NaN if there is no\n     * smallest y-value (for example, when the series is empty).\n     *\n     * @return The smallest y-value.\n     *\n     * @see #getMaxY()\n     *\n     * @since 1.0.14\n     */\n    public double getMinY() {\n        return this.minY;\n    }\n\n    /**\n     * Returns the largest y-value in the series, ignoring any Double.NaN\n     * values.  This method returns Double.NaN if there is no largest y-value\n     * (for example, when the series is empty).\n     *\n     * @return The largest y-value.\n     *\n     * @see #getMinY()\n     *\n     * @since 1.0.14\n     */\n    public double getMaxY() {\n        return this.maxY;\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (may be <code>null</code> but only for\n     *     an empty series).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item from the dataset.  Note that the returned object\n     * is a clone of the item in the series, so modifying it will have no\n     * effect on the data series.\n     *\n     * @param index  the item index.\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        return (TimeSeriesDataItem) item.clone();\n    }\n\n    /**\n     * Returns the data item for a specific period.  Note that the returned\n     * object is a clone of the item in the series, so modifying it will have\n     * no effect on the data series.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or\n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getDataItem(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a data item for the series.  This method returns the object\n     * that is used for the underlying storage - you should not modify the\n     * contents of the returned value unless you know what you are doing.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(int)\n     *\n     * @since 1.0.14\n     */\n    TimeSeriesDataItem getRawDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns a data item for the series.  This method returns the object\n     * that is used for the underlying storage - you should not modify the\n     * contents of the returned value unless you know what you are doing.\n     *\n     * @param period  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     *\n     * @since 1.0.14\n     */\n    TimeSeriesDataItem getRawDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time\n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getRawDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the\n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        item = (TimeSeriesDataItem) item.clone();\n        Class c = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = c;\n        }\n        else if (!this.timePeriodClass.equals(c)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            updateBoundsForAddedItem(item);\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a\n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException(\"There is no existing value for the \"\n                    + \"specified 'period'.\");\n        }\n        update(index, value);\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n        return addOrUpdate(new TimeSeriesDataItem(period, value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param item  the data item (<code>null</code> not permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     *\n     * @since 1.0.14\n     */\n    public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            // to find the revised minY / maxY\n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  // remove old items if necessary, but\n                                 // don't notify anyone, because that\n                                 // happens next anyway...\n        fireSeriesChanged();\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to\n     * the oldest record in the series does not exceed maximumItemAge time\n     * periods.  Oldest items will be removed if required.\n     *\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                findBoundsByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied\n     * time to the oldest record in the series does not exceed history count.\n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data\n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n        if (this.data.isEmpty()) {\n            return;  // nothing to do\n        }\n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        // check if there are any values earlier than specified by the history\n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed) {\n            findBoundsByIteration();\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not\n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.remove(\n                    index);\n            updateBoundsForRemovedItem(item);\n            if (this.data.isEmpty()) {\n                this.timePeriodClass = null;\n            }\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        delete(start, end, true);\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.14\n     */\n    public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        findBoundsByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String\n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but\n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n    /**\n     * Updates the cached values for the minimum and maximum data values.\n     *\n     * @param item  the item added (<code>null</code> not permitted).\n     *\n     * @since 1.0.14\n     */\n    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }\n\n    /**\n     * Updates the cached values for the minimum and maximum data values on\n     * the basis that the specified item has just been removed.\n     *\n     * @param item  the item added (<code>null</code> not permitted).\n     *\n     * @since 1.0.14\n     */\n    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }\n\n    /**\n     * Finds the bounds of the x and y values for the series, by iterating\n     * through all the data items.\n     *\n     * @since 1.0.14\n     */\n    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }\n\n    /**\n     * A function to find the minimum of two values, but ignoring any\n     * Double.NaN values.\n     *\n     * @param a  the first value.\n     * @param b  the second value.\n     *\n     * @return The minimum of the two values.\n     */\n    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }\n\n    /**\n     * A function to find the maximum of two values, but ignoring any\n     * Double.NaN values.\n     *\n     * @param a  the first value.\n     * @param b  the second value.\n     *\n     * @return The maximum of the two values.\n     */\n    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2009, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors\n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented\n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for\n *               contents) made a method and added to addOrUpdate.  Made a\n *               public method to enable ageing against a specified time\n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.\n *               Modified exception message in add() method to be more\n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report\n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500\n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to\n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * 10-Jan-2008 : Fixed createCopy(RegularTimePeriod, RegularTimePeriod) (bug\n *               1864222) (DG);\n * 13-Jan-2009 : Fixed constructors so that timePeriodClass doesn't need to\n *               be specified in advance (DG);\n * 26-May-2009 : Added cache for minY and maxY values (DG);\n * 09-Jun-2009 : Ensure that TimeSeriesDataItem objects used in underlying\n *               storage are cloned to keep series isolated from external\n *               changes (DG);\n * 10-Jun-2009 : Added addOrUpdate(TimeSeriesDataItem) method (DG);\n * 31-Aug-2009 : Clear minY and maxY cache values in createCopy (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.event.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value)\n * where 'period' is some instance of a subclass of {@link RegularTimePeriod}.\n * The time series will ensure that (a) all data items have the same type of\n * period (for example, {@link Day}) and (b) that each period appears at\n * most one time in the series.\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n\n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /**\n     * The maximum age of items for the series, specified as a number of\n     * time periods.\n     */\n    private long maximumItemAge;\n\n    /**\n     * The minimum y-value in the series.\n     *\n     * @since 1.0.14\n     */\n    private double minY;\n\n    /**\n     * The maximum y-value in the series.\n     *\n     * @since 1.0.14\n     */\n    private double maxY;\n\n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is\n     * created.  Use one of the other constructors if you require a different\n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     *\n     * @since 1.0.13\n     */\n    public TimeSeries(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = null;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     *\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     *\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        // FIXME: perhaps we should clone the data list\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     *\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the FIRST element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     *\n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     *\n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This\n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically\n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     *\n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the smallest y-value in the series, ignoring any null and\n     * Double.NaN values.  This method returns Double.NaN if there is no\n     * smallest y-value (for example, when the series is empty).\n     *\n     * @return The smallest y-value.\n     *\n     * @see #getMaxY()\n     *\n     * @since 1.0.14\n     */\n    public double getMinY() {\n        return this.minY;\n    }\n\n    /**\n     * Returns the largest y-value in the series, ignoring any Double.NaN\n     * values.  This method returns Double.NaN if there is no largest y-value\n     * (for example, when the series is empty).\n     *\n     * @return The largest y-value.\n     *\n     * @see #getMinY()\n     *\n     * @since 1.0.14\n     */\n    public double getMaxY() {\n        return this.maxY;\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (may be <code>null</code> but only for\n     *     an empty series).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item from the dataset.  Note that the returned object\n     * is a clone of the item in the series, so modifying it will have no\n     * effect on the data series.\n     *\n     * @param index  the item index.\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        return (TimeSeriesDataItem) item.clone();\n    }\n\n    /**\n     * Returns the data item for a specific period.  Note that the returned\n     * object is a clone of the item in the series, so modifying it will have\n     * no effect on the data series.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or\n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getDataItem(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a data item for the series.  This method returns the object\n     * that is used for the underlying storage - you should not modify the\n     * contents of the returned value unless you know what you are doing.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(int)\n     *\n     * @since 1.0.14\n     */\n    TimeSeriesDataItem getRawDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns a data item for the series.  This method returns the object\n     * that is used for the underlying storage - you should not modify the\n     * contents of the returned value unless you know what you are doing.\n     *\n     * @param period  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     *\n     * @since 1.0.14\n     */\n    TimeSeriesDataItem getRawDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getRawDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time\n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getRawDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the\n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        item = (TimeSeriesDataItem) item.clone();\n        Class c = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = c;\n        }\n        else if (!this.timePeriodClass.equals(c)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            updateBoundsForAddedItem(item);\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a\n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index < 0) {\n            throw new SeriesException(\"There is no existing value for the \"\n                    + \"specified 'period'.\");\n        }\n        update(index, value);\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        boolean iterate = false;\n        Number oldYN = item.getValue();\n        if (oldYN != null) {\n            double oldY = oldYN.doubleValue();\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n        }\n        item.setValue(value);\n        if (iterate) {\n            findBoundsByIteration();\n        }\n        else if (value != null) {\n            double yy = value.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, yy);\n            this.maxY = maxIgnoreNaN(this.maxY, yy);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getRawDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n        return addOrUpdate(new TimeSeriesDataItem(period, value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param item  the data item (<code>null</code> not permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     *\n     * @since 1.0.14\n     */\n    public TimeSeriesDataItem addOrUpdate(TimeSeriesDataItem item) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        Class periodClass = item.getPeriod().getClass();\n        if (this.timePeriodClass == null) {\n            this.timePeriodClass = periodClass;\n        }\n        else if (!this.timePeriodClass.equals(periodClass)) {\n            String msg = \"You are trying to add data where the time \"\n                    + \"period class is \" + periodClass.getName()\n                    + \", but the TimeSeries is expecting an instance of \"\n                    + this.timePeriodClass.getName() + \".\";\n            throw new SeriesException(msg);\n        }\n        TimeSeriesDataItem overwritten = null;\n        int index = Collections.binarySearch(this.data, item);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                    = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            // figure out if we need to iterate through all the y-values\n            // to find the revised minY / maxY\n            boolean iterate = false;\n            Number oldYN = existing.getValue();\n            double oldY = oldYN != null ? oldYN.doubleValue() : Double.NaN;\n            if (!Double.isNaN(oldY)) {\n                iterate = oldY <= this.minY || oldY >= this.maxY;\n            }\n            existing.setValue(item.getValue());\n            if (iterate) {\n                findBoundsByIteration();\n            }\n            else if (item.getValue() != null) {\n                double yy = item.getValue().doubleValue();\n                this.minY = minIgnoreNaN(this.minY, yy);\n                this.maxY = minIgnoreNaN(this.maxY, yy);\n            }\n        }\n        else {\n            item = (TimeSeriesDataItem) item.clone();\n            this.data.add(-index - 1, item);\n            updateBoundsForAddedItem(item);\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                TimeSeriesDataItem d = (TimeSeriesDataItem) this.data.remove(0);\n                updateBoundsForRemovedItem(d);\n            }\n        }\n        removeAgedItems(false);  // remove old items if necessary, but\n                                 // don't notify anyone, because that\n                                 // happens next anyway...\n        fireSeriesChanged();\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to\n     * the oldest record in the series does not exceed maximumItemAge time\n     * periods.  Oldest items will be removed if required.\n     *\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed) {\n                findBoundsByIteration();\n                if (notify) {\n                    fireSeriesChanged();\n                }\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied\n     * time to the oldest record in the series does not exceed history count.\n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data\n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n        if (this.data.isEmpty()) {\n            return;  // nothing to do\n        }\n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        // check if there are any values earlier than specified by the history\n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed) {\n            findBoundsByIteration();\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            this.timePeriodClass = null;\n            this.minY = Double.NaN;\n            this.maxY = Double.NaN;\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not\n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.remove(\n                    index);\n            updateBoundsForRemovedItem(item);\n            if (this.data.isEmpty()) {\n                this.timePeriodClass = null;\n            }\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        delete(start, end, true);\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.14\n     */\n    public void delete(int start, int end, boolean notify) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        findBoundsByIteration();\n        if (this.data.isEmpty()) {\n            this.timePeriodClass = null;\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String\n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but\n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n        copy.minY = Double.NaN;\n        copy.maxY = Double.NaN;\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                that.getRangeDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.timePeriodClass,\n                that.timePeriodClass)) {\n            return false;\n        }\n        if (getMaximumItemAge() != that.getMaximumItemAge()) {\n            return false;\n        }\n        if (getMaximumItemCount() != that.getMaximumItemCount()) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getRawDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getRawDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getRawDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n    /**\n     * Updates the cached values for the minimum and maximum data values.\n     *\n     * @param item  the item added (<code>null</code> not permitted).\n     *\n     * @since 1.0.14\n     */\n    private void updateBoundsForAddedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (item.getValue() != null) {\n            double y = yN.doubleValue();\n            this.minY = minIgnoreNaN(this.minY, y);\n            this.maxY = maxIgnoreNaN(this.maxY, y);\n        }\n    }\n\n    /**\n     * Updates the cached values for the minimum and maximum data values on\n     * the basis that the specified item has just been removed.\n     *\n     * @param item  the item added (<code>null</code> not permitted).\n     *\n     * @since 1.0.14\n     */\n    private void updateBoundsForRemovedItem(TimeSeriesDataItem item) {\n        Number yN = item.getValue();\n        if (yN != null) {\n            double y = yN.doubleValue();\n            if (!Double.isNaN(y)) {\n                if (y <= this.minY || y >= this.maxY) {\n                    findBoundsByIteration();\n                }\n            }\n        }\n    }\n\n    /**\n     * Finds the bounds of the x and y values for the series, by iterating\n     * through all the data items.\n     *\n     * @since 1.0.14\n     */\n    private void findBoundsByIteration() {\n        this.minY = Double.NaN;\n        this.maxY = Double.NaN;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            TimeSeriesDataItem item = (TimeSeriesDataItem) iterator.next();\n            updateBoundsForAddedItem(item);\n        }\n    }\n\n    /**\n     * A function to find the minimum of two values, but ignoring any\n     * Double.NaN values.\n     *\n     * @param a  the first value.\n     * @param b  the second value.\n     *\n     * @return The minimum of the two values.\n     */\n    private double minIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.min(a, b);\n            }\n        }\n    }\n\n    /**\n     * A function to find the maximum of two values, but ignoring any\n     * Double.NaN values.\n     *\n     * @param a  the first value.\n     * @param b  the second value.\n     *\n     * @return The maximum of the two values.\n     */\n    private double maxIgnoreNaN(double a, double b) {\n        if (Double.isNaN(a)) {\n            return b;\n        }\n        else {\n            if (Double.isNaN(b)) {\n                return a;\n            }\n            else {\n                return Math.max(a, b);\n            }\n        }\n    }\n}\n"}]}
{"project": "Chart", "bug_id": 4, "classes_modified": [{"class_name": "org.jfree.chart.plot.XYPlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -----------\n * XYPlot.java\n * -----------\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Craig MacFarlane;\n *                   Mark Watson (www.markwatson.com);\n *                   Jonathan Nash;\n *                   Gideon Krause;\n *                   Klaus Rheinwald;\n *                   Xavier Poinsard;\n *                   Richard Atkinson;\n *                   Arnaud Lelievre;\n *                   Nicolas Brodu;\n *                   Eduardo Ramalho;\n *                   Sergei Ivanov;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *                   Ulrich Voigt - patches 1997549 and 2686040;\n *                   Peter Kolb - patches 1934255 and 2603321;\n *                   Andrew Mickish - patch 1868749;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header and fixed DOS encoding problem (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Removed the code for drawing the visual representation of each\n *               data point into a separate class StandardXYItemRenderer.\n *               This will make it easier to add variations to the way the\n *               charts are drawn.  Based on code contributed by Mark\n *               Watson (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 20-Nov-2001 : Fixed clipping bug that shows up when chart is displayed\n *               inside JScrollPane (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clauses from constructor (DG);\n * 13-Dec-2001 : Added skeleton code for tooltips.  Added new constructor. (DG);\n * 16-Jan-2002 : Renamed the tooltips class (DG);\n * 22-Jan-2002 : Added DrawInfo class, incorporating tooltips and crosshairs.\n *               Crosshairs based on code by Jonathan Nash (DG);\n * 05-Feb-2002 : Added alpha-transparency setting based on code by Sylvain\n *               Vieujot (DG);\n * 26-Feb-2002 : Updated getMinimumXXX() and getMaximumXXX() methods to handle\n *               special case when chart is null (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 28-Mar-2002 : The plot now registers with the renderer as a property change\n *               listener.  Also added a new constructor (DG);\n * 09-Apr-2002 : Removed the transRangeZero from the renderer.drawItem()\n *               method.  Moved the tooltip generator into the renderer (DG);\n * 23-Apr-2002 : Fixed bug in methods for drawing horizontal and vertical\n *               lines (DG);\n * 13-May-2002 : Small change to the draw() method so that it works for\n *               OverlaidXYPlot also (DG);\n * 25-Jun-2002 : Removed redundant import (DG);\n * 20-Aug-2002 : Renamed getItemRenderer() --> getRenderer(), and\n *               setXYItemRenderer() --> setRenderer() (DG);\n * 28-Aug-2002 : Added mechanism for (optional) plot annotations (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 09-Jan-2003 : Further additions to the grid settings, plus integrated plot\n *               border bug fix contributed by Gideon Krause (DG);\n * 22-Jan-2003 : Removed monolithic constructor (DG);\n * 04-Mar-2003 : Added 'no data' message, see bug report 691634.  Added\n *               secondary range markers using code contributed by Klaus\n *               Rheinwald (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Apr-2003 : Added setDomainAxisLocation() method (DG);\n * 30-Apr-2003 : Moved annotation drawing into a separate method (DG);\n * 01-May-2003 : Added multi-pass mechanism for renderers (DG);\n * 02-May-2003 : Changed axis locations from int to AxisLocation (DG);\n * 15-May-2003 : Added an orientation attribute (DG);\n * 02-Jun-2003 : Removed range axis compatibility test (DG);\n * 05-Jun-2003 : Added domain and range grid bands (sponsored by Focus Computer\n *               Services Ltd) (DG);\n * 26-Jun-2003 : Fixed bug (757303) in getDataRange() method (DG);\n * 02-Jul-2003 : Added patch from bug report 698646 (secondary axes for\n *               overlaid plots) (DG);\n * 23-Jul-2003 : Added support for multiple secondary datasets, axes and\n *               renderers (DG);\n * 27-Jul-2003 : Added support for stacked XY area charts (RA);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug where change to secondary datasets didn't generate\n *               change event (797466) (DG)\n * 08-Sep-2003 : Added internationalization via use of properties\n *               resourceBundle (RFE 690236) (AL);\n * 08-Sep-2003 : Changed ValueAxis API (DG);\n * 08-Sep-2003 : Fixes for serialization (NB);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 17-Sep-2003 : Fixed zooming to include secondary domain axes (DG);\n * 18-Sep-2003 : Added getSecondaryDomainAxisCount() and\n *               getSecondaryRangeAxisCount() methods suggested by Eduardo\n *               Ramalho (RFE 808548) (DG);\n * 23-Sep-2003 : Split domain and range markers into foreground and\n *               background (DG);\n * 06-Oct-2003 : Fixed bug in clearDomainMarkers() and clearRangeMarkers()\n *               methods.  Fixed bug (815876) in addSecondaryRangeMarker()\n *               method.  Added new addSecondaryDomainMarker methods (see bug\n *               id 815869) (DG);\n * 10-Nov-2003 : Added getSecondaryDomain/RangeAxisMappedToDataset() methods\n *               requested by Eduardo Ramalho (DG);\n * 24-Nov-2003 : Removed unnecessary notification when updating axis anchor\n *               values (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);\n * 12-Mar-2004 : Fixed bug where primary renderer is always used to determine\n *               range type (DG);\n * 22-Mar-2004 : Fixed cloning bug (DG);\n * 23-Mar-2004 : Fixed more cloning bugs (DG);\n * 07-Apr-2004 : Fixed problem with axis range when the secondary renderer is\n *               stacked, see this post in the forum:\n *               http://www.jfree.org/phpBB2/viewtopic.php?t=8204 (DG);\n * 07-Apr-2004 : Added get/setDatasetRenderingOrder() methods (DG);\n * 26-Apr-2004 : Added option to fill quadrant areas in the background of the\n *               plot (DG);\n * 27-Apr-2004 : Removed major distinction between primary and secondary\n *               datasets, renderers and axes (DG);\n * 30-Apr-2004 : Modified to make use of the new getRangeExtent() method in the\n *               renderer interface (DG);\n * 13-May-2004 : Added optional fixedLegendItems attribute (DG);\n * 19-May-2004 : Added indexOf() method (DG);\n * 03-Jun-2004 : Fixed zooming bug (DG);\n * 18-Aug-2004 : Added removedAnnotation() method (by tkram01) (DG);\n * 05-Oct-2004 : Modified storage type for dataset-to-axis maps (DG);\n * 06-Oct-2004 : Modified getDataRange() method to use renderer to determine\n *               the x-value range (now matches behaviour for y-values).  Added\n *               getDomainAxisIndex() method (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 25-Nov-2004 : Small update to clone() implementation (DG);\n * 22-Feb-2005 : Changed axis offsets from Spacer --> RectangleInsets (DG);\n * 24-Feb-2005 : Added indexOf(XYItemRenderer) method (DG);\n * 21-Mar-2005 : Register plot as change listener in setRenderer() method (DG);\n * 21-Apr-2005 : Added get/setSeriesRenderingOrder() methods (ET);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 04-May-2005 : Fixed serialization of domain and range markers (DG);\n * 05-May-2005 : Removed unused draw() method (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 01-Jun-2005 : Added clearDomainMarkers(int) method to match\n *               clearRangeMarkers(int) (DG);\n * 06-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 06-Jul-2005 : Fixed crosshair bug (id = 1233336) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 26-Jan-2006 : Added getAnnotations() method (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 13-Oct-2006 : Fixed initialisation of CrosshairState - see bug report\n *               1565168 (DG);\n * 22-Nov-2006 : Fixed equals() and cloning() for quadrant attributes, plus\n *               API doc updates (DG);\n * 29-Nov-2006 : Added argument checks (DG);\n * 15-Jan-2007 : Fixed bug in drawRangeMarkers() (DG);\n * 07-Feb-2007 : Fixed bug 1654215, renderer with no dataset (DG);\n * 26-Feb-2007 : Added missing setDomainAxisLocation() and\n *               setRangeAxisLocation() methods (DG);\n * 02-Mar-2007 : Fix for crosshair positioning with horizontal orientation\n *               (see patch 1671648 by Sergei Ivanov) (DG);\n * 13-Mar-2007 : Added null argument checks for crosshair attributes (DG);\n * 23-Mar-2007 : Added domain zero base line facility (DG);\n * 04-May-2007 : Render only visible data items if possible (DG);\n * 24-May-2007 : Fixed bug in render method for an empty series (DG);\n * 07-Jun-2007 : Modified drawBackground() to pass orientation to\n *               fillBackground() for handling GradientPaint (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Jun-2007 : Updated drawDomainGridlines() method for renamed method in\n *               XYItemRenderer interface.\n * 24-Sep-2007 : Added new zoom methods (DG);\n * 26-Sep-2007 : Include index value in IllegalArgumentExceptions (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 12-Nov-2007 : Fixed bug in equals() method for domain and range tick\n *               band paint attributes (DG);\n * 27-Nov-2007 : Added new setFixedDomain/RangeAxisSpace() methods (DG);\n * 04-Jan-2008 : Fix for quadrant painting error - see patch 1849564 (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and\n *               removeRangeMarker() (DG);\n * 22-May-2008 : Modified calculateAxisSpace() to process range axes first,\n *               then adjust the plot area before calculating the space\n *               for the domain axes (DG);\n * 09-Jul-2008 : Added renderer state notification when series pass begins\n *               and ends - see patch 1997549 by Ulrich Voigt (DG);\n * 25-Jul-2008 : Fixed NullPointerException for plots with no axes (DG);\n * 15-Aug-2008 : Added getRendererCount() method (DG);\n * 25-Sep-2008 : Added minor tick support, see patch 1934255 by Peter Kolb (DG);\n * 25-Nov-2008 : Allow datasets to be mapped to multiple axes - based on patch\n *               1868749 by Andrew Mickish (DG);\n * 18-Dec-2008 : Use ResourceBundleWrapper - see patch 1607918 by\n *               Jess Thrysoee (DG);\n * 10-Mar-2009 : Allow some annotations to contribute to axis autoRange (DG);\n * 18-Mar-2009 : Modified anchored zoom behaviour and fixed bug in\n *               \"process visible range\" rendering (DG);\n * 19-Mar-2009 : Added panning support based on patch 2686040 by Ulrich\n *               Voigt (DG);\n * 19-Mar-2009 : Added entity support - see patch 2603321 by Peter Kolb (DG);\n * 30-Mar-2009 : Delegate panning to axes (DG);\n * 10-May-2009 : Added check for fixedLegendItems in equals(), and code to\n *               handle cloning (DG);\n * 29-Jun-2009 : Implemented Selectable (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.RenderingSource;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.annotations.XYAnnotationBoundsInfo;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.TickType;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.AbstractXYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.ResourceBundleWrapper;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.AbstractXYDataset;\nimport org.jfree.data.xy.SelectableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDatasetSelectionState;\n\n/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * <P>\n * <code>XYPlot</code> makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * <p>\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n */\npublic class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, RendererChangeListener, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7044148245716569264L;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f,\n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources\n            = ResourceBundleWrapper.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private ObjectList domainAxes;\n\n    /** The domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private ObjectList rangeAxes;\n\n    /** The range axis location. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /**\n     * Storage for the mapping between datasets/renderers and domain axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index = 0).\n     */\n    private Map datasetToDomainAxesMap;\n\n    /**\n     * Storage for the mapping between datasets/renderers and range axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index = 0).\n     */\n    private Map datasetToRangeAxesMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            = new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /**\n     * A flag that controls whether the domain minor grid-lines are visible.\n     *\n     * @since 1.0.12\n     */\n    private boolean domainMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the domain minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Stroke domainMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the domain minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Paint domainMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether the range minor grid-lines are visible.\n     *\n     * @since 1.0.12\n     */\n    private boolean rangeMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the range minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Stroke rangeMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the range minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Paint rangeMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     *\n     * @since 1.0.5\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /**\n     * The stroke used for the zero baseline against the domain axis.\n     *\n     * @since 1.0.5\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /**\n     * The paint used for the zero baseline against the domain axis.\n     *\n     * @since 1.0.5\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData = true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /**\n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be\n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            = DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            = SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the domain\n     * axis/axes.\n     *\n     * @since 1.0.13\n     */\n    private boolean domainPannable;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the range\n     * axis/axes.\n     *\n     * @since 1.0.13\n     */\n    private boolean rangePannable;\n\n    /**\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be <code>null</code>, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * <code>NullPointerException</code> may be thrown).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the renderer (<code>null</code> permitted).\n     */\n    public XYPlot(XYDataset dataset,\n                  ValueAxis domainAxis,\n                  ValueAxis rangeAxis,\n                  XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  // only relevant when this is a subplot\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxesMap = new TreeMap();\n        this.datasetToRangeAxesMap = new TreeMap();\n\n        this.annotations = new java.util.ArrayList();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainMinorGridlinesVisible = false;\n        this.domainMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainMinorGridlinePaint = Color.white;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeMinorGridlinesVisible = false;\n        this.rangeMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeMinorGridlinePaint = Color.white;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never <code>null</code>).\n     *\n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not allowed).\n     *\n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     *\n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     *\n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's\n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly <code>null</code>).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or <code>null</code>.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     *\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot's orientation).\n     *\n     * @return The edge.\n     *\n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for index\n     *     0).\n     *\n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * <code>null</code>, then the method will return the parent plot's range\n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     *\n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     *\n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     *\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     *\n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> permitted).\n     *\n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     *\n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     *\n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or <code>-1</code> if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToDomainAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices (<code>null</code> permitted).\n     *\n     * @since 1.0.12\n     */\n    public void mapDatasetToDomainAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToDomainAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToRangeAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices (<code>null</code> permitted).\n     *\n     * @since 1.0.12\n     */\n    public void mapDatasetToRangeAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToRangeAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * This method is used to perform argument checking on the list of\n     * axis indices passed to mapDatasetToDomainAxes() and\n     * mapDatasetToRangeAxes().\n     *\n     * @param indices  the list of indices (<code>null</code> permitted).\n     */\n    private void checkAxisIndices(List indices) {\n        // axisIndices can be:\n        // 1.  null;\n        // 2.  non-empty, containing only Integer objects that are unique.\n        if (indices == null) {\n            return;  // OK\n        }\n        int count = indices.size();\n        if (count == 0) {\n            throw new IllegalArgumentException(\"Empty list not permitted.\");\n        }\n        HashSet set = new HashSet();\n        for (int i = 0; i < count; i++) {\n            Object item = indices.get(i);\n            if (!(item instanceof Integer)) {\n                throw new IllegalArgumentException(\n                        \"Indices must be Integer instances.\");\n            }\n            if (set.contains(item)) {\n                throw new IllegalArgumentException(\"Indices must be unique.\");\n            }\n            set.add(item);\n        }\n    }\n\n    /**\n     * Returns the number of renderer slots for this plot.\n     *\n     * @return The number of renderer slots.\n     *\n     * @since 1.0.11\n     */\n    public int getRendererCount() {\n        return this.renderers.size();\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly <code>null</code>).\n     *\n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer for a dataset, or <code>null</code>.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     *\n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\n     * is set to <code>null</code>, no data will be displayed.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer,\n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param renderers  the renderers (<code>null</code> not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     *\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     *\n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never <code>null</code>).\n     *\n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     *\n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  The code first\n     * determines the index of the dataset, then checks if there is a\n     * renderer with the same index (if not, the method returns renderer(0).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The renderer (possibly <code>null</code>).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     *\n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     *\n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the domain gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     *\n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the domain minor gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     *\n     * @see #setDomainMinorGridlinesVisible(boolean)\n     *\n     * @since 1.0.12\n     */\n    public boolean isDomainMinorGridlinesVisible() {\n        return this.domainMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain minor grid-lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainMinorGridlinesVisible()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlinesVisible(boolean visible) {\n        if (this.domainMinorGridlinesVisible != visible) {\n            this.domainMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>stroke</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke for the minor grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setDomainMinorGridlineStroke(Stroke)\n     *\n     * @since 1.0.12\n     */\n\n    public Stroke getDomainMinorGridlineStroke() {\n        return this.domainMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the domain\n     * axis, and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>stroke</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainMinorGridlineStroke()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>paint</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainMinorGridlinePaint(Paint)\n     *\n     * @since 1.0.12\n     */\n    public Paint getDomainMinorGridlinePaint() {\n        return this.domainMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>paint</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainMinorGridlinePaint()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis minor grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeMinorGridlinesVisible(boolean)\n     *\n     * @since 1.0.12\n     */\n    public boolean isRangeMinorGridlinesVisible() {\n        return this.rangeMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis minor grid\n     * lines are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeMinorGridlinesVisible()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlinesVisible(boolean visible) {\n        if (this.rangeMinorGridlinesVisible != visible) {\n            this.rangeMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeMinorGridlineStroke(Stroke)\n     *\n     * @since 1.0.12\n     */\n    public Stroke getRangeMinorGridlineStroke() {\n        return this.rangeMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeMinorGridlineStroke()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeMinorGridlinePaint(Paint)\n     *\n     * @since 1.0.12\n     */\n    public Paint getRangeMinorGridlinePaint() {\n        return this.rangeMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the range axis\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeMinorGridlinePaint()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.5\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @since 1.0.5\n     *\n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @since 1.0.5\n     *\n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     *\n     * @since 1.0.5\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never <code>null</code>).\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin (<code>null</code> not permitted).\n     *\n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     *\n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     *\n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n        return removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     *\n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        addRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n        return removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\n    }\n\n    /**\n     * Adds an annotation to the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n        return removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     *\n     * @since 1.0.1\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        Rectangle2D revPlotArea = space.shrink(plotArea, null);\n        space = calculateDomainAxisSpace(g2, revPlotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     (<code>null</code> permitted).\n     * @param info  collects chart drawing information (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n            PlotState parentState, PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n        createAndAddEntity((Rectangle2D) dataArea.clone(), info, null, null);\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n\n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);\n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea,\n                            getDomainAxisEdge());\n                }\n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea,\n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea,\n                            getRangeAxisEdge());\n                }\n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea,\n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);\n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            }\n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        if (xAxis == null) {  // we can't draw quadrants without a valid x-axis\n            return;\n        }\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        if (yAxis == null) {  // we can't draw quadrants without a valid y-axis\n            return;\n        }\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymax, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymax, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymin, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymin, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param dataArea  the data area (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * <P>\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\n     * <code>null</code>.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        (<code>null</code> permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index,\n            PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            if (xAxis == null || yAxis == null) {\n                return foundData;  // can't render anything without axes\n            }\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            XYDatasetSelectionState selectionState = state.getSelectionState();\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this,\n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this, \n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToDomainAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToRangeAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible() || isDomainMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            Iterator iterator = ticks.iterator();\n            boolean paintLine = false;\n            while (iterator.hasNext()) {\n                paintLine = false;\n                ValueTick tick = (ValueTick) iterator.next();\n                if ((tick.getTickType() == TickType.MINOR)\n                        && isDomainMinorGridlinesVisible()) {\n                    gridStroke = getDomainMinorGridlineStroke();\n                    gridPaint = getDomainMinorGridlinePaint();\n                    paintLine = true;\n                }\n                else if ((tick.getTickType() == TickType.MAJOR)\n                        && isDomainGridlinesVisible()) {\n                    gridStroke = getDomainGridlineStroke();\n                    gridPaint = getDomainGridlinePaint();\n                    paintLine = true;\n                }\n                XYItemRenderer r = getRenderer();\n                if ((r instanceof AbstractXYItemRenderer) && paintLine) {\n                    ((AbstractXYItemRenderer) r).drawDomainLine(g2, this,\n                            getDomainAxis(), dataArea, tick.getValue(),\n                            gridPaint, gridStroke);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot's primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                boolean paintLine = false;\n                while (iterator.hasNext()) {\n                    paintLine = false;\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if ((tick.getTickType() == TickType.MINOR)\n                            && isRangeMinorGridlinesVisible()) {\n                        gridStroke = getRangeMinorGridlineStroke();\n                        gridPaint = getRangeMinorGridlinePaint();\n                        paintLine = true;\n                    }\n                    else if ((tick.getTickType() == TickType.MAJOR)\n                            && isRangeGridlinesVisible()) {\n                        gridStroke = getRangeGridlineStroke();\n                        gridPaint = getRangeGridlinePaint();\n                        paintLine = true;\n                    }\n                    if ((tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) && paintLine) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(),\n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     *\n     * @since 1.0.5\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0,\n                    this.domainZeroBaselinePaint,\n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     *\n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     *\n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     *\n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     *\n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a domain crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @since 1.0.4\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @since 1.0.4\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis xaxis = getDomainAxis();\n            if (xaxis != null) {\n                double hvalue = xaxis.java2DToValue(x, info.getDataArea(),\n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis yaxis = getRangeAxis();\n            if (yaxis != null) {\n                double vvalue = yaxis.java2DToValue(y, info.getDataArea(),\n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToDomainAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToRangeAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        // if the event was caused by a change to series visibility, then\n        // the axis ranges might need updating...\n        if (event.getSeriesVisibilityChanged()) {\n            configureDomainAxes();\n            configureRangeAxes();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible\n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     *\n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not\n     *     permitted).\n     *\n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     *\n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     *\n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     *\n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not\n     *         permitted).\n     *\n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     *\n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     *\n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedDomainAxisSpace()\n     *\n     * @since 1.0.9\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     *\n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.9\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if panning is enabled for the domain axes,\n     * and <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.13\n     */\n    public boolean isDomainPannable() {\n        return this.domainPannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along the\n     * domain axes.\n     *\n     * @param pannable  the new flag value.\n     *\n     * @since 1.0.13\n     */\n    public void setDomainPannable(boolean pannable) {\n        this.domainPannable = pannable;\n    }\n\n    /**\n     * Returns <code>true</code> if panning is enabled for the range axes,\n     * and <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.13\n     */\n    public boolean isRangePannable() {\n        return this.rangePannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along\n     * the range axes.\n     *\n     * @param pannable  the new flag value.\n     *\n     * @since 1.0.13\n     */\n    public void setRangePannable(boolean pannable) {\n        this.rangePannable = pannable;\n    }\n\n    /**\n     * Pans the domain axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     *\n     * @since 1.0.13\n     */\n    public void panDomainAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isDomainPannable()) {\n            return;\n        }\n        int domainAxisCount = getDomainAxisCount();\n        for (int i = 0; i < domainAxisCount; i++) {\n            ValueAxis axis = getDomainAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }\n\n    /**\n     * Pans the range axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     *\n     * @since 1.0.13\n     */\n    public void panRangeAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isRangePannable()) {\n            return;\n        }\n        int rangeAxisCount = getRangeAxisCount();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            ValueAxis axis = getRangeAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     *\n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each domain axis\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot\n                    // orientation\n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX,\n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange2(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     *\n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     *\n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot\n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY,\n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange2(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is <code>null</code>, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly <code>null</code>).\n     *\n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * <code>null</code> if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items (<code>null</code> permitted).\n     *\n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot's renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainMinorGridlinesVisible\n                != that.domainMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeMinorGridlinesVisible\n                != that.rangeMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxesMap,\n                that.datasetToDomainAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxesMap,\n                that.datasetToRangeAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke,\n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke,\n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainMinorGridlineStroke,\n                that.domainMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainMinorGridlinePaint,\n                that.domainMinorGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeMinorGridlineStroke,\n                that.rangeMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeMinorGridlinePaint,\n                that.rangeMinorGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint,\n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke,\n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint,\n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke,\n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke,\n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint,\n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke,\n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint,\n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedLegendItems,\n                that.fixedLegendItems)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint,\n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint,\n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i],\n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList)\n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxesMap = new TreeMap();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap = new TreeMap();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        if (this.fixedLegendItems != null) {\n            clone.fixedLegendItems\n                    = (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.domainMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.domainMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and\n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that this plot does not support\n     * selection of data items at a point (only because it hasn't been\n     * implemented yet).\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean canSelectByPoint() {\n        return false;  // TODO: make this true later\n}\n\n    /**\n     * Returns <code>true</code> to indicate that this plot supports selection\n     * of data items by region.\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean canSelectByRegion() {\n        return true;\n    }\n\n    /**\n     * Selects a single point - NOT YET IMPLEMENTED.\n     *\n     * @since 1.2.0\n     */\n    public void select(double x, double y, Rectangle2D dataArea,\n            RenderingSource source) {\n        // TODO: implement\n    }\n\n    /**\n     * Selects the data items within the specified region.\n     *\n     * @param region  the region (in Java2D coordinates).\n     * @param dataArea  the data area.\n     * @param source  the rendering source.\n     *\n     * @since 1.2.0\n     */\n    public void select(GeneralPath region, Rectangle2D dataArea,\n            RenderingSource source) {\n        // cycle through the datasets and change the selection state for the\n        // items that fall within the specified region\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset == null) {\n                continue;\n            }\n            XYDatasetSelectionState state = findSelectionStateForDataset(\n                    dataset, source);\n            if (state == null) {\n                continue;\n            }\n            GeneralPath path = convertToDataSpace(region, dataArea, dataset);\n            // now we have to iterate over all the dataset values and\n            // convert each point to Java2D space and then check if it should\n            // be selected.\n            int seriesCount = dataset.getSeriesCount();\n            for (int s = 0; s < seriesCount; s++) {\n                int itemCount = dataset.getItemCount(s);\n                for (int i = 0; i < itemCount; i++) {\n                    double x = dataset.getXValue(s, i);\n                    double y = dataset.getYValue(s, i);\n                    if (path.contains(x, y)) {\n                        state.setSelected(s, i, true);\n                        // FIXME:  we should fire just one dataset change event\n                        // for the whole selection\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the selection state for the specified dataset.  This could be\n     * <code>null</code> if the dataset hasn't been set up to support\n     * selections.\n     *\n     * @param dataset  the dataset.\n     * @param source  the selection source.\n     *\n     * @return The selection state (possibly <code>null</code>).\n     */\n    private XYDatasetSelectionState findSelectionStateForDataset(\n            XYDataset dataset, Object source) {\n        if (dataset instanceof SelectableXYDataset) {\n            SelectableXYDataset sd = (SelectableXYDataset) dataset;\n            XYDatasetSelectionState s = sd.getSelectionState();\n            return s;\n        }\n        throw new RuntimeException();\n        //return null;  // TODO: implement\n    }\n\n    /**\n     * Converts a path from Java2D space to data space.\n     *\n     * @param path  the path (<code>null</code> not permitted).\n     * @param dataArea  the data area.\n     * @param dataset  the dataset which can be used to find the appropriate\n     *         axes.\n     *\n     * @return A path in data space.\n     */\n    private GeneralPath convertToDataSpace(GeneralPath path,\n            Rectangle2D dataArea, XYDataset dataset) {\n        GeneralPath result = new GeneralPath(path.getWindingRule());\n        int datasetIndex = indexOf(dataset);\n        ValueAxis xAxis = getDomainAxisForDataset(datasetIndex);\n        ValueAxis yAxis = getRangeAxisForDataset(datasetIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge();\n        RectangleEdge yAxisEdge = getRangeAxisEdge();\n        double[] coords = new double[6];\n        PathIterator iterator = path.getPathIterator(null);\n        while (!iterator.isDone()) {\n            int segType = iterator.currentSegment(coords);\n            double xx = xAxis.java2DToValue(coords[0], dataArea, xAxisEdge);\n            double yy = yAxis.java2DToValue(coords[1], dataArea, yAxisEdge);\n            if (segType == PathIterator.SEG_MOVETO) {\n                result.moveTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_LINETO) {\n                result.lineTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_CLOSE) {\n                result.closePath();\n            }\n            iterator.next();\n        }\n        return result;\n    }\n\n    /**\n     * Clears the selection.\n     *\n     * @since 1.2.0\n     */\n    public void clearSelection() {\n        // cycle through the datasets and clear the selection state\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset instanceof AbstractXYDataset) {\n                // TODO: we could add an interface that *any* dataset could\n                // implement if it provides a selection state\n                AbstractXYDataset axyd = (AbstractXYDataset) dataset;\n                if (axyd.getSelectionState() != null) {\n                    XYDatasetSelectionState selState = axyd.getSelectionState();\n                    selState.clearSelection();\n                }\n            }\n        }\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -----------\n * XYPlot.java\n * -----------\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Craig MacFarlane;\n *                   Mark Watson (www.markwatson.com);\n *                   Jonathan Nash;\n *                   Gideon Krause;\n *                   Klaus Rheinwald;\n *                   Xavier Poinsard;\n *                   Richard Atkinson;\n *                   Arnaud Lelievre;\n *                   Nicolas Brodu;\n *                   Eduardo Ramalho;\n *                   Sergei Ivanov;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *                   Ulrich Voigt - patches 1997549 and 2686040;\n *                   Peter Kolb - patches 1934255 and 2603321;\n *                   Andrew Mickish - patch 1868749;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header and fixed DOS encoding problem (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Removed the code for drawing the visual representation of each\n *               data point into a separate class StandardXYItemRenderer.\n *               This will make it easier to add variations to the way the\n *               charts are drawn.  Based on code contributed by Mark\n *               Watson (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 20-Nov-2001 : Fixed clipping bug that shows up when chart is displayed\n *               inside JScrollPane (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clauses from constructor (DG);\n * 13-Dec-2001 : Added skeleton code for tooltips.  Added new constructor. (DG);\n * 16-Jan-2002 : Renamed the tooltips class (DG);\n * 22-Jan-2002 : Added DrawInfo class, incorporating tooltips and crosshairs.\n *               Crosshairs based on code by Jonathan Nash (DG);\n * 05-Feb-2002 : Added alpha-transparency setting based on code by Sylvain\n *               Vieujot (DG);\n * 26-Feb-2002 : Updated getMinimumXXX() and getMaximumXXX() methods to handle\n *               special case when chart is null (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 28-Mar-2002 : The plot now registers with the renderer as a property change\n *               listener.  Also added a new constructor (DG);\n * 09-Apr-2002 : Removed the transRangeZero from the renderer.drawItem()\n *               method.  Moved the tooltip generator into the renderer (DG);\n * 23-Apr-2002 : Fixed bug in methods for drawing horizontal and vertical\n *               lines (DG);\n * 13-May-2002 : Small change to the draw() method so that it works for\n *               OverlaidXYPlot also (DG);\n * 25-Jun-2002 : Removed redundant import (DG);\n * 20-Aug-2002 : Renamed getItemRenderer() --> getRenderer(), and\n *               setXYItemRenderer() --> setRenderer() (DG);\n * 28-Aug-2002 : Added mechanism for (optional) plot annotations (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 09-Jan-2003 : Further additions to the grid settings, plus integrated plot\n *               border bug fix contributed by Gideon Krause (DG);\n * 22-Jan-2003 : Removed monolithic constructor (DG);\n * 04-Mar-2003 : Added 'no data' message, see bug report 691634.  Added\n *               secondary range markers using code contributed by Klaus\n *               Rheinwald (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Apr-2003 : Added setDomainAxisLocation() method (DG);\n * 30-Apr-2003 : Moved annotation drawing into a separate method (DG);\n * 01-May-2003 : Added multi-pass mechanism for renderers (DG);\n * 02-May-2003 : Changed axis locations from int to AxisLocation (DG);\n * 15-May-2003 : Added an orientation attribute (DG);\n * 02-Jun-2003 : Removed range axis compatibility test (DG);\n * 05-Jun-2003 : Added domain and range grid bands (sponsored by Focus Computer\n *               Services Ltd) (DG);\n * 26-Jun-2003 : Fixed bug (757303) in getDataRange() method (DG);\n * 02-Jul-2003 : Added patch from bug report 698646 (secondary axes for\n *               overlaid plots) (DG);\n * 23-Jul-2003 : Added support for multiple secondary datasets, axes and\n *               renderers (DG);\n * 27-Jul-2003 : Added support for stacked XY area charts (RA);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug where change to secondary datasets didn't generate\n *               change event (797466) (DG)\n * 08-Sep-2003 : Added internationalization via use of properties\n *               resourceBundle (RFE 690236) (AL);\n * 08-Sep-2003 : Changed ValueAxis API (DG);\n * 08-Sep-2003 : Fixes for serialization (NB);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 17-Sep-2003 : Fixed zooming to include secondary domain axes (DG);\n * 18-Sep-2003 : Added getSecondaryDomainAxisCount() and\n *               getSecondaryRangeAxisCount() methods suggested by Eduardo\n *               Ramalho (RFE 808548) (DG);\n * 23-Sep-2003 : Split domain and range markers into foreground and\n *               background (DG);\n * 06-Oct-2003 : Fixed bug in clearDomainMarkers() and clearRangeMarkers()\n *               methods.  Fixed bug (815876) in addSecondaryRangeMarker()\n *               method.  Added new addSecondaryDomainMarker methods (see bug\n *               id 815869) (DG);\n * 10-Nov-2003 : Added getSecondaryDomain/RangeAxisMappedToDataset() methods\n *               requested by Eduardo Ramalho (DG);\n * 24-Nov-2003 : Removed unnecessary notification when updating axis anchor\n *               values (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);\n * 12-Mar-2004 : Fixed bug where primary renderer is always used to determine\n *               range type (DG);\n * 22-Mar-2004 : Fixed cloning bug (DG);\n * 23-Mar-2004 : Fixed more cloning bugs (DG);\n * 07-Apr-2004 : Fixed problem with axis range when the secondary renderer is\n *               stacked, see this post in the forum:\n *               http://www.jfree.org/phpBB2/viewtopic.php?t=8204 (DG);\n * 07-Apr-2004 : Added get/setDatasetRenderingOrder() methods (DG);\n * 26-Apr-2004 : Added option to fill quadrant areas in the background of the\n *               plot (DG);\n * 27-Apr-2004 : Removed major distinction between primary and secondary\n *               datasets, renderers and axes (DG);\n * 30-Apr-2004 : Modified to make use of the new getRangeExtent() method in the\n *               renderer interface (DG);\n * 13-May-2004 : Added optional fixedLegendItems attribute (DG);\n * 19-May-2004 : Added indexOf() method (DG);\n * 03-Jun-2004 : Fixed zooming bug (DG);\n * 18-Aug-2004 : Added removedAnnotation() method (by tkram01) (DG);\n * 05-Oct-2004 : Modified storage type for dataset-to-axis maps (DG);\n * 06-Oct-2004 : Modified getDataRange() method to use renderer to determine\n *               the x-value range (now matches behaviour for y-values).  Added\n *               getDomainAxisIndex() method (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 25-Nov-2004 : Small update to clone() implementation (DG);\n * 22-Feb-2005 : Changed axis offsets from Spacer --> RectangleInsets (DG);\n * 24-Feb-2005 : Added indexOf(XYItemRenderer) method (DG);\n * 21-Mar-2005 : Register plot as change listener in setRenderer() method (DG);\n * 21-Apr-2005 : Added get/setSeriesRenderingOrder() methods (ET);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 04-May-2005 : Fixed serialization of domain and range markers (DG);\n * 05-May-2005 : Removed unused draw() method (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 01-Jun-2005 : Added clearDomainMarkers(int) method to match\n *               clearRangeMarkers(int) (DG);\n * 06-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 06-Jul-2005 : Fixed crosshair bug (id = 1233336) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 26-Jan-2006 : Added getAnnotations() method (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 13-Oct-2006 : Fixed initialisation of CrosshairState - see bug report\n *               1565168 (DG);\n * 22-Nov-2006 : Fixed equals() and cloning() for quadrant attributes, plus\n *               API doc updates (DG);\n * 29-Nov-2006 : Added argument checks (DG);\n * 15-Jan-2007 : Fixed bug in drawRangeMarkers() (DG);\n * 07-Feb-2007 : Fixed bug 1654215, renderer with no dataset (DG);\n * 26-Feb-2007 : Added missing setDomainAxisLocation() and\n *               setRangeAxisLocation() methods (DG);\n * 02-Mar-2007 : Fix for crosshair positioning with horizontal orientation\n *               (see patch 1671648 by Sergei Ivanov) (DG);\n * 13-Mar-2007 : Added null argument checks for crosshair attributes (DG);\n * 23-Mar-2007 : Added domain zero base line facility (DG);\n * 04-May-2007 : Render only visible data items if possible (DG);\n * 24-May-2007 : Fixed bug in render method for an empty series (DG);\n * 07-Jun-2007 : Modified drawBackground() to pass orientation to\n *               fillBackground() for handling GradientPaint (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Jun-2007 : Updated drawDomainGridlines() method for renamed method in\n *               XYItemRenderer interface.\n * 24-Sep-2007 : Added new zoom methods (DG);\n * 26-Sep-2007 : Include index value in IllegalArgumentExceptions (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 12-Nov-2007 : Fixed bug in equals() method for domain and range tick\n *               band paint attributes (DG);\n * 27-Nov-2007 : Added new setFixedDomain/RangeAxisSpace() methods (DG);\n * 04-Jan-2008 : Fix for quadrant painting error - see patch 1849564 (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and\n *               removeRangeMarker() (DG);\n * 22-May-2008 : Modified calculateAxisSpace() to process range axes first,\n *               then adjust the plot area before calculating the space\n *               for the domain axes (DG);\n * 09-Jul-2008 : Added renderer state notification when series pass begins\n *               and ends - see patch 1997549 by Ulrich Voigt (DG);\n * 25-Jul-2008 : Fixed NullPointerException for plots with no axes (DG);\n * 15-Aug-2008 : Added getRendererCount() method (DG);\n * 25-Sep-2008 : Added minor tick support, see patch 1934255 by Peter Kolb (DG);\n * 25-Nov-2008 : Allow datasets to be mapped to multiple axes - based on patch\n *               1868749 by Andrew Mickish (DG);\n * 18-Dec-2008 : Use ResourceBundleWrapper - see patch 1607918 by\n *               Jess Thrysoee (DG);\n * 10-Mar-2009 : Allow some annotations to contribute to axis autoRange (DG);\n * 18-Mar-2009 : Modified anchored zoom behaviour and fixed bug in\n *               \"process visible range\" rendering (DG);\n * 19-Mar-2009 : Added panning support based on patch 2686040 by Ulrich\n *               Voigt (DG);\n * 19-Mar-2009 : Added entity support - see patch 2603321 by Peter Kolb (DG);\n * 30-Mar-2009 : Delegate panning to axes (DG);\n * 10-May-2009 : Added check for fixedLegendItems in equals(), and code to\n *               handle cloning (DG);\n * 29-Jun-2009 : Implemented Selectable (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.RenderingSource;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.annotations.XYAnnotationBoundsInfo;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.TickType;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.AbstractXYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.ResourceBundleWrapper;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.AbstractXYDataset;\nimport org.jfree.data.xy.SelectableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDatasetSelectionState;\n\n/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * <P>\n * <code>XYPlot</code> makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * <p>\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n */\npublic class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n        Selectable, Zoomable, RendererChangeListener, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7044148245716569264L;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f,\n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources\n            = ResourceBundleWrapper.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private ObjectList domainAxes;\n\n    /** The domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private ObjectList rangeAxes;\n\n    /** The range axis location. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /**\n     * Storage for the mapping between datasets/renderers and domain axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index = 0).\n     */\n    private Map datasetToDomainAxesMap;\n\n    /**\n     * Storage for the mapping between datasets/renderers and range axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index = 0).\n     */\n    private Map datasetToRangeAxesMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            = new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /**\n     * A flag that controls whether the domain minor grid-lines are visible.\n     *\n     * @since 1.0.12\n     */\n    private boolean domainMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the domain minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Stroke domainMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the domain minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Paint domainMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether the range minor grid-lines are visible.\n     *\n     * @since 1.0.12\n     */\n    private boolean rangeMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the range minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Stroke rangeMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the range minor grid-lines.\n     *\n     * @since 1.0.12\n     */\n    private transient Paint rangeMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     *\n     * @since 1.0.5\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /**\n     * The stroke used for the zero baseline against the domain axis.\n     *\n     * @since 1.0.5\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /**\n     * The paint used for the zero baseline against the domain axis.\n     *\n     * @since 1.0.5\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData = true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /**\n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be\n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            = DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            = SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the domain\n     * axis/axes.\n     *\n     * @since 1.0.13\n     */\n    private boolean domainPannable;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the range\n     * axis/axes.\n     *\n     * @since 1.0.13\n     */\n    private boolean rangePannable;\n\n    /**\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be <code>null</code>, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * <code>NullPointerException</code> may be thrown).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the renderer (<code>null</code> permitted).\n     */\n    public XYPlot(XYDataset dataset,\n                  ValueAxis domainAxis,\n                  ValueAxis rangeAxis,\n                  XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  // only relevant when this is a subplot\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxesMap = new TreeMap();\n        this.datasetToRangeAxesMap = new TreeMap();\n\n        this.annotations = new java.util.ArrayList();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainMinorGridlinesVisible = false;\n        this.domainMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainMinorGridlinePaint = Color.white;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeMinorGridlinesVisible = false;\n        this.rangeMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeMinorGridlinePaint = Color.white;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never <code>null</code>).\n     *\n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not allowed).\n     *\n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     *\n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     *\n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's\n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly <code>null</code>).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or <code>null</code>.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     *\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot's orientation).\n     *\n     * @return The edge.\n     *\n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for index\n     *     0).\n     *\n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * <code>null</code>, then the method will return the parent plot's range\n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     *\n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     *\n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     *\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes (<code>null</code> not permitted).\n     *\n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     *\n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     *\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> permitted).\n     *\n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     *\n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     *\n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or <code>-1</code> if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToDomainAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices (<code>null</code> permitted).\n     *\n     * @since 1.0.12\n     */\n    public void mapDatasetToDomainAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToDomainAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        List axisIndices = new java.util.ArrayList(1);\n        axisIndices.add(new Integer(axisIndex));\n        mapDatasetToRangeAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices (<code>null</code> permitted).\n     *\n     * @since 1.0.12\n     */\n    public void mapDatasetToRangeAxes(int index, List axisIndices) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires 'index' >= 0.\");\n        }\n        checkAxisIndices(axisIndices);\n        Integer key = new Integer(index);\n        this.datasetToRangeAxesMap.put(key, new ArrayList(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * This method is used to perform argument checking on the list of\n     * axis indices passed to mapDatasetToDomainAxes() and\n     * mapDatasetToRangeAxes().\n     *\n     * @param indices  the list of indices (<code>null</code> permitted).\n     */\n    private void checkAxisIndices(List indices) {\n        // axisIndices can be:\n        // 1.  null;\n        // 2.  non-empty, containing only Integer objects that are unique.\n        if (indices == null) {\n            return;  // OK\n        }\n        int count = indices.size();\n        if (count == 0) {\n            throw new IllegalArgumentException(\"Empty list not permitted.\");\n        }\n        HashSet set = new HashSet();\n        for (int i = 0; i < count; i++) {\n            Object item = indices.get(i);\n            if (!(item instanceof Integer)) {\n                throw new IllegalArgumentException(\n                        \"Indices must be Integer instances.\");\n            }\n            if (set.contains(item)) {\n                throw new IllegalArgumentException(\"Indices must be unique.\");\n            }\n            set.add(item);\n        }\n    }\n\n    /**\n     * Returns the number of renderer slots for this plot.\n     *\n     * @return The number of renderer slots.\n     *\n     * @since 1.0.11\n     */\n    public int getRendererCount() {\n        return this.renderers.size();\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly <code>null</code>).\n     *\n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer for a dataset, or <code>null</code>.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     *\n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\n     * is set to <code>null</code>, no data will be displayed.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer,\n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param renderers  the renderers (<code>null</code> not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     *\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     *\n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never <code>null</code>).\n     *\n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     *\n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  The code first\n     * determines the index of the dataset, then checks if there is a\n     * renderer with the same index (if not, the method returns renderer(0).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The renderer (possibly <code>null</code>).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     *\n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     *\n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the domain gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     *\n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if the domain minor gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     *\n     * @see #setDomainMinorGridlinesVisible(boolean)\n     *\n     * @since 1.0.12\n     */\n    public boolean isDomainMinorGridlinesVisible() {\n        return this.domainMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain minor grid-lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainMinorGridlinesVisible()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlinesVisible(boolean visible) {\n        if (this.domainMinorGridlinesVisible != visible) {\n            this.domainMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>stroke</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke for the minor grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setDomainMinorGridlineStroke(Stroke)\n     *\n     * @since 1.0.12\n     */\n\n    public Stroke getDomainMinorGridlineStroke() {\n        return this.domainMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the domain\n     * axis, and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>stroke</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainMinorGridlineStroke()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>paint</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainMinorGridlinePaint(Paint)\n     *\n     * @since 1.0.12\n     */\n    public Paint getDomainMinorGridlinePaint() {\n        return this.domainMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @throws IllegalArgumentException if <code>paint</code> is\n     *     <code>null</code>.\n     *\n     * @see #getDomainMinorGridlinePaint()\n     *\n     * @since 1.0.12\n     */\n    public void setDomainMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis minor grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeMinorGridlinesVisible(boolean)\n     *\n     * @since 1.0.12\n     */\n    public boolean isRangeMinorGridlinesVisible() {\n        return this.rangeMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis minor grid\n     * lines are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeMinorGridlinesVisible()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlinesVisible(boolean visible) {\n        if (this.rangeMinorGridlinesVisible != visible) {\n            this.rangeMinorGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeMinorGridlineStroke(Stroke)\n     *\n     * @since 1.0.12\n     */\n    public Stroke getRangeMinorGridlineStroke() {\n        return this.rangeMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeMinorGridlineStroke()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeMinorGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeMinorGridlinePaint(Paint)\n     *\n     * @since 1.0.12\n     */\n    public Paint getRangeMinorGridlinePaint() {\n        return this.rangeMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the range axis\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeMinorGridlinePaint()\n     *\n     * @since 1.0.12\n     */\n    public void setRangeMinorGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeMinorGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.5\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @since 1.0.5\n     *\n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @since 1.0.5\n     *\n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     *\n     * @since 1.0.5\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     *\n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     *\n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never <code>null</code>).\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin (<code>null</code> not permitted).\n     *\n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly <code>null</code>).\n     *\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint (<code>null</code> permitted).\n     *\n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     *\n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     *\n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n        return removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     *\n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        addRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n        return removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\n    }\n\n    /**\n     * Adds an annotation to the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.10\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n        return removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     *\n     * @since 1.0.1\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        Rectangle2D revPlotArea = space.shrink(plotArea, null);\n        space = calculateDomainAxisSpace(g2, revPlotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     (<code>null</code> permitted).\n     * @param info  collects chart drawing information (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n            PlotState parentState, PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n        createAndAddEntity((Rectangle2D) dataArea.clone(), info, null, null);\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n\n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);\n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea,\n                            getDomainAxisEdge());\n                }\n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea,\n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea,\n                            getRangeAxisEdge());\n                }\n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea,\n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);\n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            }\n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        if (xAxis == null) {  // we can't draw quadrants without a valid x-axis\n            return;\n        }\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        if (yAxis == null) {  // we can't draw quadrants without a valid y-axis\n            return;\n        }\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymax, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymax, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymin, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymin, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param dataArea  the data area (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * <P>\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\n     * <code>null</code>.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        (<code>null</code> permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index,\n            PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            if (xAxis == null || yAxis == null) {\n                return foundData;  // can't render anything without axes\n            }\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            XYDatasetSelectionState selectionState = state.getSelectionState();\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this,\n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem = Math.max(itemBounds[0] - 1, 0);\n                            lastItem = Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            boolean selected = false;\n                            if (selectionState != null) {\n                                selected = selectionState.isSelected(series,\n                                        item);\n                            }\n                            renderer.drawItem(g2, state, dataArea, this, \n                                    xAxis, yAxis, dataset, series, item,\n                                    selected, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToDomainAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (index < 0 || index >= upper) {\n            throw new IllegalArgumentException(\"Index \" + index\n                    + \" out of bounds.\");\n        }\n        ValueAxis valueAxis = null;\n        List axisIndices = (List) this.datasetToRangeAxesMap.get(\n                new Integer(index));\n        if (axisIndices != null) {\n            // the first axis in the list is used for data <--> Java2D\n            Integer axisIndex = (Integer) axisIndices.get(0);\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible() || isDomainMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            Iterator iterator = ticks.iterator();\n            boolean paintLine = false;\n            while (iterator.hasNext()) {\n                paintLine = false;\n                ValueTick tick = (ValueTick) iterator.next();\n                if ((tick.getTickType() == TickType.MINOR)\n                        && isDomainMinorGridlinesVisible()) {\n                    gridStroke = getDomainMinorGridlineStroke();\n                    gridPaint = getDomainMinorGridlinePaint();\n                    paintLine = true;\n                }\n                else if ((tick.getTickType() == TickType.MAJOR)\n                        && isDomainGridlinesVisible()) {\n                    gridStroke = getDomainGridlineStroke();\n                    gridPaint = getDomainGridlinePaint();\n                    paintLine = true;\n                }\n                XYItemRenderer r = getRenderer();\n                if ((r instanceof AbstractXYItemRenderer) && paintLine) {\n                    ((AbstractXYItemRenderer) r).drawDomainLine(g2, this,\n                            getDomainAxis(), dataArea, tick.getValue(),\n                            gridPaint, gridStroke);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot's primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) {\n            Stroke gridStroke = null;\n            Paint gridPaint = null;\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                boolean paintLine = false;\n                while (iterator.hasNext()) {\n                    paintLine = false;\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if ((tick.getTickType() == TickType.MINOR)\n                            && isRangeMinorGridlinesVisible()) {\n                        gridStroke = getRangeMinorGridlineStroke();\n                        gridPaint = getRangeMinorGridlinePaint();\n                        paintLine = true;\n                    }\n                    else if ((tick.getTickType() == TickType.MAJOR)\n                            && isRangeGridlinesVisible()) {\n                        gridStroke = getRangeGridlineStroke();\n                        gridPaint = getRangeGridlinePaint();\n                        paintLine = true;\n                    }\n                    if ((tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) && paintLine) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(),\n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     *\n     * @since 1.0.5\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0,\n                    this.domainZeroBaselinePaint,\n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     *\n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     *\n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     *\n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     *\n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a domain crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @since 1.0.4\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @since 1.0.4\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx,\n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea,\n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy,\n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis xaxis = getDomainAxis();\n            if (xaxis != null) {\n                double hvalue = xaxis.java2DToValue(x, info.getDataArea(),\n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis yaxis = getRangeAxis();\n            if (yaxis != null) {\n                double vvalue = yaxis.java2DToValue(y, info.getDataArea(),\n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToDomainAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            List mappedAxes = (List) this.datasetToRangeAxesMap.get(\n                    new Integer(i));\n            if (mappedAxes == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n                }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        // if the event was caused by a change to series visibility, then\n        // the axis ranges might need updating...\n        if (event.getSeriesVisibilityChanged()) {\n            configureDomainAxes();\n            configureRangeAxes();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible\n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     *\n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not\n     *     permitted).\n     *\n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     *\n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     *\n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     *\n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not\n     *         permitted).\n     *\n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     *\n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     *\n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     *\n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedDomainAxisSpace()\n     *\n     * @since 1.0.9\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     *\n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.9\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns <code>true</code> if panning is enabled for the domain axes,\n     * and <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.13\n     */\n    public boolean isDomainPannable() {\n        return this.domainPannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along the\n     * domain axes.\n     *\n     * @param pannable  the new flag value.\n     *\n     * @since 1.0.13\n     */\n    public void setDomainPannable(boolean pannable) {\n        this.domainPannable = pannable;\n    }\n\n    /**\n     * Returns <code>true</code> if panning is enabled for the range axes,\n     * and <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     *\n     * @since 1.0.13\n     */\n    public boolean isRangePannable() {\n        return this.rangePannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along\n     * the range axes.\n     *\n     * @param pannable  the new flag value.\n     *\n     * @since 1.0.13\n     */\n    public void setRangePannable(boolean pannable) {\n        this.rangePannable = pannable;\n    }\n\n    /**\n     * Pans the domain axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     *\n     * @since 1.0.13\n     */\n    public void panDomainAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isDomainPannable()) {\n            return;\n        }\n        int domainAxisCount = getDomainAxisCount();\n        for (int i = 0; i < domainAxisCount; i++) {\n            ValueAxis axis = getDomainAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }\n\n    /**\n     * Pans the range axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     *\n     * @since 1.0.13\n     */\n    public void panRangeAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isRangePannable()) {\n            return;\n        }\n        int rangeAxisCount = getRangeAxisCount();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            ValueAxis axis = getRangeAxis(i);\n            if (axis == null) {\n                continue;\n            }\n            if (axis.isInverted()) {\n                percent = -percent;\n            }\n            axis.pan(percent);\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     *\n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each domain axis\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot\n                    // orientation\n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX,\n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange2(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     *\n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     *\n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot\n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY,\n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange2(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is <code>null</code>, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly <code>null</code>).\n     *\n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * <code>null</code> if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items (<code>null</code> permitted).\n     *\n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot's renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainMinorGridlinesVisible\n                != that.domainMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeMinorGridlinesVisible\n                != that.rangeMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxesMap,\n                that.datasetToDomainAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxesMap,\n                that.datasetToRangeAxesMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke,\n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke,\n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainMinorGridlineStroke,\n                that.domainMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainMinorGridlinePaint,\n                that.domainMinorGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeMinorGridlineStroke,\n                that.rangeMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeMinorGridlinePaint,\n                that.rangeMinorGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint,\n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke,\n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint,\n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke,\n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke,\n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint,\n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke,\n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint,\n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers,\n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers,\n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers,\n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers,\n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedLegendItems,\n                that.fixedLegendItems)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint,\n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint,\n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i],\n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList)\n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxesMap = new TreeMap();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap = new TreeMap();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        if (this.fixedLegendItems != null) {\n            clone.fixedLegendItems\n                    = (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.domainMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeMinorGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeMinorGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.domainMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and\n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that this plot does not support\n     * selection of data items at a point (only because it hasn't been\n     * implemented yet).\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean canSelectByPoint() {\n        return false;  // TODO: make this true later\n}\n\n    /**\n     * Returns <code>true</code> to indicate that this plot supports selection\n     * of data items by region.\n     *\n     * @return A boolean.\n     *\n     * @since 1.2.0\n     */\n    public boolean canSelectByRegion() {\n        return true;\n    }\n\n    /**\n     * Selects a single point - NOT YET IMPLEMENTED.\n     *\n     * @since 1.2.0\n     */\n    public void select(double x, double y, Rectangle2D dataArea,\n            RenderingSource source) {\n        // TODO: implement\n    }\n\n    /**\n     * Selects the data items within the specified region.\n     *\n     * @param region  the region (in Java2D coordinates).\n     * @param dataArea  the data area.\n     * @param source  the rendering source.\n     *\n     * @since 1.2.0\n     */\n    public void select(GeneralPath region, Rectangle2D dataArea,\n            RenderingSource source) {\n        // cycle through the datasets and change the selection state for the\n        // items that fall within the specified region\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset == null) {\n                continue;\n            }\n            XYDatasetSelectionState state = findSelectionStateForDataset(\n                    dataset, source);\n            if (state == null) {\n                continue;\n            }\n            GeneralPath path = convertToDataSpace(region, dataArea, dataset);\n            // now we have to iterate over all the dataset values and\n            // convert each point to Java2D space and then check if it should\n            // be selected.\n            int seriesCount = dataset.getSeriesCount();\n            for (int s = 0; s < seriesCount; s++) {\n                int itemCount = dataset.getItemCount(s);\n                for (int i = 0; i < itemCount; i++) {\n                    double x = dataset.getXValue(s, i);\n                    double y = dataset.getYValue(s, i);\n                    if (path.contains(x, y)) {\n                        state.setSelected(s, i, true);\n                        // FIXME:  we should fire just one dataset change event\n                        // for the whole selection\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the selection state for the specified dataset.  This could be\n     * <code>null</code> if the dataset hasn't been set up to support\n     * selections.\n     *\n     * @param dataset  the dataset.\n     * @param source  the selection source.\n     *\n     * @return The selection state (possibly <code>null</code>).\n     */\n    private XYDatasetSelectionState findSelectionStateForDataset(\n            XYDataset dataset, Object source) {\n        if (dataset instanceof SelectableXYDataset) {\n            SelectableXYDataset sd = (SelectableXYDataset) dataset;\n            XYDatasetSelectionState s = sd.getSelectionState();\n            return s;\n        }\n        throw new RuntimeException();\n        //return null;  // TODO: implement\n    }\n\n    /**\n     * Converts a path from Java2D space to data space.\n     *\n     * @param path  the path (<code>null</code> not permitted).\n     * @param dataArea  the data area.\n     * @param dataset  the dataset which can be used to find the appropriate\n     *         axes.\n     *\n     * @return A path in data space.\n     */\n    private GeneralPath convertToDataSpace(GeneralPath path,\n            Rectangle2D dataArea, XYDataset dataset) {\n        GeneralPath result = new GeneralPath(path.getWindingRule());\n        int datasetIndex = indexOf(dataset);\n        ValueAxis xAxis = getDomainAxisForDataset(datasetIndex);\n        ValueAxis yAxis = getRangeAxisForDataset(datasetIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge();\n        RectangleEdge yAxisEdge = getRangeAxisEdge();\n        double[] coords = new double[6];\n        PathIterator iterator = path.getPathIterator(null);\n        while (!iterator.isDone()) {\n            int segType = iterator.currentSegment(coords);\n            double xx = xAxis.java2DToValue(coords[0], dataArea, xAxisEdge);\n            double yy = yAxis.java2DToValue(coords[1], dataArea, yAxisEdge);\n            if (segType == PathIterator.SEG_MOVETO) {\n                result.moveTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_LINETO) {\n                result.lineTo((float) xx, (float) yy);\n            }\n            else if (segType == PathIterator.SEG_CLOSE) {\n                result.closePath();\n            }\n            iterator.next();\n        }\n        return result;\n    }\n\n    /**\n     * Clears the selection.\n     *\n     * @since 1.2.0\n     */\n    public void clearSelection() {\n        // cycle through the datasets and clear the selection state\n        int datasetCount = this.datasets.size();\n        for (int d = 0; d < datasetCount; d++) {\n            XYDataset dataset = (XYDataset) this.datasets.get(d);\n            if (dataset instanceof AbstractXYDataset) {\n                // TODO: we could add an interface that *any* dataset could\n                // implement if it provides a selection state\n                AbstractXYDataset axyd = (AbstractXYDataset) dataset;\n                if (axyd.getSelectionState() != null) {\n                    XYDatasetSelectionState selState = axyd.getSelectionState();\n                    selState.clearSelection();\n                }\n            }\n        }\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 5, "classes_modified": [{"class_name": "org.jfree.data.xy.XYSeries", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------\n * XYSeries.java\n * -------------\n * (C) Copyright 2001-2008, Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Aaron Metzger;\n *                   Jonathan Gabbai;\n *                   Richard Atkinson;\n *                   Michel Santos;\n *                   Ted Schwartz (fix for bug 1955483);\n *\n * Changes\n * -------\n * 15-Nov-2001 : Version 1 (DG);\n * 03-Apr-2002 : Added an add(double, double) method (DG);\n * 29-Apr-2002 : Added a clear() method (ARM);\n * 06-Jun-2002 : Updated Javadoc comments (DG);\n * 29-Aug-2002 : Modified to give user control over whether or not duplicate\n *               x-values are allowed (DG);\n * 07-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 11-Nov-2002 : Added maximum item count, code contributed by Jonathan\n *               Gabbai (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 04-Aug-2003 : Added getItems() method (DG);\n * 15-Aug-2003 : Changed 'data' from private to protected, added new add()\n *               methods with a 'notify' argument (DG);\n * 22-Sep-2003 : Added getAllowDuplicateXValues() method (RA);\n * 29-Jan-2004 : Added autoSort attribute, based on a contribution by\n *               Michel Santos - see patch 886740 (DG);\n * 03-Feb-2004 : Added indexOf() method (DG);\n * 16-Feb-2004 : Added remove() method (DG);\n * 18-Aug-2004 : Moved from org.jfree.data --> org.jfree.data.xy (DG);\n * 21-Feb-2005 : Added update(Number, Number) and addOrUpdate(Number, Number)\n *               methods (DG);\n * 03-May-2005 : Added a new constructor, fixed the setMaximumItemCount()\n *               method to remove items (and notify listeners) if necessary,\n *               fixed the add() and addOrUpdate() methods to handle unsorted\n *               series (DG);\n * ------------- JFreeChart 1.0.x ---------------------------------------------\n * 11-Jan-2005 : Renamed update(int, Number) --> updateByIndex() (DG);\n * 15-Jan-2007 : Added toArray() method (DG);\n * 20-Jun-2007 : Removed deprecated code and JCommon dependencies (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 22-Nov-2007 : Reimplemented clone() (DG);\n * 01-May-2008 : Fixed bug 1955483 in addOrUpdate() method, thanks to\n *               Ted Schwartz (DG);\n * 24-Nov-2008 : Further fix for 1955483 (DG);\n *\n */\n\npackage org.jfree.data.xy;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (x, y).  By\n * default, items in the series will be sorted into ascending order by x-value,\n * and duplicate x-values are permitted.  Both the sorting and duplicate\n * defaults can be changed in the constructor.  Y-values can be\n * <code>null</code> to represent missing values.\n */\npublic class XYSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    static final long serialVersionUID = -5908509288197150436L;\n\n    // In version 0.9.12, in response to several developer requests, I changed\n    // the 'data' attribute from 'private' to 'protected', so that others can\n    // make subclasses that work directly with the underlying data structure.\n\n    /** Storage for the data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount = Integer.MAX_VALUE;\n\n    /** A flag that controls whether the items are automatically sorted. */\n    private boolean autoSort;\n\n    /** A flag that controls whether or not duplicate x-values are allowed. */\n    private boolean allowDuplicateXValues;\n\n    /**\n     * Creates a new empty series.  By default, items added to the series will\n     * be sorted into ascending order by x-value, and duplicate x-values will\n     * be allowed (these defaults can be modified with another constructor.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     */\n    public XYSeries(Comparable key) {\n        this(key, true, true);\n    }\n\n    /**\n     * Constructs a new empty series, with the auto-sort flag set as requested,\n     * and duplicate values allowed.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     * @param autoSort  a flag that controls whether or not the items in the\n     *                  series are sorted.\n     */\n    public XYSeries(Comparable key, boolean autoSort) {\n        this(key, autoSort, true);\n    }\n\n    /**\n     * Constructs a new xy-series that contains no data.  You can specify\n     * whether or not duplicate x-values are allowed for the series.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     * @param autoSort  a flag that controls whether or not the items in the\n     *                  series are sorted.\n     * @param allowDuplicateXValues  a flag that controls whether duplicate\n     *                               x-values are allowed.\n     */\n    public XYSeries(Comparable key,\n                    boolean autoSort,\n                    boolean allowDuplicateXValues) {\n        super(key);\n        this.data = new java.util.ArrayList();\n        this.autoSort = autoSort;\n        this.allowDuplicateXValues = allowDuplicateXValues;\n    }\n\n    /**\n     * Returns the flag that controls whether the items in the series are\n     * automatically sorted.  There is no setter for this flag, it must be\n     * defined in the series constructor.\n     *\n     * @return A boolean.\n     */\n    public boolean getAutoSort() {\n        return this.autoSort;\n    }\n\n    /**\n     * Returns a flag that controls whether duplicate x-values are allowed.\n     * This flag can only be set in the constructor.\n     *\n     * @return A boolean.\n     */\n    public boolean getAllowDuplicateXValues() {\n        return this.allowDuplicateXValues;\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link XYDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the first element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     * <p>\n     * Typically this value is set before the series is populated with data,\n     * but if it is applied later, it may cause some items to be removed from\n     * the series (in which case a {@link SeriesChangeEvent} will be sent to\n     * all registered listeners.\n     *\n     * @param maximum  the maximum number of items for the series.\n     */\n    public void setMaximumItemCount(int maximum) {\n        this.maximumItemCount = maximum;\n        boolean dataRemoved = false;\n        while (this.data.size() > maximum) {\n            this.data.remove(0);\n            dataRemoved = true;\n        }\n        if (dataRemoved) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (x, y) item (<code>null</code> not permitted).\n     */\n    public void add(XYDataItem item) {\n        // argument checking delegated...\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param x  the x value.\n     * @param y  the y value.\n     */\n    public void add(double x, double y) {\n        add(new Double(x), new Double(y), true);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x value.\n     * @param y  the y value.\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(double x, double y, boolean notify) {\n        add(new Double(x), new Double(y), notify);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.  The unusual pairing of parameter types is to\n     * make it easier to add <code>null</code> y-values.\n     *\n     * @param x  the x value.\n     * @param y  the y value (<code>null</code> permitted).\n     */\n    public void add(double x, Number y) {\n        add(new Double(x), y);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  The unusual\n     * pairing of parameter types is to make it easier to add null y-values.\n     *\n     * @param x  the x value.\n     * @param y  the y value (<code>null</code> permitted).\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(double x, Number y, boolean notify) {\n        add(new Double(x), y, notify);\n    }\n\n    /**\n     * Adds a new data item to the series (in the correct position if the\n     * <code>autoSort</code> flag is set for the series) and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     * <P>\n     * Throws an exception if the x-value is a duplicate AND the\n     * allowDuplicateXValues flag is false.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @throws SeriesException if the x-value is a duplicate and the\n     *     <code>allowDuplicateXValues</code> flag is not set for this series.\n     */\n    public void add(Number x, Number y) {\n        // argument checking delegated...\n        add(x, y, true);\n    }\n\n    /**\n     * Adds new data to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     * <P>\n     * Throws an exception if the x-value is a duplicate AND the\n     * allowDuplicateXValues flag is false.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     * @param notify  a flag the controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(Number x, Number y, boolean notify) {\n        // delegate argument checking to XYDataItem...\n        XYDataItem item = new XYDataItem(x, y);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param item  the (x, y) item (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(XYDataItem item, boolean notify) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n\n        if (this.autoSort) {\n            int index = Collections.binarySearch(this.data, item);\n            if (index < 0) {\n                this.data.add(-index - 1, item);\n            }\n            else {\n                if (this.allowDuplicateXValues) {\n                    // need to make sure we are adding *after* any duplicates\n                    int size = this.data.size();\n                    while (index < size\n                           && item.compareTo(this.data.get(index)) == 0) {\n                        index++;\n                    }\n                    if (index < this.data.size()) {\n                        this.data.add(index, item);\n                    }\n                    else {\n                        this.data.add(item);\n                    }\n                }\n                else {\n                    throw new SeriesException(\"X-value already exists.\");\n                }\n            }\n        }\n        else {\n            if (!this.allowDuplicateXValues) {\n                // can't allow duplicate values, so we need to check whether\n                // there is an item with the given x-value already\n                int index = indexOf(item.getX());\n                if (index >= 0) {\n                    throw new SeriesException(\"X-value already exists.\");\n                }\n            }\n            this.data.add(item);\n        }\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes a range of items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param start  the start index (zero-based).\n     * @param end  the end index (zero-based).\n     */\n    public void delete(int start, int end) {\n        for (int i = start; i <= end; i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Removes the item at the specified index and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     *\n     * @return The item removed.\n     */\n    public XYDataItem remove(int index) {\n        XYDataItem result = (XYDataItem) this.data.remove(index);\n        fireSeriesChanged();\n        return result;\n    }\n\n    /**\n     * Removes the item with the specified x-value and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value.\n\n     * @return The item removed.\n     */\n    public XYDataItem remove(Number x) {\n        return remove(indexOf(x));\n    }\n\n    /**\n     * Removes all data items from the series.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Return the data item with the specified index.\n     *\n     * @param index  the index.\n     *\n     * @return The data item with the specified index.\n     */\n    public XYDataItem getDataItem(int index) {\n        return (XYDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the x-value at the specified index.\n     *\n     * @param index  the index (zero-based).\n     *\n     * @return The x-value (never <code>null</code>).\n     */\n    public Number getX(int index) {\n        return getDataItem(index).getX();\n    }\n\n    /**\n     * Returns the y-value at the specified index.\n     *\n     * @param index  the index (zero-based).\n     *\n     * @return The y-value (possibly <code>null</code>).\n     */\n    public Number getY(int index) {\n        return getDataItem(index).getY();\n    }\n\n    /**\n     * Updates the value of an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the item (zero based index).\n     * @param y  the new value (<code>null</code> permitted).\n     *\n     * @since 1.0.1\n     */\n    public void updateByIndex(int index, Number y) {\n        XYDataItem item = getDataItem(index);\n        item.setY(y);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Updates an item in the series.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @throws SeriesException if there is no existing item with the specified\n     *         x-value.\n     */\n    public void update(Number x, Number y) {\n        int index = indexOf(x);\n        if (index < 0) {\n            throw new SeriesException(\"No observation for x = \" + x);\n        }\n        else {\n            XYDataItem item = getDataItem(index);\n            item.setY(y);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value.\n     * @param y  the y-value.\n     *\n     * @return The item that was overwritten, if any.\n     *\n     * @since 1.0.10\n     */\n    public XYDataItem addOrUpdate(double x, double y) {\n        return addOrUpdate(new Double(x), new Double(y));\n    }\n\n    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0 && !this.allowDuplicateXValues) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n\n    /**\n     * Returns the index of the item with the specified x-value, or a negative\n     * index if the series does not contain an item with that x-value.  Be\n     * aware that for an unsorted series, the index is found by iterating\n     * through all items in the series.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(Number x) {\n        if (this.autoSort) {\n            return Collections.binarySearch(this.data, new XYDataItem(x, null));\n        }\n        else {\n            for (int i = 0; i < this.data.size(); i++) {\n                XYDataItem item = (XYDataItem) this.data.get(i);\n                if (item.getX().equals(x)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * Returns a new array containing the x and y values from this series.\n     *\n     * @return A new array containing the x and y values from this series.\n     *\n     * @since 1.0.4\n     */\n    public double[][] toArray() {\n        int itemCount = getItemCount();\n        double[][] result = new double[2][itemCount];\n        for (int i = 0; i < itemCount; i++) {\n            result[0][i] = this.getX(i).doubleValue();\n            Number y = getY(i);\n            if (y != null) {\n                result[1][i] = y.doubleValue();\n            }\n            else {\n                result[1][i] = Double.NaN;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone of the series.\n     *\n     * @return A clone of the series.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        XYSeries clone = (XYSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new series by copying a subset of the data in this time series.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A series containing a copy of this series from start until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public XYSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        XYSeries copy = (XYSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                XYDataItem item = (XYDataItem) this.data.get(index);\n                XYDataItem clone = (XYDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Unable to add cloned data item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n\n    /**\n     * Tests this series for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against for equality\n     *             (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYSeries)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        XYSeries that = (XYSeries) obj;\n        if (this.maximumItemCount != that.maximumItemCount) {\n            return false;\n        }\n        if (this.autoSort != that.autoSort) {\n            return false;\n        }\n        if (this.allowDuplicateXValues != that.allowDuplicateXValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            XYDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            XYDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            XYDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (this.autoSort ? 1 : 0);\n        result = 29 * result + (this.allowDuplicateXValues ? 1 : 0);\n        return result;\n    }\n\n}\n\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------\n * XYSeries.java\n * -------------\n * (C) Copyright 2001-2008, Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Aaron Metzger;\n *                   Jonathan Gabbai;\n *                   Richard Atkinson;\n *                   Michel Santos;\n *                   Ted Schwartz (fix for bug 1955483);\n *\n * Changes\n * -------\n * 15-Nov-2001 : Version 1 (DG);\n * 03-Apr-2002 : Added an add(double, double) method (DG);\n * 29-Apr-2002 : Added a clear() method (ARM);\n * 06-Jun-2002 : Updated Javadoc comments (DG);\n * 29-Aug-2002 : Modified to give user control over whether or not duplicate\n *               x-values are allowed (DG);\n * 07-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 11-Nov-2002 : Added maximum item count, code contributed by Jonathan\n *               Gabbai (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 04-Aug-2003 : Added getItems() method (DG);\n * 15-Aug-2003 : Changed 'data' from private to protected, added new add()\n *               methods with a 'notify' argument (DG);\n * 22-Sep-2003 : Added getAllowDuplicateXValues() method (RA);\n * 29-Jan-2004 : Added autoSort attribute, based on a contribution by\n *               Michel Santos - see patch 886740 (DG);\n * 03-Feb-2004 : Added indexOf() method (DG);\n * 16-Feb-2004 : Added remove() method (DG);\n * 18-Aug-2004 : Moved from org.jfree.data --> org.jfree.data.xy (DG);\n * 21-Feb-2005 : Added update(Number, Number) and addOrUpdate(Number, Number)\n *               methods (DG);\n * 03-May-2005 : Added a new constructor, fixed the setMaximumItemCount()\n *               method to remove items (and notify listeners) if necessary,\n *               fixed the add() and addOrUpdate() methods to handle unsorted\n *               series (DG);\n * ------------- JFreeChart 1.0.x ---------------------------------------------\n * 11-Jan-2005 : Renamed update(int, Number) --> updateByIndex() (DG);\n * 15-Jan-2007 : Added toArray() method (DG);\n * 20-Jun-2007 : Removed deprecated code and JCommon dependencies (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 22-Nov-2007 : Reimplemented clone() (DG);\n * 01-May-2008 : Fixed bug 1955483 in addOrUpdate() method, thanks to\n *               Ted Schwartz (DG);\n * 24-Nov-2008 : Further fix for 1955483 (DG);\n *\n */\n\npackage org.jfree.data.xy;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (x, y).  By\n * default, items in the series will be sorted into ascending order by x-value,\n * and duplicate x-values are permitted.  Both the sorting and duplicate\n * defaults can be changed in the constructor.  Y-values can be\n * <code>null</code> to represent missing values.\n */\npublic class XYSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    static final long serialVersionUID = -5908509288197150436L;\n\n    // In version 0.9.12, in response to several developer requests, I changed\n    // the 'data' attribute from 'private' to 'protected', so that others can\n    // make subclasses that work directly with the underlying data structure.\n\n    /** Storage for the data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount = Integer.MAX_VALUE;\n\n    /** A flag that controls whether the items are automatically sorted. */\n    private boolean autoSort;\n\n    /** A flag that controls whether or not duplicate x-values are allowed. */\n    private boolean allowDuplicateXValues;\n\n    /**\n     * Creates a new empty series.  By default, items added to the series will\n     * be sorted into ascending order by x-value, and duplicate x-values will\n     * be allowed (these defaults can be modified with another constructor.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     */\n    public XYSeries(Comparable key) {\n        this(key, true, true);\n    }\n\n    /**\n     * Constructs a new empty series, with the auto-sort flag set as requested,\n     * and duplicate values allowed.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     * @param autoSort  a flag that controls whether or not the items in the\n     *                  series are sorted.\n     */\n    public XYSeries(Comparable key, boolean autoSort) {\n        this(key, autoSort, true);\n    }\n\n    /**\n     * Constructs a new xy-series that contains no data.  You can specify\n     * whether or not duplicate x-values are allowed for the series.\n     *\n     * @param key  the series key (<code>null</code> not permitted).\n     * @param autoSort  a flag that controls whether or not the items in the\n     *                  series are sorted.\n     * @param allowDuplicateXValues  a flag that controls whether duplicate\n     *                               x-values are allowed.\n     */\n    public XYSeries(Comparable key,\n                    boolean autoSort,\n                    boolean allowDuplicateXValues) {\n        super(key);\n        this.data = new java.util.ArrayList();\n        this.autoSort = autoSort;\n        this.allowDuplicateXValues = allowDuplicateXValues;\n    }\n\n    /**\n     * Returns the flag that controls whether the items in the series are\n     * automatically sorted.  There is no setter for this flag, it must be\n     * defined in the series constructor.\n     *\n     * @return A boolean.\n     */\n    public boolean getAutoSort() {\n        return this.autoSort;\n    }\n\n    /**\n     * Returns a flag that controls whether duplicate x-values are allowed.\n     * This flag can only be set in the constructor.\n     *\n     * @return A boolean.\n     */\n    public boolean getAllowDuplicateXValues() {\n        return this.allowDuplicateXValues;\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link XYDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the first element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     * <p>\n     * Typically this value is set before the series is populated with data,\n     * but if it is applied later, it may cause some items to be removed from\n     * the series (in which case a {@link SeriesChangeEvent} will be sent to\n     * all registered listeners.\n     *\n     * @param maximum  the maximum number of items for the series.\n     */\n    public void setMaximumItemCount(int maximum) {\n        this.maximumItemCount = maximum;\n        boolean dataRemoved = false;\n        while (this.data.size() > maximum) {\n            this.data.remove(0);\n            dataRemoved = true;\n        }\n        if (dataRemoved) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the (x, y) item (<code>null</code> not permitted).\n     */\n    public void add(XYDataItem item) {\n        // argument checking delegated...\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param x  the x value.\n     * @param y  the y value.\n     */\n    public void add(double x, double y) {\n        add(new Double(x), new Double(y), true);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x value.\n     * @param y  the y value.\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(double x, double y, boolean notify) {\n        add(new Double(x), new Double(y), notify);\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.  The unusual pairing of parameter types is to\n     * make it easier to add <code>null</code> y-values.\n     *\n     * @param x  the x value.\n     * @param y  the y value (<code>null</code> permitted).\n     */\n    public void add(double x, Number y) {\n        add(new Double(x), y);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  The unusual\n     * pairing of parameter types is to make it easier to add null y-values.\n     *\n     * @param x  the x value.\n     * @param y  the y value (<code>null</code> permitted).\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(double x, Number y, boolean notify) {\n        add(new Double(x), y, notify);\n    }\n\n    /**\n     * Adds a new data item to the series (in the correct position if the\n     * <code>autoSort</code> flag is set for the series) and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     * <P>\n     * Throws an exception if the x-value is a duplicate AND the\n     * allowDuplicateXValues flag is false.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @throws SeriesException if the x-value is a duplicate and the\n     *     <code>allowDuplicateXValues</code> flag is not set for this series.\n     */\n    public void add(Number x, Number y) {\n        // argument checking delegated...\n        add(x, y, true);\n    }\n\n    /**\n     * Adds new data to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     * <P>\n     * Throws an exception if the x-value is a duplicate AND the\n     * allowDuplicateXValues flag is false.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     * @param notify  a flag the controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(Number x, Number y, boolean notify) {\n        // delegate argument checking to XYDataItem...\n        XYDataItem item = new XYDataItem(x, y);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a data item to the series and, if requested, sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param item  the (x, y) item (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether or not a\n     *                {@link SeriesChangeEvent} is sent to all registered\n     *                listeners.\n     */\n    public void add(XYDataItem item, boolean notify) {\n\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n\n        if (this.autoSort) {\n            int index = Collections.binarySearch(this.data, item);\n            if (index < 0) {\n                this.data.add(-index - 1, item);\n            }\n            else {\n                if (this.allowDuplicateXValues) {\n                    // need to make sure we are adding *after* any duplicates\n                    int size = this.data.size();\n                    while (index < size\n                           && item.compareTo(this.data.get(index)) == 0) {\n                        index++;\n                    }\n                    if (index < this.data.size()) {\n                        this.data.add(index, item);\n                    }\n                    else {\n                        this.data.add(item);\n                    }\n                }\n                else {\n                    throw new SeriesException(\"X-value already exists.\");\n                }\n            }\n        }\n        else {\n            if (!this.allowDuplicateXValues) {\n                // can't allow duplicate values, so we need to check whether\n                // there is an item with the given x-value already\n                int index = indexOf(item.getX());\n                if (index >= 0) {\n                    throw new SeriesException(\"X-value already exists.\");\n                }\n            }\n            this.data.add(item);\n        }\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n        if (notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes a range of items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param start  the start index (zero-based).\n     * @param end  the end index (zero-based).\n     */\n    public void delete(int start, int end) {\n        for (int i = start; i <= end; i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Removes the item at the specified index and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     *\n     * @return The item removed.\n     */\n    public XYDataItem remove(int index) {\n        XYDataItem result = (XYDataItem) this.data.remove(index);\n        fireSeriesChanged();\n        return result;\n    }\n\n    /**\n     * Removes the item with the specified x-value and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value.\n\n     * @return The item removed.\n     */\n    public XYDataItem remove(Number x) {\n        return remove(indexOf(x));\n    }\n\n    /**\n     * Removes all data items from the series.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Return the data item with the specified index.\n     *\n     * @param index  the index.\n     *\n     * @return The data item with the specified index.\n     */\n    public XYDataItem getDataItem(int index) {\n        return (XYDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the x-value at the specified index.\n     *\n     * @param index  the index (zero-based).\n     *\n     * @return The x-value (never <code>null</code>).\n     */\n    public Number getX(int index) {\n        return getDataItem(index).getX();\n    }\n\n    /**\n     * Returns the y-value at the specified index.\n     *\n     * @param index  the index (zero-based).\n     *\n     * @return The y-value (possibly <code>null</code>).\n     */\n    public Number getY(int index) {\n        return getDataItem(index).getY();\n    }\n\n    /**\n     * Updates the value of an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the item (zero based index).\n     * @param y  the new value (<code>null</code> permitted).\n     *\n     * @since 1.0.1\n     */\n    public void updateByIndex(int index, Number y) {\n        XYDataItem item = getDataItem(index);\n        item.setY(y);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Updates an item in the series.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @throws SeriesException if there is no existing item with the specified\n     *         x-value.\n     */\n    public void update(Number x, Number y) {\n        int index = indexOf(x);\n        if (index < 0) {\n            throw new SeriesException(\"No observation for x = \" + x);\n        }\n        else {\n            XYDataItem item = getDataItem(index);\n            item.setY(y);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value.\n     * @param y  the y-value.\n     *\n     * @return The item that was overwritten, if any.\n     *\n     * @since 1.0.10\n     */\n    public XYDataItem addOrUpdate(double x, double y) {\n        return addOrUpdate(new Double(x), new Double(y));\n    }\n\n    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n        if (this.allowDuplicateXValues) {\n            add(x, y);\n            return null;\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            if (this.autoSort) {\n                this.data.add(-index - 1, new XYDataItem(x, y));\n            }\n            else {\n                this.data.add(new XYDataItem(x, y));\n            }\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n\n    /**\n     * Returns the index of the item with the specified x-value, or a negative\n     * index if the series does not contain an item with that x-value.  Be\n     * aware that for an unsorted series, the index is found by iterating\n     * through all items in the series.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(Number x) {\n        if (this.autoSort) {\n            return Collections.binarySearch(this.data, new XYDataItem(x, null));\n        }\n        else {\n            for (int i = 0; i < this.data.size(); i++) {\n                XYDataItem item = (XYDataItem) this.data.get(i);\n                if (item.getX().equals(x)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    /**\n     * Returns a new array containing the x and y values from this series.\n     *\n     * @return A new array containing the x and y values from this series.\n     *\n     * @since 1.0.4\n     */\n    public double[][] toArray() {\n        int itemCount = getItemCount();\n        double[][] result = new double[2][itemCount];\n        for (int i = 0; i < itemCount; i++) {\n            result[0][i] = this.getX(i).doubleValue();\n            Number y = getY(i);\n            if (y != null) {\n                result[1][i] = y.doubleValue();\n            }\n            else {\n                result[1][i] = Double.NaN;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone of the series.\n     *\n     * @return A clone of the series.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        XYSeries clone = (XYSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new series by copying a subset of the data in this time series.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A series containing a copy of this series from start until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public XYSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        XYSeries copy = (XYSeries) super.clone();\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                XYDataItem item = (XYDataItem) this.data.get(index);\n                XYDataItem clone = (XYDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Unable to add cloned data item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n\n    /**\n     * Tests this series for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against for equality\n     *             (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYSeries)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        XYSeries that = (XYSeries) obj;\n        if (this.maximumItemCount != that.maximumItemCount) {\n            return false;\n        }\n        if (this.autoSort != that.autoSort) {\n            return false;\n        }\n        if (this.allowDuplicateXValues != that.allowDuplicateXValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            XYDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            XYDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            XYDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (this.autoSort ? 1 : 0);\n        result = 29 * result + (this.allowDuplicateXValues ? 1 : 0);\n        return result;\n    }\n\n}\n\n"}]}
{"project": "Chart", "bug_id": 6, "classes_modified": [{"class_name": "org.jfree.chart.util.ShapeList", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * --------------\n * ShapeList.java\n * --------------\n * (C) Copyright 2003-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 21-Jun-2007 : Copied from JCommon (DG);\n * 17-Jun-2008 : Fixed bug in equals() (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Shape;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\n/**\n * A table of {@link Shape} objects.\n */\npublic class ShapeList extends AbstractObjectList {\n\n    /**\n     * Creates a new list.\n     */\n    public ShapeList() {\n        super();\n    }\n\n    /**\n     * Returns a {@link Shape} object from the list.\n     *\n     * @param index the index (zero-based).\n     *\n     * @return The object.\n     */\n    public Shape getShape(int index) {\n        return (Shape) get(index);\n    }\n\n    /**\n     * Sets the {@link Shape} for an item in the list.  The list is expanded \n\t * if necessary.\n     *\n     * @param index  the index (zero-based).\n     * @param shape  the {@link Shape}.\n     */\n    public void setShape(int index, Shape shape) {\n        set(index, shape);\n    }\n\n    /**\n     * Returns an independent copy of the list.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if an item in the list does not\n     *         support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Tests the list for equality with another object (typically also a list).\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ShapeList)) {\n            return false;\n        }\n        return super.equals(obj);\n\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n\n        stream.defaultWriteObject();\n        int count = size();\n        stream.writeInt(count);\n        for (int i = 0; i < count; i++) {\n            Shape shape = getShape(i);\n            if (shape != null) {\n                stream.writeInt(i);\n                SerialUtilities.writeShape(shape, stream);\n            }\n            else {\n                stream.writeInt(-1);\n            }\n        }\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) throws IOException,\n            ClassNotFoundException {\n\n        stream.defaultReadObject();\n        int count = stream.readInt();\n        for (int i = 0; i < count; i++) {\n            int index = stream.readInt();\n            if (index != -1) {\n                setShape(index, SerialUtilities.readShape(stream));\n            }\n        }\n\n    }\n\n}\n\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * --------------\n * ShapeList.java\n * --------------\n * (C) Copyright 2003-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 21-Jun-2007 : Copied from JCommon (DG);\n * 17-Jun-2008 : Fixed bug in equals() (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Shape;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\n/**\n * A table of {@link Shape} objects.\n */\npublic class ShapeList extends AbstractObjectList {\n\n    /**\n     * Creates a new list.\n     */\n    public ShapeList() {\n        super();\n    }\n\n    /**\n     * Returns a {@link Shape} object from the list.\n     *\n     * @param index the index (zero-based).\n     *\n     * @return The object.\n     */\n    public Shape getShape(int index) {\n        return (Shape) get(index);\n    }\n\n    /**\n     * Sets the {@link Shape} for an item in the list.  The list is expanded \n\t * if necessary.\n     *\n     * @param index  the index (zero-based).\n     * @param shape  the {@link Shape}.\n     */\n    public void setShape(int index, Shape shape) {\n        set(index, shape);\n    }\n\n    /**\n     * Returns an independent copy of the list.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if an item in the list does not\n     *         support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Tests the list for equality with another object (typically also a list).\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ShapeList)) {\n            return false;\n        }\n        ShapeList that = (ShapeList) obj;\n        int listSize = size();\n        for (int i = 0; i < listSize; i++) {\n           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n               return false;\n           }\n        }\n        return true;\n\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n\n        stream.defaultWriteObject();\n        int count = size();\n        stream.writeInt(count);\n        for (int i = 0; i < count; i++) {\n            Shape shape = getShape(i);\n            if (shape != null) {\n                stream.writeInt(i);\n                SerialUtilities.writeShape(shape, stream);\n            }\n            else {\n                stream.writeInt(-1);\n            }\n        }\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) throws IOException,\n            ClassNotFoundException {\n\n        stream.defaultReadObject();\n        int count = stream.readInt();\n        for (int i = 0; i < count; i++) {\n            int index = stream.readInt();\n            if (index != -1) {\n                setShape(index, SerialUtilities.readShape(stream));\n            }\n        }\n\n    }\n\n}\n\n"}]}
{"project": "Chart", "bug_id": 7, "classes_modified": [{"class_name": "org.jfree.data.time.TimePeriodValues", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------\n * TimePeriodValues.java\n * ---------------------\n * (C) Copyright 2003-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 22-Apr-2003 : Version 1 (DG);\n * 30-Jul-2003 : Added clone and equals methods while testing (DG);\n * 11-Mar-2005 : Fixed bug in bounds recalculation - see bug report \n *               1161329 (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 03-Oct-2006 : Fixed NullPointerException in equals(), fire change event in \n *               add() method, updated API docs (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to \n *               Comparable (DG);\n * 07-Apr-2008 : Fixed bug with maxMiddleIndex in updateBounds() (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * A structure containing zero, one or many {@link TimePeriodValue} instances.  \n * The time periods can overlap, and are maintained in the order that they are \n * added to the collection.\n * <p>\n * This is similar to the {@link TimeSeries} class, except that the time \n * periods can have irregular lengths.\n */\npublic class TimePeriodValues extends Series implements Serializable {\n\n    /** For serialization. */\n    static final long serialVersionUID = -2210593619794989709L;\n    \n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The list of data pairs in the series. */\n    private List data;\n\n    /** Index of the time period with the minimum start milliseconds. */\n    private int minStartIndex = -1;\n    \n    /** Index of the time period with the maximum start milliseconds. */\n    private int maxStartIndex = -1;\n    \n    /** Index of the time period with the minimum middle milliseconds. */\n    private int minMiddleIndex = -1;\n    \n    /** Index of the time period with the maximum middle milliseconds. */\n    private int maxMiddleIndex = -1;\n    \n    /** Index of the time period with the minimum end milliseconds. */\n    private int minEndIndex = -1;\n    \n    /** Index of the time period with the maximum end milliseconds. */\n    private int maxEndIndex = -1;\n\n    /**\n     * Creates a new (empty) collection of time period values.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     */\n    public TimePeriodValues(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description.\n     * @param range  the range description.\n     */\n    public TimePeriodValues(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.data = new ArrayList();\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     * \n     * @see #getRangeDescription()\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and fires a property change event (with the\n     * property name <code>Domain</code> if the description changes).\n     *\n     * @param description  the new description (<code>null</code> permitted).\n     * \n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     * \n     * @see #getDomainDescription()\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and fires a property change event with the\n     * name <code>Range</code>.\n     *\n     * @param description  the new description (<code>null</code> permitted).\n     * \n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns one data item for the series.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return One data item for the series.\n     */\n    public TimePeriodValue getDataItem(int index) {\n        return (TimePeriodValue) this.data.get(index);\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return The time period at the specified index.\n     * \n     * @see #getDataItem(int)\n     */\n    public TimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return The value at the specified index (possibly <code>null</code>).\n     * \n     * @see #getDataItem(int)\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the item (<code>null</code> not permitted).\n     */\n    public void add(TimePeriodValue item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null item not allowed.\");\n        }\n        this.data.add(item);\n        updateBounds(item.getPeriod(), this.data.size() - 1);\n        fireSeriesChanged();\n    }\n    \n    /**\n     * Update the index values for the maximum and minimum bounds.\n     * \n     * @param period  the time period.\n     * @param index  the index of the time period.\n     */\n    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }\n    \n    /**\n     * Recalculates the bounds for the collection of items.\n     */\n    private void recalculateBounds() {\n        this.minStartIndex = -1;\n        this.minMiddleIndex = -1;\n        this.minEndIndex = -1;\n        this.maxStartIndex = -1;\n        this.maxMiddleIndex = -1;\n        this.maxEndIndex = -1;\n        for (int i = 0; i < this.data.size(); i++) {\n            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i);\n            updateBounds(tpv.getPeriod(), i);\n        }\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @see #add(TimePeriod, Number)\n     */\n    public void add(TimePeriod period, double value) {\n        TimePeriodValue item = new TimePeriodValue(period, value);\n        add(item);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(TimePeriod period, Number value) {\n        TimePeriodValue item = new TimePeriodValue(period, value);\n        add(item);\n    }\n\n    /**\n     * Updates (changes) the value of a data item and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the index of the data item to update.\n     * @param value  the new value (<code>null</code> not permitted).\n     */\n    public void update(int index, Number value) {\n        TimePeriodValue item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive) and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        recalculateBounds();\n        fireSeriesChanged();\n    }\n    \n    /**\n     * Tests the series for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimePeriodValues)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        TimePeriodValues that = (TimePeriodValues) obj;\n        if (!ObjectUtilities.equal(this.getDomainDescription(), \n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.getRangeDescription(), \n                that.getRangeDescription())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(that.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result;\n        result = (this.domain != null ? this.domain.hashCode() : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + this.data.hashCode();\n        result = 29 * result + this.minStartIndex;\n        result = 29 * result + this.maxStartIndex;\n        result = 29 * result + this.minMiddleIndex;\n        result = 29 * result + this.maxMiddleIndex;\n        result = 29 * result + this.minEndIndex;\n        result = 29 * result + this.maxEndIndex;\n        return result;\n    }\n\n    /**\n     * Returns a clone of the collection.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *       object is immutable;</li>\n     *   <li>we pass over to the more general method createCopy(start, end).\n     *   </li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n    \n    /**\n     * Returns the index of the time period with the minimum start milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinStartIndex() {\n        return this.minStartIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum start milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxStartIndex() {\n        return this.maxStartIndex;\n    }\n\n    /**\n     * Returns the index of the time period with the minimum middle \n     * milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinMiddleIndex() {\n        return this.minMiddleIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum middle \n     * milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxMiddleIndex() {\n        return this.maxMiddleIndex;\n    }\n\n    /**\n     * Returns the index of the time period with the minimum end milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinEndIndex() {\n        return this.minEndIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum end milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxEndIndex() {\n        return this.maxEndIndex;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------\n * TimePeriodValues.java\n * ---------------------\n * (C) Copyright 2003-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 22-Apr-2003 : Version 1 (DG);\n * 30-Jul-2003 : Added clone and equals methods while testing (DG);\n * 11-Mar-2005 : Fixed bug in bounds recalculation - see bug report \n *               1161329 (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 03-Oct-2006 : Fixed NullPointerException in equals(), fire change event in \n *               add() method, updated API docs (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to \n *               Comparable (DG);\n * 07-Apr-2008 : Fixed bug with maxMiddleIndex in updateBounds() (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * A structure containing zero, one or many {@link TimePeriodValue} instances.  \n * The time periods can overlap, and are maintained in the order that they are \n * added to the collection.\n * <p>\n * This is similar to the {@link TimeSeries} class, except that the time \n * periods can have irregular lengths.\n */\npublic class TimePeriodValues extends Series implements Serializable {\n\n    /** For serialization. */\n    static final long serialVersionUID = -2210593619794989709L;\n    \n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The list of data pairs in the series. */\n    private List data;\n\n    /** Index of the time period with the minimum start milliseconds. */\n    private int minStartIndex = -1;\n    \n    /** Index of the time period with the maximum start milliseconds. */\n    private int maxStartIndex = -1;\n    \n    /** Index of the time period with the minimum middle milliseconds. */\n    private int minMiddleIndex = -1;\n    \n    /** Index of the time period with the maximum middle milliseconds. */\n    private int maxMiddleIndex = -1;\n    \n    /** Index of the time period with the minimum end milliseconds. */\n    private int minEndIndex = -1;\n    \n    /** Index of the time period with the maximum end milliseconds. */\n    private int maxEndIndex = -1;\n\n    /**\n     * Creates a new (empty) collection of time period values.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     */\n    public TimePeriodValues(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description.\n     * @param range  the range description.\n     */\n    public TimePeriodValues(Comparable name, String domain, String range) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.data = new ArrayList();\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     * \n     * @see #getRangeDescription()\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and fires a property change event (with the\n     * property name <code>Domain</code> if the description changes).\n     *\n     * @param description  the new description (<code>null</code> permitted).\n     * \n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     * \n     * @see #getDomainDescription()\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and fires a property change event with the\n     * name <code>Range</code>.\n     *\n     * @param description  the new description (<code>null</code> permitted).\n     * \n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns one data item for the series.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return One data item for the series.\n     */\n    public TimePeriodValue getDataItem(int index) {\n        return (TimePeriodValue) this.data.get(index);\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return The time period at the specified index.\n     * \n     * @see #getDataItem(int)\n     */\n    public TimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  the item index (in the range <code>0</code> to \n     *     <code>getItemCount() - 1</code>).\n     *\n     * @return The value at the specified index (possibly <code>null</code>).\n     * \n     * @see #getDataItem(int)\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Adds a data item to the series and sends a {@link SeriesChangeEvent} to\n     * all registered listeners.\n     *\n     * @param item  the item (<code>null</code> not permitted).\n     */\n    public void add(TimePeriodValue item) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null item not allowed.\");\n        }\n        this.data.add(item);\n        updateBounds(item.getPeriod(), this.data.size() - 1);\n        fireSeriesChanged();\n    }\n    \n    /**\n     * Update the index values for the maximum and minimum bounds.\n     * \n     * @param period  the time period.\n     * @param index  the index of the time period.\n     */\n    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }\n    \n    /**\n     * Recalculates the bounds for the collection of items.\n     */\n    private void recalculateBounds() {\n        this.minStartIndex = -1;\n        this.minMiddleIndex = -1;\n        this.minEndIndex = -1;\n        this.maxStartIndex = -1;\n        this.maxMiddleIndex = -1;\n        this.maxEndIndex = -1;\n        for (int i = 0; i < this.data.size(); i++) {\n            TimePeriodValue tpv = (TimePeriodValue) this.data.get(i);\n            updateBounds(tpv.getPeriod(), i);\n        }\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @see #add(TimePeriod, Number)\n     */\n    public void add(TimePeriod period, double value) {\n        TimePeriodValue item = new TimePeriodValue(period, value);\n        add(item);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(TimePeriod period, Number value) {\n        TimePeriodValue item = new TimePeriodValue(period, value);\n        add(item);\n    }\n\n    /**\n     * Updates (changes) the value of a data item and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param index  the index of the data item to update.\n     * @param value  the new value (<code>null</code> not permitted).\n     */\n    public void update(int index, Number value) {\n        TimePeriodValue item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive) and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        recalculateBounds();\n        fireSeriesChanged();\n    }\n    \n    /**\n     * Tests the series for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimePeriodValues)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        TimePeriodValues that = (TimePeriodValues) obj;\n        if (!ObjectUtilities.equal(this.getDomainDescription(), \n                that.getDomainDescription())) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.getRangeDescription(), \n                that.getRangeDescription())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(that.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result;\n        result = (this.domain != null ? this.domain.hashCode() : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + this.data.hashCode();\n        result = 29 * result + this.minStartIndex;\n        result = 29 * result + this.maxStartIndex;\n        result = 29 * result + this.minMiddleIndex;\n        result = 29 * result + this.maxMiddleIndex;\n        result = 29 * result + this.minEndIndex;\n        result = 29 * result + this.maxEndIndex;\n        return result;\n    }\n\n    /**\n     * Returns a clone of the collection.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *       object is immutable;</li>\n     *   <li>we pass over to the more general method createCopy(start, end).\n     *   </li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Creates a new instance by copying a subset of the data in this \n     * collection.\n     *\n     * @param start  the index of the first item to copy.\n     * @param end  the index of the last item to copy.\n     *\n     * @return A copy of a subset of the items.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimePeriodValues createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        TimePeriodValues copy = (TimePeriodValues) super.clone();\n\n        copy.data = new ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimePeriodValue item = (TimePeriodValue) this.data.get(index);\n                TimePeriodValue clone = (TimePeriodValue) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    System.err.println(\"Failed to add cloned item.\");\n                }\n            }\n        }\n        return copy;\n\n    }\n    \n    /**\n     * Returns the index of the time period with the minimum start milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinStartIndex() {\n        return this.minStartIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum start milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxStartIndex() {\n        return this.maxStartIndex;\n    }\n\n    /**\n     * Returns the index of the time period with the minimum middle \n     * milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinMiddleIndex() {\n        return this.minMiddleIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum middle \n     * milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxMiddleIndex() {\n        return this.maxMiddleIndex;\n    }\n\n    /**\n     * Returns the index of the time period with the minimum end milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMinEndIndex() {\n        return this.minEndIndex;\n    }\n    \n    /**\n     * Returns the index of the time period with the maximum end milliseconds.\n     * \n     * @return The index.\n     */\n    public int getMaxEndIndex() {\n        return this.maxEndIndex;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 8, "classes_modified": [{"class_name": "org.jfree.data.time.Week", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------\n * Week.java\n * ---------\n * (C) Copyright 2001-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Aimin Han;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 18-Dec-2001 : Changed order of parameters in constructor (DG);\n * 19-Dec-2001 : Added a new constructor as suggested by Paul English (DG);\n * 29-Jan-2002 : Worked on the parseWeek() method (DG);\n * 13-Feb-2002 : Fixed bug in Week(Date) constructor (DG);\n * 26-Feb-2002 : Changed getStart(), getMiddle() and getEnd() methods to\n *               evaluate with reference to a particular time zone (DG);\n * 05-Apr-2002 : Reinstated this class to the JCommon library (DG);\n * 24-Jun-2002 : Removed unnecessary main method (DG);\n * 10-Sep-2002 : Added getSerialIndex() method (DG);\n * 06-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Oct-2002 : Changed to observe 52 or 53 weeks per year, consistent with\n *               GregorianCalendar. Thanks to Aimin Han for the code (DG);\n * 02-Jan-2003 : Removed debug code (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package, and implemented\n *               Serializable (DG);\n * 21-Oct-2003 : Added hashCode() method (DG);\n * 24-May-2004 : Modified getFirstMillisecond() and getLastMillisecond() to\n *               take account of firstDayOfWeek setting in Java's Calendar\n *               class (DG);\n * 30-Sep-2004 : Replaced getTime().getTime() with getTimeInMillis() (DG);\n * 04-Nov-2004 : Reverted change of 30-Sep-2004, because it won't work for\n *               JDK 1.3 (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 06-Mar-2006 : Fix for bug 1448828, incorrect calculation of week and year\n *               for the first few days of some years (DG);\n * 05-Oct-2006 : Updated API docs (DG);\n * 06-Oct-2006 : Refactored to cache first and last millisecond values (DG);\n * 09-Jan-2007 : Fixed bug in next() (DG);\n * 28-Aug-2007 : Added new constructor to avoid problem in creating new\n *               instances (DG);\n * 19-Dec-2007 : Fixed bug in deprecated constructor (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n/**\n * A calendar week.  All years are considered to have 53 weeks, numbered from 1\n * to 53, although in many cases the 53rd week is empty.  Most of the time, the\n * 1st week of the year *begins* in the previous calendar year, but it always\n * finishes in the current year (this behaviour matches the workings of the\n * <code>GregorianCalendar</code> class).\n * <P>\n * This class is immutable, which is a requirement for all\n * {@link RegularTimePeriod} subclasses.\n */\npublic class Week extends RegularTimePeriod implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 1856387786939865061L;\n\n    /** Constant for the first week in the year. */\n    public static final int FIRST_WEEK_IN_YEAR = 1;\n\n    /** Constant for the last week in the year. */\n    public static final int LAST_WEEK_IN_YEAR = 53;\n\n    /** The year in which the week falls. */\n    private short year;\n\n    /** The week (1-53). */\n    private byte week;\n\n    /** The first millisecond. */\n    private long firstMillisecond;\n\n    /** The last millisecond. */\n    private long lastMillisecond;\n\n    /**\n     * Creates a new time period for the week in which the current system\n     * date/time falls.\n     */\n    public Week() {\n        this(new Date());\n    }\n\n    /**\n     * Creates a time period representing the week in the specified year.\n     *\n     * @param week  the week (1 to 53).\n     * @param year  the year (1900 to 9999).\n     */\n    public Week(int week, int year) {\n        if ((week < FIRST_WEEK_IN_YEAR) && (week > LAST_WEEK_IN_YEAR)) {\n            throw new IllegalArgumentException(\n                    \"The 'week' argument must be in the range 1 - 53.\");\n        }\n        this.week = (byte) week;\n        this.year = (short) year;\n        peg(Calendar.getInstance());\n    }\n\n    /**\n     * Creates a time period representing the week in the specified year.\n     *\n     * @param week  the week (1 to 53).\n     * @param year  the year (1900 to 9999).\n     */\n    public Week(int week, Year year) {\n        if ((week < FIRST_WEEK_IN_YEAR) && (week > LAST_WEEK_IN_YEAR)) {\n            throw new IllegalArgumentException(\n                    \"The 'week' argument must be in the range 1 - 53.\");\n        }\n        this.week = (byte) week;\n        this.year = (short) year.getYear();\n        peg(Calendar.getInstance());\n   }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     */\n    public Week(Date time) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     *\n     * @since 1.0.7\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        Calendar calendar = Calendar.getInstance(zone, locale);\n        calendar.setTime(time);\n\n        // sometimes the last few days of the year are considered to fall in\n        // the *first* week of the following year.  Refer to the Javadocs for\n        // GregorianCalendar.\n        int tempWeek = calendar.get(Calendar.WEEK_OF_YEAR);\n        if (tempWeek == 1\n                && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n            this.week = 1;\n            this.year = (short) (calendar.get(Calendar.YEAR) + 1);\n        }\n        else {\n            this.week = (byte) Math.min(tempWeek, LAST_WEEK_IN_YEAR);\n            int yyyy = calendar.get(Calendar.YEAR);\n            // alternatively, sometimes the first few days of the year are\n            // considered to fall in the *last* week of the previous year...\n            if (calendar.get(Calendar.MONTH) == Calendar.JANUARY\n                    && this.week >= 52) {\n                yyyy--;\n            }\n            this.year = (short) yyyy;\n        }\n        peg(calendar);\n    }\n\n    /**\n     * Returns the year in which the week falls.\n     *\n     * @return The year (never <code>null</code>).\n     */\n    public Year getYear() {\n        return new Year(this.year);\n    }\n\n    /**\n     * Returns the year in which the week falls, as an integer value.\n     *\n     * @return The year.\n     */\n    public int getYearValue() {\n        return this.year;\n    }\n\n    /**\n     * Returns the week.\n     *\n     * @return The week.\n     */\n    public int getWeek() {\n        return this.week;\n    }\n\n    /**\n     * Returns the first millisecond of the week.  This will be determined\n     * relative to the time zone specified in the constructor, or in the\n     * calendar instance passed in the most recent call to the\n     * {@link #peg(Calendar)} method.\n     *\n     * @return The first millisecond of the week.\n     *\n     * @see #getLastMillisecond()\n     */\n    public long getFirstMillisecond() {\n        return this.firstMillisecond;\n    }\n\n    /**\n     * Returns the last millisecond of the week.  This will be\n     * determined relative to the time zone specified in the constructor, or\n     * in the calendar instance passed in the most recent call to the\n     * {@link #peg(Calendar)} method.\n     *\n     * @return The last millisecond of the week.\n     *\n     * @see #getFirstMillisecond()\n     */\n    public long getLastMillisecond() {\n        return this.lastMillisecond;\n    }\n\n    /**\n     * Recalculates the start date/time and end date/time for this time period\n     * relative to the supplied calendar (which incorporates a time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @since 1.0.3\n     */\n    public void peg(Calendar calendar) {\n        this.firstMillisecond = getFirstMillisecond(calendar);\n        this.lastMillisecond = getLastMillisecond(calendar);\n    }\n\n    /**\n     * Returns the week preceding this one.  This method will return\n     * <code>null</code> for some lower limit on the range of weeks (currently\n     * week 1, 1900).  For week 1 of any year, the previous week is always week\n     * 53, but week 53 may not contain any days (you should check for this).\n     *\n     * @return The preceding week (possibly <code>null</code>).\n     */\n    public RegularTimePeriod previous() {\n\n        Week result;\n        if (this.week != FIRST_WEEK_IN_YEAR) {\n            result = new Week(this.week - 1, this.year);\n        }\n        else {\n            // we need to work out if the previous year has 52 or 53 weeks...\n            if (this.year > 1900) {\n                int yy = this.year - 1;\n                Calendar prevYearCalendar = Calendar.getInstance();\n                prevYearCalendar.set(yy, Calendar.DECEMBER, 31);\n                result = new Week(prevYearCalendar.getActualMaximum(\n                        Calendar.WEEK_OF_YEAR), yy);\n            }\n            else {\n                result = null;\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the week following this one.  This method will return\n     * <code>null</code> for some upper limit on the range of weeks (currently\n     * week 53, 9999).  For week 52 of any year, the following week is always\n     * week 53, but week 53 may not contain any days (you should check for\n     * this).\n     *\n     * @return The following week (possibly <code>null</code>).\n     */\n    public RegularTimePeriod next() {\n\n        Week result;\n        if (this.week < 52) {\n            result = new Week(this.week + 1, this.year);\n        }\n        else {\n            Calendar calendar = Calendar.getInstance();\n            calendar.set(this.year, Calendar.DECEMBER, 31);\n            int actualMaxWeek\n                = calendar.getActualMaximum(Calendar.WEEK_OF_YEAR);\n            if (this.week < actualMaxWeek) {\n                result = new Week(this.week + 1, this.year);\n            }\n            else {\n                if (this.year < 9999) {\n                    result = new Week(FIRST_WEEK_IN_YEAR, this.year + 1);\n                }\n                else {\n                    result = null;\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a serial index number for the week.\n     *\n     * @return The serial index number.\n     */\n    public long getSerialIndex() {\n        return this.year * 53L + this.week;\n    }\n\n    /**\n     * Returns the first millisecond of the week, evaluated using the supplied\n     * calendar (which determines the time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @return The first millisecond of the week.\n     *\n     * @throws NullPointerException if <code>calendar</code> is\n     *     <code>null</code>.\n     */\n    public long getFirstMillisecond(Calendar calendar) {\n        Calendar c = (Calendar) calendar.clone();\n        c.clear();\n        c.set(Calendar.YEAR, this.year);\n        c.set(Calendar.WEEK_OF_YEAR, this.week);\n        c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());\n        c.set(Calendar.HOUR, 0);\n        c.set(Calendar.MINUTE, 0);\n        c.set(Calendar.SECOND, 0);\n        c.set(Calendar.MILLISECOND, 0);\n        //return c.getTimeInMillis();  // this won't work for JDK 1.3\n        return c.getTime().getTime();\n    }\n\n    /**\n     * Returns the last millisecond of the week, evaluated using the supplied\n     * calendar (which determines the time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @return The last millisecond of the week.\n     *\n     * @throws NullPointerException if <code>calendar</code> is\n     *     <code>null</code>.\n     */\n    public long getLastMillisecond(Calendar calendar) {\n        Calendar c = (Calendar) calendar.clone();\n        c.clear();\n        c.set(Calendar.YEAR, this.year);\n        c.set(Calendar.WEEK_OF_YEAR, this.week + 1);\n        c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());\n        c.set(Calendar.HOUR, 0);\n        c.set(Calendar.MINUTE, 0);\n        c.set(Calendar.SECOND, 0);\n        c.set(Calendar.MILLISECOND, 0);\n        //return c.getTimeInMillis();  // this won't work for JDK 1.3\n        return c.getTime().getTime() - 1;\n    }\n\n    /**\n     * Returns a string representing the week (e.g. \"Week 9, 2002\").\n     *\n     * TODO: look at internationalisation.\n     *\n     * @return A string representing the week.\n     */\n    public String toString() {\n        return \"Week \" + this.week + \", \" + this.year;\n    }\n\n    /**\n     * Tests the equality of this Week object to an arbitrary object.  Returns\n     * true if the target is a Week instance representing the same week as this\n     * object.  In all other cases, returns false.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> if week and year of this and object are the\n     *         same.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Week)) {\n            return false;\n        }\n        Week that = (Week) obj;\n        if (this.week != that.week) {\n            return false;\n        }\n        if (this.year != that.year) {\n            return false;\n        }\n        return true;\n\n    }\n\n    /**\n     * Returns a hash code for this object instance.  The approach described by\n     * Joshua Bloch in \"Effective Java\" has been used here:\n     * <p>\n     * <code>http://developer.java.sun.com/developer/Books/effectivejava\n     * /Chapter3.pdf</code>\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = 17;\n        result = 37 * result + this.week;\n        result = 37 * result + this.year;\n        return result;\n    }\n\n    /**\n     * Returns an integer indicating the order of this Week object relative to\n     * the specified object:\n     *\n     * negative == before, zero == same, positive == after.\n     *\n     * @param o1  the object to compare.\n     *\n     * @return negative == before, zero == same, positive == after.\n     */\n    public int compareTo(Object o1) {\n\n        int result;\n\n        // CASE 1 : Comparing to another Week object\n        // --------------------------------------------\n        if (o1 instanceof Week) {\n            Week w = (Week) o1;\n            result = this.year - w.getYear().getYear();\n            if (result == 0) {\n                result = this.week - w.getWeek();\n            }\n        }\n\n        // CASE 2 : Comparing to another TimePeriod object\n        // -----------------------------------------------\n        else if (o1 instanceof RegularTimePeriod) {\n            // more difficult case - evaluate later...\n            result = 0;\n        }\n\n        // CASE 3 : Comparing to a non-TimePeriod object\n        // ---------------------------------------------\n        else {\n            // consider time periods to be ordered after general objects\n            result = 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Parses the string argument as a week.\n     * <P>\n     * This method is required to accept the format \"YYYY-Wnn\".  It will also\n     * accept \"Wnn-YYYY\". Anything else, at the moment, is a bonus.\n     *\n     * @param s  string to parse.\n     *\n     * @return <code>null</code> if the string is not parseable, the week\n     *         otherwise.\n     */\n    public static Week parseWeek(String s) {\n\n        Week result = null;\n        if (s != null) {\n\n            // trim whitespace from either end of the string\n            s = s.trim();\n\n            int i = Week.findSeparator(s);\n            if (i != -1) {\n                String s1 = s.substring(0, i).trim();\n                String s2 = s.substring(i + 1, s.length()).trim();\n\n                Year y = Week.evaluateAsYear(s1);\n                int w;\n                if (y != null) {\n                    w = Week.stringToWeek(s2);\n                    if (w == -1) {\n                        throw new TimePeriodFormatException(\n                                \"Can't evaluate the week.\");\n                    }\n                    result = new Week(w, y);\n                }\n                else {\n                    y = Week.evaluateAsYear(s2);\n                    if (y != null) {\n                        w = Week.stringToWeek(s1);\n                        if (w == -1) {\n                            throw new TimePeriodFormatException(\n                                    \"Can't evaluate the week.\");\n                        }\n                        result = new Week(w, y);\n                    }\n                    else {\n                        throw new TimePeriodFormatException(\n                                \"Can't evaluate the year.\");\n                    }\n                }\n\n            }\n            else {\n                throw new TimePeriodFormatException(\n                        \"Could not find separator.\");\n            }\n\n        }\n        return result;\n\n    }\n\n    /**\n     * Finds the first occurrence of ' ', '-', ',' or '.'\n     *\n     * @param s  the string to parse.\n     *\n     * @return <code>-1</code> if none of the characters was found, the\n     *      index of the first occurrence otherwise.\n     */\n    private static int findSeparator(String s) {\n\n        int result = s.indexOf('-');\n        if (result == -1) {\n            result = s.indexOf(',');\n        }\n        if (result == -1) {\n            result = s.indexOf(' ');\n        }\n        if (result == -1) {\n            result = s.indexOf('.');\n        }\n        return result;\n    }\n\n    /**\n     * Creates a year from a string, or returns null (format exceptions\n     * suppressed).\n     *\n     * @param s  string to parse.\n     *\n     * @return <code>null</code> if the string is not parseable, the year\n     *         otherwise.\n     */\n    private static Year evaluateAsYear(String s) {\n\n        Year result = null;\n        try {\n            result = Year.parseYear(s);\n        }\n        catch (TimePeriodFormatException e) {\n            // suppress\n        }\n        return result;\n\n    }\n\n    /**\n     * Converts a string to a week.\n     *\n     * @param s  the string to parse.\n     * @return <code>-1</code> if the string does not contain a week number,\n     *         the number of the week otherwise.\n     */\n    private static int stringToWeek(String s) {\n\n        int result = -1;\n        s = s.replace('W', ' ');\n        s = s.trim();\n        try {\n            result = Integer.parseInt(s);\n            if ((result < 1) || (result > LAST_WEEK_IN_YEAR)) {\n                result = -1;\n            }\n        }\n        catch (NumberFormatException e) {\n            // suppress\n        }\n        return result;\n\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------\n * Week.java\n * ---------\n * (C) Copyright 2001-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Aimin Han;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 18-Dec-2001 : Changed order of parameters in constructor (DG);\n * 19-Dec-2001 : Added a new constructor as suggested by Paul English (DG);\n * 29-Jan-2002 : Worked on the parseWeek() method (DG);\n * 13-Feb-2002 : Fixed bug in Week(Date) constructor (DG);\n * 26-Feb-2002 : Changed getStart(), getMiddle() and getEnd() methods to\n *               evaluate with reference to a particular time zone (DG);\n * 05-Apr-2002 : Reinstated this class to the JCommon library (DG);\n * 24-Jun-2002 : Removed unnecessary main method (DG);\n * 10-Sep-2002 : Added getSerialIndex() method (DG);\n * 06-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Oct-2002 : Changed to observe 52 or 53 weeks per year, consistent with\n *               GregorianCalendar. Thanks to Aimin Han for the code (DG);\n * 02-Jan-2003 : Removed debug code (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package, and implemented\n *               Serializable (DG);\n * 21-Oct-2003 : Added hashCode() method (DG);\n * 24-May-2004 : Modified getFirstMillisecond() and getLastMillisecond() to\n *               take account of firstDayOfWeek setting in Java's Calendar\n *               class (DG);\n * 30-Sep-2004 : Replaced getTime().getTime() with getTimeInMillis() (DG);\n * 04-Nov-2004 : Reverted change of 30-Sep-2004, because it won't work for\n *               JDK 1.3 (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 06-Mar-2006 : Fix for bug 1448828, incorrect calculation of week and year\n *               for the first few days of some years (DG);\n * 05-Oct-2006 : Updated API docs (DG);\n * 06-Oct-2006 : Refactored to cache first and last millisecond values (DG);\n * 09-Jan-2007 : Fixed bug in next() (DG);\n * 28-Aug-2007 : Added new constructor to avoid problem in creating new\n *               instances (DG);\n * 19-Dec-2007 : Fixed bug in deprecated constructor (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n/**\n * A calendar week.  All years are considered to have 53 weeks, numbered from 1\n * to 53, although in many cases the 53rd week is empty.  Most of the time, the\n * 1st week of the year *begins* in the previous calendar year, but it always\n * finishes in the current year (this behaviour matches the workings of the\n * <code>GregorianCalendar</code> class).\n * <P>\n * This class is immutable, which is a requirement for all\n * {@link RegularTimePeriod} subclasses.\n */\npublic class Week extends RegularTimePeriod implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 1856387786939865061L;\n\n    /** Constant for the first week in the year. */\n    public static final int FIRST_WEEK_IN_YEAR = 1;\n\n    /** Constant for the last week in the year. */\n    public static final int LAST_WEEK_IN_YEAR = 53;\n\n    /** The year in which the week falls. */\n    private short year;\n\n    /** The week (1-53). */\n    private byte week;\n\n    /** The first millisecond. */\n    private long firstMillisecond;\n\n    /** The last millisecond. */\n    private long lastMillisecond;\n\n    /**\n     * Creates a new time period for the week in which the current system\n     * date/time falls.\n     */\n    public Week() {\n        this(new Date());\n    }\n\n    /**\n     * Creates a time period representing the week in the specified year.\n     *\n     * @param week  the week (1 to 53).\n     * @param year  the year (1900 to 9999).\n     */\n    public Week(int week, int year) {\n        if ((week < FIRST_WEEK_IN_YEAR) && (week > LAST_WEEK_IN_YEAR)) {\n            throw new IllegalArgumentException(\n                    \"The 'week' argument must be in the range 1 - 53.\");\n        }\n        this.week = (byte) week;\n        this.year = (short) year;\n        peg(Calendar.getInstance());\n    }\n\n    /**\n     * Creates a time period representing the week in the specified year.\n     *\n     * @param week  the week (1 to 53).\n     * @param year  the year (1900 to 9999).\n     */\n    public Week(int week, Year year) {\n        if ((week < FIRST_WEEK_IN_YEAR) && (week > LAST_WEEK_IN_YEAR)) {\n            throw new IllegalArgumentException(\n                    \"The 'week' argument must be in the range 1 - 53.\");\n        }\n        this.week = (byte) week;\n        this.year = (short) year.getYear();\n        peg(Calendar.getInstance());\n   }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     */\n    public Week(Date time) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     *\n     * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n     */\n    public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a time period for the week in which the specified date/time\n     * falls, calculated relative to the specified time zone.\n     *\n     * @param time  the date/time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     *\n     * @since 1.0.7\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        Calendar calendar = Calendar.getInstance(zone, locale);\n        calendar.setTime(time);\n\n        // sometimes the last few days of the year are considered to fall in\n        // the *first* week of the following year.  Refer to the Javadocs for\n        // GregorianCalendar.\n        int tempWeek = calendar.get(Calendar.WEEK_OF_YEAR);\n        if (tempWeek == 1\n                && calendar.get(Calendar.MONTH) == Calendar.DECEMBER) {\n            this.week = 1;\n            this.year = (short) (calendar.get(Calendar.YEAR) + 1);\n        }\n        else {\n            this.week = (byte) Math.min(tempWeek, LAST_WEEK_IN_YEAR);\n            int yyyy = calendar.get(Calendar.YEAR);\n            // alternatively, sometimes the first few days of the year are\n            // considered to fall in the *last* week of the previous year...\n            if (calendar.get(Calendar.MONTH) == Calendar.JANUARY\n                    && this.week >= 52) {\n                yyyy--;\n            }\n            this.year = (short) yyyy;\n        }\n        peg(calendar);\n    }\n\n    /**\n     * Returns the year in which the week falls.\n     *\n     * @return The year (never <code>null</code>).\n     */\n    public Year getYear() {\n        return new Year(this.year);\n    }\n\n    /**\n     * Returns the year in which the week falls, as an integer value.\n     *\n     * @return The year.\n     */\n    public int getYearValue() {\n        return this.year;\n    }\n\n    /**\n     * Returns the week.\n     *\n     * @return The week.\n     */\n    public int getWeek() {\n        return this.week;\n    }\n\n    /**\n     * Returns the first millisecond of the week.  This will be determined\n     * relative to the time zone specified in the constructor, or in the\n     * calendar instance passed in the most recent call to the\n     * {@link #peg(Calendar)} method.\n     *\n     * @return The first millisecond of the week.\n     *\n     * @see #getLastMillisecond()\n     */\n    public long getFirstMillisecond() {\n        return this.firstMillisecond;\n    }\n\n    /**\n     * Returns the last millisecond of the week.  This will be\n     * determined relative to the time zone specified in the constructor, or\n     * in the calendar instance passed in the most recent call to the\n     * {@link #peg(Calendar)} method.\n     *\n     * @return The last millisecond of the week.\n     *\n     * @see #getFirstMillisecond()\n     */\n    public long getLastMillisecond() {\n        return this.lastMillisecond;\n    }\n\n    /**\n     * Recalculates the start date/time and end date/time for this time period\n     * relative to the supplied calendar (which incorporates a time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @since 1.0.3\n     */\n    public void peg(Calendar calendar) {\n        this.firstMillisecond = getFirstMillisecond(calendar);\n        this.lastMillisecond = getLastMillisecond(calendar);\n    }\n\n    /**\n     * Returns the week preceding this one.  This method will return\n     * <code>null</code> for some lower limit on the range of weeks (currently\n     * week 1, 1900).  For week 1 of any year, the previous week is always week\n     * 53, but week 53 may not contain any days (you should check for this).\n     *\n     * @return The preceding week (possibly <code>null</code>).\n     */\n    public RegularTimePeriod previous() {\n\n        Week result;\n        if (this.week != FIRST_WEEK_IN_YEAR) {\n            result = new Week(this.week - 1, this.year);\n        }\n        else {\n            // we need to work out if the previous year has 52 or 53 weeks...\n            if (this.year > 1900) {\n                int yy = this.year - 1;\n                Calendar prevYearCalendar = Calendar.getInstance();\n                prevYearCalendar.set(yy, Calendar.DECEMBER, 31);\n                result = new Week(prevYearCalendar.getActualMaximum(\n                        Calendar.WEEK_OF_YEAR), yy);\n            }\n            else {\n                result = null;\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the week following this one.  This method will return\n     * <code>null</code> for some upper limit on the range of weeks (currently\n     * week 53, 9999).  For week 52 of any year, the following week is always\n     * week 53, but week 53 may not contain any days (you should check for\n     * this).\n     *\n     * @return The following week (possibly <code>null</code>).\n     */\n    public RegularTimePeriod next() {\n\n        Week result;\n        if (this.week < 52) {\n            result = new Week(this.week + 1, this.year);\n        }\n        else {\n            Calendar calendar = Calendar.getInstance();\n            calendar.set(this.year, Calendar.DECEMBER, 31);\n            int actualMaxWeek\n                = calendar.getActualMaximum(Calendar.WEEK_OF_YEAR);\n            if (this.week < actualMaxWeek) {\n                result = new Week(this.week + 1, this.year);\n            }\n            else {\n                if (this.year < 9999) {\n                    result = new Week(FIRST_WEEK_IN_YEAR, this.year + 1);\n                }\n                else {\n                    result = null;\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a serial index number for the week.\n     *\n     * @return The serial index number.\n     */\n    public long getSerialIndex() {\n        return this.year * 53L + this.week;\n    }\n\n    /**\n     * Returns the first millisecond of the week, evaluated using the supplied\n     * calendar (which determines the time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @return The first millisecond of the week.\n     *\n     * @throws NullPointerException if <code>calendar</code> is\n     *     <code>null</code>.\n     */\n    public long getFirstMillisecond(Calendar calendar) {\n        Calendar c = (Calendar) calendar.clone();\n        c.clear();\n        c.set(Calendar.YEAR, this.year);\n        c.set(Calendar.WEEK_OF_YEAR, this.week);\n        c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());\n        c.set(Calendar.HOUR, 0);\n        c.set(Calendar.MINUTE, 0);\n        c.set(Calendar.SECOND, 0);\n        c.set(Calendar.MILLISECOND, 0);\n        //return c.getTimeInMillis();  // this won't work for JDK 1.3\n        return c.getTime().getTime();\n    }\n\n    /**\n     * Returns the last millisecond of the week, evaluated using the supplied\n     * calendar (which determines the time zone).\n     *\n     * @param calendar  the calendar (<code>null</code> not permitted).\n     *\n     * @return The last millisecond of the week.\n     *\n     * @throws NullPointerException if <code>calendar</code> is\n     *     <code>null</code>.\n     */\n    public long getLastMillisecond(Calendar calendar) {\n        Calendar c = (Calendar) calendar.clone();\n        c.clear();\n        c.set(Calendar.YEAR, this.year);\n        c.set(Calendar.WEEK_OF_YEAR, this.week + 1);\n        c.set(Calendar.DAY_OF_WEEK, c.getFirstDayOfWeek());\n        c.set(Calendar.HOUR, 0);\n        c.set(Calendar.MINUTE, 0);\n        c.set(Calendar.SECOND, 0);\n        c.set(Calendar.MILLISECOND, 0);\n        //return c.getTimeInMillis();  // this won't work for JDK 1.3\n        return c.getTime().getTime() - 1;\n    }\n\n    /**\n     * Returns a string representing the week (e.g. \"Week 9, 2002\").\n     *\n     * TODO: look at internationalisation.\n     *\n     * @return A string representing the week.\n     */\n    public String toString() {\n        return \"Week \" + this.week + \", \" + this.year;\n    }\n\n    /**\n     * Tests the equality of this Week object to an arbitrary object.  Returns\n     * true if the target is a Week instance representing the same week as this\n     * object.  In all other cases, returns false.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> if week and year of this and object are the\n     *         same.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Week)) {\n            return false;\n        }\n        Week that = (Week) obj;\n        if (this.week != that.week) {\n            return false;\n        }\n        if (this.year != that.year) {\n            return false;\n        }\n        return true;\n\n    }\n\n    /**\n     * Returns a hash code for this object instance.  The approach described by\n     * Joshua Bloch in \"Effective Java\" has been used here:\n     * <p>\n     * <code>http://developer.java.sun.com/developer/Books/effectivejava\n     * /Chapter3.pdf</code>\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result = 17;\n        result = 37 * result + this.week;\n        result = 37 * result + this.year;\n        return result;\n    }\n\n    /**\n     * Returns an integer indicating the order of this Week object relative to\n     * the specified object:\n     *\n     * negative == before, zero == same, positive == after.\n     *\n     * @param o1  the object to compare.\n     *\n     * @return negative == before, zero == same, positive == after.\n     */\n    public int compareTo(Object o1) {\n\n        int result;\n\n        // CASE 1 : Comparing to another Week object\n        // --------------------------------------------\n        if (o1 instanceof Week) {\n            Week w = (Week) o1;\n            result = this.year - w.getYear().getYear();\n            if (result == 0) {\n                result = this.week - w.getWeek();\n            }\n        }\n\n        // CASE 2 : Comparing to another TimePeriod object\n        // -----------------------------------------------\n        else if (o1 instanceof RegularTimePeriod) {\n            // more difficult case - evaluate later...\n            result = 0;\n        }\n\n        // CASE 3 : Comparing to a non-TimePeriod object\n        // ---------------------------------------------\n        else {\n            // consider time periods to be ordered after general objects\n            result = 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Parses the string argument as a week.\n     * <P>\n     * This method is required to accept the format \"YYYY-Wnn\".  It will also\n     * accept \"Wnn-YYYY\". Anything else, at the moment, is a bonus.\n     *\n     * @param s  string to parse.\n     *\n     * @return <code>null</code> if the string is not parseable, the week\n     *         otherwise.\n     */\n    public static Week parseWeek(String s) {\n\n        Week result = null;\n        if (s != null) {\n\n            // trim whitespace from either end of the string\n            s = s.trim();\n\n            int i = Week.findSeparator(s);\n            if (i != -1) {\n                String s1 = s.substring(0, i).trim();\n                String s2 = s.substring(i + 1, s.length()).trim();\n\n                Year y = Week.evaluateAsYear(s1);\n                int w;\n                if (y != null) {\n                    w = Week.stringToWeek(s2);\n                    if (w == -1) {\n                        throw new TimePeriodFormatException(\n                                \"Can't evaluate the week.\");\n                    }\n                    result = new Week(w, y);\n                }\n                else {\n                    y = Week.evaluateAsYear(s2);\n                    if (y != null) {\n                        w = Week.stringToWeek(s1);\n                        if (w == -1) {\n                            throw new TimePeriodFormatException(\n                                    \"Can't evaluate the week.\");\n                        }\n                        result = new Week(w, y);\n                    }\n                    else {\n                        throw new TimePeriodFormatException(\n                                \"Can't evaluate the year.\");\n                    }\n                }\n\n            }\n            else {\n                throw new TimePeriodFormatException(\n                        \"Could not find separator.\");\n            }\n\n        }\n        return result;\n\n    }\n\n    /**\n     * Finds the first occurrence of ' ', '-', ',' or '.'\n     *\n     * @param s  the string to parse.\n     *\n     * @return <code>-1</code> if none of the characters was found, the\n     *      index of the first occurrence otherwise.\n     */\n    private static int findSeparator(String s) {\n\n        int result = s.indexOf('-');\n        if (result == -1) {\n            result = s.indexOf(',');\n        }\n        if (result == -1) {\n            result = s.indexOf(' ');\n        }\n        if (result == -1) {\n            result = s.indexOf('.');\n        }\n        return result;\n    }\n\n    /**\n     * Creates a year from a string, or returns null (format exceptions\n     * suppressed).\n     *\n     * @param s  string to parse.\n     *\n     * @return <code>null</code> if the string is not parseable, the year\n     *         otherwise.\n     */\n    private static Year evaluateAsYear(String s) {\n\n        Year result = null;\n        try {\n            result = Year.parseYear(s);\n        }\n        catch (TimePeriodFormatException e) {\n            // suppress\n        }\n        return result;\n\n    }\n\n    /**\n     * Converts a string to a week.\n     *\n     * @param s  the string to parse.\n     * @return <code>-1</code> if the string does not contain a week number,\n     *         the number of the week otherwise.\n     */\n    private static int stringToWeek(String s) {\n\n        int result = -1;\n        s = s.replace('W', ' ');\n        s = s.trim();\n        try {\n            result = Integer.parseInt(s);\n            if ((result < 1) || (result > LAST_WEEK_IN_YEAR)) {\n                result = -1;\n            }\n        }\n        catch (NumberFormatException e) {\n            // suppress\n        }\n        return result;\n\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 9, "classes_modified": [{"class_name": "org.jfree.data.time.TimeSeries", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors\n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented\n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for\n *               contents) made a method and added to addOrUpdate.  Made a\n *               public method to enable ageing against a specified time\n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.\n *               Modified exception message in add() method to be more\n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report\n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500\n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to\n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * 10-Jan-2008 : Fixed createCopy(RegularTimePeriod, RegularTimePeriod) (bug\n *               1864222) (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value).\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n\n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /**\n     * The maximum age of items for the series, specified as a number of\n     * time periods.\n     */\n    private long maximumItemAge;\n\n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is\n     * created.  Use one of the other constructors if you require a different\n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                Day.class);\n    }\n\n    /**\n     * Creates a new (empty) time series with the specified name and class\n     * of {@link RegularTimePeriod}.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not\n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                timePeriodClass);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not\n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, String domain, String range,\n                      Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     *\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     *\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     *\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the FIRST element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     *\n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     *\n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This\n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically\n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     *\n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (never <code>null</code>).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item for the series.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the data item for a specific period.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or\n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time\n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the\n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    /**\n     * Adds a data item to the series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a\n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to\n     * the oldest record in the series does not exceed maximumItemAge time\n     * periods.  Oldest items will be removed if required.\n     *\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied\n     * time to the oldest record in the series does not exceed history count.\n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data\n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n\n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        // check if there are any values earlier than specified by the history\n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not\n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String\n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but\n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors\n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented\n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for\n *               contents) made a method and added to addOrUpdate.  Made a\n *               public method to enable ageing against a specified time\n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.\n *               Modified exception message in add() method to be more\n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report\n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500\n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to\n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * 10-Jan-2008 : Fixed createCopy(RegularTimePeriod, RegularTimePeriod) (bug\n *               1864222) (DG);\n *\n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value).\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n\n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /**\n     * The maximum age of items for the series, specified as a number of\n     * time periods.\n     */\n    private long maximumItemAge;\n\n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is\n     * created.  Use one of the other constructors if you require a different\n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                Day.class);\n    }\n\n    /**\n     * Creates a new (empty) time series with the specified name and class\n     * of {@link RegularTimePeriod}.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not\n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,\n                timePeriodClass);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not\n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, String domain, String range,\n                      Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     *\n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     *\n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code>\n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     *\n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains\n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     *\n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.\n     * If you add a new item to the series such that the number of items will\n     * exceed the maximum item count, then the FIRST element in the series is\n     * automatically removed, ensuring that the maximum item count is not\n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     *\n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     *\n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This\n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically\n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     *\n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (never <code>null</code>).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item for the series.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     *\n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the data item for a specific period.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or\n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time\n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the\n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    /**\n     * Adds a data item to the series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n\n    /**\n     * Adds a data item to the series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not\n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends\n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a\n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \"\n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(),\n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          double value) {\n        return addOrUpdate(period, new Double(value));\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a\n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered\n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not\n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period,\n                                          Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing\n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to\n     * the oldest record in the series does not exceed maximumItemAge time\n     * periods.  Oldest items will be removed if required.\n     *\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history\n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex())\n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied\n     * time to the oldest record in the series does not exceed history count.\n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data\n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is\n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n\n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE;\n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class,\n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n\n        // check if there are any values earlier than specified by the history\n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index\n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not\n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String\n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but\n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item\n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if ((endIndex < 0)  || (endIndex < startIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 10, "classes_modified": [{"class_name": "org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + toolTipText\n            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 11, "classes_modified": [{"class_name": "org.jfree.chart.util.ShapeUtilities", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}]}
{"project": "Chart", "bug_id": 12, "classes_modified": [{"class_name": "org.jfree.chart.plot.MultiplePiePlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * --------------------\n * MultiplePiePlot.java\n * --------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Brian Cabana (patch 1943021);\n *\n * Changes\n * -------\n * 29-Jan-2004 : Version 1 (DG);\n * 31-Mar-2004 : Added setPieIndex() call during drawing (DG);\n * 20-Apr-2005 : Small change for update to LegendItem constructors (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 16-Jun-2005 : Added get/setDataset() and equals() methods (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 06-Apr-2006 : Fixed bug 1190647 - legend and section colors not consistent\n *               when aggregation limit is specified (DG);\n * 27-Sep-2006 : Updated draw() method for deprecated code (DG);\n * 17-Jan-2007 : Updated prefetchSectionPaints() to check settings in\n *               underlying PiePlot (DG);\n * 17-May-2007 : Added argument check to setPieChart() (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Apr-2008 : In the constructor, register the plot as a dataset listener -\n *               see patch 1943021 from Brian Cabana (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.title.TextTitle;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.TableOrder;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryToPieDataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays multiple pie plots using data from a\n * {@link CategoryDataset}.\n */\npublic class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -355377800470807389L;\n\n    /** The chart object that draws the individual pie charts. */\n    private JFreeChart pieChart;\n\n    /** The dataset. */\n    private CategoryDataset dataset;\n\n    /** The data extract order (by row or by column). */\n    private TableOrder dataExtractOrder;\n\n    /** The pie section limit percentage. */\n    private double limit = 0.0;\n\n    /**\n     * The key for the aggregated items.\n     * @since 1.0.2\n     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public void setDataset(CategoryDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of\n        // change listeners...\n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self to trigger plot change event\n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }\n\n    /**\n     * Returns the pie chart that is used to draw the individual pie plots.\n     *\n     * @return The pie chart (never <code>null</code>).\n     *\n     * @see #setPieChart(JFreeChart)\n     */\n    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }\n\n    /**\n     * Sets the chart that is used to draw the individual pie plots.  The\n     * chart's plot must be an instance of {@link PiePlot}.\n     *\n     * @param pieChart  the pie chart (<code>null</code> not permitted).\n     *\n     * @see #getPieChart()\n     */\n    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the data extract order (by row or by column).\n     *\n     * @return The data extract order (never <code>null</code>).\n     */\n    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }\n\n    /**\n     * Sets the data extract order (by row or by column) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param order  the order (<code>null</code> not permitted).\n     */\n    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the limit (as a percentage) below which small pie sections are\n     * aggregated.\n     *\n     * @return The limit percentage.\n     */\n    public double getLimit() {\n        return this.limit;\n    }\n\n    /**\n     * Sets the limit below which pie sections are aggregated.\n     * Set this to 0.0 if you don't want any aggregation to occur.\n     *\n     * @param limit  the limit percent.\n     */\n    public void setLimit(double limit) {\n        this.limit = limit;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the key for aggregated items in the pie plots, if there are any.\n     * The default value is \"Other\".\n     *\n     * @return The aggregated items key.\n     *\n     * @since 1.0.2\n     */\n    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }\n\n    /**\n     * Sets the key for aggregated items in the pie plots.  You must ensure\n     * that this doesn't clash with any keys in the dataset.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the pie section representing the\n     * aggregated items.  The default value is <code>Color.lightGray</code>.\n     *\n     * @return The paint.\n     *\n     * @since 1.0.2\n     */\n    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the pie section representing the aggregated\n     * items and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return \"Multiple Pie Plot\";\n         // TODO: need to fetch this from localised resources\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing.\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        // check that there is some data to display...\n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        // the columns variable is always >= rows\n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        // swap rows and columns to match plotArea shape\n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            // update the section colors to match the global colors...\n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * For each key in the dataset, check the <code>sectionPaints</code>\n     * cache to see if a paint is associated with that key and, if not,\n     * fetch one from the drawing supplier.  These colors are cached so that\n     * the legend and all the subplots use consistent colors.\n     */\n    private void prefetchSectionPaints() {\n\n        // pre-fetch the colors for each key...this is because the subplots\n        // may not display every key, but we need the coloring to be\n        // consistent...\n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            // column keys provide potential keys for individual pies\n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            // row keys provide potential keys for individual pies\n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n\n        if (this.dataset != null) {\n            List keys = null;\n\n            prefetchSectionPaints();\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                keys = this.dataset.getColumnKeys();\n            }\n            else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {\n                keys = this.dataset.getRowKeys();\n            }\n\n            if (keys != null) {\n                int section = 0;\n                Iterator iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    Comparable key = (Comparable) iterator.next();\n                    String label = key.toString();\n                    String description = label;\n                    Paint paint = (Paint) this.sectionPaints.get(key);\n                    LegendItem item = new LegendItem(label, description,\n                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                            paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                    section++;\n                }\n            }\n            if (this.limit > 0.0) {\n                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\n                        this.aggregatedItemsKey.toString(), null, null,\n                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                        this.aggregatedItemsPaint,\n                        Plot.DEFAULT_OUTLINE_STROKE,\n                        this.aggregatedItemsPaint));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the\n     * plot's dataset is not considered in the equality test.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> if this plot is equal to <code>obj</code>, and\n     *     <code>false</code> otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.aggregatedItemsPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\n        this.sectionPaints = new HashMap();\n    }\n\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * --------------------\n * MultiplePiePlot.java\n * --------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Brian Cabana (patch 1943021);\n *\n * Changes\n * -------\n * 29-Jan-2004 : Version 1 (DG);\n * 31-Mar-2004 : Added setPieIndex() call during drawing (DG);\n * 20-Apr-2005 : Small change for update to LegendItem constructors (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 16-Jun-2005 : Added get/setDataset() and equals() methods (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 06-Apr-2006 : Fixed bug 1190647 - legend and section colors not consistent\n *               when aggregation limit is specified (DG);\n * 27-Sep-2006 : Updated draw() method for deprecated code (DG);\n * 17-Jan-2007 : Updated prefetchSectionPaints() to check settings in\n *               underlying PiePlot (DG);\n * 17-May-2007 : Added argument check to setPieChart() (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Apr-2008 : In the constructor, register the plot as a dataset listener -\n *               see patch 1943021 from Brian Cabana (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.title.TextTitle;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.TableOrder;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryToPieDataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays multiple pie plots using data from a\n * {@link CategoryDataset}.\n */\npublic class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -355377800470807389L;\n\n    /** The chart object that draws the individual pie charts. */\n    private JFreeChart pieChart;\n\n    /** The dataset. */\n    private CategoryDataset dataset;\n\n    /** The data extract order (by row or by column). */\n    private TableOrder dataExtractOrder;\n\n    /** The pie section limit percentage. */\n    private double limit = 0.0;\n\n    /**\n     * The key for the aggregated items.\n     * @since 1.0.2\n     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public void setDataset(CategoryDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of\n        // change listeners...\n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self to trigger plot change event\n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }\n\n    /**\n     * Returns the pie chart that is used to draw the individual pie plots.\n     *\n     * @return The pie chart (never <code>null</code>).\n     *\n     * @see #setPieChart(JFreeChart)\n     */\n    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }\n\n    /**\n     * Sets the chart that is used to draw the individual pie plots.  The\n     * chart's plot must be an instance of {@link PiePlot}.\n     *\n     * @param pieChart  the pie chart (<code>null</code> not permitted).\n     *\n     * @see #getPieChart()\n     */\n    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the data extract order (by row or by column).\n     *\n     * @return The data extract order (never <code>null</code>).\n     */\n    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }\n\n    /**\n     * Sets the data extract order (by row or by column) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param order  the order (<code>null</code> not permitted).\n     */\n    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the limit (as a percentage) below which small pie sections are\n     * aggregated.\n     *\n     * @return The limit percentage.\n     */\n    public double getLimit() {\n        return this.limit;\n    }\n\n    /**\n     * Sets the limit below which pie sections are aggregated.\n     * Set this to 0.0 if you don't want any aggregation to occur.\n     *\n     * @param limit  the limit percent.\n     */\n    public void setLimit(double limit) {\n        this.limit = limit;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the key for aggregated items in the pie plots, if there are any.\n     * The default value is \"Other\".\n     *\n     * @return The aggregated items key.\n     *\n     * @since 1.0.2\n     */\n    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }\n\n    /**\n     * Sets the key for aggregated items in the pie plots.  You must ensure\n     * that this doesn't clash with any keys in the dataset.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the pie section representing the\n     * aggregated items.  The default value is <code>Color.lightGray</code>.\n     *\n     * @return The paint.\n     *\n     * @since 1.0.2\n     */\n    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the pie section representing the aggregated\n     * items and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return \"Multiple Pie Plot\";\n         // TODO: need to fetch this from localised resources\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing.\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        // check that there is some data to display...\n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        // the columns variable is always >= rows\n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        // swap rows and columns to match plotArea shape\n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            // update the section colors to match the global colors...\n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * For each key in the dataset, check the <code>sectionPaints</code>\n     * cache to see if a paint is associated with that key and, if not,\n     * fetch one from the drawing supplier.  These colors are cached so that\n     * the legend and all the subplots use consistent colors.\n     */\n    private void prefetchSectionPaints() {\n\n        // pre-fetch the colors for each key...this is because the subplots\n        // may not display every key, but we need the coloring to be\n        // consistent...\n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            // column keys provide potential keys for individual pies\n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            // row keys provide potential keys for individual pies\n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n\n        if (this.dataset != null) {\n            List keys = null;\n\n            prefetchSectionPaints();\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                keys = this.dataset.getColumnKeys();\n            }\n            else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {\n                keys = this.dataset.getRowKeys();\n            }\n\n            if (keys != null) {\n                int section = 0;\n                Iterator iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    Comparable key = (Comparable) iterator.next();\n                    String label = key.toString();\n                    String description = label;\n                    Paint paint = (Paint) this.sectionPaints.get(key);\n                    LegendItem item = new LegendItem(label, description,\n                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                            paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                    section++;\n                }\n            }\n            if (this.limit > 0.0) {\n                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\n                        this.aggregatedItemsKey.toString(), null, null,\n                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                        this.aggregatedItemsPaint,\n                        Plot.DEFAULT_OUTLINE_STROKE,\n                        this.aggregatedItemsPaint));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the\n     * plot's dataset is not considered in the equality test.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> if this plot is equal to <code>obj</code>, and\n     *     <code>false</code> otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.aggregatedItemsPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\n        this.sectionPaints = new HashMap();\n    }\n\n\n}\n"}]}
{"project": "Chart", "bug_id": 13, "classes_modified": [{"class_name": "org.jfree.chart.block.BorderArrangement", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ----------------------\n * BorderArrangement.java\n * ----------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes:\n * --------\n * 22-Oct-2004 : Version 1 (DG);\n * 08-Feb-2005 : Updated for changes in RectangleConstraint (DG);\n * 24-Feb-2005 : Improved arrangeRR() method (DG);\n * 03-May-2005 : Implemented Serializable and added equals() method (DG);\n * 13-May-2005 : Fixed bugs in the arrange() method (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 08-Apr-2008 : Fixed bug in arrangeFF() method where width is too small for\n *               left and right blocks (DG);\n *\n */\n\npackage org.jfree.chart.block;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.Serializable;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.Size2D;\nimport org.jfree.data.Range;\n\n/**\n * An arrangement manager that lays out blocks in a similar way to\n * Swing's BorderLayout class.\n */\npublic class BorderArrangement implements Arrangement, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 506071142274883745L;\n\n    /** The block (if any) at the center of the layout. */\n    private Block centerBlock;\n\n    /** The block (if any) at the top of the layout. */\n    private Block topBlock;\n\n    /** The block (if any) at the bottom of the layout. */\n    private Block bottomBlock;\n\n    /** The block (if any) at the left of the layout. */\n    private Block leftBlock;\n\n    /** The block (if any) at the right of the layout. */\n    private Block rightBlock;\n\n    /**\n     * Creates a new instance.\n     */\n    public BorderArrangement() {\n    }\n\n    /**\n     * Adds a block to the arrangement manager at the specified edge.\n     *\n     * @param block  the block (<code>null</code> permitted).\n     * @param key  the edge (an instance of {@link RectangleEdge}) or\n     *             <code>null</code> for the center block.\n     */\n    public void add(Block block, Object key) {\n\n        if (key == null) {\n            this.centerBlock = block;\n        }\n        else {\n            RectangleEdge edge = (RectangleEdge) key;\n            if (edge == RectangleEdge.TOP) {\n                this.topBlock = block;\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                this.bottomBlock = block;\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                this.leftBlock = block;\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                this.rightBlock = block;\n            }\n        }\n    }\n\n    /**\n     * Arranges the items in the specified container, subject to the given\n     * constraint.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The block size.\n     */\n    public Size2D arrange(BlockContainer container,\n                          Graphics2D g2,\n                          RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint\n                = container.toContentConstraint(constraint);\n        Size2D contentSize = null;\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeNN(container, g2);\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                contentSize = arrangeFF(container, g2, constraint);\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeFR(container, g2, constraint);\n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\n                        constraint.getHeightRange(), g2);\n            }\n        }\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\n                container.calculateTotalHeight(contentSize.getHeight()));\n    }\n\n    /**\n     * Performs an arrangement without constraints.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n            w[2] = size.width;\n            h[2] = size.height;\n       }\n        if (this.rightBlock != null) {\n            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            Size2D size = this.centerBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n        double height = h[0] + h[1] + centerHeight;\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    centerHeight));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], centerHeight));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], centerHeight));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Performs an arrangement with a fixed width and a range for the height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }\n\n    /**\n     * Arranges the container width a fixed width and no constraint on the\n     * height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param width  the fixed width.\n     *\n     * @return The container size after arranging the contents.\n     */\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\n                LengthConstraintType.FIXED, 0.0, null,\n                LengthConstraintType.NONE);\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2, c1);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\n                new Range(0.0, width), LengthConstraintType.RANGE,\n                0.0, null, LengthConstraintType.NONE);\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, c2);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        if (this.rightBlock != null) {\n            double maxW = Math.max(width - w[2], 0.0);\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(Math.min(w[2], maxW), maxW),\n                    LengthConstraintType.RANGE, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.rightBlock.arrange(g2, c3);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.centerBlock.arrange(g2, c4);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\n    }\n\n    /**\n     * Performs an arrangement with range constraints on both the vertical\n     * and horizontal sides.\n     *\n     * @param container  the container.\n     * @param widthRange  the allowable range for the container width.\n     * @param heightRange  the allowable range for the container height.\n     * @param g2  the graphics device.\n     *\n     * @return The container size.\n     */\n    protected Size2D arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(widthRange,\n                    heightRange);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Range heightRange2 = Range.shift(heightRange, -h[0], false);\n            RectangleConstraint c2 = new RectangleConstraint(widthRange,\n                    heightRange2);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(widthRange,\n                    heightRange3);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        Range widthRange2 = Range.shift(widthRange, -w[2], false);\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(widthRange2,\n                    heightRange3);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\n        if (this.centerBlock != null) {\n            RectangleConstraint c5 = new RectangleConstraint(widthRange3,\n                    heightRange3);\n            // TODO:  the width and height ranges should be reduced by the\n            // height required for the top and bottom, and the width required\n            // by the left and right\n            Size2D size = this.centerBlock.arrange(g2, c5);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], h[3]));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], height - h[0] - h[1]));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n\n    /**\n     * Clears the layout.\n     */\n    public void clear() {\n        this.centerBlock = null;\n        this.topBlock = null;\n        this.bottomBlock = null;\n        this.leftBlock = null;\n        this.rightBlock = null;\n    }\n\n    /**\n     * Tests this arrangement for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof BorderArrangement)) {\n            return false;\n        }\n        BorderArrangement that = (BorderArrangement) obj;\n        if (!ObjectUtilities.equal(this.topBlock, that.topBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.bottomBlock, that.bottomBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.leftBlock, that.leftBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rightBlock, that.rightBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.centerBlock, that.centerBlock)) {\n            return false;\n        }\n        return true;\n    }\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ----------------------\n * BorderArrangement.java\n * ----------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes:\n * --------\n * 22-Oct-2004 : Version 1 (DG);\n * 08-Feb-2005 : Updated for changes in RectangleConstraint (DG);\n * 24-Feb-2005 : Improved arrangeRR() method (DG);\n * 03-May-2005 : Implemented Serializable and added equals() method (DG);\n * 13-May-2005 : Fixed bugs in the arrange() method (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 08-Apr-2008 : Fixed bug in arrangeFF() method where width is too small for\n *               left and right blocks (DG);\n *\n */\n\npackage org.jfree.chart.block;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.Serializable;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.Size2D;\nimport org.jfree.data.Range;\n\n/**\n * An arrangement manager that lays out blocks in a similar way to\n * Swing's BorderLayout class.\n */\npublic class BorderArrangement implements Arrangement, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 506071142274883745L;\n\n    /** The block (if any) at the center of the layout. */\n    private Block centerBlock;\n\n    /** The block (if any) at the top of the layout. */\n    private Block topBlock;\n\n    /** The block (if any) at the bottom of the layout. */\n    private Block bottomBlock;\n\n    /** The block (if any) at the left of the layout. */\n    private Block leftBlock;\n\n    /** The block (if any) at the right of the layout. */\n    private Block rightBlock;\n\n    /**\n     * Creates a new instance.\n     */\n    public BorderArrangement() {\n    }\n\n    /**\n     * Adds a block to the arrangement manager at the specified edge.\n     *\n     * @param block  the block (<code>null</code> permitted).\n     * @param key  the edge (an instance of {@link RectangleEdge}) or\n     *             <code>null</code> for the center block.\n     */\n    public void add(Block block, Object key) {\n\n        if (key == null) {\n            this.centerBlock = block;\n        }\n        else {\n            RectangleEdge edge = (RectangleEdge) key;\n            if (edge == RectangleEdge.TOP) {\n                this.topBlock = block;\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                this.bottomBlock = block;\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                this.leftBlock = block;\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                this.rightBlock = block;\n            }\n        }\n    }\n\n    /**\n     * Arranges the items in the specified container, subject to the given\n     * constraint.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The block size.\n     */\n    public Size2D arrange(BlockContainer container,\n                          Graphics2D g2,\n                          RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint\n                = container.toContentConstraint(constraint);\n        Size2D contentSize = null;\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeNN(container, g2);\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                contentSize = arrangeFF(container, g2, constraint);\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeFR(container, g2, constraint);\n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\n                        constraint.getHeightRange(), g2);\n            }\n        }\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\n                container.calculateTotalHeight(contentSize.getHeight()));\n    }\n\n    /**\n     * Performs an arrangement without constraints.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n            w[2] = size.width;\n            h[2] = size.height;\n       }\n        if (this.rightBlock != null) {\n            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            Size2D size = this.centerBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n        double height = h[0] + h[1] + centerHeight;\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    centerHeight));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], centerHeight));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], centerHeight));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Performs an arrangement with a fixed width and a range for the height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }\n\n    /**\n     * Arranges the container width a fixed width and no constraint on the\n     * height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param width  the fixed width.\n     *\n     * @return The container size after arranging the contents.\n     */\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\n                LengthConstraintType.FIXED, 0.0, null,\n                LengthConstraintType.NONE);\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2, c1);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\n                new Range(0.0, width), LengthConstraintType.RANGE,\n                0.0, null, LengthConstraintType.NONE);\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, c2);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        if (this.rightBlock != null) {\n            double maxW = Math.max(width - w[2], 0.0);\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(Math.min(w[2], maxW), maxW),\n                    LengthConstraintType.RANGE, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.rightBlock.arrange(g2, c3);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.centerBlock.arrange(g2, c4);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\n    }\n\n    /**\n     * Performs an arrangement with range constraints on both the vertical\n     * and horizontal sides.\n     *\n     * @param container  the container.\n     * @param widthRange  the allowable range for the container width.\n     * @param heightRange  the allowable range for the container height.\n     * @param g2  the graphics device.\n     *\n     * @return The container size.\n     */\n    protected Size2D arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(widthRange,\n                    heightRange);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Range heightRange2 = Range.shift(heightRange, -h[0], false);\n            RectangleConstraint c2 = new RectangleConstraint(widthRange,\n                    heightRange2);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(widthRange,\n                    heightRange3);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        Range widthRange2 = Range.shift(widthRange, -w[2], false);\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(widthRange2,\n                    heightRange3);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\n        if (this.centerBlock != null) {\n            RectangleConstraint c5 = new RectangleConstraint(widthRange3,\n                    heightRange3);\n            // TODO:  the width and height ranges should be reduced by the\n            // height required for the top and bottom, and the width required\n            // by the left and right\n            Size2D size = this.centerBlock.arrange(g2, c5);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], h[3]));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], height - h[0] - h[1]));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n\n    /**\n     * Clears the layout.\n     */\n    public void clear() {\n        this.centerBlock = null;\n        this.topBlock = null;\n        this.bottomBlock = null;\n        this.leftBlock = null;\n        this.rightBlock = null;\n    }\n\n    /**\n     * Tests this arrangement for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof BorderArrangement)) {\n            return false;\n        }\n        BorderArrangement that = (BorderArrangement) obj;\n        if (!ObjectUtilities.equal(this.topBlock, that.topBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.bottomBlock, that.bottomBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.leftBlock, that.leftBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rightBlock, that.rightBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.centerBlock, that.centerBlock)) {\n            return false;\n        }\n        return true;\n    }\n}\n"}]}
{"project": "Chart", "bug_id": 14, "classes_modified": [{"class_name": "org.jfree.chart.plot.CategoryPlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               annotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 14-Nov-2007 : Added missing event notifications (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(Marker)\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain \n     * axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeDomainMarker(Marker, Layer)\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    /**\n     * Adds a marker for display by a particular renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeDomainMarker(int, Marker, Layer, boolean)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeRangeMarker(Marker)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * \n     * @see #removeRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker)\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     * \n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation, \n    \t\tboolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.7\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.7\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               annotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 14-Nov-2007 : Added missing event notifications (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(Marker)\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain \n     * axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeDomainMarker(Marker, Layer)\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    /**\n     * Adds a marker for display by a particular renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeDomainMarker(int, Marker, Layer, boolean)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeRangeMarker(Marker)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * \n     * @see #removeRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker)\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     * \n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation, \n    \t\tboolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.7\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.7\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n"}, {"class_name": "org.jfree.chart.plot.XYPlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -----------\n * XYPlot.java\n * -----------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Craig MacFarlane;\n *                   Mark Watson (www.markwatson.com);\n *                   Jonathan Nash;\n *                   Gideon Krause;\n *                   Klaus Rheinwald;\n *                   Xavier Poinsard;\n *                   Richard Atkinson;\n *                   Arnaud Lelievre;\n *                   Nicolas Brodu;\n *                   Eduardo Ramalho;\n *                   Sergei Ivanov;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header and fixed DOS encoding problem (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Removed the code for drawing the visual representation of each\n *               data point into a separate class StandardXYItemRenderer.\n *               This will make it easier to add variations to the way the\n *               charts are drawn.  Based on code contributed by Mark\n *               Watson (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 20-Nov-2001 : Fixed clipping bug that shows up when chart is displayed\n *               inside JScrollPane (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clauses from constructor (DG);\n * 13-Dec-2001 : Added skeleton code for tooltips.  Added new constructor. (DG);\n * 16-Jan-2002 : Renamed the tooltips class (DG);\n * 22-Jan-2002 : Added DrawInfo class, incorporating tooltips and crosshairs.\n *               Crosshairs based on code by Jonathan Nash (DG);\n * 05-Feb-2002 : Added alpha-transparency setting based on code by Sylvain\n *               Vieujot (DG);\n * 26-Feb-2002 : Updated getMinimumXXX() and getMaximumXXX() methods to handle\n *               special case when chart is null (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 28-Mar-2002 : The plot now registers with the renderer as a property change\n *               listener.  Also added a new constructor (DG);\n * 09-Apr-2002 : Removed the transRangeZero from the renderer.drawItem()\n *               method.  Moved the tooltip generator into the renderer (DG);\n * 23-Apr-2002 : Fixed bug in methods for drawing horizontal and vertical\n *               lines (DG);\n * 13-May-2002 : Small change to the draw() method so that it works for\n *               OverlaidXYPlot also (DG);\n * 25-Jun-2002 : Removed redundant import (DG);\n * 20-Aug-2002 : Renamed getItemRenderer() --> getRenderer(), and\n *               setXYItemRenderer() --> setRenderer() (DG);\n * 28-Aug-2002 : Added mechanism for (optional) plot annotations (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 09-Jan-2003 : Further additions to the grid settings, plus integrated plot\n *               border bug fix contributed by Gideon Krause (DG);\n * 22-Jan-2003 : Removed monolithic constructor (DG);\n * 04-Mar-2003 : Added 'no data' message, see bug report 691634.  Added\n *               secondary range markers using code contributed by Klaus\n *               Rheinwald (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Apr-2003 : Added setDomainAxisLocation() method (DG);\n * 30-Apr-2003 : Moved annotation drawing into a separate method (DG);\n * 01-May-2003 : Added multi-pass mechanism for renderers (DG);\n * 02-May-2003 : Changed axis locations from int to AxisLocation (DG);\n * 15-May-2003 : Added an orientation attribute (DG);\n * 02-Jun-2003 : Removed range axis compatibility test (DG);\n * 05-Jun-2003 : Added domain and range grid bands (sponsored by Focus Computer\n *               Services Ltd) (DG);\n * 26-Jun-2003 : Fixed bug (757303) in getDataRange() method (DG);\n * 02-Jul-2003 : Added patch from bug report 698646 (secondary axes for\n *               overlaid plots) (DG);\n * 23-Jul-2003 : Added support for multiple secondary datasets, axes and\n *               renderers (DG);\n * 27-Jul-2003 : Added support for stacked XY area charts (RA);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug where change to secondary datasets didn't generate\n *               change event (797466) (DG)\n * 08-Sep-2003 : Added internationalization via use of properties\n *               resourceBundle (RFE 690236) (AL);\n * 08-Sep-2003 : Changed ValueAxis API (DG);\n * 08-Sep-2003 : Fixes for serialization (NB);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 17-Sep-2003 : Fixed zooming to include secondary domain axes (DG);\n * 18-Sep-2003 : Added getSecondaryDomainAxisCount() and\n *               getSecondaryRangeAxisCount() methods suggested by Eduardo\n *               Ramalho (RFE 808548) (DG);\n * 23-Sep-2003 : Split domain and range markers into foreground and\n *               background (DG);\n * 06-Oct-2003 : Fixed bug in clearDomainMarkers() and clearRangeMarkers()\n *               methods.  Fixed bug (815876) in addSecondaryRangeMarker()\n *               method.  Added new addSecondaryDomainMarker methods (see bug\n *               id 815869) (DG);\n * 10-Nov-2003 : Added getSecondaryDomain/RangeAxisMappedToDataset() methods\n *               requested by Eduardo Ramalho (DG);\n * 24-Nov-2003 : Removed unnecessary notification when updating axis anchor\n *               values (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);\n * 12-Mar-2004 : Fixed bug where primary renderer is always used to determine\n *               range type (DG);\n * 22-Mar-2004 : Fixed cloning bug (DG);\n * 23-Mar-2004 : Fixed more cloning bugs (DG);\n * 07-Apr-2004 : Fixed problem with axis range when the secondary renderer is\n *               stacked, see this post in the forum:\n *               http://www.jfree.org/phpBB2/viewtopic.php?t=8204 (DG);\n * 07-Apr-2004 : Added get/setDatasetRenderingOrder() methods (DG);\n * 26-Apr-2004 : Added option to fill quadrant areas in the background of the\n *               plot (DG);\n * 27-Apr-2004 : Removed major distinction between primary and secondary\n *               datasets, renderers and axes (DG);\n * 30-Apr-2004 : Modified to make use of the new getRangeExtent() method in the\n *               renderer interface (DG);\n * 13-May-2004 : Added optional fixedLegendItems attribute (DG);\n * 19-May-2004 : Added indexOf() method (DG);\n * 03-Jun-2004 : Fixed zooming bug (DG);\n * 18-Aug-2004 : Added removedAnnotation() method (by tkram01) (DG);\n * 05-Oct-2004 : Modified storage type for dataset-to-axis maps (DG);\n * 06-Oct-2004 : Modified getDataRange() method to use renderer to determine\n *               the x-value range (now matches behaviour for y-values).  Added\n *               getDomainAxisIndex() method (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 25-Nov-2004 : Small update to clone() implementation (DG);\n * 22-Feb-2005 : Changed axis offsets from Spacer --> RectangleInsets (DG);\n * 24-Feb-2005 : Added indexOf(XYItemRenderer) method (DG);\n * 21-Mar-2005 : Register plot as change listener in setRenderer() method (DG);\n * 21-Apr-2005 : Added get/setSeriesRenderingOrder() methods (ET);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 04-May-2005 : Fixed serialization of domain and range markers (DG);\n * 05-May-2005 : Removed unused draw() method (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 01-Jun-2005 : Added clearDomainMarkers(int) method to match \n *               clearRangeMarkers(int) (DG);\n * 06-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 06-Jul-2005 : Fixed crosshair bug (id = 1233336) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 26-Jan-2006 : Added getAnnotations() method (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 13-Oct-2006 : Fixed initialisation of CrosshairState - see bug report \n *               1565168 (DG);\n * 22-Nov-2006 : Fixed equals() and cloning() for quadrant attributes, plus \n *               API doc updates (DG);\n * 29-Nov-2006 : Added argument checks (DG);\n * 15-Jan-2007 : Fixed bug in drawRangeMarkers() (DG);\n * 07-Feb-2007 : Fixed bug 1654215, renderer with no dataset (DG);\n * 26-Feb-2007 : Added missing setDomainAxisLocation() and \n *               setRangeAxisLocation() methods (DG);\n * 02-Mar-2007 : Fix for crosshair positioning with horizontal orientation\n *               (see patch 1671648 by Sergei Ivanov) (DG);\n * 13-Mar-2007 : Added null argument checks for crosshair attributes (DG);\n * 23-Mar-2007 : Added domain zero base line facility (DG);\n * 04-May-2007 : Render only visible data items if possible (DG);\n * 24-May-2007 : Fixed bug in render method for an empty series (DG);\n * 07-Jun-2007 : Modified drawBackground() to pass orientation to \n *               fillBackground() for handling GradientPaint (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Jun-2007 : Updated drawDomainGridlines() method for renamed method in\n *               XYItemRenderer interface.\n * 24-Sep-2007 : Added new zoom methods (DG);\n * 26-Sep-2007 : Include index value in IllegalArgumentExceptions (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 12-Nov-2007 : Fixed bug in equals() method for domain and range tick\n *               band paint attributes (DG);\n * 27-Nov-2007 : Added new setFixedDomain/RangeAxisSpace() methods (DG);\n * 04-Jan-2008 : Fix for quadrant painting error - see patch 1849564 (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.XYDataset;\n\n/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * <P>\n * <code>XYPlot</code> makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * <p>\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n */\npublic class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n        RendererChangeListener, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7044148245716569264L;\n    \n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, \n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private ObjectList domainAxes;\n\n    /** The domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private ObjectList rangeAxes;\n\n    /** The range axis location. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /**\n     * Storage for keys that map datasets/renderers to domain axes.  If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToDomainAxisMap;\n\n    /**\n     * Storage for keys that map datasets/renderers to range axes. If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToRangeAxisMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            = new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     * \n     * @since 1.0.5\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /** \n     * The stroke used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /** \n     * The paint used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData = true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            = DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            = SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be <code>null</code>, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * <code>NullPointerException</code> may be thrown).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the renderer (<code>null</code> permitted).\n     */\n    public XYPlot(XYDataset dataset,\n                  ValueAxis domainAxis,\n                  ValueAxis rangeAxis,\n                  XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  // only relevant when this is a subplot\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxisMap = new TreeMap();\n        this.datasetToRangeAxisMap = new TreeMap();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations = new java.util.ArrayList();\n\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not allowed).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly <code>null</code>).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or <code>null</code>.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n    \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot's orientation).\n     *\n     * @return The edge.\n     * \n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes. \n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for index\n     *     0).\n     * \n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }        \n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * <code>null</code>, then the method will return the parent plot's range \n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     * \n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     * \n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    } \n    \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     * \n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> permitted).\n     * \n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }   \n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or <code>-1</code> if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer for a dataset, or <code>null</code>.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\n     * is set to <code>null</code>, no data will be displayed.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer, \n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers (<code>null</code> not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never <code>null</code>).\n     * \n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  The code first\n     * determines the index of the dataset, then checks if there is a\n     * renderer with the same index (if not, the method returns renderer(0).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The renderer (possibly <code>null</code>).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the domain gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <p>\n     * If you set this to <code>null</code>, no grid lines will be drawn.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>stroke</code> is \n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>paint</code> is \n     *     <code>null</code>.\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @since 1.0.5\n     * \n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     * \n     * @since 1.0.5\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never <code>null</code>).\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin (<code>null</code> not permitted).\n     * \n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n    \taddDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\t\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     * \n     * @since 1.0.1\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     (<code>null</code> permitted).\n     * @param info  collects chart drawing information (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n        \n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);            \n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \n                            getDomainAxisEdge());\n                } \n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \n                            getRangeAxisEdge());\n                } \n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);                \n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            } \n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmin)\n                    );\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymax, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymax, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymin, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymin, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param dataArea  the data area (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * <P>\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\n     * <code>null</code>.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        (<code>null</code> permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2,\n                          Rectangle2D dataArea,\n                          int index,\n                          PlotRenderingInfo info,\n                          CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(\n                new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex\n            = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(),\n                        dataArea, tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot's primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                while (iterator.hasNext()) {\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if (tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), \n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     * \n     * @since 1.0.5\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, \n                    this.domainZeroBaselinePaint, \n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, \n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }    \n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     * \n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     * \n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n    \n    /**\n     * Draws a domain crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis da = getDomainAxis();\n            if (da != null) {\n                double hvalue = da.java2DToValue(x, info.getDataArea(), \n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis ra = getRangeAxis();\n            if (ra != null) {\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), \n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible \n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *     permitted).\n     *     \n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) { \n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each domain axis\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX, \n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     * \n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);    \n    }\n    \n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is <code>null</code>, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * <code>null</code> if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot's renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, \n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, \n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, \n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, \n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, \n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, \n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint, \n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, \n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i], \n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList) \n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxisMap = new TreeMap();\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\n        clone.datasetToRangeAxisMap = new TreeMap();\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and \n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n    \n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -----------\n * XYPlot.java\n * -----------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Craig MacFarlane;\n *                   Mark Watson (www.markwatson.com);\n *                   Jonathan Nash;\n *                   Gideon Krause;\n *                   Klaus Rheinwald;\n *                   Xavier Poinsard;\n *                   Richard Atkinson;\n *                   Arnaud Lelievre;\n *                   Nicolas Brodu;\n *                   Eduardo Ramalho;\n *                   Sergei Ivanov;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header and fixed DOS encoding problem (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Removed the code for drawing the visual representation of each\n *               data point into a separate class StandardXYItemRenderer.\n *               This will make it easier to add variations to the way the\n *               charts are drawn.  Based on code contributed by Mark\n *               Watson (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 20-Nov-2001 : Fixed clipping bug that shows up when chart is displayed\n *               inside JScrollPane (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clauses from constructor (DG);\n * 13-Dec-2001 : Added skeleton code for tooltips.  Added new constructor. (DG);\n * 16-Jan-2002 : Renamed the tooltips class (DG);\n * 22-Jan-2002 : Added DrawInfo class, incorporating tooltips and crosshairs.\n *               Crosshairs based on code by Jonathan Nash (DG);\n * 05-Feb-2002 : Added alpha-transparency setting based on code by Sylvain\n *               Vieujot (DG);\n * 26-Feb-2002 : Updated getMinimumXXX() and getMaximumXXX() methods to handle\n *               special case when chart is null (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 28-Mar-2002 : The plot now registers with the renderer as a property change\n *               listener.  Also added a new constructor (DG);\n * 09-Apr-2002 : Removed the transRangeZero from the renderer.drawItem()\n *               method.  Moved the tooltip generator into the renderer (DG);\n * 23-Apr-2002 : Fixed bug in methods for drawing horizontal and vertical\n *               lines (DG);\n * 13-May-2002 : Small change to the draw() method so that it works for\n *               OverlaidXYPlot also (DG);\n * 25-Jun-2002 : Removed redundant import (DG);\n * 20-Aug-2002 : Renamed getItemRenderer() --> getRenderer(), and\n *               setXYItemRenderer() --> setRenderer() (DG);\n * 28-Aug-2002 : Added mechanism for (optional) plot annotations (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 09-Jan-2003 : Further additions to the grid settings, plus integrated plot\n *               border bug fix contributed by Gideon Krause (DG);\n * 22-Jan-2003 : Removed monolithic constructor (DG);\n * 04-Mar-2003 : Added 'no data' message, see bug report 691634.  Added\n *               secondary range markers using code contributed by Klaus\n *               Rheinwald (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Apr-2003 : Added setDomainAxisLocation() method (DG);\n * 30-Apr-2003 : Moved annotation drawing into a separate method (DG);\n * 01-May-2003 : Added multi-pass mechanism for renderers (DG);\n * 02-May-2003 : Changed axis locations from int to AxisLocation (DG);\n * 15-May-2003 : Added an orientation attribute (DG);\n * 02-Jun-2003 : Removed range axis compatibility test (DG);\n * 05-Jun-2003 : Added domain and range grid bands (sponsored by Focus Computer\n *               Services Ltd) (DG);\n * 26-Jun-2003 : Fixed bug (757303) in getDataRange() method (DG);\n * 02-Jul-2003 : Added patch from bug report 698646 (secondary axes for\n *               overlaid plots) (DG);\n * 23-Jul-2003 : Added support for multiple secondary datasets, axes and\n *               renderers (DG);\n * 27-Jul-2003 : Added support for stacked XY area charts (RA);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug where change to secondary datasets didn't generate\n *               change event (797466) (DG)\n * 08-Sep-2003 : Added internationalization via use of properties\n *               resourceBundle (RFE 690236) (AL);\n * 08-Sep-2003 : Changed ValueAxis API (DG);\n * 08-Sep-2003 : Fixes for serialization (NB);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 17-Sep-2003 : Fixed zooming to include secondary domain axes (DG);\n * 18-Sep-2003 : Added getSecondaryDomainAxisCount() and\n *               getSecondaryRangeAxisCount() methods suggested by Eduardo\n *               Ramalho (RFE 808548) (DG);\n * 23-Sep-2003 : Split domain and range markers into foreground and\n *               background (DG);\n * 06-Oct-2003 : Fixed bug in clearDomainMarkers() and clearRangeMarkers()\n *               methods.  Fixed bug (815876) in addSecondaryRangeMarker()\n *               method.  Added new addSecondaryDomainMarker methods (see bug\n *               id 815869) (DG);\n * 10-Nov-2003 : Added getSecondaryDomain/RangeAxisMappedToDataset() methods\n *               requested by Eduardo Ramalho (DG);\n * 24-Nov-2003 : Removed unnecessary notification when updating axis anchor\n *               values (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);\n * 12-Mar-2004 : Fixed bug where primary renderer is always used to determine\n *               range type (DG);\n * 22-Mar-2004 : Fixed cloning bug (DG);\n * 23-Mar-2004 : Fixed more cloning bugs (DG);\n * 07-Apr-2004 : Fixed problem with axis range when the secondary renderer is\n *               stacked, see this post in the forum:\n *               http://www.jfree.org/phpBB2/viewtopic.php?t=8204 (DG);\n * 07-Apr-2004 : Added get/setDatasetRenderingOrder() methods (DG);\n * 26-Apr-2004 : Added option to fill quadrant areas in the background of the\n *               plot (DG);\n * 27-Apr-2004 : Removed major distinction between primary and secondary\n *               datasets, renderers and axes (DG);\n * 30-Apr-2004 : Modified to make use of the new getRangeExtent() method in the\n *               renderer interface (DG);\n * 13-May-2004 : Added optional fixedLegendItems attribute (DG);\n * 19-May-2004 : Added indexOf() method (DG);\n * 03-Jun-2004 : Fixed zooming bug (DG);\n * 18-Aug-2004 : Added removedAnnotation() method (by tkram01) (DG);\n * 05-Oct-2004 : Modified storage type for dataset-to-axis maps (DG);\n * 06-Oct-2004 : Modified getDataRange() method to use renderer to determine\n *               the x-value range (now matches behaviour for y-values).  Added\n *               getDomainAxisIndex() method (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 25-Nov-2004 : Small update to clone() implementation (DG);\n * 22-Feb-2005 : Changed axis offsets from Spacer --> RectangleInsets (DG);\n * 24-Feb-2005 : Added indexOf(XYItemRenderer) method (DG);\n * 21-Mar-2005 : Register plot as change listener in setRenderer() method (DG);\n * 21-Apr-2005 : Added get/setSeriesRenderingOrder() methods (ET);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 04-May-2005 : Fixed serialization of domain and range markers (DG);\n * 05-May-2005 : Removed unused draw() method (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 01-Jun-2005 : Added clearDomainMarkers(int) method to match \n *               clearRangeMarkers(int) (DG);\n * 06-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 06-Jul-2005 : Fixed crosshair bug (id = 1233336) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 26-Jan-2006 : Added getAnnotations() method (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 13-Oct-2006 : Fixed initialisation of CrosshairState - see bug report \n *               1565168 (DG);\n * 22-Nov-2006 : Fixed equals() and cloning() for quadrant attributes, plus \n *               API doc updates (DG);\n * 29-Nov-2006 : Added argument checks (DG);\n * 15-Jan-2007 : Fixed bug in drawRangeMarkers() (DG);\n * 07-Feb-2007 : Fixed bug 1654215, renderer with no dataset (DG);\n * 26-Feb-2007 : Added missing setDomainAxisLocation() and \n *               setRangeAxisLocation() methods (DG);\n * 02-Mar-2007 : Fix for crosshair positioning with horizontal orientation\n *               (see patch 1671648 by Sergei Ivanov) (DG);\n * 13-Mar-2007 : Added null argument checks for crosshair attributes (DG);\n * 23-Mar-2007 : Added domain zero base line facility (DG);\n * 04-May-2007 : Render only visible data items if possible (DG);\n * 24-May-2007 : Fixed bug in render method for an empty series (DG);\n * 07-Jun-2007 : Modified drawBackground() to pass orientation to \n *               fillBackground() for handling GradientPaint (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Jun-2007 : Updated drawDomainGridlines() method for renamed method in\n *               XYItemRenderer interface.\n * 24-Sep-2007 : Added new zoom methods (DG);\n * 26-Sep-2007 : Include index value in IllegalArgumentExceptions (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 12-Nov-2007 : Fixed bug in equals() method for domain and range tick\n *               band paint attributes (DG);\n * 27-Nov-2007 : Added new setFixedDomain/RangeAxisSpace() methods (DG);\n * 04-Jan-2008 : Fix for quadrant painting error - see patch 1849564 (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.XYDataset;\n\n/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * <P>\n * <code>XYPlot</code> makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * <p>\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n */\npublic class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n        RendererChangeListener, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7044148245716569264L;\n    \n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, \n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private ObjectList domainAxes;\n\n    /** The domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private ObjectList rangeAxes;\n\n    /** The range axis location. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /**\n     * Storage for keys that map datasets/renderers to domain axes.  If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToDomainAxisMap;\n\n    /**\n     * Storage for keys that map datasets/renderers to range axes. If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToRangeAxisMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            = new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     * \n     * @since 1.0.5\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /** \n     * The stroke used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /** \n     * The paint used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData = true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            = DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            = SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be <code>null</code>, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * <code>NullPointerException</code> may be thrown).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the renderer (<code>null</code> permitted).\n     */\n    public XYPlot(XYDataset dataset,\n                  ValueAxis domainAxis,\n                  ValueAxis rangeAxis,\n                  XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  // only relevant when this is a subplot\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxisMap = new TreeMap();\n        this.datasetToRangeAxisMap = new TreeMap();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations = new java.util.ArrayList();\n\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not allowed).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly <code>null</code>).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or <code>null</code>.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n    \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot's orientation).\n     *\n     * @return The edge.\n     * \n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes. \n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for index\n     *     0).\n     * \n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }        \n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * <code>null</code>, then the method will return the parent plot's range \n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     * \n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     * \n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    } \n    \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     * \n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> permitted).\n     * \n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }   \n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or <code>-1</code> if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer for a dataset, or <code>null</code>.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\n     * is set to <code>null</code>, no data will be displayed.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer, \n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers (<code>null</code> not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never <code>null</code>).\n     * \n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  The code first\n     * determines the index of the dataset, then checks if there is a\n     * renderer with the same index (if not, the method returns renderer(0).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The renderer (possibly <code>null</code>).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the domain gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <p>\n     * If you set this to <code>null</code>, no grid lines will be drawn.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>stroke</code> is \n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>paint</code> is \n     *     <code>null</code>.\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @since 1.0.5\n     * \n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     * \n     * @since 1.0.5\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never <code>null</code>).\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin (<code>null</code> not permitted).\n     * \n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n    \taddDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\t\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     * \n     * @since 1.0.1\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     (<code>null</code> permitted).\n     * @param info  collects chart drawing information (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n        \n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);            \n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \n                            getDomainAxisEdge());\n                } \n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \n                            getRangeAxisEdge());\n                } \n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);                \n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            } \n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmin)\n                    );\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymax, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymax, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymin, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymin, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param dataArea  the data area (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * <P>\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\n     * <code>null</code>.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        (<code>null</code> permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2,\n                          Rectangle2D dataArea,\n                          int index,\n                          PlotRenderingInfo info,\n                          CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(\n                new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex\n            = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(),\n                        dataArea, tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot's primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                while (iterator.hasNext()) {\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if (tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), \n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     * \n     * @since 1.0.5\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, \n                    this.domainZeroBaselinePaint, \n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, \n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }    \n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     * \n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     * \n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n    \n    /**\n     * Draws a domain crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis da = getDomainAxis();\n            if (da != null) {\n                double hvalue = da.java2DToValue(x, info.getDataArea(), \n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis ra = getRangeAxis();\n            if (ra != null) {\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), \n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible \n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *     permitted).\n     *     \n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) { \n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each domain axis\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX, \n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     * \n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);    \n    }\n    \n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is <code>null</code>, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * <code>null</code> if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot's renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, \n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, \n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, \n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, \n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, \n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, \n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint, \n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, \n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i], \n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList) \n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxisMap = new TreeMap();\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\n        clone.datasetToRangeAxisMap = new TreeMap();\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and \n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n    \n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 15, "classes_modified": [{"class_name": "org.jfree.chart.plot.PiePlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ------------\n * PiePlot.java\n * ------------\n * (C) Copyright 2000-2008, by Andrzej Porebski and Contributors.\n *\n * Original Author:  Andrzej Porebski;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Martin Cordova (percentages in labels);\n *                   Richard Atkinson (URL support for image maps);\n *                   Christian W. Zuckschwerdt;\n *                   Arnaud Lelievre;\n *                   Andreas Schroeder (very minor);\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Moved series paint and stroke methods from JFreeChart.java to \n *               Plot.java (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 13-Nov-2001 : Modified plot subclasses so that null axes are possible for \n *               pie plot (DG);\n * 17-Nov-2001 : Added PieDataset interface and amended this class accordingly,\n *               and completed removal of BlankAxis class as it is no longer \n *               required (DG);\n * 19-Nov-2001 : Changed 'drawCircle' property to 'circular' property (DG);\n * 21-Nov-2001 : Added options for exploding pie sections and filled out range \n *               of properties (DG);\n *               Added option for percentages in chart labels, based on code\n *               by Martin Cordova (DG);\n * 30-Nov-2001 : Changed default font from \"Arial\" --> \"SansSerif\" (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clause in constructor (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Renamed tooltips class (DG);\n * 22-Jan-2002 : Fixed bug correlating legend labels with pie data (DG);\n * 05-Feb-2002 : Added alpha-transparency to plot class, and updated \n *               constructors accordingly (DG);\n * 06-Feb-2002 : Added optional background image and alpha-transparency to Plot\n *               and subclasses.  Clipped drawing within plot area (DG);\n * 26-Mar-2002 : Added an empty zoom method (DG);\n * 18-Apr-2002 : PieDataset is no longer sorted (oldman);\n * 23-Apr-2002 : Moved dataset from JFreeChart to Plot.  Added \n *               getLegendItemLabels() method (DG);\n * 19-Jun-2002 : Added attributes to control starting angle and direction \n *               (default is now clockwise) (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 02-Jul-2002 : Fixed sign of percentage bug introduced in 0.9.2 (DG);\n * 16-Jul-2002 : Added check for null dataset in getLegendItemLabels() (DG);\n * 30-Jul-2002 : Moved summation code to DatasetUtilities (DG);\n * 05-Aug-2002 : Added URL support for image maps - new member variable for\n *               urlGenerator, modified constructor and minor change to the \n *               draw method (RA);\n * 18-Sep-2002 : Modified the percent label creation and added setters for the\n *               formatters (AS);\n * 24-Sep-2002 : Added getLegendItems() method (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 09-Oct-2002 : Added check for null entity collection (DG);\n * 30-Oct-2002 : Changed PieDataset interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 02-Jan-2003 : Fixed \"no data\" message (DG);\n * 23-Jan-2003 : Modified to extract data from rows OR columns in \n *               CategoryDataset (DG);\n * 14-Feb-2003 : Fixed label drawing so that foreground alpha does not apply \n *               (bug id 685536) (DG);\n * 07-Mar-2003 : Modified to pass pieIndex on to PieSectionEntity and tooltip \n *               and URL generators (DG);\n * 21-Mar-2003 : Added a minimum angle for drawing arcs \n *               (see bug id 620031) (DG);\n * 24-Apr-2003 : Switched around PieDataset and KeyedValuesDataset (DG);\n * 02-Jun-2003 : Fixed bug 721733 (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 29-Aug-2003 : Fixed bug 796936 (null pointer on setOutlinePaint()) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 05-Nov-2003 : Fixed missing legend bug (DG);\n * 10-Nov-2003 : Re-added the DatasetChangeListener to constructors (CZ);\n * 29-Jan-2004 : Fixed clipping bug in draw() method (DG);\n * 11-Mar-2004 : Major overhaul to improve labelling (DG);\n * 31-Mar-2004 : Made an adjustment for the plot area when the label generator \n *               is null.  Fixed null pointer exception when the label \n *               generator returns null for a label (DG);\n * 06-Apr-2004 : Added getter, setter, serialization and draw support for \n *               labelBackgroundPaint (AS);\n * 08-Apr-2004 : Added flag to control whether null values are ignored or \n *               not (DG);\n * 15-Apr-2004 : Fixed some minor warnings from Eclipse (DG);\n * 26-Apr-2004 : Added attributes for label outline and shadow (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 04-Nov-2004 : Fixed null pointer exception with new LegendTitle class (DG);\n * 09-Nov-2004 : Added user definable legend item shape (DG);\n * 25-Nov-2004 : Added new legend label generator (DG);\n * 20-Apr-2005 : Added a tool tip generator for legend labels (DG);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 10-May-2005 : Added flag to control visibility of label linking lines, plus\n *               another flag to control the handling of zero values (DG);\n * 08-Jun-2005 : Fixed bug in getLegendItems() method (not respecting flags\n *               for ignoring null and zero values), and fixed equals() method \n *               to handle GradientPaint (DG);\n * 15-Jul-2005 : Added sectionOutlinesVisible attribute (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 09-Jan-2006 : Fixed bug 1400442, inconsistent treatment of null and zero\n *               values in dataset (DG);\n * 28-Feb-2006 : Fixed bug 1440415, bad distribution of pie section \n *               labels (DG);\n * 27-Sep-2006 : Initialised baseSectionPaint correctly, added lookup methods\n *               for section paint, outline paint and outline stroke (DG);\n * 27-Sep-2006 : Refactored paint and stroke methods to use keys rather than\n *               section indices (DG);\n * 03-Oct-2006 : Replaced call to JRE 1.5 method (DG);\n * 23-Nov-2006 : Added support for URLs for the legend items (DG);\n * 24-Nov-2006 : Cloning fixes (DG);\n * 17-Apr-2007 : Check for null label in legend items (DG);\n * 19-Apr-2007 : Deprecated override settings (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 14-Jun-2007 : Added label distributor attribute (DG);\n * 19-Jun-2007 : Removed deprecated code (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Jul-2007 : Added simple label option (DG);\n * 21-Nov-2007 : Fixed labelling bugs, added debug code, restored default\n *               white background (DG); \n * 19-Mar-2008 : Fixed IllegalArgumentException when drawing with null \n *               dataset (DG);\n *    \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.PaintMap;\nimport org.jfree.chart.StrokeMap;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.entity.PieSectionEntity;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.labels.PieSectionLabelGenerator;\nimport org.jfree.chart.labels.PieToolTipGenerator;\nimport org.jfree.chart.labels.StandardPieSectionLabelGenerator;\nimport org.jfree.chart.text.G2TextMeasurer;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextBlock;\nimport org.jfree.chart.text.TextBox;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.PieURLGenerator;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.Rotation;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.jfree.chart.util.UnitType;\nimport org.jfree.data.DefaultKeyedValues;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays data in the form of a pie chart, using data from any \n * class that implements the {@link PieDataset} interface.\n * <P>\n * Special notes:\n * <ol>\n * <li>the default starting point is 12 o'clock and the pie sections proceed\n * in a clockwise direction, but these settings can be changed;</li>\n * <li>negative values in the dataset are ignored;</li>\n * <li>there are utility methods for creating a {@link PieDataset} from a\n * {@link org.jfree.data.category.CategoryDataset};</li>\n * </ol>\n *\n * @see Plot\n * @see PieDataset\n */\npublic class PiePlot extends Plot implements Cloneable, Serializable {\n    \n    /** For serialization. */\n    private static final long serialVersionUID = -795612466005590431L;\n    \n    /** The default interior gap. */\n    public static final double DEFAULT_INTERIOR_GAP = 0.08;\n\n    /** The maximum interior gap (currently 40%). */\n    public static final double MAX_INTERIOR_GAP = 0.40;\n\n    /** The default starting angle for the pie chart. */\n    public static final double DEFAULT_START_ANGLE = 90.0;\n\n    /** The default section label font. */\n    public static final Font DEFAULT_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** The default section label paint. */\n    public static final Paint DEFAULT_LABEL_PAINT = Color.black;\n    \n    /** The default section label background paint. */\n    public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, \n            255, 192);\n\n    /** The default section label outline paint. */\n    public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black;\n    \n    /** The default section label outline stroke. */\n    public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke(\n            0.5f);\n    \n    /** The default section label shadow paint. */\n    public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151, \n            151, 128);\n    \n    /** The default minimum arc angle to draw. */\n    public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001;\n\n    /** The dataset for the pie chart. */\n    private PieDataset dataset;\n\n    /** The pie index (used by the {@link MultiplePiePlot} class). */\n    private int pieIndex;\n\n    /** \n     * The amount of space left around the outside of the pie plot, expressed \n     * as a percentage of the plot area width and height. \n     */\n    private double interiorGap;\n\n    /** Flag determining whether to draw an ellipse or a perfect circle. */\n    private boolean circular;\n\n    /** The starting angle. */\n    private double startAngle;\n\n    /** The direction for the pie segments. */\n    private Rotation direction;\n\n    /** The section paint map. */\n    private PaintMap sectionPaintMap;\n\n    /** The base section paint (fallback). */\n    private transient Paint baseSectionPaint;\n\n    /** \n     * A flag that controls whether or not an outline is drawn for each\n     * section in the plot.\n     */\n    private boolean sectionOutlinesVisible;\n\n    /** The section outline paint map. */\n    private PaintMap sectionOutlinePaintMap;\n\n    /** The base section outline paint (fallback). */\n    private transient Paint baseSectionOutlinePaint;\n\n    /** The section outline stroke map. */\n    private StrokeMap sectionOutlineStrokeMap;\n\n    /** The base section outline stroke (fallback). */\n    private transient Stroke baseSectionOutlineStroke;\n\n    /** The shadow paint. */\n    private transient Paint shadowPaint = Color.gray;\n\n    /** The x-offset for the shadow effect. */\n    private double shadowXOffset = 4.0f;\n    \n    /** The y-offset for the shadow effect. */\n    private double shadowYOffset = 4.0f;\n    \n    /** The percentage amount to explode each pie section. */\n    private Map explodePercentages;\n    \n    /** The section label generator. */\n    private PieSectionLabelGenerator labelGenerator;\n\n    /** The font used to display the section labels. */\n    private Font labelFont;\n\n    /** The color used to draw the section labels. */\n    private transient Paint labelPaint;\n    \n    /** \n     * The color used to draw the background of the section labels.  If this\n     * is <code>null</code>, the background is not filled.\n     */\n    private transient Paint labelBackgroundPaint;\n\n    /** \n     * The paint used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelOutlinePaint;\n    \n    /** \n     * The stroke used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Stroke labelOutlineStroke;\n    \n    /** \n     * The paint used to draw the shadow for the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelShadowPaint;\n    \n    /**\n     * A flag that controls whether simple or extended labels are used.\n     * \n     * @since 1.0.7\n     */\n    private boolean simpleLabels = true;\n    \n    /**\n     * The padding between the labels and the label outlines.  This is not\n     * allowed to be <code>null</code>.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets labelPadding;\n    \n    /**\n     * The simple label offset.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets simpleLabelOffset;\n    \n    /** The maximum label width as a percentage of the plot width. */\n    private double maximumLabelWidth = 0.14;\n    \n    /** \n     * The gap between the labels and the link corner, as a percentage of the \n     * plot width. \n     */\n    private double labelGap = 0.025;\n\n    /** A flag that controls whether or not the label links are drawn. */\n    private boolean labelLinksVisible;\n    \n    /** The link margin. */\n    private double labelLinkMargin = 0.025;\n    \n    /** The paint used for the label linking lines. */\n    private transient Paint labelLinkPaint = Color.black;\n    \n    /** The stroke used for the label linking lines. */\n    private transient Stroke labelLinkStroke = new BasicStroke(0.5f);\n    \n    /** \n     * The pie section label distributor.\n     * \n     * @since 1.0.6\n     */\n    private AbstractPieLabelDistributor labelDistributor;\n    \n    /** The tooltip generator. */\n    private PieToolTipGenerator toolTipGenerator;\n\n    /** The URL generator. */\n    private PieURLGenerator urlGenerator;\n    \n    /** The legend label generator. */\n    private PieSectionLabelGenerator legendLabelGenerator;\n    \n    /** A tool tip generator for the legend. */\n    private PieSectionLabelGenerator legendLabelToolTipGenerator;\n    \n    /** \n     * A URL generator for the legend items (optional).  \n     *\n     * @since 1.0.4. \n     */\n    private PieURLGenerator legendLabelURLGenerator;\n    \n    /** \n     * A flag that controls whether <code>null</code> values are ignored.  \n     */\n    private boolean ignoreNullValues;\n    \n    /**\n     * A flag that controls whether zero values are ignored.\n     */\n    private boolean ignoreZeroValues;\n\n    /** The legend item shape. */\n    private transient Shape legendItemShape;\n    \n    /**\n     * The smallest arc angle that will get drawn (this is to avoid a bug in \n     * various Java implementations that causes the JVM to crash).  See this \n     * link for details:\n     *\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707\n     *\n     * ...and this bug report in the Java Bug Parade:\n     *\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\n     */\n    private double minimumArcAngleToDraw;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources =\n            ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * interior of the plot region.  This is drawn as a lightGray rectangle \n     * showing the padding provided by the 'interiorGap' setting.\n     */\n    static final boolean DEBUG_DRAW_INTERIOR = false;\n    \n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * link area (in blue) and link ellipse (in yellow).  This controls where \n     * the label links have 'elbow' points.\n     */\n    static final boolean DEBUG_DRAW_LINK_AREA = false;\n    \n    /**\n     * This debug flag controls whether or not an outline is drawn showing\n     * the pie area (in green).\n     */\n    static final boolean DEBUG_DRAW_PIE_AREA = false;\n    \n    /**\n     * Creates a new plot.  The dataset is initially set to <code>null</code>.\n     */\n    public PiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a plot that will draw a pie chart for the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public PiePlot(PieDataset dataset) {\n        super();\n        this.dataset = dataset;\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        this.pieIndex = 0;\n        \n        this.interiorGap = DEFAULT_INTERIOR_GAP;\n        this.circular = true;\n        this.startAngle = DEFAULT_START_ANGLE;\n        this.direction = Rotation.CLOCKWISE;\n        this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;\n\n        this.sectionPaintMap = new PaintMap();\n        this.baseSectionPaint = Color.gray;\n\n        this.sectionOutlinesVisible = true;\n        this.sectionOutlinePaintMap = new PaintMap();\n        this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;\n\n        this.sectionOutlineStrokeMap = new StrokeMap();\n        this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        \n        this.explodePercentages = new TreeMap();\n\n        this.labelGenerator = new StandardPieSectionLabelGenerator();\n        this.labelFont = DEFAULT_LABEL_FONT;\n        this.labelPaint = DEFAULT_LABEL_PAINT;\n        this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;\n        this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;\n        this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;\n        this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;\n        this.labelLinksVisible = true;\n        this.labelDistributor = new PieLabelDistributor(0);\n        \n        this.simpleLabels = false;\n        this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, \n                0.18, 0.18, 0.18);\n        this.labelPadding = new RectangleInsets(2, 2, 2, 2);\n        \n        this.toolTipGenerator = null;\n        this.urlGenerator = null;\n        this.legendLabelGenerator = new StandardPieSectionLabelGenerator();\n        this.legendLabelToolTipGenerator = null;\n        this.legendLabelURLGenerator = null;\n        this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;\n        \n        this.ignoreNullValues = false;\n        this.ignoreZeroValues = false;\n    }\n\n    /**\n     * Returns the dataset.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(PieDataset)\n     */\n    public PieDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset and sends a {@link DatasetChangeEvent} to 'this'.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(PieDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of \n        // change listeners...\n        PieDataset existing = this.dataset;\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n    \n    /**\n     * Returns the pie index (this is used by the {@link MultiplePiePlot} class\n     * to track subplots).\n     * \n     * @return The pie index.\n     * \n     * @see #setPieIndex(int)\n     */\n    public int getPieIndex() {\n        return this.pieIndex;\n    }\n    \n    /**\n     * Sets the pie index (this is used by the {@link MultiplePiePlot} class to \n     * track subplots).\n     * \n     * @param index  the index.\n     * \n     * @see #getPieIndex()\n     */\n    public void setPieIndex(int index) {\n        this.pieIndex = index;\n    }\n    \n    /**\n     * Returns the start angle for the first pie section.  This is measured in \n     * degrees starting from 3 o'clock and measuring anti-clockwise.\n     *\n     * @return The start angle.\n     * \n     * @see #setStartAngle(double)\n     */\n    public double getStartAngle() {\n        return this.startAngle;\n    }\n\n    /**\n     * Sets the starting angle and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  The initial default value is 90 degrees, which \n     * corresponds to 12 o'clock.  A value of zero corresponds to 3 o'clock...\n     * this is the encoding used by Java's Arc2D class.\n     *\n     * @param angle  the angle (in degrees).\n     * \n     * @see #getStartAngle()\n     */\n    public void setStartAngle(double angle) {\n        this.startAngle = angle;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the direction in which the pie sections are drawn (clockwise or \n     * anti-clockwise).\n     *\n     * @return The direction (never <code>null</code>).\n     * \n     * @see #setDirection(Rotation)\n     */\n    public Rotation getDirection() {\n        return this.direction;\n    }\n\n    /**\n     * Sets the direction in which the pie sections are drawn and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param direction  the direction (<code>null</code> not permitted).\n     * \n     * @see #getDirection()\n     */\n    public void setDirection(Rotation direction) {\n        if (direction == null) {\n            throw new IllegalArgumentException(\"Null 'direction' argument.\");\n        }\n        this.direction = direction;\n        notifyListeners(new PlotChangeEvent(this));\n\n    }\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available \n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     * \n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  This controls the space between the edges of the \n     * pie plot and the plot area itself (the region where the section labels \n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     * \n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     * \n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));   \n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At \n     * present, this only affects whether or not the key is presented in the \n     * legend.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether zero values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether zero values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This \n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key) {\n        return lookupSectionPaint(key, false);        \n    }\n    \n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code> \n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but \n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier \n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {\n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a key for the specified section.  If there is no such section \n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes \n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).  \n     * \n     * @param section  the section index.\n     * \n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }\n    \n    /**\n     * Returns the paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionPaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionPaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionPaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionPaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionPaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionPaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * defined, which is rare.  The default value is <code>Color.gray</code>.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionPaint(Paint)\n     */\n    public Paint getBaseSectionPaint() {\n        return this.baseSectionPaint;   \n    }\n    \n    /**\n     * Sets the base section paint and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionPaint()\n     */\n    public void setBaseSectionPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE PAINT ////////////////////////////////////////////////\n\n    /**\n     * Returns the flag that controls whether or not the outline is drawn for\n     * each pie section.\n     * \n     * @return The flag that controls whether or not the outline is drawn for\n     *         each pie section.\n     *         \n     * @see #setSectionOutlinesVisible(boolean)\n     */\n    public boolean getSectionOutlinesVisible() {\n        return this.sectionOutlinesVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not the outline is drawn for \n     * each pie section, and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getSectionOutlinesVisible()\n     */\n    public void setSectionOutlinesVisible(boolean visible) {\n        this.sectionOutlinesVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint for the specified section.  This is equivalent \n     * to <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlinePaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key) {\n        return lookupSectionOutlinePaint(key, false);        \n    }\n    \n    /**\n     * Returns the outline paint for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline paint from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlinePaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key, \n            boolean autoPopulate) {\n        \n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionOutlinePaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlinePaint();\n                this.sectionOutlinePaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlinePaint;\n            }\n        }\n        else {\n            result = this.baseSectionOutlinePaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the outline paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlinePaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionOutlinePaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlinePaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the outline paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlinePaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlinePaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionOutlinePaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * available.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlinePaint(Paint)\n     */\n    public Paint getBaseSectionOutlinePaint() {\n        return this.baseSectionOutlinePaint;   \n    }\n    \n    /**\n     * Sets the base section paint.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlinePaint()\n     */\n    public void setBaseSectionOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE STROKE ///////////////////////////////////////////////\n\n    /**\n     * Returns the outline stroke for the specified section.  This is equivalent \n     * to <code>lookupSectionOutlineStroke(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The stroke for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlineStroke(Comparable, boolean)\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key) {\n        return lookupSectionOutlineStroke(key, false);        \n    }\n    \n    /**\n     * Returns the outline stroke for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline stroke from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlineStroke()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline stroke settings.\n     *     \n     * @return The stroke.\n     * \n     * @since 1.0.3\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key, \n            boolean autoPopulate) {\n        \n        Stroke result = null;\n        \n        // is a stroke defined for the specified key\n        result = this.sectionOutlineStrokeMap.getStroke(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlineStroke();\n                this.sectionOutlineStrokeMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlineStroke;\n            }\n        }\n        else {\n            result = this.baseSectionOutlineStroke;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the outline stroke associated with the specified key, or \n     * <code>null</code> if there is no stroke associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The stroke associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlineStroke(Comparable, Stroke)\n     * \n     * @since 1.0.3\n     */\n    public Stroke getSectionOutlineStroke(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlineStrokeMap.getStroke(key);\n    }\n    \n    /**\n     * Sets the outline stroke associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param stroke  the stroke.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlineStroke(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlineStroke(Comparable key, Stroke stroke) {\n        // null argument check delegated...\n        this.sectionOutlineStrokeMap.put(key, stroke);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section stroke.  This is used when no other stroke is \n     * available.\n     * \n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlineStroke(Stroke)\n     */\n    public Stroke getBaseSectionOutlineStroke() {\n        return this.baseSectionOutlineStroke;   \n    }\n    \n    /**\n     * Sets the base section stroke.\n     * \n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlineStroke()\n     */\n    public void setBaseSectionOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.baseSectionOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the shadow paint.\n     * \n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setShadowPaint(Paint)\n     */\n    public Paint getShadowPaint() {\n        return this.shadowPaint;   \n    }\n    \n    /**\n     * Sets the shadow paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getShadowPaint()\n     */\n    public void setShadowPaint(Paint paint) {\n        this.shadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the x-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowXOffset(double)\n     */\n    public double getShadowXOffset() {\n        return this.shadowXOffset;\n    }\n    \n    /**\n     * Sets the x-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowXOffset()\n     */\n    public void setShadowXOffset(double offset) {\n        this.shadowXOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the y-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowYOffset(double)\n     */\n    public double getShadowYOffset() {\n        return this.shadowYOffset;\n    }\n    \n    /**\n     * Sets the y-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowYOffset()\n     */\n    public void setShadowYOffset(double offset) {\n        this.shadowYOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the amount that the section with the specified key should be\n     * exploded.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The amount that the section with the specified key should be\n     *     exploded.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *\n     * @since 1.0.3\n     * \n     * @see #setExplodePercent(Comparable, double)\n     */\n    public double getExplodePercent(Comparable key) {\n        double result = 0.0;\n        if (this.explodePercentages != null) {\n            Number percent = (Number) this.explodePercentages.get(key);\n            if (percent != null) {\n                result = percent.doubleValue();\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the amount that a pie section should be exploded and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the section key (<code>null</code> not permitted).\n     * @param percent  the explode percentage (0.30 = 30 percent).\n     * \n     * @since 1.0.3\n     * \n     * @see #getExplodePercent(Comparable)\n     */\n    public void setExplodePercent(Comparable key, double percent) {\n        if (key == null) { \n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.explodePercentages == null) {\n            this.explodePercentages = new TreeMap();\n        }\n        this.explodePercentages.put(key, new Double(percent));\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum explode percent.\n     * \n     * @return The percent.\n     */\n    public double getMaximumExplodePercent() {\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the section label generator. \n     * \n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLabelGenerator() {\n        return this.labelGenerator;   \n    }\n    \n    /**\n     * Sets the section label generator and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLabelGenerator()\n     */\n    public void setLabelGenerator(PieSectionLabelGenerator generator) {\n        this.labelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the gap between the edge of the pie and the labels, expressed as \n     * a percentage of the plot width.\n     * \n     * @return The gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #setLabelGap(double)\n     */\n    public double getLabelGap() {\n        return this.labelGap;   \n    }\n    \n    /**\n     * Sets the gap between the edge of the pie and the labels (expressed as a \n     * percentage of the plot width) and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param gap  the gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #getLabelGap()\n     */\n    public void setLabelGap(double gap) {\n        this.labelGap = gap;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum label width as a percentage of the plot width.\n     * \n     * @return The width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #setMaximumLabelWidth(double)\n     */\n    public double getMaximumLabelWidth() {\n        return this.maximumLabelWidth;   \n    }\n    \n    /**\n     * Sets the maximum label width as a percentage of the plot width and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param width  the width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #getMaximumLabelWidth()\n     */\n    public void setMaximumLabelWidth(double width) {\n        this.maximumLabelWidth = width;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether or not label linking lines are\n     * visible.\n     * \n     * @return A boolean.\n     * \n     * @see #setLabelLinksVisible(boolean)\n     */\n    public boolean getLabelLinksVisible() {\n        return this.labelLinksVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not label linking lines are \n     * visible and sends a {@link PlotChangeEvent} to all registered listeners.\n     * Please take care when hiding the linking lines - depending on the data \n     * values, the labels can be displayed some distance away from the\n     * corresponding pie section.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getLabelLinksVisible()\n     */\n    public void setLabelLinksVisible(boolean visible) {\n        this.labelLinksVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the margin (expressed as a percentage of the width or height) \n     * between the edge of the pie and the link point.\n     * \n     * @return The link margin (as a percentage, where 0.05 is five percent).\n     * \n     * @see #setLabelLinkMargin(double)\n     */\n    public double getLabelLinkMargin() {\n        return this.labelLinkMargin;   \n    }\n    \n    /**\n     * Sets the link margin and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param margin  the margin.\n     * \n     * @see #getLabelLinkMargin()\n     */\n    public void setLabelLinkMargin(double margin) {\n        this.labelLinkMargin = margin;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the paint used for the lines that connect pie sections to their \n     * corresponding labels.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelLinkPaint(Paint)\n     */\n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;   \n    }\n    \n    /**\n     * Sets the paint used for the lines that connect pie sections to their \n     * corresponding labels, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelLinkPaint()\n     */\n    public void setLabelLinkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelLinkPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used for the label linking lines.\n     * \n     * @return The stroke.\n     * \n     * @see #setLabelLinkStroke(Stroke)\n     */\n    public Stroke getLabelLinkStroke() {\n        return this.labelLinkStroke;   \n    }\n    \n    /**\n     * Sets the link stroke and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param stroke  the stroke.\n     * \n     * @see #getLabelLinkStroke()\n     */\n    public void setLabelLinkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.labelLinkStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the section label font.\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the section label font and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     * \n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.labelFont = font;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label paint.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the section label paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label background paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelBackgroundPaint(Paint)\n     */\n    public Paint getLabelBackgroundPaint() {\n        return this.labelBackgroundPaint;\n    }\n\n    /**\n     * Sets the section label background paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelBackgroundPaint()\n     */\n    public void setLabelBackgroundPaint(Paint paint) {\n        this.labelBackgroundPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlinePaint(Paint)\n     */\n    public Paint getLabelOutlinePaint() {\n        return this.labelOutlinePaint;\n    }\n\n    /**\n     * Sets the section label outline paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlinePaint()\n     */\n    public void setLabelOutlinePaint(Paint paint) {\n        this.labelOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlineStroke(Stroke)\n     */\n    public Stroke getLabelOutlineStroke() {\n        return this.labelOutlineStroke;\n    }\n\n    /**\n     * Sets the section label outline stroke and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlineStroke()\n     */\n    public void setLabelOutlineStroke(Stroke stroke) {\n        this.labelOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label shadow paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelShadowPaint(Paint)\n     */\n    public Paint getLabelShadowPaint() {\n        return this.labelShadowPaint;\n    }\n\n    /**\n     * Sets the section label shadow paint and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelShadowPaint()\n     */\n    public void setLabelShadowPaint(Paint paint) {\n        this.labelShadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the label padding.\n     * \n     * @return The label padding (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setLabelPadding(RectangleInsets)\n     */\n    public RectangleInsets getLabelPadding() {\n        return this.labelPadding;\n    }\n    \n    /**\n     * Sets the padding between each label and its outline and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param padding  the padding (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getLabelPadding()\n     */\n    public void setLabelPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.labelPadding = padding;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the flag that controls whether simple or extended labels are\n     * displayed on the plot.\n     * \n     * @return A boolean.\n     * \n     * @since 1.0.7\n     */\n    public boolean getSimpleLabels() {\n        return this.simpleLabels;\n    }\n    \n    /**\n     * Sets the flag that controls whether simple or extended labels are \n     * displayed on the plot, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param simple  the new flag value.\n     * \n     * @since 1.0.7\n     */\n    public void setSimpleLabels(boolean simple) {\n        this.simpleLabels = simple;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the offset used for the simple labels, if they are displayed.\n     * \n     * @return The offset (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setSimpleLabelOffset(RectangleInsets)\n     */\n    public RectangleInsets getSimpleLabelOffset() {\n        return this.simpleLabelOffset;\n    }\n    \n    /**\n     * Sets the offset for the simple labels and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getSimpleLabelOffset()\n     */\n    public void setSimpleLabelOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.simpleLabelOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));        \n    }\n    \n    /**\n     * Returns the object responsible for the vertical layout of the pie \n     * section labels.\n     * \n     * @return The label distributor (never <code>null</code>).\n     * \n     * @since 1.0.6\n     */\n    public AbstractPieLabelDistributor getLabelDistributor() {\n        return this.labelDistributor;\n    }\n    \n    /**\n     * Sets the label distributor and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param distributor  the distributor (<code>null</code> not permitted).\n     *\n     * @since 1.0.6\n     */\n    public void setLabelDistributor(AbstractPieLabelDistributor distributor) {\n        if (distributor == null) {\n            throw new IllegalArgumentException(\"Null 'distributor' argument.\");\n        }\n        this.labelDistributor = distributor;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the tool tip generator, an object that is responsible for \n     * generating the text items used for tool tips by the plot.  If the \n     * generator is <code>null</code>, no tool tips will be created.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setToolTipGenerator(PieToolTipGenerator)\n     */\n    public PieToolTipGenerator getToolTipGenerator() {\n        return this.toolTipGenerator;\n    }\n\n    /**\n     * Sets the tool tip generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  Set the generator to <code>null</code> if you \n     * don't want any tool tips.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getToolTipGenerator()\n     */\n    public void setToolTipGenerator(PieToolTipGenerator generator) {\n        this.toolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the URL generator.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setURLGenerator(PieURLGenerator)\n     */\n    public PieURLGenerator getURLGenerator() {\n        return this.urlGenerator;\n    }\n\n    /**\n     * Sets the URL generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getURLGenerator()\n     */\n    public void setURLGenerator(PieURLGenerator generator) {\n        this.urlGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.\n     *\n     * @return The minimum angle.\n     * \n     * @see #setMinimumArcAngleToDraw(double)\n     */\n    public double getMinimumArcAngleToDraw() {\n        return this.minimumArcAngleToDraw;\n    }\n\n    /**\n     * Sets the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.  See this \n     * link for details:\n     * <br><br>\n     * <a href=\"http://www.jfree.org/phpBB2/viewtopic.php?t=2707\">\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707</a>\n     * <br><br>\n     * ...and this bug report in the Java Bug Parade:\n     * <br><br>\n     * <a href=\n     * \"http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\">\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html</a>\n     *\n     * @param angle  the minimum angle.\n     * \n     * @see #getMinimumArcAngleToDraw()\n     */\n    public void setMinimumArcAngleToDraw(double angle) {\n        this.minimumArcAngleToDraw = angle;\n    }\n    \n    /**\n     * Returns the shape used for legend items.\n     * \n     * @return The shape (never <code>null</code>).\n     * \n     * @see #setLegendItemShape(Shape)\n     */\n    public Shape getLegendItemShape() {\n        return this.legendItemShape;\n    }\n\n    /**\n     * Sets the shape used for legend items and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param shape  the shape (<code>null</code> not permitted).\n     * \n     * @see #getLegendItemShape()\n     */\n    public void setLegendItemShape(Shape shape) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        this.legendItemShape = shape;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label generator.\n     * \n     * @return The legend label generator (never <code>null</code>).\n     * \n     * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelGenerator() {\n        return this.legendLabelGenerator;\n    }\n    \n    /**\n     * Sets the legend label generator and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> not permitted).\n     * \n     * @see #getLegendLabelGenerator()\n     */\n    public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendLabelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label tool tip generator.\n     * \n     * @return The legend label tool tip generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelToolTipGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {\n        return this.legendLabelToolTipGenerator;\n    }\n    \n    /**\n     * Sets the legend label tool tip generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelToolTipGenerator()\n     */\n    public void setLegendLabelToolTipGenerator(\n            PieSectionLabelGenerator generator) {\n        this.legendLabelToolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label URL generator.\n     * \n     * @return The legend label URL generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelURLGenerator(PieURLGenerator)\n     * \n     * @since 1.0.4\n     */\n    public PieURLGenerator getLegendLabelURLGenerator() {\n        return this.legendLabelURLGenerator;\n    }\n    \n    /**\n     * Sets the legend label URL generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelURLGenerator()\n     * \n     * @since 1.0.4\n     */\n    public void setLegendLabelURLGenerator(PieURLGenerator generator) {\n        this.legendLabelURLGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Initialises the drawing procedure.  This method will be called before \n     * the first item is rendered, giving the plot an opportunity to initialise\n     * any state information it wants to maintain.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param plot  the plot.\n     * @param index  the secondary index (<code>null</code> for primary \n     *               renderer).\n     * @param info  collects chart rendering information for return to caller.\n     * \n     * @return A state object (maintains state information relevant to one \n     *         chart drawing).\n     */\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing \n     *              (<code>null</code> permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                     PlotState parentState, PlotRenderingInfo info) {\n\n        // adjust for insets...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        if (info != null) {\n            info.setPlotArea(area);\n            info.setDataArea(area);\n        }\n\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawPie(g2, area, info);\n        }\n        else {\n            drawNoDataMessage(g2, area);\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, area);\n\n    }\n\n    /**\n     * Draws the pie.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param info  chart rendering info.\n     */\n    protected void drawPie(Graphics2D g2, Rectangle2D plotArea, \n                           PlotRenderingInfo info) {\n\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        // adjust the plot area for interior spacing and labels...\n        double labelReserve = 0.0;\n        if (this.labelGenerator != null && !this.simpleLabels) {\n            labelReserve = this.labelGap + this.maximumLabelWidth;    \n        }\n        double gapHorizontal = plotArea.getWidth() * (this.interiorGap \n                + labelReserve) * 2.0;\n        double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;\n\n        \n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * this.interiorGap;\n            double vGap = plotArea.getHeight() * this.interiorGap;\n        \n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.gray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n        \n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        // make the link area a square if the pie chart is to be circular...\n        if (this.circular) {\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n\n        // the link area defines the dog leg points for the linking lines to \n        // the labels\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH);\n        state.setLinkArea(linkArea);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkArea);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), \n                    linkArea.getWidth(), linkArea.getHeight()));\n        }\n        \n        // the explode area defines the max circle/ellipse for the exploded \n        // pie sections.  it is defined by shrinking the linkArea by the \n        // linkMargin factor.\n        double lm = 0.0;\n        if (!this.simpleLabels) {\n            lm = this.labelLinkMargin;\n        }\n        double hh = linkArea.getWidth() * lm * 2.0;\n        double vv = linkArea.getHeight() * lm * 2.0;\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        // the pie area defines the circle/ellipse for regular pie sections.\n        // it is defined by shrinking the explodeArea by the explodeMargin \n        // factor. \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, \n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        if (DEBUG_DRAW_PIE_AREA) {\n            g2.setPaint(Color.green);\n            g2.draw(pieArea);\n        }\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY());\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius(pieArea.getHeight() / 2.0);\n        \n        // plot the data (unless the dataset is null)...\n        if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {\n\n            List keys = this.dataset.getKeys();\n            double totalValue = DatasetUtilities.calculatePieDatasetTotal(\n                    this.dataset);\n\n            int passesRequired = state.getPassesRequired();\n            for (int pass = 0; pass < passesRequired; pass++) {\n                double runningTotal = 0.0;\n                for (int section = 0; section < keys.size(); section++) {\n                    Number n = this.dataset.getValue(section);\n                    if (n != null) {\n                        double value = n.doubleValue();\n                        if (value > 0.0) {\n                            runningTotal += value;\n                            drawItem(g2, section, explodeArea, state, pass);\n                        }\n                    } \n                }\n            }\n            if (this.simpleLabels) {\n                drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, \n                        state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, plotArea, linkArea, state);\n            }\n\n        }\n        else {\n            drawNoDataMessage(g2, plotArea);\n        }\n    }\n    \n    /**\n     * Draws a single data item.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param section  the section index.\n     * @param dataArea  the data plot area.\n     * @param state  state information for one chart.\n     * @param currentPass  the current pass index.\n     */\n    protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea,\n                            PiePlotState state, int currentPass) {\n    \n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;   \n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n        \n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;         \n        }\n        else {\n            throw new IllegalStateException(\"Rotation type not recognised.\");   \n        }\n        \n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(getSectionKey(section)) / mep;                \n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(), \n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, \n                    Arc2D.PIE);\n            \n            if (currentPass == 0) {\n                if (this.shadowPaint != null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset, \n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, true);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n                \n                // update the linking line target for later\n                // add an entity for the pie section\n                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset, \n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }    \n        state.setLatestAngle(angle2);\n    }\n    \n    /**\n     * Draws the pie section labels in the simple form.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the section keys.\n     * @param totalValue  the total value for all sections in the pie.\n     * @param plotArea  the plot area.\n     * @param pieArea  the area containing the pie.\n     * @param state  the plot state.\n     *\n     * @since 1.0.7\n     */\n    protected void drawSimpleLabels(Graphics2D g2, List keys, \n            double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, \n            PiePlotState state) {\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE, \n                0.18, 0.18, 0.18, 0.18);\n        Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                \n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), \n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n                \n                PieSectionLabelGenerator labelGenerator = getLabelGenerator();\n                if (labelGenerator == null) {\n                    continue;\n                }\n                String label = labelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out, \n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg, \n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null \n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n                \n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(getLabelGenerator()\n                        .generateSectionLabel(getDataset(), key), g2, x, y, \n                        TextAnchor.CENTER);\n                \n            }\n        }\n       \n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the labels for the pie sections.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the keys.\n     * @param totalValue  the total value.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param state  the state.\n     */\n    protected void drawLabels(Graphics2D g2, List keys, double totalValue, \n                              Rectangle2D plotArea, Rectangle2D linkArea, \n                              PiePlotState state) {   \n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        // classify the keys according to which side the label will appear...\n        DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n       \n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n       \n        g2.setFont(getLabelFont());\n        \n        // calculate the max label width from the plot dimensions, because\n        // a circular pie can leave a lot more room for labels...\n        double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n        \n        // draw the labels...\n        if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the left labels.\n     * \n     * @param leftKeys  a collection of keys and angles (to the middle of the\n     *         section, in degrees) for the sections on the left side of the \n     *         plot.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, \n                                  Rectangle2D plotArea, Rectangle2D linkArea, \n                                  float maxLabelWidth, PiePlotState state) {\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {   \n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta) \n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 0.9 \n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }\n    \n    /**\n     * Draws the right labels.\n     * \n     * @param keys  the keys.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawRightLabels(KeyedValues keys, Graphics2D g2, \n                                   Rectangle2D plotArea, Rectangle2D linkArea, \n                                   float maxLabelWidth, PiePlotState state) {\n\n        // draw the right labels...\n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() \n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta), \n                        0.9 + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }\n    \n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items (never <code>null</code>).\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.dataset == null) {\n            return result;\n        }\n        List keys = this.dataset.getKeys();\n        int section = 0;\n        Shape shape = getLegendItemShape();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number n = this.dataset.getValue(key);\n            boolean include = true;\n            if (n == null) {\n                include = !this.ignoreNullValues;   \n            }\n            else {\n                double v = n.doubleValue();\n                if (v == 0.0) {\n                    include = !this.ignoreZeroValues;   \n                }\n                else {\n                    include = v > 0.0;   \n                }\n            }\n            if (include) {\n                String label = this.legendLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label != null) {\n                    String description = label;\n                    String toolTipText = null;\n                    if (this.legendLabelToolTipGenerator != null) {\n                        toolTipText = this.legendLabelToolTipGenerator\n                                .generateSectionLabel(this.dataset, key);\n                    }\n                    String urlText = null;\n                    if (this.legendLabelURLGenerator != null) {\n                        urlText = this.legendLabelURLGenerator.generateURL(\n                                this.dataset, key, this.pieIndex);\n                    }\n                    Paint paint = lookupSectionPaint(key, true);\n                    Paint outlinePaint = lookupSectionOutlinePaint(key);\n                    Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                    LegendItem item = new LegendItem(label, description, \n                            toolTipText, urlText, true, shape, true, paint, \n                            true, outlinePaint, outlineStroke, \n                            false,          // line not visible\n                            new Line2D.Float(), new BasicStroke(), Color.black);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                }\n                section++;\n            }\n            else {\n                section++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Pie_Plot\");\n    }\n\n    /**\n     * Returns a rectangle that can be used to create a pie section (taking\n     * into account the amount by which the pie section is 'exploded').\n     *\n     * @param unexploded  the area inside which the unexploded pie sections are\n     *                    drawn.\n     * @param exploded  the area inside which the exploded pie sections are \n     *                  drawn.\n     * @param angle  the start angle.\n     * @param extent  the extent of the arc.\n     * @param explodePercent  the amount by which the pie section is exploded.\n     *\n     * @return A rectangle that can be used to create a pie section.\n     */\n    protected Rectangle2D getArcBounds(Rectangle2D unexploded, \n                                       Rectangle2D exploded,\n                                       double angle, double extent, \n                                       double explodePercent) {\n\n        if (explodePercent == 0.0) {\n            return unexploded;\n        }\n        else {\n            Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point1 = arc1.getEndPoint();\n            Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point2 = arc2.getEndPoint();\n            double deltaX = (point1.getX() - point2.getX()) * explodePercent;\n            double deltaY = (point1.getY() - point2.getY()) * explodePercent;\n            return new Rectangle2D.Double(unexploded.getX() - deltaX, \n                    unexploded.getY() - deltaY, unexploded.getWidth(), \n                    unexploded.getHeight());\n        }\n    }\n    \n    /**\n     * Draws a section label on the left side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawLeftLabel(Graphics2D g2, PiePlotState state, \n                                 PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n        \n    }\n\n    /**\n     * Draws a section label on the right side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawRightLabel(Graphics2D g2, PiePlotState state, \n                                  PieLabelRecord record) {\n        \n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        \n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n    \n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the \n     * plot's dataset is NOT included in the test for equality.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PiePlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        PiePlot that = (PiePlot) obj;\n        if (this.pieIndex != that.pieIndex) {\n            return false;\n        }\n        if (this.interiorGap != that.interiorGap) {\n            return false;\n        }\n        if (this.circular != that.circular) {\n            return false;\n        }\n        if (this.startAngle != that.startAngle) {\n            return false;\n        }\n        if (this.direction != that.direction) {\n            return false;\n        }\n        if (this.ignoreZeroValues != that.ignoreZeroValues) {\n            return false;\n        }\n        if (this.ignoreNullValues != that.ignoreNullValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionPaintMap, \n                that.sectionPaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.baseSectionPaint, \n                that.baseSectionPaint)) {\n            return false;\n        }\n        if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, \n                that.sectionOutlinePaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.baseSectionOutlinePaint, that.baseSectionOutlinePaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, \n                that.sectionOutlineStrokeMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.baseSectionOutlineStroke, that.baseSectionOutlineStroke\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!(this.shadowXOffset == that.shadowXOffset)) {\n            return false;\n        }\n        if (!(this.shadowYOffset == that.shadowYOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.explodePercentages, \n                that.explodePercentages)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelGenerator, \n                that.labelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelBackgroundPaint, \n                that.labelBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelOutlinePaint, \n                that.labelOutlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelOutlineStroke, \n                that.labelOutlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelShadowPaint, \n                that.labelShadowPaint)) {\n            return false;\n        }\n        if (this.simpleLabels != that.simpleLabels) {\n            return false;\n        }\n        if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {\n            return false;\n        }\n        if (!this.labelPadding.equals(that.labelPadding)) {\n            return false;\n        }\n        if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {\n            return false;\n        }\n        if (!(this.labelGap == that.labelGap)) {\n            return false;\n        }\n        if (!(this.labelLinkMargin == that.labelLinkMargin)) {\n            return false;\n        }\n        if (this.labelLinksVisible != that.labelLinksVisible) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelLinkStroke, \n                that.labelLinkStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGenerator, \n                that.toolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {\n            return false;\n        }\n        if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelGenerator, \n                that.legendLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,\n                that.legendLabelToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelURLGenerator,\n                that.legendLabelURLGenerator)) {\n            return false;\n        }\n        // can't find any difference...\n        return true;\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the plot does \n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        PiePlot clone = (PiePlot) super.clone();\n        if (clone.dataset != null) {\n            clone.dataset.addChangeListener(clone);\n        }\n        if (this.urlGenerator instanceof PublicCloneable) {\n            clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(\n                    this.urlGenerator);\n        }\n        clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);\n        if (this.legendLabelGenerator != null) {\n            clone.legendLabelGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelGenerator);\n        }\n        if (this.legendLabelToolTipGenerator != null) {\n            clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelToolTipGenerator);\n        }\n        if (this.legendLabelURLGenerator instanceof PublicCloneable) {\n            clone.legendLabelURLGenerator = (PieURLGenerator) \n                    ObjectUtilities.clone(this.legendLabelURLGenerator);\n        }\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.baseSectionPaint, stream);\n        SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);\n        SerialUtilities.writePaint(this.shadowPaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.labelBackgroundPaint, stream);\n        SerialUtilities.writePaint(this.labelOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.labelOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelShadowPaint, stream);\n        SerialUtilities.writePaint(this.labelLinkPaint, stream);\n        SerialUtilities.writeStroke(this.labelLinkStroke, stream);\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.baseSectionPaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.labelBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.labelOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelOutlineStroke = SerialUtilities.readStroke(stream);\n        this.labelShadowPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkStroke = SerialUtilities.readStroke(stream);\n        this.legendItemShape = SerialUtilities.readShape(stream);\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ------------\n * PiePlot.java\n * ------------\n * (C) Copyright 2000-2008, by Andrzej Porebski and Contributors.\n *\n * Original Author:  Andrzej Porebski;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Martin Cordova (percentages in labels);\n *                   Richard Atkinson (URL support for image maps);\n *                   Christian W. Zuckschwerdt;\n *                   Arnaud Lelievre;\n *                   Andreas Schroeder (very minor);\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Moved series paint and stroke methods from JFreeChart.java to \n *               Plot.java (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 13-Nov-2001 : Modified plot subclasses so that null axes are possible for \n *               pie plot (DG);\n * 17-Nov-2001 : Added PieDataset interface and amended this class accordingly,\n *               and completed removal of BlankAxis class as it is no longer \n *               required (DG);\n * 19-Nov-2001 : Changed 'drawCircle' property to 'circular' property (DG);\n * 21-Nov-2001 : Added options for exploding pie sections and filled out range \n *               of properties (DG);\n *               Added option for percentages in chart labels, based on code\n *               by Martin Cordova (DG);\n * 30-Nov-2001 : Changed default font from \"Arial\" --> \"SansSerif\" (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clause in constructor (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Renamed tooltips class (DG);\n * 22-Jan-2002 : Fixed bug correlating legend labels with pie data (DG);\n * 05-Feb-2002 : Added alpha-transparency to plot class, and updated \n *               constructors accordingly (DG);\n * 06-Feb-2002 : Added optional background image and alpha-transparency to Plot\n *               and subclasses.  Clipped drawing within plot area (DG);\n * 26-Mar-2002 : Added an empty zoom method (DG);\n * 18-Apr-2002 : PieDataset is no longer sorted (oldman);\n * 23-Apr-2002 : Moved dataset from JFreeChart to Plot.  Added \n *               getLegendItemLabels() method (DG);\n * 19-Jun-2002 : Added attributes to control starting angle and direction \n *               (default is now clockwise) (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 02-Jul-2002 : Fixed sign of percentage bug introduced in 0.9.2 (DG);\n * 16-Jul-2002 : Added check for null dataset in getLegendItemLabels() (DG);\n * 30-Jul-2002 : Moved summation code to DatasetUtilities (DG);\n * 05-Aug-2002 : Added URL support for image maps - new member variable for\n *               urlGenerator, modified constructor and minor change to the \n *               draw method (RA);\n * 18-Sep-2002 : Modified the percent label creation and added setters for the\n *               formatters (AS);\n * 24-Sep-2002 : Added getLegendItems() method (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 09-Oct-2002 : Added check for null entity collection (DG);\n * 30-Oct-2002 : Changed PieDataset interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 02-Jan-2003 : Fixed \"no data\" message (DG);\n * 23-Jan-2003 : Modified to extract data from rows OR columns in \n *               CategoryDataset (DG);\n * 14-Feb-2003 : Fixed label drawing so that foreground alpha does not apply \n *               (bug id 685536) (DG);\n * 07-Mar-2003 : Modified to pass pieIndex on to PieSectionEntity and tooltip \n *               and URL generators (DG);\n * 21-Mar-2003 : Added a minimum angle for drawing arcs \n *               (see bug id 620031) (DG);\n * 24-Apr-2003 : Switched around PieDataset and KeyedValuesDataset (DG);\n * 02-Jun-2003 : Fixed bug 721733 (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 29-Aug-2003 : Fixed bug 796936 (null pointer on setOutlinePaint()) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 05-Nov-2003 : Fixed missing legend bug (DG);\n * 10-Nov-2003 : Re-added the DatasetChangeListener to constructors (CZ);\n * 29-Jan-2004 : Fixed clipping bug in draw() method (DG);\n * 11-Mar-2004 : Major overhaul to improve labelling (DG);\n * 31-Mar-2004 : Made an adjustment for the plot area when the label generator \n *               is null.  Fixed null pointer exception when the label \n *               generator returns null for a label (DG);\n * 06-Apr-2004 : Added getter, setter, serialization and draw support for \n *               labelBackgroundPaint (AS);\n * 08-Apr-2004 : Added flag to control whether null values are ignored or \n *               not (DG);\n * 15-Apr-2004 : Fixed some minor warnings from Eclipse (DG);\n * 26-Apr-2004 : Added attributes for label outline and shadow (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 04-Nov-2004 : Fixed null pointer exception with new LegendTitle class (DG);\n * 09-Nov-2004 : Added user definable legend item shape (DG);\n * 25-Nov-2004 : Added new legend label generator (DG);\n * 20-Apr-2005 : Added a tool tip generator for legend labels (DG);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 10-May-2005 : Added flag to control visibility of label linking lines, plus\n *               another flag to control the handling of zero values (DG);\n * 08-Jun-2005 : Fixed bug in getLegendItems() method (not respecting flags\n *               for ignoring null and zero values), and fixed equals() method \n *               to handle GradientPaint (DG);\n * 15-Jul-2005 : Added sectionOutlinesVisible attribute (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 09-Jan-2006 : Fixed bug 1400442, inconsistent treatment of null and zero\n *               values in dataset (DG);\n * 28-Feb-2006 : Fixed bug 1440415, bad distribution of pie section \n *               labels (DG);\n * 27-Sep-2006 : Initialised baseSectionPaint correctly, added lookup methods\n *               for section paint, outline paint and outline stroke (DG);\n * 27-Sep-2006 : Refactored paint and stroke methods to use keys rather than\n *               section indices (DG);\n * 03-Oct-2006 : Replaced call to JRE 1.5 method (DG);\n * 23-Nov-2006 : Added support for URLs for the legend items (DG);\n * 24-Nov-2006 : Cloning fixes (DG);\n * 17-Apr-2007 : Check for null label in legend items (DG);\n * 19-Apr-2007 : Deprecated override settings (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 14-Jun-2007 : Added label distributor attribute (DG);\n * 19-Jun-2007 : Removed deprecated code (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Jul-2007 : Added simple label option (DG);\n * 21-Nov-2007 : Fixed labelling bugs, added debug code, restored default\n *               white background (DG); \n * 19-Mar-2008 : Fixed IllegalArgumentException when drawing with null \n *               dataset (DG);\n *    \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.PaintMap;\nimport org.jfree.chart.StrokeMap;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.entity.PieSectionEntity;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.labels.PieSectionLabelGenerator;\nimport org.jfree.chart.labels.PieToolTipGenerator;\nimport org.jfree.chart.labels.StandardPieSectionLabelGenerator;\nimport org.jfree.chart.text.G2TextMeasurer;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextBlock;\nimport org.jfree.chart.text.TextBox;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.PieURLGenerator;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.Rotation;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.jfree.chart.util.UnitType;\nimport org.jfree.data.DefaultKeyedValues;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays data in the form of a pie chart, using data from any \n * class that implements the {@link PieDataset} interface.\n * <P>\n * Special notes:\n * <ol>\n * <li>the default starting point is 12 o'clock and the pie sections proceed\n * in a clockwise direction, but these settings can be changed;</li>\n * <li>negative values in the dataset are ignored;</li>\n * <li>there are utility methods for creating a {@link PieDataset} from a\n * {@link org.jfree.data.category.CategoryDataset};</li>\n * </ol>\n *\n * @see Plot\n * @see PieDataset\n */\npublic class PiePlot extends Plot implements Cloneable, Serializable {\n    \n    /** For serialization. */\n    private static final long serialVersionUID = -795612466005590431L;\n    \n    /** The default interior gap. */\n    public static final double DEFAULT_INTERIOR_GAP = 0.08;\n\n    /** The maximum interior gap (currently 40%). */\n    public static final double MAX_INTERIOR_GAP = 0.40;\n\n    /** The default starting angle for the pie chart. */\n    public static final double DEFAULT_START_ANGLE = 90.0;\n\n    /** The default section label font. */\n    public static final Font DEFAULT_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** The default section label paint. */\n    public static final Paint DEFAULT_LABEL_PAINT = Color.black;\n    \n    /** The default section label background paint. */\n    public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, \n            255, 192);\n\n    /** The default section label outline paint. */\n    public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black;\n    \n    /** The default section label outline stroke. */\n    public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke(\n            0.5f);\n    \n    /** The default section label shadow paint. */\n    public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151, \n            151, 128);\n    \n    /** The default minimum arc angle to draw. */\n    public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001;\n\n    /** The dataset for the pie chart. */\n    private PieDataset dataset;\n\n    /** The pie index (used by the {@link MultiplePiePlot} class). */\n    private int pieIndex;\n\n    /** \n     * The amount of space left around the outside of the pie plot, expressed \n     * as a percentage of the plot area width and height. \n     */\n    private double interiorGap;\n\n    /** Flag determining whether to draw an ellipse or a perfect circle. */\n    private boolean circular;\n\n    /** The starting angle. */\n    private double startAngle;\n\n    /** The direction for the pie segments. */\n    private Rotation direction;\n\n    /** The section paint map. */\n    private PaintMap sectionPaintMap;\n\n    /** The base section paint (fallback). */\n    private transient Paint baseSectionPaint;\n\n    /** \n     * A flag that controls whether or not an outline is drawn for each\n     * section in the plot.\n     */\n    private boolean sectionOutlinesVisible;\n\n    /** The section outline paint map. */\n    private PaintMap sectionOutlinePaintMap;\n\n    /** The base section outline paint (fallback). */\n    private transient Paint baseSectionOutlinePaint;\n\n    /** The section outline stroke map. */\n    private StrokeMap sectionOutlineStrokeMap;\n\n    /** The base section outline stroke (fallback). */\n    private transient Stroke baseSectionOutlineStroke;\n\n    /** The shadow paint. */\n    private transient Paint shadowPaint = Color.gray;\n\n    /** The x-offset for the shadow effect. */\n    private double shadowXOffset = 4.0f;\n    \n    /** The y-offset for the shadow effect. */\n    private double shadowYOffset = 4.0f;\n    \n    /** The percentage amount to explode each pie section. */\n    private Map explodePercentages;\n    \n    /** The section label generator. */\n    private PieSectionLabelGenerator labelGenerator;\n\n    /** The font used to display the section labels. */\n    private Font labelFont;\n\n    /** The color used to draw the section labels. */\n    private transient Paint labelPaint;\n    \n    /** \n     * The color used to draw the background of the section labels.  If this\n     * is <code>null</code>, the background is not filled.\n     */\n    private transient Paint labelBackgroundPaint;\n\n    /** \n     * The paint used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelOutlinePaint;\n    \n    /** \n     * The stroke used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Stroke labelOutlineStroke;\n    \n    /** \n     * The paint used to draw the shadow for the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelShadowPaint;\n    \n    /**\n     * A flag that controls whether simple or extended labels are used.\n     * \n     * @since 1.0.7\n     */\n    private boolean simpleLabels = true;\n    \n    /**\n     * The padding between the labels and the label outlines.  This is not\n     * allowed to be <code>null</code>.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets labelPadding;\n    \n    /**\n     * The simple label offset.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets simpleLabelOffset;\n    \n    /** The maximum label width as a percentage of the plot width. */\n    private double maximumLabelWidth = 0.14;\n    \n    /** \n     * The gap between the labels and the link corner, as a percentage of the \n     * plot width. \n     */\n    private double labelGap = 0.025;\n\n    /** A flag that controls whether or not the label links are drawn. */\n    private boolean labelLinksVisible;\n    \n    /** The link margin. */\n    private double labelLinkMargin = 0.025;\n    \n    /** The paint used for the label linking lines. */\n    private transient Paint labelLinkPaint = Color.black;\n    \n    /** The stroke used for the label linking lines. */\n    private transient Stroke labelLinkStroke = new BasicStroke(0.5f);\n    \n    /** \n     * The pie section label distributor.\n     * \n     * @since 1.0.6\n     */\n    private AbstractPieLabelDistributor labelDistributor;\n    \n    /** The tooltip generator. */\n    private PieToolTipGenerator toolTipGenerator;\n\n    /** The URL generator. */\n    private PieURLGenerator urlGenerator;\n    \n    /** The legend label generator. */\n    private PieSectionLabelGenerator legendLabelGenerator;\n    \n    /** A tool tip generator for the legend. */\n    private PieSectionLabelGenerator legendLabelToolTipGenerator;\n    \n    /** \n     * A URL generator for the legend items (optional).  \n     *\n     * @since 1.0.4. \n     */\n    private PieURLGenerator legendLabelURLGenerator;\n    \n    /** \n     * A flag that controls whether <code>null</code> values are ignored.  \n     */\n    private boolean ignoreNullValues;\n    \n    /**\n     * A flag that controls whether zero values are ignored.\n     */\n    private boolean ignoreZeroValues;\n\n    /** The legend item shape. */\n    private transient Shape legendItemShape;\n    \n    /**\n     * The smallest arc angle that will get drawn (this is to avoid a bug in \n     * various Java implementations that causes the JVM to crash).  See this \n     * link for details:\n     *\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707\n     *\n     * ...and this bug report in the Java Bug Parade:\n     *\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\n     */\n    private double minimumArcAngleToDraw;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources =\n            ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * interior of the plot region.  This is drawn as a lightGray rectangle \n     * showing the padding provided by the 'interiorGap' setting.\n     */\n    static final boolean DEBUG_DRAW_INTERIOR = false;\n    \n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * link area (in blue) and link ellipse (in yellow).  This controls where \n     * the label links have 'elbow' points.\n     */\n    static final boolean DEBUG_DRAW_LINK_AREA = false;\n    \n    /**\n     * This debug flag controls whether or not an outline is drawn showing\n     * the pie area (in green).\n     */\n    static final boolean DEBUG_DRAW_PIE_AREA = false;\n    \n    /**\n     * Creates a new plot.  The dataset is initially set to <code>null</code>.\n     */\n    public PiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a plot that will draw a pie chart for the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public PiePlot(PieDataset dataset) {\n        super();\n        this.dataset = dataset;\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        this.pieIndex = 0;\n        \n        this.interiorGap = DEFAULT_INTERIOR_GAP;\n        this.circular = true;\n        this.startAngle = DEFAULT_START_ANGLE;\n        this.direction = Rotation.CLOCKWISE;\n        this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;\n\n        this.sectionPaintMap = new PaintMap();\n        this.baseSectionPaint = Color.gray;\n\n        this.sectionOutlinesVisible = true;\n        this.sectionOutlinePaintMap = new PaintMap();\n        this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;\n\n        this.sectionOutlineStrokeMap = new StrokeMap();\n        this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        \n        this.explodePercentages = new TreeMap();\n\n        this.labelGenerator = new StandardPieSectionLabelGenerator();\n        this.labelFont = DEFAULT_LABEL_FONT;\n        this.labelPaint = DEFAULT_LABEL_PAINT;\n        this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;\n        this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;\n        this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;\n        this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;\n        this.labelLinksVisible = true;\n        this.labelDistributor = new PieLabelDistributor(0);\n        \n        this.simpleLabels = false;\n        this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, \n                0.18, 0.18, 0.18);\n        this.labelPadding = new RectangleInsets(2, 2, 2, 2);\n        \n        this.toolTipGenerator = null;\n        this.urlGenerator = null;\n        this.legendLabelGenerator = new StandardPieSectionLabelGenerator();\n        this.legendLabelToolTipGenerator = null;\n        this.legendLabelURLGenerator = null;\n        this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;\n        \n        this.ignoreNullValues = false;\n        this.ignoreZeroValues = false;\n    }\n\n    /**\n     * Returns the dataset.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(PieDataset)\n     */\n    public PieDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset and sends a {@link DatasetChangeEvent} to 'this'.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(PieDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of \n        // change listeners...\n        PieDataset existing = this.dataset;\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n    \n    /**\n     * Returns the pie index (this is used by the {@link MultiplePiePlot} class\n     * to track subplots).\n     * \n     * @return The pie index.\n     * \n     * @see #setPieIndex(int)\n     */\n    public int getPieIndex() {\n        return this.pieIndex;\n    }\n    \n    /**\n     * Sets the pie index (this is used by the {@link MultiplePiePlot} class to \n     * track subplots).\n     * \n     * @param index  the index.\n     * \n     * @see #getPieIndex()\n     */\n    public void setPieIndex(int index) {\n        this.pieIndex = index;\n    }\n    \n    /**\n     * Returns the start angle for the first pie section.  This is measured in \n     * degrees starting from 3 o'clock and measuring anti-clockwise.\n     *\n     * @return The start angle.\n     * \n     * @see #setStartAngle(double)\n     */\n    public double getStartAngle() {\n        return this.startAngle;\n    }\n\n    /**\n     * Sets the starting angle and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  The initial default value is 90 degrees, which \n     * corresponds to 12 o'clock.  A value of zero corresponds to 3 o'clock...\n     * this is the encoding used by Java's Arc2D class.\n     *\n     * @param angle  the angle (in degrees).\n     * \n     * @see #getStartAngle()\n     */\n    public void setStartAngle(double angle) {\n        this.startAngle = angle;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the direction in which the pie sections are drawn (clockwise or \n     * anti-clockwise).\n     *\n     * @return The direction (never <code>null</code>).\n     * \n     * @see #setDirection(Rotation)\n     */\n    public Rotation getDirection() {\n        return this.direction;\n    }\n\n    /**\n     * Sets the direction in which the pie sections are drawn and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param direction  the direction (<code>null</code> not permitted).\n     * \n     * @see #getDirection()\n     */\n    public void setDirection(Rotation direction) {\n        if (direction == null) {\n            throw new IllegalArgumentException(\"Null 'direction' argument.\");\n        }\n        this.direction = direction;\n        notifyListeners(new PlotChangeEvent(this));\n\n    }\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available \n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     * \n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  This controls the space between the edges of the \n     * pie plot and the plot area itself (the region where the section labels \n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     * \n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     * \n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));   \n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At \n     * present, this only affects whether or not the key is presented in the \n     * legend.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether zero values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether zero values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This \n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key) {\n        return lookupSectionPaint(key, false);        \n    }\n    \n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code> \n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but \n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier \n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {\n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a key for the specified section.  If there is no such section \n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes \n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).  \n     * \n     * @param section  the section index.\n     * \n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }\n    \n    /**\n     * Returns the paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionPaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionPaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionPaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionPaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionPaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionPaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * defined, which is rare.  The default value is <code>Color.gray</code>.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionPaint(Paint)\n     */\n    public Paint getBaseSectionPaint() {\n        return this.baseSectionPaint;   \n    }\n    \n    /**\n     * Sets the base section paint and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionPaint()\n     */\n    public void setBaseSectionPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE PAINT ////////////////////////////////////////////////\n\n    /**\n     * Returns the flag that controls whether or not the outline is drawn for\n     * each pie section.\n     * \n     * @return The flag that controls whether or not the outline is drawn for\n     *         each pie section.\n     *         \n     * @see #setSectionOutlinesVisible(boolean)\n     */\n    public boolean getSectionOutlinesVisible() {\n        return this.sectionOutlinesVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not the outline is drawn for \n     * each pie section, and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getSectionOutlinesVisible()\n     */\n    public void setSectionOutlinesVisible(boolean visible) {\n        this.sectionOutlinesVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint for the specified section.  This is equivalent \n     * to <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlinePaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key) {\n        return lookupSectionOutlinePaint(key, false);        \n    }\n    \n    /**\n     * Returns the outline paint for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline paint from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlinePaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key, \n            boolean autoPopulate) {\n        \n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionOutlinePaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlinePaint();\n                this.sectionOutlinePaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlinePaint;\n            }\n        }\n        else {\n            result = this.baseSectionOutlinePaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the outline paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlinePaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionOutlinePaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlinePaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the outline paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlinePaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlinePaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionOutlinePaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * available.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlinePaint(Paint)\n     */\n    public Paint getBaseSectionOutlinePaint() {\n        return this.baseSectionOutlinePaint;   \n    }\n    \n    /**\n     * Sets the base section paint.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlinePaint()\n     */\n    public void setBaseSectionOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE STROKE ///////////////////////////////////////////////\n\n    /**\n     * Returns the outline stroke for the specified section.  This is equivalent \n     * to <code>lookupSectionOutlineStroke(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The stroke for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlineStroke(Comparable, boolean)\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key) {\n        return lookupSectionOutlineStroke(key, false);        \n    }\n    \n    /**\n     * Returns the outline stroke for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline stroke from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlineStroke()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline stroke settings.\n     *     \n     * @return The stroke.\n     * \n     * @since 1.0.3\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key, \n            boolean autoPopulate) {\n        \n        Stroke result = null;\n        \n        // is a stroke defined for the specified key\n        result = this.sectionOutlineStrokeMap.getStroke(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlineStroke();\n                this.sectionOutlineStrokeMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlineStroke;\n            }\n        }\n        else {\n            result = this.baseSectionOutlineStroke;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the outline stroke associated with the specified key, or \n     * <code>null</code> if there is no stroke associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The stroke associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlineStroke(Comparable, Stroke)\n     * \n     * @since 1.0.3\n     */\n    public Stroke getSectionOutlineStroke(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlineStrokeMap.getStroke(key);\n    }\n    \n    /**\n     * Sets the outline stroke associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param stroke  the stroke.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlineStroke(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlineStroke(Comparable key, Stroke stroke) {\n        // null argument check delegated...\n        this.sectionOutlineStrokeMap.put(key, stroke);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section stroke.  This is used when no other stroke is \n     * available.\n     * \n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlineStroke(Stroke)\n     */\n    public Stroke getBaseSectionOutlineStroke() {\n        return this.baseSectionOutlineStroke;   \n    }\n    \n    /**\n     * Sets the base section stroke.\n     * \n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlineStroke()\n     */\n    public void setBaseSectionOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.baseSectionOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the shadow paint.\n     * \n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setShadowPaint(Paint)\n     */\n    public Paint getShadowPaint() {\n        return this.shadowPaint;   \n    }\n    \n    /**\n     * Sets the shadow paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getShadowPaint()\n     */\n    public void setShadowPaint(Paint paint) {\n        this.shadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the x-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowXOffset(double)\n     */\n    public double getShadowXOffset() {\n        return this.shadowXOffset;\n    }\n    \n    /**\n     * Sets the x-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowXOffset()\n     */\n    public void setShadowXOffset(double offset) {\n        this.shadowXOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the y-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowYOffset(double)\n     */\n    public double getShadowYOffset() {\n        return this.shadowYOffset;\n    }\n    \n    /**\n     * Sets the y-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowYOffset()\n     */\n    public void setShadowYOffset(double offset) {\n        this.shadowYOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the amount that the section with the specified key should be\n     * exploded.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The amount that the section with the specified key should be\n     *     exploded.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *\n     * @since 1.0.3\n     * \n     * @see #setExplodePercent(Comparable, double)\n     */\n    public double getExplodePercent(Comparable key) {\n        double result = 0.0;\n        if (this.explodePercentages != null) {\n            Number percent = (Number) this.explodePercentages.get(key);\n            if (percent != null) {\n                result = percent.doubleValue();\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the amount that a pie section should be exploded and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the section key (<code>null</code> not permitted).\n     * @param percent  the explode percentage (0.30 = 30 percent).\n     * \n     * @since 1.0.3\n     * \n     * @see #getExplodePercent(Comparable)\n     */\n    public void setExplodePercent(Comparable key, double percent) {\n        if (key == null) { \n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.explodePercentages == null) {\n            this.explodePercentages = new TreeMap();\n        }\n        this.explodePercentages.put(key, new Double(percent));\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum explode percent.\n     * \n     * @return The percent.\n     */\n    public double getMaximumExplodePercent() {\n        if (this.dataset == null) {\n            return 0.0;\n        }\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the section label generator. \n     * \n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLabelGenerator() {\n        return this.labelGenerator;   \n    }\n    \n    /**\n     * Sets the section label generator and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLabelGenerator()\n     */\n    public void setLabelGenerator(PieSectionLabelGenerator generator) {\n        this.labelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the gap between the edge of the pie and the labels, expressed as \n     * a percentage of the plot width.\n     * \n     * @return The gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #setLabelGap(double)\n     */\n    public double getLabelGap() {\n        return this.labelGap;   \n    }\n    \n    /**\n     * Sets the gap between the edge of the pie and the labels (expressed as a \n     * percentage of the plot width) and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param gap  the gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #getLabelGap()\n     */\n    public void setLabelGap(double gap) {\n        this.labelGap = gap;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum label width as a percentage of the plot width.\n     * \n     * @return The width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #setMaximumLabelWidth(double)\n     */\n    public double getMaximumLabelWidth() {\n        return this.maximumLabelWidth;   \n    }\n    \n    /**\n     * Sets the maximum label width as a percentage of the plot width and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param width  the width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #getMaximumLabelWidth()\n     */\n    public void setMaximumLabelWidth(double width) {\n        this.maximumLabelWidth = width;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether or not label linking lines are\n     * visible.\n     * \n     * @return A boolean.\n     * \n     * @see #setLabelLinksVisible(boolean)\n     */\n    public boolean getLabelLinksVisible() {\n        return this.labelLinksVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not label linking lines are \n     * visible and sends a {@link PlotChangeEvent} to all registered listeners.\n     * Please take care when hiding the linking lines - depending on the data \n     * values, the labels can be displayed some distance away from the\n     * corresponding pie section.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getLabelLinksVisible()\n     */\n    public void setLabelLinksVisible(boolean visible) {\n        this.labelLinksVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the margin (expressed as a percentage of the width or height) \n     * between the edge of the pie and the link point.\n     * \n     * @return The link margin (as a percentage, where 0.05 is five percent).\n     * \n     * @see #setLabelLinkMargin(double)\n     */\n    public double getLabelLinkMargin() {\n        return this.labelLinkMargin;   \n    }\n    \n    /**\n     * Sets the link margin and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param margin  the margin.\n     * \n     * @see #getLabelLinkMargin()\n     */\n    public void setLabelLinkMargin(double margin) {\n        this.labelLinkMargin = margin;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the paint used for the lines that connect pie sections to their \n     * corresponding labels.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelLinkPaint(Paint)\n     */\n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;   \n    }\n    \n    /**\n     * Sets the paint used for the lines that connect pie sections to their \n     * corresponding labels, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelLinkPaint()\n     */\n    public void setLabelLinkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelLinkPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used for the label linking lines.\n     * \n     * @return The stroke.\n     * \n     * @see #setLabelLinkStroke(Stroke)\n     */\n    public Stroke getLabelLinkStroke() {\n        return this.labelLinkStroke;   \n    }\n    \n    /**\n     * Sets the link stroke and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param stroke  the stroke.\n     * \n     * @see #getLabelLinkStroke()\n     */\n    public void setLabelLinkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.labelLinkStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the section label font.\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the section label font and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     * \n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.labelFont = font;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label paint.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the section label paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label background paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelBackgroundPaint(Paint)\n     */\n    public Paint getLabelBackgroundPaint() {\n        return this.labelBackgroundPaint;\n    }\n\n    /**\n     * Sets the section label background paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelBackgroundPaint()\n     */\n    public void setLabelBackgroundPaint(Paint paint) {\n        this.labelBackgroundPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlinePaint(Paint)\n     */\n    public Paint getLabelOutlinePaint() {\n        return this.labelOutlinePaint;\n    }\n\n    /**\n     * Sets the section label outline paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlinePaint()\n     */\n    public void setLabelOutlinePaint(Paint paint) {\n        this.labelOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlineStroke(Stroke)\n     */\n    public Stroke getLabelOutlineStroke() {\n        return this.labelOutlineStroke;\n    }\n\n    /**\n     * Sets the section label outline stroke and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlineStroke()\n     */\n    public void setLabelOutlineStroke(Stroke stroke) {\n        this.labelOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label shadow paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelShadowPaint(Paint)\n     */\n    public Paint getLabelShadowPaint() {\n        return this.labelShadowPaint;\n    }\n\n    /**\n     * Sets the section label shadow paint and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelShadowPaint()\n     */\n    public void setLabelShadowPaint(Paint paint) {\n        this.labelShadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the label padding.\n     * \n     * @return The label padding (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setLabelPadding(RectangleInsets)\n     */\n    public RectangleInsets getLabelPadding() {\n        return this.labelPadding;\n    }\n    \n    /**\n     * Sets the padding between each label and its outline and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param padding  the padding (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getLabelPadding()\n     */\n    public void setLabelPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.labelPadding = padding;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the flag that controls whether simple or extended labels are\n     * displayed on the plot.\n     * \n     * @return A boolean.\n     * \n     * @since 1.0.7\n     */\n    public boolean getSimpleLabels() {\n        return this.simpleLabels;\n    }\n    \n    /**\n     * Sets the flag that controls whether simple or extended labels are \n     * displayed on the plot, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param simple  the new flag value.\n     * \n     * @since 1.0.7\n     */\n    public void setSimpleLabels(boolean simple) {\n        this.simpleLabels = simple;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the offset used for the simple labels, if they are displayed.\n     * \n     * @return The offset (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setSimpleLabelOffset(RectangleInsets)\n     */\n    public RectangleInsets getSimpleLabelOffset() {\n        return this.simpleLabelOffset;\n    }\n    \n    /**\n     * Sets the offset for the simple labels and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getSimpleLabelOffset()\n     */\n    public void setSimpleLabelOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.simpleLabelOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));        \n    }\n    \n    /**\n     * Returns the object responsible for the vertical layout of the pie \n     * section labels.\n     * \n     * @return The label distributor (never <code>null</code>).\n     * \n     * @since 1.0.6\n     */\n    public AbstractPieLabelDistributor getLabelDistributor() {\n        return this.labelDistributor;\n    }\n    \n    /**\n     * Sets the label distributor and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param distributor  the distributor (<code>null</code> not permitted).\n     *\n     * @since 1.0.6\n     */\n    public void setLabelDistributor(AbstractPieLabelDistributor distributor) {\n        if (distributor == null) {\n            throw new IllegalArgumentException(\"Null 'distributor' argument.\");\n        }\n        this.labelDistributor = distributor;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the tool tip generator, an object that is responsible for \n     * generating the text items used for tool tips by the plot.  If the \n     * generator is <code>null</code>, no tool tips will be created.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setToolTipGenerator(PieToolTipGenerator)\n     */\n    public PieToolTipGenerator getToolTipGenerator() {\n        return this.toolTipGenerator;\n    }\n\n    /**\n     * Sets the tool tip generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  Set the generator to <code>null</code> if you \n     * don't want any tool tips.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getToolTipGenerator()\n     */\n    public void setToolTipGenerator(PieToolTipGenerator generator) {\n        this.toolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the URL generator.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setURLGenerator(PieURLGenerator)\n     */\n    public PieURLGenerator getURLGenerator() {\n        return this.urlGenerator;\n    }\n\n    /**\n     * Sets the URL generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getURLGenerator()\n     */\n    public void setURLGenerator(PieURLGenerator generator) {\n        this.urlGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.\n     *\n     * @return The minimum angle.\n     * \n     * @see #setMinimumArcAngleToDraw(double)\n     */\n    public double getMinimumArcAngleToDraw() {\n        return this.minimumArcAngleToDraw;\n    }\n\n    /**\n     * Sets the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.  See this \n     * link for details:\n     * <br><br>\n     * <a href=\"http://www.jfree.org/phpBB2/viewtopic.php?t=2707\">\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707</a>\n     * <br><br>\n     * ...and this bug report in the Java Bug Parade:\n     * <br><br>\n     * <a href=\n     * \"http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\">\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html</a>\n     *\n     * @param angle  the minimum angle.\n     * \n     * @see #getMinimumArcAngleToDraw()\n     */\n    public void setMinimumArcAngleToDraw(double angle) {\n        this.minimumArcAngleToDraw = angle;\n    }\n    \n    /**\n     * Returns the shape used for legend items.\n     * \n     * @return The shape (never <code>null</code>).\n     * \n     * @see #setLegendItemShape(Shape)\n     */\n    public Shape getLegendItemShape() {\n        return this.legendItemShape;\n    }\n\n    /**\n     * Sets the shape used for legend items and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param shape  the shape (<code>null</code> not permitted).\n     * \n     * @see #getLegendItemShape()\n     */\n    public void setLegendItemShape(Shape shape) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        this.legendItemShape = shape;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label generator.\n     * \n     * @return The legend label generator (never <code>null</code>).\n     * \n     * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelGenerator() {\n        return this.legendLabelGenerator;\n    }\n    \n    /**\n     * Sets the legend label generator and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> not permitted).\n     * \n     * @see #getLegendLabelGenerator()\n     */\n    public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendLabelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label tool tip generator.\n     * \n     * @return The legend label tool tip generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelToolTipGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {\n        return this.legendLabelToolTipGenerator;\n    }\n    \n    /**\n     * Sets the legend label tool tip generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelToolTipGenerator()\n     */\n    public void setLegendLabelToolTipGenerator(\n            PieSectionLabelGenerator generator) {\n        this.legendLabelToolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label URL generator.\n     * \n     * @return The legend label URL generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelURLGenerator(PieURLGenerator)\n     * \n     * @since 1.0.4\n     */\n    public PieURLGenerator getLegendLabelURLGenerator() {\n        return this.legendLabelURLGenerator;\n    }\n    \n    /**\n     * Sets the legend label URL generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelURLGenerator()\n     * \n     * @since 1.0.4\n     */\n    public void setLegendLabelURLGenerator(PieURLGenerator generator) {\n        this.legendLabelURLGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Initialises the drawing procedure.  This method will be called before \n     * the first item is rendered, giving the plot an opportunity to initialise\n     * any state information it wants to maintain.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param plot  the plot.\n     * @param index  the secondary index (<code>null</code> for primary \n     *               renderer).\n     * @param info  collects chart rendering information for return to caller.\n     * \n     * @return A state object (maintains state information relevant to one \n     *         chart drawing).\n     */\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n        if (this.dataset != null) {\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        }\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing \n     *              (<code>null</code> permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                     PlotState parentState, PlotRenderingInfo info) {\n\n        // adjust for insets...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        if (info != null) {\n            info.setPlotArea(area);\n            info.setDataArea(area);\n        }\n\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawPie(g2, area, info);\n        }\n        else {\n            drawNoDataMessage(g2, area);\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, area);\n\n    }\n\n    /**\n     * Draws the pie.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param info  chart rendering info.\n     */\n    protected void drawPie(Graphics2D g2, Rectangle2D plotArea, \n                           PlotRenderingInfo info) {\n\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        // adjust the plot area for interior spacing and labels...\n        double labelReserve = 0.0;\n        if (this.labelGenerator != null && !this.simpleLabels) {\n            labelReserve = this.labelGap + this.maximumLabelWidth;    \n        }\n        double gapHorizontal = plotArea.getWidth() * (this.interiorGap \n                + labelReserve) * 2.0;\n        double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;\n\n        \n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * this.interiorGap;\n            double vGap = plotArea.getHeight() * this.interiorGap;\n        \n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.gray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n        \n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        // make the link area a square if the pie chart is to be circular...\n        if (this.circular) {\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n\n        // the link area defines the dog leg points for the linking lines to \n        // the labels\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH);\n        state.setLinkArea(linkArea);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkArea);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), \n                    linkArea.getWidth(), linkArea.getHeight()));\n        }\n        \n        // the explode area defines the max circle/ellipse for the exploded \n        // pie sections.  it is defined by shrinking the linkArea by the \n        // linkMargin factor.\n        double lm = 0.0;\n        if (!this.simpleLabels) {\n            lm = this.labelLinkMargin;\n        }\n        double hh = linkArea.getWidth() * lm * 2.0;\n        double vv = linkArea.getHeight() * lm * 2.0;\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        // the pie area defines the circle/ellipse for regular pie sections.\n        // it is defined by shrinking the explodeArea by the explodeMargin \n        // factor. \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, \n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        if (DEBUG_DRAW_PIE_AREA) {\n            g2.setPaint(Color.green);\n            g2.draw(pieArea);\n        }\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY());\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius(pieArea.getHeight() / 2.0);\n        \n        // plot the data (unless the dataset is null)...\n        if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {\n\n            List keys = this.dataset.getKeys();\n            double totalValue = DatasetUtilities.calculatePieDatasetTotal(\n                    this.dataset);\n\n            int passesRequired = state.getPassesRequired();\n            for (int pass = 0; pass < passesRequired; pass++) {\n                double runningTotal = 0.0;\n                for (int section = 0; section < keys.size(); section++) {\n                    Number n = this.dataset.getValue(section);\n                    if (n != null) {\n                        double value = n.doubleValue();\n                        if (value > 0.0) {\n                            runningTotal += value;\n                            drawItem(g2, section, explodeArea, state, pass);\n                        }\n                    } \n                }\n            }\n            if (this.simpleLabels) {\n                drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, \n                        state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, plotArea, linkArea, state);\n            }\n\n        }\n        else {\n            drawNoDataMessage(g2, plotArea);\n        }\n    }\n    \n    /**\n     * Draws a single data item.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param section  the section index.\n     * @param dataArea  the data plot area.\n     * @param state  state information for one chart.\n     * @param currentPass  the current pass index.\n     */\n    protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea,\n                            PiePlotState state, int currentPass) {\n    \n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;   \n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n        \n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;         \n        }\n        else {\n            throw new IllegalStateException(\"Rotation type not recognised.\");   \n        }\n        \n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(getSectionKey(section)) / mep;                \n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(), \n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, \n                    Arc2D.PIE);\n            \n            if (currentPass == 0) {\n                if (this.shadowPaint != null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset, \n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, true);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n                \n                // update the linking line target for later\n                // add an entity for the pie section\n                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset, \n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }    \n        state.setLatestAngle(angle2);\n    }\n    \n    /**\n     * Draws the pie section labels in the simple form.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the section keys.\n     * @param totalValue  the total value for all sections in the pie.\n     * @param plotArea  the plot area.\n     * @param pieArea  the area containing the pie.\n     * @param state  the plot state.\n     *\n     * @since 1.0.7\n     */\n    protected void drawSimpleLabels(Graphics2D g2, List keys, \n            double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, \n            PiePlotState state) {\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE, \n                0.18, 0.18, 0.18, 0.18);\n        Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                \n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), \n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n                \n                PieSectionLabelGenerator labelGenerator = getLabelGenerator();\n                if (labelGenerator == null) {\n                    continue;\n                }\n                String label = labelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out, \n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg, \n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null \n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n                \n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(getLabelGenerator()\n                        .generateSectionLabel(getDataset(), key), g2, x, y, \n                        TextAnchor.CENTER);\n                \n            }\n        }\n       \n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the labels for the pie sections.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the keys.\n     * @param totalValue  the total value.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param state  the state.\n     */\n    protected void drawLabels(Graphics2D g2, List keys, double totalValue, \n                              Rectangle2D plotArea, Rectangle2D linkArea, \n                              PiePlotState state) {   \n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        // classify the keys according to which side the label will appear...\n        DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n       \n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n       \n        g2.setFont(getLabelFont());\n        \n        // calculate the max label width from the plot dimensions, because\n        // a circular pie can leave a lot more room for labels...\n        double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n        \n        // draw the labels...\n        if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the left labels.\n     * \n     * @param leftKeys  a collection of keys and angles (to the middle of the\n     *         section, in degrees) for the sections on the left side of the \n     *         plot.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, \n                                  Rectangle2D plotArea, Rectangle2D linkArea, \n                                  float maxLabelWidth, PiePlotState state) {\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {   \n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta) \n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 0.9 \n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }\n    \n    /**\n     * Draws the right labels.\n     * \n     * @param keys  the keys.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawRightLabels(KeyedValues keys, Graphics2D g2, \n                                   Rectangle2D plotArea, Rectangle2D linkArea, \n                                   float maxLabelWidth, PiePlotState state) {\n\n        // draw the right labels...\n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() \n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta), \n                        0.9 + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }\n    \n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items (never <code>null</code>).\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.dataset == null) {\n            return result;\n        }\n        List keys = this.dataset.getKeys();\n        int section = 0;\n        Shape shape = getLegendItemShape();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number n = this.dataset.getValue(key);\n            boolean include = true;\n            if (n == null) {\n                include = !this.ignoreNullValues;   \n            }\n            else {\n                double v = n.doubleValue();\n                if (v == 0.0) {\n                    include = !this.ignoreZeroValues;   \n                }\n                else {\n                    include = v > 0.0;   \n                }\n            }\n            if (include) {\n                String label = this.legendLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label != null) {\n                    String description = label;\n                    String toolTipText = null;\n                    if (this.legendLabelToolTipGenerator != null) {\n                        toolTipText = this.legendLabelToolTipGenerator\n                                .generateSectionLabel(this.dataset, key);\n                    }\n                    String urlText = null;\n                    if (this.legendLabelURLGenerator != null) {\n                        urlText = this.legendLabelURLGenerator.generateURL(\n                                this.dataset, key, this.pieIndex);\n                    }\n                    Paint paint = lookupSectionPaint(key, true);\n                    Paint outlinePaint = lookupSectionOutlinePaint(key);\n                    Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                    LegendItem item = new LegendItem(label, description, \n                            toolTipText, urlText, true, shape, true, paint, \n                            true, outlinePaint, outlineStroke, \n                            false,          // line not visible\n                            new Line2D.Float(), new BasicStroke(), Color.black);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                }\n                section++;\n            }\n            else {\n                section++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Pie_Plot\");\n    }\n\n    /**\n     * Returns a rectangle that can be used to create a pie section (taking\n     * into account the amount by which the pie section is 'exploded').\n     *\n     * @param unexploded  the area inside which the unexploded pie sections are\n     *                    drawn.\n     * @param exploded  the area inside which the exploded pie sections are \n     *                  drawn.\n     * @param angle  the start angle.\n     * @param extent  the extent of the arc.\n     * @param explodePercent  the amount by which the pie section is exploded.\n     *\n     * @return A rectangle that can be used to create a pie section.\n     */\n    protected Rectangle2D getArcBounds(Rectangle2D unexploded, \n                                       Rectangle2D exploded,\n                                       double angle, double extent, \n                                       double explodePercent) {\n\n        if (explodePercent == 0.0) {\n            return unexploded;\n        }\n        else {\n            Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point1 = arc1.getEndPoint();\n            Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point2 = arc2.getEndPoint();\n            double deltaX = (point1.getX() - point2.getX()) * explodePercent;\n            double deltaY = (point1.getY() - point2.getY()) * explodePercent;\n            return new Rectangle2D.Double(unexploded.getX() - deltaX, \n                    unexploded.getY() - deltaY, unexploded.getWidth(), \n                    unexploded.getHeight());\n        }\n    }\n    \n    /**\n     * Draws a section label on the left side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawLeftLabel(Graphics2D g2, PiePlotState state, \n                                 PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n        \n    }\n\n    /**\n     * Draws a section label on the right side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawRightLabel(Graphics2D g2, PiePlotState state, \n                                  PieLabelRecord record) {\n        \n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        \n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n    \n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the \n     * plot's dataset is NOT included in the test for equality.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PiePlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        PiePlot that = (PiePlot) obj;\n        if (this.pieIndex != that.pieIndex) {\n            return false;\n        }\n        if (this.interiorGap != that.interiorGap) {\n            return false;\n        }\n        if (this.circular != that.circular) {\n            return false;\n        }\n        if (this.startAngle != that.startAngle) {\n            return false;\n        }\n        if (this.direction != that.direction) {\n            return false;\n        }\n        if (this.ignoreZeroValues != that.ignoreZeroValues) {\n            return false;\n        }\n        if (this.ignoreNullValues != that.ignoreNullValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionPaintMap, \n                that.sectionPaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.baseSectionPaint, \n                that.baseSectionPaint)) {\n            return false;\n        }\n        if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, \n                that.sectionOutlinePaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.baseSectionOutlinePaint, that.baseSectionOutlinePaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, \n                that.sectionOutlineStrokeMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.baseSectionOutlineStroke, that.baseSectionOutlineStroke\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!(this.shadowXOffset == that.shadowXOffset)) {\n            return false;\n        }\n        if (!(this.shadowYOffset == that.shadowYOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.explodePercentages, \n                that.explodePercentages)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelGenerator, \n                that.labelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelBackgroundPaint, \n                that.labelBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelOutlinePaint, \n                that.labelOutlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelOutlineStroke, \n                that.labelOutlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelShadowPaint, \n                that.labelShadowPaint)) {\n            return false;\n        }\n        if (this.simpleLabels != that.simpleLabels) {\n            return false;\n        }\n        if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {\n            return false;\n        }\n        if (!this.labelPadding.equals(that.labelPadding)) {\n            return false;\n        }\n        if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {\n            return false;\n        }\n        if (!(this.labelGap == that.labelGap)) {\n            return false;\n        }\n        if (!(this.labelLinkMargin == that.labelLinkMargin)) {\n            return false;\n        }\n        if (this.labelLinksVisible != that.labelLinksVisible) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelLinkStroke, \n                that.labelLinkStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGenerator, \n                that.toolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {\n            return false;\n        }\n        if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelGenerator, \n                that.legendLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,\n                that.legendLabelToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelURLGenerator,\n                that.legendLabelURLGenerator)) {\n            return false;\n        }\n        // can't find any difference...\n        return true;\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the plot does \n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        PiePlot clone = (PiePlot) super.clone();\n        if (clone.dataset != null) {\n            clone.dataset.addChangeListener(clone);\n        }\n        if (this.urlGenerator instanceof PublicCloneable) {\n            clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(\n                    this.urlGenerator);\n        }\n        clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);\n        if (this.legendLabelGenerator != null) {\n            clone.legendLabelGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelGenerator);\n        }\n        if (this.legendLabelToolTipGenerator != null) {\n            clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelToolTipGenerator);\n        }\n        if (this.legendLabelURLGenerator instanceof PublicCloneable) {\n            clone.legendLabelURLGenerator = (PieURLGenerator) \n                    ObjectUtilities.clone(this.legendLabelURLGenerator);\n        }\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.baseSectionPaint, stream);\n        SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);\n        SerialUtilities.writePaint(this.shadowPaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.labelBackgroundPaint, stream);\n        SerialUtilities.writePaint(this.labelOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.labelOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelShadowPaint, stream);\n        SerialUtilities.writePaint(this.labelLinkPaint, stream);\n        SerialUtilities.writeStroke(this.labelLinkStroke, stream);\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.baseSectionPaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.labelBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.labelOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelOutlineStroke = SerialUtilities.readStroke(stream);\n        this.labelShadowPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkStroke = SerialUtilities.readStroke(stream);\n        this.legendItemShape = SerialUtilities.readShape(stream);\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 16, "classes_modified": [{"class_name": "org.jfree.data.category.DefaultIntervalCategoryDataset", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------------------------\n * DefaultIntervalCategoryDataset.java\n * -----------------------------------\n * (C) Copyright 2002-2008, by Jeremy Bowman and Contributors.\n *\n * Original Author:  Jeremy Bowman;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 29-Apr-2002 : Version 1, contributed by Jeremy Bowman (DG);\n * 24-Oct-2002 : Amendments for changes made to the dataset interface (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 08-Mar-2007 : Added equals() and clone() overrides (DG);\n * 20-Jun-2007 : Removed deprecated code (DG);\n * 25-Feb-2008 : Fix for the special case where the dataset is empty, see bug \n *               1897580 (DG)\n *\n */\n\npackage org.jfree.data.category;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ResourceBundle;\n\nimport org.jfree.data.DataUtilities;\nimport org.jfree.data.UnknownKeyException;\nimport org.jfree.data.general.AbstractSeriesDataset;\n\n/**\n * A convenience class that provides a default implementation of the\n * {@link IntervalCategoryDataset} interface.\n * <p>\n * The standard constructor accepts data in a two dimensional array where the\n * first dimension is the series, and the second dimension is the category.\n */\npublic class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n        implements IntervalCategoryDataset {\n\n    /** The series keys. */\n    private Comparable[] seriesKeys;\n\n    /** The category keys. */\n    private Comparable[] categoryKeys;\n\n    /** Storage for the start value data. */\n    private Number[][] startData;\n\n    /** Storage for the end value data. */\n    private Number[][] endData;\n\n    /**\n     * Creates a new dataset using the specified data values and automatically\n     * generated series and category keys.\n     *\n     * @param starts  the starting values for the intervals (<code>null</code>\n     *                not permitted).\n     * @param ends  the ending values for the intervals (<code>null</code> not\n     *                permitted).\n     */\n    public DefaultIntervalCategoryDataset(double[][] starts, double[][] ends) {\n        this(DataUtilities.createNumberArray2D(starts),\n                DataUtilities.createNumberArray2D(ends));\n    }\n\n    /**\n     * Constructs a dataset and populates it with data from the array.\n     * <p>\n     * The arrays are indexed as data[series][category].  Series and category\n     * names are automatically generated - you can change them using the\n     * {@link #setSeriesKeys(Comparable[])} and \n     * {@link #setCategoryKeys(Comparable[])} methods.\n     *\n     * @param starts  the start values data.\n     * @param ends  the end values data.\n     */\n    public DefaultIntervalCategoryDataset(Number[][] starts, Number[][] ends) {\n        this(null, null, starts, ends);\n    }\n\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series.\n     * <p>\n     * Category names are generated automatically (\"Category 1\", \"Category 2\",\n     * etc).\n     *\n     * @param seriesNames  the series names (if <code>null</code>, series names\n     *         will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n    public DefaultIntervalCategoryDataset(String[] seriesNames,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this(seriesNames, null, starts, ends);\n\n    }\n\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series and the\n     * supplied objects for the categories.\n     *\n     * @param seriesKeys  the series keys (if <code>null</code>, series keys\n     *         will be generated automatically).\n     * @param categoryKeys  the category keys (if <code>null</code>, category \n     *         keys will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        }\n\n    }\n\n    /**\n     * Returns the number of series in the dataset (possibly zero).\n     *\n     * @return The number of series in the dataset.\n     * \n     * @see #getRowCount()\n     * @see #getCategoryCount()\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        if (this.startData != null) {\n            result = this.startData.length;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a series index.\n     *\n     * @param seriesKey  the series key.\n     *\n     * @return The series index.\n     * \n     * @see #getRowIndex(Comparable)\n     * @see #getSeriesKey(int)\n     */\n    public int getSeriesIndex(Comparable seriesKey) {\n        int result = -1;\n        for (int i = 0; i < this.seriesKeys.length; i++) {\n            if (seriesKey.equals(this.seriesKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the name of the specified series.\n     *\n     * @param series  the index of the required series (zero-based).\n     *\n     * @return The name of the specified series.\n     * \n     * @see #getSeriesIndex(Comparable)\n     */\n    public Comparable getSeriesKey(int series) {\n        if ((series >= getSeriesCount()) || (series < 0)) {\n            throw new IllegalArgumentException(\"No such series : \" + series);\n        }\n        return this.seriesKeys[series];\n    }\n\n    /**\n     * Sets the names of the series in the dataset.\n     *\n     * @param seriesKeys  the new keys (<code>null</code> not permitted, the \n     *         length of the array must match the number of series in the \n     *         dataset).\n     *         \n     * @see #setCategoryKeys(Comparable[])\n     */\n    public void setSeriesKeys(Comparable[] seriesKeys) {\n        if (seriesKeys == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKeys' argument.\");\n        }\n        if (seriesKeys.length != getSeriesCount()) {\n            throw new IllegalArgumentException(\n                    \"The number of series keys does not match the data.\");\n        }\n        this.seriesKeys = seriesKeys;\n        fireDatasetChanged();\n    }\n\n    /**\n     * Returns the number of categories in the dataset.\n     *\n     * @return The number of categories in the dataset.\n     * \n     * @see #getColumnCount()\n     */\n    public int getCategoryCount() {\n        int result = 0;\n        if (this.startData != null) {\n            if (getSeriesCount() > 0) {\n                result = this.startData[0].length;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories in the dataset.  This method supports \n     * the {@link CategoryDataset} interface.\n     *\n     * @return A list of the categories in the dataset.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        // the CategoryDataset interface expects a list of categories, but\n        // we've stored them in an array...\n        if (this.categoryKeys == null) {\n            return new ArrayList();\n        }\n        else {\n            return Collections.unmodifiableList(Arrays.asList(\n                    this.categoryKeys));\n        }\n    }\n\n    /**\n     * Sets the categories for the dataset.\n     *\n     * @param categoryKeys  an array of objects representing the categories in \n     *                      the dataset.\n     *                      \n     * @see #getRowKeys()\n     * @see #setSeriesKeys(Comparable[])\n     */\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     * \n     * @param series    The required series (zero based index).\n     * @param category  The required category.\n     * \n     * @return The data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(int, int)\n     */\n    public Number getValue(int series, int category) {\n        return getEndValue(series, category);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series \n     *         (possibly <code>null</code>).\n     *         \n     * @see #getStartValue(int, int)\n     */\n    public Number getStartValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getStartValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series \n     *         (possibly <code>null</code>).\n     *         \n     * @see #getStartValue(Comparable, Comparable)\n     */\n    public Number getStartValue(int series, int category) {\n\n        // check arguments...\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        // fetch the value...\n        return this.startData[series][category];\n\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(int, int)\n     */\n    public Number getEndValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getEndValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getEndValue(int series, int category) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        return this.endData[series][category];\n    }\n\n    /**\n     * Sets the start data value for one category in a series.\n     * \n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     * \n     * @param value The value.\n     * \n     * @see #setEndValue(int, Comparable, Number)\n     */\n    public void setStartValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.startData[series][categoryIndex] = value;\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Sets the end data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value the value.\n     * \n     * @see #setStartValue(int, Comparable, Number)\n     */\n    public void setEndValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.endData[series][categoryIndex] = value;\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Returns the index for the given category.\n     *\n     * @param category  the category (<code>null</code> not permitted).\n     *\n     * @return The index.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public int getCategoryIndex(Comparable category) {\n        int result = -1;\n        for (int i = 0; i < this.categoryKeys.length; i++) {\n            if (category.equals(this.categoryKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Generates an array of keys, by appending a space plus an integer\n     * (starting with 1) to the supplied prefix string.\n     *\n     * @param count  the number of keys required.\n     * @param prefix  the name prefix.\n     *\n     * @return An array of <i>prefixN</i> with N = { 1 .. count}.\n     */\n    private Comparable[] generateKeys(int count, String prefix) {\n        Comparable[] result = new Comparable[count];\n        String name;\n        for (int i = 0; i < count; i++) {\n            name = prefix + (i + 1);\n            result[i] = name;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a column key.\n     *\n     * @param column  the column index.\n     *\n     * @return The column key.\n     * \n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return this.categoryKeys[column];\n    }\n\n    /**\n     * Returns a column index.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     * \n     * @see #getCategoryIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable columnKey) {\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        return getCategoryIndex(columnKey);\n    }\n\n    /**\n     * Returns a row index.\n     *\n     * @param rowKey  the row key.\n     *\n     * @return The row index.\n     * \n     * @see #getSeriesIndex(Comparable)\n     */\n    public int getRowIndex(Comparable rowKey) {\n        return getSeriesIndex(rowKey);\n    }\n\n    /**\n     * Returns a list of the series in the dataset.  This method supports the \n     * {@link CategoryDataset} interface.\n     *\n     * @return A list of the series in the dataset.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        // the CategoryDataset interface expects a list of series, but\n        // we've stored them in an array...\n        if (this.seriesKeys == null) {\n            return new java.util.ArrayList();\n        }\n        else {\n            return Collections.unmodifiableList(Arrays.asList(this.seriesKeys));\n        }\n    }\n\n    /**\n     * Returns the name of the specified series.\n     *\n     * @param row  the index of the required row/series (zero-based).\n     *\n     * @return The name of the specified series.\n     * \n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        if ((row >= getRowCount()) || (row < 0)) {\n            throw new IllegalArgumentException(\n                    \"The 'row' argument is out of bounds.\");\n        }\n        return this.seriesKeys[row];\n    }\n\n    /**\n     * Returns the number of categories in the dataset.  This method is part of \n     * the {@link CategoryDataset} interface.\n     *\n     * @return The number of categories in the dataset.\n     * \n     * @see #getCategoryCount()\n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.categoryKeys.length;\n    }\n\n    /**\n     * Returns the number of series in the dataset (possibly zero).\n     *\n     * @return The number of series in the dataset.\n     * \n     * @see #getSeriesCount()\n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.seriesKeys.length;\n    }\n    \n    /**\n     * Tests this dataset for equality with an arbitrary object.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof DefaultIntervalCategoryDataset)) {\n            return false;\n        }\n        DefaultIntervalCategoryDataset that \n                = (DefaultIntervalCategoryDataset) obj;\n        if (!Arrays.equals(this.seriesKeys, that.seriesKeys)) {\n            return false;\n        }\n        if (!Arrays.equals(this.categoryKeys, that.categoryKeys)) {\n            return false;\n        }\n        if (!equal(this.startData, that.startData)) {\n            return false;\n        }\n        if (!equal(this.endData, that.endData)) {\n            return false;\n        }\n        // seem to be the same...\n        return true;\n    }\n\n    /**\n     * Returns a clone of this dataset.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if there is a problem cloning the\n     *         dataset.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultIntervalCategoryDataset clone \n                = (DefaultIntervalCategoryDataset) super.clone();\n        clone.categoryKeys = (Comparable[]) this.categoryKeys.clone();\n        clone.seriesKeys = (Comparable[]) this.seriesKeys.clone();\n        clone.startData = clone(this.startData);\n        clone.endData = clone(this.endData);\n        return clone;\n    }\n    \n    /**\n     * Tests two double[][] arrays for equality.\n     * \n     * @param array1  the first array (<code>null</code> permitted).\n     * @param array2  the second arrray (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    private static boolean equal(Number[][] array1, Number[][] array2) {\n        if (array1 == null) {\n            return (array2 == null);\n        }\n        if (array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n        for (int i = 0; i < array1.length; i++) {\n            if (!Arrays.equals(array1[i], array2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Clones a two dimensional array of <code>Number</code> objects.\n     * \n     * @param array  the array (<code>null</code> not permitted).\n     * \n     * @return A clone of the array.\n     */\n    private static Number[][] clone(Number[][] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"Null 'array' argument.\");\n        }\n        Number[][] result = new Number[array.length][];\n        for (int i = 0; i < array.length; i++) {\n            Number[] child = array[i];\n            Number[] copychild = new Number[child.length];\n            System.arraycopy(child, 0, copychild, 0, child.length);\n            result[i] = copychild;\n        }\n        return result;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------------------------\n * DefaultIntervalCategoryDataset.java\n * -----------------------------------\n * (C) Copyright 2002-2008, by Jeremy Bowman and Contributors.\n *\n * Original Author:  Jeremy Bowman;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 29-Apr-2002 : Version 1, contributed by Jeremy Bowman (DG);\n * 24-Oct-2002 : Amendments for changes made to the dataset interface (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 08-Mar-2007 : Added equals() and clone() overrides (DG);\n * 20-Jun-2007 : Removed deprecated code (DG);\n * 25-Feb-2008 : Fix for the special case where the dataset is empty, see bug \n *               1897580 (DG)\n *\n */\n\npackage org.jfree.data.category;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.ResourceBundle;\n\nimport org.jfree.data.DataUtilities;\nimport org.jfree.data.UnknownKeyException;\nimport org.jfree.data.general.AbstractSeriesDataset;\n\n/**\n * A convenience class that provides a default implementation of the\n * {@link IntervalCategoryDataset} interface.\n * <p>\n * The standard constructor accepts data in a two dimensional array where the\n * first dimension is the series, and the second dimension is the category.\n */\npublic class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n        implements IntervalCategoryDataset {\n\n    /** The series keys. */\n    private Comparable[] seriesKeys;\n\n    /** The category keys. */\n    private Comparable[] categoryKeys;\n\n    /** Storage for the start value data. */\n    private Number[][] startData;\n\n    /** Storage for the end value data. */\n    private Number[][] endData;\n\n    /**\n     * Creates a new dataset using the specified data values and automatically\n     * generated series and category keys.\n     *\n     * @param starts  the starting values for the intervals (<code>null</code>\n     *                not permitted).\n     * @param ends  the ending values for the intervals (<code>null</code> not\n     *                permitted).\n     */\n    public DefaultIntervalCategoryDataset(double[][] starts, double[][] ends) {\n        this(DataUtilities.createNumberArray2D(starts),\n                DataUtilities.createNumberArray2D(ends));\n    }\n\n    /**\n     * Constructs a dataset and populates it with data from the array.\n     * <p>\n     * The arrays are indexed as data[series][category].  Series and category\n     * names are automatically generated - you can change them using the\n     * {@link #setSeriesKeys(Comparable[])} and \n     * {@link #setCategoryKeys(Comparable[])} methods.\n     *\n     * @param starts  the start values data.\n     * @param ends  the end values data.\n     */\n    public DefaultIntervalCategoryDataset(Number[][] starts, Number[][] ends) {\n        this(null, null, starts, ends);\n    }\n\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series.\n     * <p>\n     * Category names are generated automatically (\"Category 1\", \"Category 2\",\n     * etc).\n     *\n     * @param seriesNames  the series names (if <code>null</code>, series names\n     *         will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n    public DefaultIntervalCategoryDataset(String[] seriesNames,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this(seriesNames, null, starts, ends);\n\n    }\n\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series and the\n     * supplied objects for the categories.\n     *\n     * @param seriesKeys  the series keys (if <code>null</code>, series keys\n     *         will be generated automatically).\n     * @param categoryKeys  the category keys (if <code>null</code>, category \n     *         keys will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        }\n\n    }\n\n    /**\n     * Returns the number of series in the dataset (possibly zero).\n     *\n     * @return The number of series in the dataset.\n     * \n     * @see #getRowCount()\n     * @see #getCategoryCount()\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        if (this.startData != null) {\n            result = this.startData.length;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a series index.\n     *\n     * @param seriesKey  the series key.\n     *\n     * @return The series index.\n     * \n     * @see #getRowIndex(Comparable)\n     * @see #getSeriesKey(int)\n     */\n    public int getSeriesIndex(Comparable seriesKey) {\n        int result = -1;\n        for (int i = 0; i < this.seriesKeys.length; i++) {\n            if (seriesKey.equals(this.seriesKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the name of the specified series.\n     *\n     * @param series  the index of the required series (zero-based).\n     *\n     * @return The name of the specified series.\n     * \n     * @see #getSeriesIndex(Comparable)\n     */\n    public Comparable getSeriesKey(int series) {\n        if ((series >= getSeriesCount()) || (series < 0)) {\n            throw new IllegalArgumentException(\"No such series : \" + series);\n        }\n        return this.seriesKeys[series];\n    }\n\n    /**\n     * Sets the names of the series in the dataset.\n     *\n     * @param seriesKeys  the new keys (<code>null</code> not permitted, the \n     *         length of the array must match the number of series in the \n     *         dataset).\n     *         \n     * @see #setCategoryKeys(Comparable[])\n     */\n    public void setSeriesKeys(Comparable[] seriesKeys) {\n        if (seriesKeys == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKeys' argument.\");\n        }\n        if (seriesKeys.length != getSeriesCount()) {\n            throw new IllegalArgumentException(\n                    \"The number of series keys does not match the data.\");\n        }\n        this.seriesKeys = seriesKeys;\n        fireDatasetChanged();\n    }\n\n    /**\n     * Returns the number of categories in the dataset.\n     *\n     * @return The number of categories in the dataset.\n     * \n     * @see #getColumnCount()\n     */\n    public int getCategoryCount() {\n        int result = 0;\n        if (this.startData != null) {\n            if (getSeriesCount() > 0) {\n                result = this.startData[0].length;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories in the dataset.  This method supports \n     * the {@link CategoryDataset} interface.\n     *\n     * @return A list of the categories in the dataset.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        // the CategoryDataset interface expects a list of categories, but\n        // we've stored them in an array...\n        if (this.categoryKeys == null) {\n            return new ArrayList();\n        }\n        else {\n            return Collections.unmodifiableList(Arrays.asList(\n                    this.categoryKeys));\n        }\n    }\n\n    /**\n     * Sets the categories for the dataset.\n     *\n     * @param categoryKeys  an array of objects representing the categories in \n     *                      the dataset.\n     *                      \n     * @see #getRowKeys()\n     * @see #setSeriesKeys(Comparable[])\n     */\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (categoryKeys.length != getCategoryCount()) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     * \n     * @param series    The required series (zero based index).\n     * @param category  The required category.\n     * \n     * @return The data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the data value for one category in a series.\n     * <P>\n     * This method is part of the CategoryDataset interface.  Not particularly\n     * meaningful for this class...returns the end value.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(int, int)\n     */\n    public Number getValue(int series, int category) {\n        return getEndValue(series, category);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series \n     *         (possibly <code>null</code>).\n     *         \n     * @see #getStartValue(int, int)\n     */\n    public Number getStartValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getStartValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the start data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The start data value for one category in a series \n     *         (possibly <code>null</code>).\n     *         \n     * @see #getStartValue(Comparable, Comparable)\n     */\n    public Number getStartValue(int series, int category) {\n\n        // check arguments...\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        // fetch the value...\n        return this.startData[series][category];\n\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series.\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(int, int)\n     */\n    public Number getEndValue(Comparable series, Comparable category) {\n        int seriesIndex = getSeriesIndex(series);\n        if (seriesIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'series' key.\");\n        }\n        int itemIndex = getColumnIndex(category);\n        if (itemIndex < 0) {\n            throw new UnknownKeyException(\"Unknown 'category' key.\");\n        }\n        return getEndValue(seriesIndex, itemIndex);\n    }\n\n    /**\n     * Returns the end data value for one category in a series.\n     *\n     * @param series  the required series (zero based index).\n     * @param category  the required category.\n     *\n     * @return The end data value for one category in a series (null possible).\n     * \n     * @see #getEndValue(Comparable, Comparable)\n     */\n    public Number getEndValue(int series, int category) {\n        if ((series < 0) || (series >= getSeriesCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"series index out of range.\");\n        }\n\n        if ((category < 0) || (category >= getCategoryCount())) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.getValue(): \"\n                + \"category index out of range.\");\n        }\n\n        return this.endData[series][category];\n    }\n\n    /**\n     * Sets the start data value for one category in a series.\n     * \n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     * \n     * @param value The value.\n     * \n     * @see #setEndValue(int, Comparable, Number)\n     */\n    public void setStartValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.startData[series][categoryIndex] = value;\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Sets the end data value for one category in a series.\n     *\n     * @param series  the series (zero-based index).\n     * @param category  the category.\n     *\n     * @param value the value.\n     * \n     * @see #setStartValue(int, Comparable, Number)\n     */\n    public void setEndValue(int series, Comparable category, Number value) {\n\n        // does the series exist?\n        if ((series < 0) || (series > getSeriesCount() - 1)) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"series outside valid range.\");\n        }\n\n        // is the category valid?\n        int categoryIndex = getCategoryIndex(category);\n        if (categoryIndex < 0) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setValue: \"\n                + \"unrecognised category.\");\n        }\n\n        // update the data...\n        this.endData[series][categoryIndex] = value;\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Returns the index for the given category.\n     *\n     * @param category  the category (<code>null</code> not permitted).\n     *\n     * @return The index.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public int getCategoryIndex(Comparable category) {\n        int result = -1;\n        for (int i = 0; i < this.categoryKeys.length; i++) {\n            if (category.equals(this.categoryKeys[i])) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Generates an array of keys, by appending a space plus an integer\n     * (starting with 1) to the supplied prefix string.\n     *\n     * @param count  the number of keys required.\n     * @param prefix  the name prefix.\n     *\n     * @return An array of <i>prefixN</i> with N = { 1 .. count}.\n     */\n    private Comparable[] generateKeys(int count, String prefix) {\n        Comparable[] result = new Comparable[count];\n        String name;\n        for (int i = 0; i < count; i++) {\n            name = prefix + (i + 1);\n            result[i] = name;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a column key.\n     *\n     * @param column  the column index.\n     *\n     * @return The column key.\n     * \n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return this.categoryKeys[column];\n    }\n\n    /**\n     * Returns a column index.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     * \n     * @see #getCategoryIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable columnKey) {\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        return getCategoryIndex(columnKey);\n    }\n\n    /**\n     * Returns a row index.\n     *\n     * @param rowKey  the row key.\n     *\n     * @return The row index.\n     * \n     * @see #getSeriesIndex(Comparable)\n     */\n    public int getRowIndex(Comparable rowKey) {\n        return getSeriesIndex(rowKey);\n    }\n\n    /**\n     * Returns a list of the series in the dataset.  This method supports the \n     * {@link CategoryDataset} interface.\n     *\n     * @return A list of the series in the dataset.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        // the CategoryDataset interface expects a list of series, but\n        // we've stored them in an array...\n        if (this.seriesKeys == null) {\n            return new java.util.ArrayList();\n        }\n        else {\n            return Collections.unmodifiableList(Arrays.asList(this.seriesKeys));\n        }\n    }\n\n    /**\n     * Returns the name of the specified series.\n     *\n     * @param row  the index of the required row/series (zero-based).\n     *\n     * @return The name of the specified series.\n     * \n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        if ((row >= getRowCount()) || (row < 0)) {\n            throw new IllegalArgumentException(\n                    \"The 'row' argument is out of bounds.\");\n        }\n        return this.seriesKeys[row];\n    }\n\n    /**\n     * Returns the number of categories in the dataset.  This method is part of \n     * the {@link CategoryDataset} interface.\n     *\n     * @return The number of categories in the dataset.\n     * \n     * @see #getCategoryCount()\n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.categoryKeys.length;\n    }\n\n    /**\n     * Returns the number of series in the dataset (possibly zero).\n     *\n     * @return The number of series in the dataset.\n     * \n     * @see #getSeriesCount()\n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.seriesKeys.length;\n    }\n    \n    /**\n     * Tests this dataset for equality with an arbitrary object.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof DefaultIntervalCategoryDataset)) {\n            return false;\n        }\n        DefaultIntervalCategoryDataset that \n                = (DefaultIntervalCategoryDataset) obj;\n        if (!Arrays.equals(this.seriesKeys, that.seriesKeys)) {\n            return false;\n        }\n        if (!Arrays.equals(this.categoryKeys, that.categoryKeys)) {\n            return false;\n        }\n        if (!equal(this.startData, that.startData)) {\n            return false;\n        }\n        if (!equal(this.endData, that.endData)) {\n            return false;\n        }\n        // seem to be the same...\n        return true;\n    }\n\n    /**\n     * Returns a clone of this dataset.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if there is a problem cloning the\n     *         dataset.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultIntervalCategoryDataset clone \n                = (DefaultIntervalCategoryDataset) super.clone();\n        clone.categoryKeys = (Comparable[]) this.categoryKeys.clone();\n        clone.seriesKeys = (Comparable[]) this.seriesKeys.clone();\n        clone.startData = clone(this.startData);\n        clone.endData = clone(this.endData);\n        return clone;\n    }\n    \n    /**\n     * Tests two double[][] arrays for equality.\n     * \n     * @param array1  the first array (<code>null</code> permitted).\n     * @param array2  the second arrray (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    private static boolean equal(Number[][] array1, Number[][] array2) {\n        if (array1 == null) {\n            return (array2 == null);\n        }\n        if (array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n        for (int i = 0; i < array1.length; i++) {\n            if (!Arrays.equals(array1[i], array2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Clones a two dimensional array of <code>Number</code> objects.\n     * \n     * @param array  the array (<code>null</code> not permitted).\n     * \n     * @return A clone of the array.\n     */\n    private static Number[][] clone(Number[][] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"Null 'array' argument.\");\n        }\n        Number[][] result = new Number[array.length][];\n        for (int i = 0; i < array.length; i++) {\n            Number[] child = array[i];\n            Number[] copychild = new Number[child.length];\n            System.arraycopy(child, 0, copychild, 0, child.length);\n            result[i] = copychild;\n        }\n        return result;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 17, "classes_modified": [{"class_name": "org.jfree.data.time.TimeSeries", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors \n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented \n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for \n *               contents) made a method and added to addOrUpdate.  Made a \n *               public method to enable ageing against a specified time \n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.  \n *               Modified exception message in add() method to be more \n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report \n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500 \n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to \n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * \n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value).\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n    \n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /** \n     * The maximum age of items for the series, specified as a number of\n     * time periods. \n     */\n    private long maximumItemAge;\n    \n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is \n     * created.  Use one of the other constructors if you require a different \n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                Day.class);\n    }\n\n    /**\n     * Creates a new (empty) time series with the specified name and class\n     * of {@link RegularTimePeriod}.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                timePeriodClass);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, String domain, String range, \n                      Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     * \n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     * \n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains \n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     * \n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.  \n     * If you add a new item to the series such that the number of items will \n     * exceed the maximum item count, then the FIRST element in the series is \n     * automatically removed, ensuring that the maximum item count is not \n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     * \n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     * \n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This \n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically \n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     * \n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (never <code>null</code>).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item for the series.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     * \n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the data item for a specific period.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or \n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time \n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        } \n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the \n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n        \n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a \n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \" \n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(), \n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          double value) {\n        return this.addOrUpdate(period, new Double(value));    \n    }\n    \n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");   \n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing \n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to \n     * the oldest record in the series does not exceed maximumItemAge time \n     * periods.  Oldest items will be removed if required.\n     * \n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history \n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex()) \n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied \n     * time to the oldest record in the series does not exceed history count.  \n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data \n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n        \n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE; \n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class, \n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        \n        // check if there are any values earlier than specified by the history \n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index \n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not \n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item \n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time \n     * series.\n     *\n     * @param start  the first time period to copy.\n     * @param end  the last time period to copy.\n     *\n     * @return A time series containing a copy of this time series from start \n     *         until end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end \n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(\n            getDomainDescription(), s.getDomainDescription()\n        )) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(\n            getRangeDescription(), s.getRangeDescription()\n        )) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode() \n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null \n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors \n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented \n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for \n *               contents) made a method and added to addOrUpdate.  Made a \n *               public method to enable ageing against a specified time \n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.  \n *               Modified exception message in add() method to be more \n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report \n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500 \n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to \n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * \n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value).\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n    \n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /** \n     * The maximum age of items for the series, specified as a number of\n     * time periods. \n     */\n    private long maximumItemAge;\n    \n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is \n     * created.  Use one of the other constructors if you require a different \n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                Day.class);\n    }\n\n    /**\n     * Creates a new (empty) time series with the specified name and class\n     * of {@link RegularTimePeriod}.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                timePeriodClass);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, String domain, String range, \n                      Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     * \n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     * \n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains \n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     * \n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.  \n     * If you add a new item to the series such that the number of items will \n     * exceed the maximum item count, then the FIRST element in the series is \n     * automatically removed, ensuring that the maximum item count is not \n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     * \n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     * \n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This \n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically \n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     * \n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (never <code>null</code>).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item for the series.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     * \n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the data item for a specific period.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or \n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time \n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        } \n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the \n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n        \n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a \n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \" \n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(), \n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          double value) {\n        return this.addOrUpdate(period, new Double(value));    \n    }\n    \n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");   \n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing \n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to \n     * the oldest record in the series does not exceed maximumItemAge time \n     * periods.  Oldest items will be removed if required.\n     * \n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history \n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex()) \n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied \n     * time to the oldest record in the series does not exceed history count.  \n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data \n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n        \n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE; \n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class, \n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        \n        // check if there are any values earlier than specified by the history \n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index \n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not \n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        TimeSeries clone = (TimeSeries) super.clone();\n        clone.data = (List) ObjectUtilities.deepClone(this.data);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item \n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time \n     * series.\n     *\n     * @param start  the first time period to copy.\n     * @param end  the last time period to copy.\n     *\n     * @return A time series containing a copy of this time series from start \n     *         until end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end \n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(\n            getDomainDescription(), s.getDomainDescription()\n        )) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(\n            getRangeDescription(), s.getRangeDescription()\n        )) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode() \n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null \n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 18, "classes_modified": [{"class_name": "org.jfree.data.DefaultKeyedValues", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------------\n * DefaultKeyedValues.java\n * -----------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Thomas Morgner;\n *\n * Changes:\n * --------\n * 31-Oct-2002 : Version 1 (DG);\n * 11-Feb-2003 : Fixed bug in getValue(key) method for unrecognised key (DG);\n * 05-Mar-2003 : Added methods to sort stored data 'by key' or 'by value' (DG);\n * 13-Mar-2003 : Implemented Serializable (DG);\n * 08-Apr-2003 : Modified removeValue(Comparable) method to fix bug 717049 (DG);\n * 18-Aug-2003 : Implemented Cloneable (DG);\n * 27-Aug-2003 : Moved SortOrder from org.jfree.data --> org.jfree.util (DG);\n * 09-Feb-2004 : Modified getIndex() method - see bug report 893256 (DG);\n * 15-Sep-2004 : Updated clone() method and added PublicCloneable \n *               interface (DG);\n * 25-Nov-2004 : Small update to the clone() implementation (DG);\n * 24-Feb-2005 : Added methods addValue(Comparable, double) and \n *               setValue(Comparable, double) for convenience (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 31-Jul-2006 : Added a clear() method (DG);\n * 01-Aug-2006 : Added argument check to getIndex() method (DG);\n * 30-Apr-2007 : Added insertValue() methods (DG);\n * 31-Oct-2007 : Performance improvements by using separate lists for keys and \n *               values (TM);\n * 21-Nov-2007 : Fixed bug in removeValue() method from previous patch (DG);\n *               \n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.SortOrder;\n\n/**\n * An ordered list of (key, value) items.  This class provides a default \n * implementation of the {@link KeyedValues} interface.\n */\npublic class DefaultKeyedValues implements KeyedValues, \n                                           Cloneable, PublicCloneable, \n                                           Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 8468154364608194797L;\n    \n    /** Storage for the keys. */\n    private ArrayList keys;\n    \n    /** Storage for the values. */\n    private ArrayList values;\n    \n    /** \n     * Contains (key, Integer) mappings, where the Integer is the index for\n     * the key in the list. \n     */\n    private HashMap indexMap; \n\n  /**\n     * Creates a new collection (initially empty).\n     */\n    public DefaultKeyedValues() {\n        this.keys = new ArrayList();\n        this.values = new ArrayList();\n        this.indexMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of items (values) in the collection.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.indexMap.size();\n    }\n\n    /**\n     * Returns a value.\n     *\n     * @param item  the item of interest (zero-based index).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Number getValue(int item) {\n        return (Number) this.values.get(item);\n    }\n\n    /**\n     * Returns a key.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The row key.\n     * \n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Comparable getKey(int index) {\n        return (Comparable) this.keys.get(index);\n    }\n\n    /**\n     * Returns the index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The index, or <code>-1</code> if the key is not recognised.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     */\n    public int getIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        final Integer i = (Integer) this.indexMap.get(key);\n        if (i == null) {\n            return -1;  // key not found\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Returns the keys for the values in the collection.\n     *\n     * @return The keys (never <code>null</code>).\n     */\n    public List getKeys() {\n        return (List) this.keys.clone();\n    }\n\n    /**\n     * Returns the value for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @throws UnknownKeyException if the key is not recognised.\n     * \n     * @see #getValue(int)\n     */\n    public Number getValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n            throw new UnknownKeyException(\"Key not found: \" + key);\n        }\n        return getValue(index);\n    }\n\n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @see #addValue(Comparable, Number)\n     */\n    public void addValue(Comparable key, double value) {\n        addValue(key, new Double(value)); \n    }\n    \n    /**\n     * Adds a new value to the collection, or updates an existing value.\n     * This method passes control directly to the \n     * {@link #setValue(Comparable, Number)} method.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void addValue(Comparable key, Number value) {\n        setValue(key, value);\n    }\n\n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void setValue(Comparable key, double value) {\n        setValue(key, new Double(value));   \n    }\n    \n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void setValue(Comparable key, Number value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int keyIndex = getIndex(key);\n        if (keyIndex >= 0) {\n            this.keys.set(keyIndex, key);\n            this.values.set(keyIndex, value);\n        }\n        else {\n            this.keys.add(key);\n            this.values.add(value);\n            this.indexMap.put(key, new Integer(this.keys.size() - 1));\n        }\n    }\n    \n    /**\n     * Inserts a new value at the specified position in the dataset or, if\n     * there is an existing item with the specified key, updates the value \n     * for that item and moves it to the specified position.\n     * \n     * @param position  the position (in the range 0 to getItemCount()).\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @since 1.0.6\n     */\n    public void insertValue(int position, Comparable key, double value) {\n        insertValue(position, key, new Double(value));\n    }\n\n    /**\n     * Inserts a new value at the specified position in the dataset or, if\n     * there is an existing item with the specified key, updates the value \n     * for that item and moves it to the specified position.\n     * \n     * @param position  the position (in the range 0 to getItemCount()).\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * \n     * @since 1.0.6\n     */\n    public void insertValue(int position, Comparable key, Number value) {\n        if (position < 0 || position > getItemCount()) {\n            throw new IllegalArgumentException(\"'position' out of bounds.\");\n        }\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int pos = getIndex(key);\n        if (pos == position) {\n            this.keys.set(pos, key);\n            this.values.set(pos, value);\n        }\n        else {\n            if (pos >= 0) {\n                this.keys.remove(pos);\n                this.values.remove(pos);\n            }\n          \n            this.keys.add(position, key);\n            this.values.add(position, value);\n            rebuildIndex();\n        }\n    }\n\n    /**\n     * Rebuilds the key to indexed-position mapping after an positioned insert\n     * or a remove operation.\n     */\n    private void rebuildIndex () {\n        this.indexMap.clear();\n        for (int i = 0; i < this.keys.size(); i++) {\n            final Object key = this.keys.get(i);\n            this.indexMap.put(key, new Integer(i));\n        }\n    }\n\n    /**\n     * Removes a value from the collection.\n     *\n     * @param index  the index of the item to remove (in the range \n     *     <code>0</code> to <code>getItemCount() - 1</code>).\n     *     \n     * @throws IndexOutOfBoundsException if <code>index</code> is not within\n     *     the specified range.\n     */\n    public void removeValue(int index) {\n        this.keys.remove(index);\n        this.values.remove(index);\n        if (index < this.keys.size()) {\n        rebuildIndex();\n        }\n    }\n\n    /**\n     * Removes a value from the collection.\n     *\n     * @param key  the item key (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * @throws UnknownKeyException if <code>key</code> is not recognised.\n     */\n    public void removeValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n\t\t\treturn;\n        }\n        removeValue(index);\n    }\n    \n    /**\n     * Clears all values from the collection.\n     * \n     * @since 1.0.2\n     */\n    public void clear() {\n        this.keys.clear();\n        this.values.clear();\n        this.indexMap.clear();\n    }\n\n    /**\n     * Sorts the items in the list by key.\n     *\n     * @param order  the sort order (<code>null</code> not permitted).\n     */\n    public void sortByKeys(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), \n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_KEY, order);\n        Arrays.sort(data, comparator);\n        clear();\n\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }\n\n    /**\n     * Sorts the items in the list by value.  If the list contains \n     * <code>null</code> values, they will sort to the end of the list, \n     * irrespective of the sort order.\n     *\n     * @param order  the sort order (<code>null</code> not permitted).\n     */\n    public void sortByValues(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), \n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_VALUE, order);\n        Arrays.sort(data, comparator);\n\n        clear();\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }\n\n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n\n        if (!(obj instanceof KeyedValues)) {\n            return false;\n        }\n\n        KeyedValues that = (KeyedValues) obj;\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            Comparable k1 = getKey(i);\n            Comparable k2 = that.getKey(i);\n            if (!k1.equals(k2)) {\n                return false;\n            }\n            Number v1 = getValue(i);\n            Number v2 = that.getValue(i);\n            if (v1 == null) {\n                if (v2 != null) {\n                    return false;\n                }\n            }\n            else {\n                if (!v1.equals(v2)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     * \n     * @return A hash code.\n     */\n    public int hashCode() {\n        return (this.keys != null ? this.keys.hashCode() : 0);\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues clone = (DefaultKeyedValues) super.clone();\n        clone.keys = (ArrayList) this.keys.clone();\n        clone.values = (ArrayList) this.values.clone();\n        clone.indexMap = (HashMap) this.indexMap.clone();\n        return clone;\n    }\n    \n}", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------------\n * DefaultKeyedValues.java\n * -----------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Thomas Morgner;\n *\n * Changes:\n * --------\n * 31-Oct-2002 : Version 1 (DG);\n * 11-Feb-2003 : Fixed bug in getValue(key) method for unrecognised key (DG);\n * 05-Mar-2003 : Added methods to sort stored data 'by key' or 'by value' (DG);\n * 13-Mar-2003 : Implemented Serializable (DG);\n * 08-Apr-2003 : Modified removeValue(Comparable) method to fix bug 717049 (DG);\n * 18-Aug-2003 : Implemented Cloneable (DG);\n * 27-Aug-2003 : Moved SortOrder from org.jfree.data --> org.jfree.util (DG);\n * 09-Feb-2004 : Modified getIndex() method - see bug report 893256 (DG);\n * 15-Sep-2004 : Updated clone() method and added PublicCloneable \n *               interface (DG);\n * 25-Nov-2004 : Small update to the clone() implementation (DG);\n * 24-Feb-2005 : Added methods addValue(Comparable, double) and \n *               setValue(Comparable, double) for convenience (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 31-Jul-2006 : Added a clear() method (DG);\n * 01-Aug-2006 : Added argument check to getIndex() method (DG);\n * 30-Apr-2007 : Added insertValue() methods (DG);\n * 31-Oct-2007 : Performance improvements by using separate lists for keys and \n *               values (TM);\n * 21-Nov-2007 : Fixed bug in removeValue() method from previous patch (DG);\n *               \n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.SortOrder;\n\n/**\n * An ordered list of (key, value) items.  This class provides a default \n * implementation of the {@link KeyedValues} interface.\n */\npublic class DefaultKeyedValues implements KeyedValues, \n                                           Cloneable, PublicCloneable, \n                                           Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 8468154364608194797L;\n    \n    /** Storage for the keys. */\n    private ArrayList keys;\n    \n    /** Storage for the values. */\n    private ArrayList values;\n    \n    /** \n     * Contains (key, Integer) mappings, where the Integer is the index for\n     * the key in the list. \n     */\n    private HashMap indexMap; \n\n  /**\n     * Creates a new collection (initially empty).\n     */\n    public DefaultKeyedValues() {\n        this.keys = new ArrayList();\n        this.values = new ArrayList();\n        this.indexMap = new HashMap();\n    }\n\n    /**\n     * Returns the number of items (values) in the collection.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.indexMap.size();\n    }\n\n    /**\n     * Returns a value.\n     *\n     * @param item  the item of interest (zero-based index).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Number getValue(int item) {\n        return (Number) this.values.get(item);\n    }\n\n    /**\n     * Returns a key.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The row key.\n     * \n     * @throws IndexOutOfBoundsException if <code>item</code> is out of bounds.\n     */\n    public Comparable getKey(int index) {\n        return (Comparable) this.keys.get(index);\n    }\n\n    /**\n     * Returns the index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The index, or <code>-1</code> if the key is not recognised.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     */\n    public int getIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        final Integer i = (Integer) this.indexMap.get(key);\n        if (i == null) {\n            return -1;  // key not found\n        }\n        return i.intValue();\n    }\n\n    /**\n     * Returns the keys for the values in the collection.\n     *\n     * @return The keys (never <code>null</code>).\n     */\n    public List getKeys() {\n        return (List) this.keys.clone();\n    }\n\n    /**\n     * Returns the value for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @throws UnknownKeyException if the key is not recognised.\n     * \n     * @see #getValue(int)\n     */\n    public Number getValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n            throw new UnknownKeyException(\"Key not found: \" + key);\n        }\n        return getValue(index);\n    }\n\n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @see #addValue(Comparable, Number)\n     */\n    public void addValue(Comparable key, double value) {\n        addValue(key, new Double(value)); \n    }\n    \n    /**\n     * Adds a new value to the collection, or updates an existing value.\n     * This method passes control directly to the \n     * {@link #setValue(Comparable, Number)} method.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void addValue(Comparable key, Number value) {\n        setValue(key, value);\n    }\n\n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void setValue(Comparable key, double value) {\n        setValue(key, new Double(value));   \n    }\n    \n    /**\n     * Updates an existing value, or adds a new value to the collection.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void setValue(Comparable key, Number value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int keyIndex = getIndex(key);\n        if (keyIndex >= 0) {\n            this.keys.set(keyIndex, key);\n            this.values.set(keyIndex, value);\n        }\n        else {\n            this.keys.add(key);\n            this.values.add(value);\n            this.indexMap.put(key, new Integer(this.keys.size() - 1));\n        }\n    }\n    \n    /**\n     * Inserts a new value at the specified position in the dataset or, if\n     * there is an existing item with the specified key, updates the value \n     * for that item and moves it to the specified position.\n     * \n     * @param position  the position (in the range 0 to getItemCount()).\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value.\n     * \n     * @since 1.0.6\n     */\n    public void insertValue(int position, Comparable key, double value) {\n        insertValue(position, key, new Double(value));\n    }\n\n    /**\n     * Inserts a new value at the specified position in the dataset or, if\n     * there is an existing item with the specified key, updates the value \n     * for that item and moves it to the specified position.\n     * \n     * @param position  the position (in the range 0 to getItemCount()).\n     * @param key  the key (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * \n     * @since 1.0.6\n     */\n    public void insertValue(int position, Comparable key, Number value) {\n        if (position < 0 || position > getItemCount()) {\n            throw new IllegalArgumentException(\"'position' out of bounds.\");\n        }\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int pos = getIndex(key);\n        if (pos == position) {\n            this.keys.set(pos, key);\n            this.values.set(pos, value);\n        }\n        else {\n            if (pos >= 0) {\n                this.keys.remove(pos);\n                this.values.remove(pos);\n            }\n          \n            this.keys.add(position, key);\n            this.values.add(position, value);\n            rebuildIndex();\n        }\n    }\n\n    /**\n     * Rebuilds the key to indexed-position mapping after an positioned insert\n     * or a remove operation.\n     */\n    private void rebuildIndex () {\n        this.indexMap.clear();\n        for (int i = 0; i < this.keys.size(); i++) {\n            final Object key = this.keys.get(i);\n            this.indexMap.put(key, new Integer(i));\n        }\n    }\n\n    /**\n     * Removes a value from the collection.\n     *\n     * @param index  the index of the item to remove (in the range \n     *     <code>0</code> to <code>getItemCount() - 1</code>).\n     *     \n     * @throws IndexOutOfBoundsException if <code>index</code> is not within\n     *     the specified range.\n     */\n    public void removeValue(int index) {\n        this.keys.remove(index);\n        this.values.remove(index);\n        rebuildIndex();\n    }\n\n    /**\n     * Removes a value from the collection.\n     *\n     * @param key  the item key (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * @throws UnknownKeyException if <code>key</code> is not recognised.\n     */\n    public void removeValue(Comparable key) {\n        int index = getIndex(key);\n        if (index < 0) {\n            throw new UnknownKeyException(\"The key (\" + key \n                    + \") is not recognised.\");\n        }\n        removeValue(index);\n    }\n    \n    /**\n     * Clears all values from the collection.\n     * \n     * @since 1.0.2\n     */\n    public void clear() {\n        this.keys.clear();\n        this.values.clear();\n        this.indexMap.clear();\n    }\n\n    /**\n     * Sorts the items in the list by key.\n     *\n     * @param order  the sort order (<code>null</code> not permitted).\n     */\n    public void sortByKeys(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), \n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_KEY, order);\n        Arrays.sort(data, comparator);\n        clear();\n\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }\n\n    /**\n     * Sorts the items in the list by value.  If the list contains \n     * <code>null</code> values, they will sort to the end of the list, \n     * irrespective of the sort order.\n     *\n     * @param order  the sort order (<code>null</code> not permitted).\n     */\n    public void sortByValues(SortOrder order) {\n        final int size = this.keys.size();\n        final DefaultKeyedValue[] data = new DefaultKeyedValue[size];\n        for (int i = 0; i < size; i++) {\n            data[i] = new DefaultKeyedValue((Comparable) this.keys.get(i), \n                    (Number) this.values.get(i));\n        }\n\n        Comparator comparator = new KeyedValueComparator(\n                KeyedValueComparatorType.BY_VALUE, order);\n        Arrays.sort(data, comparator);\n\n        clear();\n        for (int i = 0; i < data.length; i++) {\n            final DefaultKeyedValue value = data[i];\n            addValue(value.getKey(), value.getValue());\n        }\n    }\n\n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n\n        if (!(obj instanceof KeyedValues)) {\n            return false;\n        }\n\n        KeyedValues that = (KeyedValues) obj;\n        int count = getItemCount();\n        if (count != that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            Comparable k1 = getKey(i);\n            Comparable k2 = that.getKey(i);\n            if (!k1.equals(k2)) {\n                return false;\n            }\n            Number v1 = getValue(i);\n            Number v2 = that.getValue(i);\n            if (v1 == null) {\n                if (v2 != null) {\n                    return false;\n                }\n            }\n            else {\n                if (!v1.equals(v2)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     * \n     * @return A hash code.\n     */\n    public int hashCode() {\n        return (this.keys != null ? this.keys.hashCode() : 0);\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues clone = (DefaultKeyedValues) super.clone();\n        clone.keys = (ArrayList) this.keys.clone();\n        clone.values = (ArrayList) this.values.clone();\n        clone.indexMap = (HashMap) this.indexMap.clone();\n        return clone;\n    }\n    \n}"}, {"class_name": "org.jfree.data.DefaultKeyedValues2D", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -------------------------\n * DefaultKeyedValues2D.java\n * -------------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andreas Schroeder;\n *\n * Changes\n * -------\n * 28-Oct-2002 : Version 1 (DG);\n * 21-Jan-2003 : Updated Javadocs (DG);\n * 13-Mar-2003 : Implemented Serializable (DG);\n * 18-Aug-2003 : Implemented Cloneable (DG);\n * 31-Mar-2004 : Made the rows optionally sortable by a flag (AS);\n * 01-Apr-2004 : Implemented remove method (AS);\n * 05-Apr-2004 : Added clear() method (DG);\n * 15-Sep-2004 : Fixed clone() method (DG);\n * 12-Jan-2005 : Fixed bug in getValue() method (DG);\n * 23-Mar-2005 : Implemented PublicCloneable (DG);\n * 09-Jun-2005 : Modified getValue() method to throw exception for unknown\n *               keys (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 18-Jan-2007 : Fixed bug in getValue() method (DG);\n * 30-Mar-2007 : Fixed bug 1690654, problem with removeValue() (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 21-Nov-2007 : Fixed bug (1835955) in removeColumn(Comparable) method (DG);\n *\n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\n\n/**\n * A data structure that stores zero, one or many values, where each value \n * is associated with two keys (a 'row' key and a 'column' key).  The keys \n * should be (a) instances of {@link Comparable} and (b) immutable.  \n */\npublic class DefaultKeyedValues2D implements KeyedValues2D, \n                                             PublicCloneable, Cloneable, \n                                             Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5514169970951994748L;\n    \n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n    \n    /** If the row keys should be sorted by their comparable order. */\n    private boolean sortRowKeys;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public DefaultKeyedValues2D() {\n        this(false);\n    }\n\n    /**\n     * Creates a new instance (initially empty).\n     * \n     * @param sortRowKeys  if the row keys should be sorted.\n     */\n    public DefaultKeyedValues2D(boolean sortRowKeys) {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n        this.sortRowKeys = sortRowKeys;\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the value for a given row and column.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     * \n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        Number result = null;\n        DefaultKeyedValues rowData = (DefaultKeyedValues) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            // the row may not have an entry for this key, in which case the \n            // return value is null\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                result = rowData.getValue(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (in the range 0 to {@link #getRowCount()} - 1).\n     *\n     * @return The row key.\n     * \n     * @see #getRowIndex(Comparable)\n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getRowIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.sortRowKeys) {\n            return Collections.binarySearch(this.rowKeys, key);\n        }\n        else {\n            return this.rowKeys.indexOf(key);\n        }\n    }\n\n    /**\n     * Returns the row keys in an unmodifiable list.\n     *\n     * @return The row keys.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column (in the range 0 to {@link #getColumnCount()} \n     *     - 1).\n     *\n     * @return The key.\n     * \n     * @see #getColumnIndex(Comparable)\n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     * @see #getRowIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys in an unmodifiable list.\n     *\n     * @return The column keys.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the value for the given row and column keys.  This method will\n     * throw an {@link UnknownKeyException} if either key is not defined in the\n     * data structure.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        \n        // check that the column key is defined in the 2D structure\n        if (!(this.columnKeys.contains(columnKey))) {\n            throw new UnknownKeyException(\"Unrecognised columnKey: \" \n                    + columnKey);\n        }\n        \n        // now fetch the row data - need to bear in mind that the row\n        // structure may not have an entry for the column key, but that we\n        // have already checked that the key is valid for the 2D structure\n        int row = getRowIndex(rowKey);\n        if (row >= 0) {\n            DefaultKeyedValues rowData \n                = (DefaultKeyedValues) this.rows.get(row);\n            int col = rowData.getIndex(columnKey);\n            return (col >= 0 ? rowData.getValue(col) : null);\n        }\n        else {\n            throw new UnknownKeyException(\"Unrecognised rowKey: \" + rowKey);\n        }\n    }\n\n    /**\n     * Adds a value to the table.  Performs the same function as \n     * #setValue(Number, Comparable, Comparable).\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #setValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void addValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n        // defer argument checking\n        setValue(value, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates a value.\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void setValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n\n        DefaultKeyedValues row;\n        int rowIndex = getRowIndex(rowKey);\n        \n        if (rowIndex >= 0) {\n            row = (DefaultKeyedValues) this.rows.get(rowIndex);\n        }\n        else {\n            row = new DefaultKeyedValues();\n            if (this.sortRowKeys) {\n                rowIndex = -rowIndex - 1;\n                this.rowKeys.add(rowIndex, rowKey);\n                this.rows.add(rowIndex, row);\n            }\n            else {\n                this.rowKeys.add(rowKey);\n                this.rows.add(row);\n            }\n        }\n        row.setValue(columnKey, value);\n        \n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }\n\n    /**\n     * Removes a value from the table by setting it to <code>null</code>.  If\n     * all the values in the specified row and/or column are now \n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     */\n    public void removeValue(Comparable rowKey, Comparable columnKey) {\n        setValue(null, rowKey, columnKey);\n        \n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; \n             item++) {\n            if (row.getValue(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n        \n        // 2. check whether the column is now empty.\n        allNull = true;\n        //int columnIndex = getColumnIndex(columnKey);\n        \n        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n             item++) {\n            row = (DefaultKeyedValues) this.rows.get(item);\n            int columnIndex = row.getIndex(columnKey);\n            if (columnIndex >= 0 && row.getValue(columnIndex) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n                 item++) {\n                row = (DefaultKeyedValues) this.rows.get(item);\n                int columnIndex = row.getIndex(columnKey);\n                if (columnIndex >= 0) {\n                    row.removeValue(columnIndex);\n                }\n            }\n            this.columnKeys.remove(columnKey);\n        }\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowIndex  the row index.\n     * \n     * @see #removeRow(Comparable)\n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * \n     * @see #removeRow(int)\n     * @see #removeColumn(Comparable)\n     */\n    public void removeRow(Comparable rowKey) {\n        removeRow(getRowIndex(rowKey));\n    }\n\n    /**\n     * Removes a column.\n     *\n     * @param columnIndex  the column index.\n     * \n     * @see #removeColumn(Comparable)\n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes a column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if the table does not contain a column with\n     *     the specified key.\n     * @throws IllegalArgumentException if <code>columnKey</code> is \n     *     <code>null</code>.\n     * \n     * @see #removeColumn(int)\n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n                rowData.removeValue(columnKey);\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Clears all the data and associated keys.\n     */\n    public void clear() {\n        this.rowKeys.clear();\n        this.columnKeys.clear();\n        this.rows.clear();\n    }\n    \n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param o  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object o) {\n\n        if (o == null) {\n            return false;\n        }\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof KeyedValues2D)) {\n            return false;\n        }\n        KeyedValues2D kv2D = (KeyedValues2D) o;\n        if (!getRowKeys().equals(kv2D.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(kv2D.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != kv2D.getRowCount()) {\n            return false;\n        }\n\n        int colCount = getColumnCount();\n        if (colCount != kv2D.getColumnCount()) {\n            return false;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Number v1 = getValue(r, c);\n                Number v2 = kv2D.getValue(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     * \n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues2D clone = (DefaultKeyedValues2D) super.clone();\n        // for the keys, a shallow copy should be fine because keys\n        // should be immutable...\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n        \n        // but the row data requires a deep copy\n        clone.rows = (List) ObjectUtilities.deepClone(this.rows);\n        return clone;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -------------------------\n * DefaultKeyedValues2D.java\n * -------------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andreas Schroeder;\n *\n * Changes\n * -------\n * 28-Oct-2002 : Version 1 (DG);\n * 21-Jan-2003 : Updated Javadocs (DG);\n * 13-Mar-2003 : Implemented Serializable (DG);\n * 18-Aug-2003 : Implemented Cloneable (DG);\n * 31-Mar-2004 : Made the rows optionally sortable by a flag (AS);\n * 01-Apr-2004 : Implemented remove method (AS);\n * 05-Apr-2004 : Added clear() method (DG);\n * 15-Sep-2004 : Fixed clone() method (DG);\n * 12-Jan-2005 : Fixed bug in getValue() method (DG);\n * 23-Mar-2005 : Implemented PublicCloneable (DG);\n * 09-Jun-2005 : Modified getValue() method to throw exception for unknown\n *               keys (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 18-Jan-2007 : Fixed bug in getValue() method (DG);\n * 30-Mar-2007 : Fixed bug 1690654, problem with removeValue() (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 21-Nov-2007 : Fixed bug (1835955) in removeColumn(Comparable) method (DG);\n *\n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\n\n/**\n * A data structure that stores zero, one or many values, where each value \n * is associated with two keys (a 'row' key and a 'column' key).  The keys \n * should be (a) instances of {@link Comparable} and (b) immutable.  \n */\npublic class DefaultKeyedValues2D implements KeyedValues2D, \n                                             PublicCloneable, Cloneable, \n                                             Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5514169970951994748L;\n    \n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n    \n    /** If the row keys should be sorted by their comparable order. */\n    private boolean sortRowKeys;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public DefaultKeyedValues2D() {\n        this(false);\n    }\n\n    /**\n     * Creates a new instance (initially empty).\n     * \n     * @param sortRowKeys  if the row keys should be sorted.\n     */\n    public DefaultKeyedValues2D(boolean sortRowKeys) {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n        this.sortRowKeys = sortRowKeys;\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the value for a given row and column.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     * \n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        Number result = null;\n        DefaultKeyedValues rowData = (DefaultKeyedValues) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            // the row may not have an entry for this key, in which case the \n            // return value is null\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                result = rowData.getValue(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (in the range 0 to {@link #getRowCount()} - 1).\n     *\n     * @return The row key.\n     * \n     * @see #getRowIndex(Comparable)\n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getRowIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.sortRowKeys) {\n            return Collections.binarySearch(this.rowKeys, key);\n        }\n        else {\n            return this.rowKeys.indexOf(key);\n        }\n    }\n\n    /**\n     * Returns the row keys in an unmodifiable list.\n     *\n     * @return The row keys.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column (in the range 0 to {@link #getColumnCount()} \n     *     - 1).\n     *\n     * @return The key.\n     * \n     * @see #getColumnIndex(Comparable)\n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     * @see #getRowIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys in an unmodifiable list.\n     *\n     * @return The column keys.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the value for the given row and column keys.  This method will\n     * throw an {@link UnknownKeyException} if either key is not defined in the\n     * data structure.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        \n        // check that the column key is defined in the 2D structure\n        if (!(this.columnKeys.contains(columnKey))) {\n            throw new UnknownKeyException(\"Unrecognised columnKey: \" \n                    + columnKey);\n        }\n        \n        // now fetch the row data - need to bear in mind that the row\n        // structure may not have an entry for the column key, but that we\n        // have already checked that the key is valid for the 2D structure\n        int row = getRowIndex(rowKey);\n        if (row >= 0) {\n            DefaultKeyedValues rowData \n                = (DefaultKeyedValues) this.rows.get(row);\n            int col = rowData.getIndex(columnKey);\n            return (col >= 0 ? rowData.getValue(col) : null);\n        }\n        else {\n            throw new UnknownKeyException(\"Unrecognised rowKey: \" + rowKey);\n        }\n    }\n\n    /**\n     * Adds a value to the table.  Performs the same function as \n     * #setValue(Number, Comparable, Comparable).\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #setValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void addValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n        // defer argument checking\n        setValue(value, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates a value.\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void setValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n\n        DefaultKeyedValues row;\n        int rowIndex = getRowIndex(rowKey);\n        \n        if (rowIndex >= 0) {\n            row = (DefaultKeyedValues) this.rows.get(rowIndex);\n        }\n        else {\n            row = new DefaultKeyedValues();\n            if (this.sortRowKeys) {\n                rowIndex = -rowIndex - 1;\n                this.rowKeys.add(rowIndex, rowKey);\n                this.rows.add(rowIndex, row);\n            }\n            else {\n                this.rowKeys.add(rowKey);\n                this.rows.add(row);\n            }\n        }\n        row.setValue(columnKey, value);\n        \n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }\n\n    /**\n     * Removes a value from the table by setting it to <code>null</code>.  If\n     * all the values in the specified row and/or column are now \n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     */\n    public void removeValue(Comparable rowKey, Comparable columnKey) {\n        setValue(null, rowKey, columnKey);\n        \n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; \n             item++) {\n            if (row.getValue(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n        \n        // 2. check whether the column is now empty.\n        allNull = true;\n        //int columnIndex = getColumnIndex(columnKey);\n        \n        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n             item++) {\n            row = (DefaultKeyedValues) this.rows.get(item);\n            int columnIndex = row.getIndex(columnKey);\n            if (columnIndex >= 0 && row.getValue(columnIndex) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n                 item++) {\n                row = (DefaultKeyedValues) this.rows.get(item);\n                int columnIndex = row.getIndex(columnKey);\n                if (columnIndex >= 0) {\n                    row.removeValue(columnIndex);\n                }\n            }\n            this.columnKeys.remove(columnKey);\n        }\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowIndex  the row index.\n     * \n     * @see #removeRow(Comparable)\n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * \n     * @see #removeRow(int)\n     * @see #removeColumn(Comparable)\n     */\n    public void removeRow(Comparable rowKey) {\n        removeRow(getRowIndex(rowKey));\n    }\n\n    /**\n     * Removes a column.\n     *\n     * @param columnIndex  the column index.\n     * \n     * @see #removeColumn(Comparable)\n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes a column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if the table does not contain a column with\n     *     the specified key.\n     * @throws IllegalArgumentException if <code>columnKey</code> is \n     *     <code>null</code>.\n     * \n     * @see #removeColumn(int)\n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n    \tif (columnKey == null) {\n    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\n    \t}\n    \tif (!this.columnKeys.contains(columnKey)) {\n    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\n    \t}\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                rowData.removeValue(columnKey);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Clears all the data and associated keys.\n     */\n    public void clear() {\n        this.rowKeys.clear();\n        this.columnKeys.clear();\n        this.rows.clear();\n    }\n    \n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param o  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object o) {\n\n        if (o == null) {\n            return false;\n        }\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof KeyedValues2D)) {\n            return false;\n        }\n        KeyedValues2D kv2D = (KeyedValues2D) o;\n        if (!getRowKeys().equals(kv2D.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(kv2D.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != kv2D.getRowCount()) {\n            return false;\n        }\n\n        int colCount = getColumnCount();\n        if (colCount != kv2D.getColumnCount()) {\n            return false;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Number v1 = getValue(r, c);\n                Number v2 = kv2D.getValue(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     * \n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues2D clone = (DefaultKeyedValues2D) super.clone();\n        // for the keys, a shallow copy should be fine because keys\n        // should be immutable...\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n        \n        // but the row data requires a deep copy\n        clone.rows = (List) ObjectUtilities.deepClone(this.rows);\n        return clone;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 19, "classes_modified": [{"class_name": "org.jfree.chart.plot.CategoryPlot", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               anntotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");   \n        }\n        this.domainGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");   \n        }\n        this.annotations.add(annotation);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        // TODO: notify?\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        this.fixedDomainAxisSpace = space;\n        // TODO: notify?\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        this.fixedRangeAxisSpace = space;\n        // TODO: fire event?\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               anntotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");   \n        }\n        this.domainGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");   \n        }\n        this.annotations.add(annotation);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        // TODO: notify?\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        this.fixedDomainAxisSpace = space;\n        // TODO: notify?\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        this.fixedRangeAxisSpace = space;\n        // TODO: fire event?\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 20, "classes_modified": [{"class_name": "org.jfree.chart.plot.ValueMarker", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------\n * ValueMarker.java\n * ----------------\n * (C) Copyright 2004-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 09-Feb-2004 : Version 1 (DG);\n * 16-Feb-2005 : Added new constructor (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 05-Sep-2006 : Added setValue() method (DG);\n * 08-Oct-2007 : Fixed bug 1808376, constructor calling super with incorrect\n *               values (DG);\n * \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Paint;\nimport java.awt.Stroke;\n\nimport org.jfree.chart.event.MarkerChangeEvent;\n\n/**\n * A marker that represents a single value.  Markers can be added to plots to\n * highlight specific values.\n */\npublic class ValueMarker extends Marker {\n    \n    /** The value. */\n    private double value;\n\n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     */\n    public ValueMarker(double value) {\n        super();\n        this.value = value;\n    }\n    \n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke) {\n        this(value, paint, stroke, paint, stroke, 1.0f);\n    }\n    \n    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n    }\n    \n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     * \n     * @see #setValue(double)\n     */\n    public double getValue() {\n        return this.value;\n    }\n    \n    /**\n     * Sets the value for the marker and sends a {@link MarkerChangeEvent} to \n     * all registered listeners.\n     * \n     * @param value  the value.\n     * \n     * @see #getValue()\n     * \n     * @since 1.0.3\n     */\n    public void setValue(double value) { \n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Tests this marker for equality with an arbitrary object.  This method\n     * returns <code>true</code> if:\n     * \n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>ValueMarker</code>;</li>\n     * <li><code>obj</code> has the same value as this marker;</li>\n     * <li><code>super.equals(obj)</code> returns <code>true</code>.</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value != that.value) {\n            return false;\n        }\n        return true;\n    }\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------\n * ValueMarker.java\n * ----------------\n * (C) Copyright 2004-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 09-Feb-2004 : Version 1 (DG);\n * 16-Feb-2005 : Added new constructor (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 05-Sep-2006 : Added setValue() method (DG);\n * 08-Oct-2007 : Fixed bug 1808376, constructor calling super with incorrect\n *               values (DG);\n * \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Paint;\nimport java.awt.Stroke;\n\nimport org.jfree.chart.event.MarkerChangeEvent;\n\n/**\n * A marker that represents a single value.  Markers can be added to plots to\n * highlight specific values.\n */\npublic class ValueMarker extends Marker {\n    \n    /** The value. */\n    private double value;\n\n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     */\n    public ValueMarker(double value) {\n        super();\n        this.value = value;\n    }\n    \n    /**\n     * Creates a new marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke) {\n        this(value, paint, stroke, paint, stroke, 1.0f);\n    }\n    \n    /**\n     * Creates a new value marker.\n     * \n     * @param value  the value.\n     * @param paint  the paint (<code>null</code> not permitted).\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n     * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n     */\n    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n        this.value = value;\n    }\n    \n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     * \n     * @see #setValue(double)\n     */\n    public double getValue() {\n        return this.value;\n    }\n    \n    /**\n     * Sets the value for the marker and sends a {@link MarkerChangeEvent} to \n     * all registered listeners.\n     * \n     * @param value  the value.\n     * \n     * @see #getValue()\n     * \n     * @since 1.0.3\n     */\n    public void setValue(double value) { \n        this.value = value;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Tests this marker for equality with an arbitrary object.  This method\n     * returns <code>true</code> if:\n     * \n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>ValueMarker</code>;</li>\n     * <li><code>obj</code> has the same value as this marker;</li>\n     * <li><code>super.equals(obj)</code> returns <code>true</code>.</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof ValueMarker)) {\n            return false;\n        }\n        ValueMarker that = (ValueMarker) obj;\n        if (this.value != that.value) {\n            return false;\n        }\n        return true;\n    }\n}\n"}]}
{"project": "Chart", "bug_id": 21, "classes_modified": [{"class_name": "org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * DefaultBoxAndWhiskerCategoryDataset.java\n * ----------------------------------------\n * (C) Copyright 2003-2007, by David Browning and Contributors.\n *\n * Original Author:  David Browning (for Australian Institute of Marine \n *                   Science);\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 05-Aug-2003 : Version 1, contributed by David Browning (DG);\n * 27-Aug-2003 : Moved from org.jfree.data --> org.jfree.data.statistics (DG);\n * 12-Nov-2003 : Changed 'data' from private to protected and added a new 'add' \n *               method as proposed by Tim Bardzil.  Also removed old code (DG);\n * 01-Mar-2004 : Added equals() method (DG);\n * 18-Nov-2004 : Updates for changes in RangeInfo interface (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for the 1.0.0 \n *               release (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 02-Feb-2007 : Removed author tags from all over JFreeChart sources (DG);\n * 17-Apr-2007 : Fixed bug 1701822 (DG);\n * 13-Jun-2007 : Fixed error in previous patch (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 28-Sep-2007 : Fixed cloning bug (DG);\n * 02-Oct-2007 : Fixed bug in updating cached bounds (DG);\n * 03-Oct-2007 : Fixed another bug in updating cached bounds (DG);\n *\n */\n\npackage org.jfree.data.statistics;\n\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.data.KeyedObjects2D;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.general.AbstractDataset;\n\n/**\n * A convenience class that provides a default implementation of the\n * {@link BoxAndWhiskerCategoryDataset} interface.\n */\npublic class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n        implements BoxAndWhiskerCategoryDataset, RangeInfo, PublicCloneable {\n\n    /** Storage for the data. */\n    protected KeyedObjects2D data;\n\n    /** The minimum range value. */\n    private double minimumRangeValue;\n    \n    /** The row index for the cell that the minimum range value comes from. */\n    private int minimumRangeValueRow;\n    \n    /** \n     * The column index for the cell that the minimum range value comes from. \n     */\n    private int minimumRangeValueColumn;\n\n    /** The maximum range value. */\n    private double maximumRangeValue;\n\n    /** The row index for the cell that the maximum range value comes from. */\n    private int maximumRangeValueRow;\n    \n    /** \n     * The column index for the cell that the maximum range value comes from. \n     */\n    private int maximumRangeValueColumn;\n    \n    /** The range of values. */\n    private Range rangeBounds;\n\n    /**\n     * Creates a new dataset.\n     */\n    public DefaultBoxAndWhiskerCategoryDataset() {\n        this.data = new KeyedObjects2D();\n        this.minimumRangeValue = Double.NaN;\n        this.minimumRangeValueRow = -1;\n        this.minimumRangeValueColumn = -1;\n        this.maximumRangeValue = Double.NaN;\n        this.maximumRangeValueRow = -1;\n        this.maximumRangeValueColumn = -1;\n        this.rangeBounds = new Range(0.0, 0.0);\n    }\n\n    /**\n     * Adds a list of values relating to one box-and-whisker entity to the \n     * table.  The various median values are calculated.\n     *\n     * @param list  a collection of values from which the various medians will \n     *              be calculated.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #add(BoxAndWhiskerItem, Comparable, Comparable)\n     */\n    public void add(List list, Comparable rowKey, Comparable columnKey) {\n        BoxAndWhiskerItem item = BoxAndWhiskerCalculator\n                .calculateBoxAndWhiskerStatistics(list);\n        add(item, rowKey, columnKey);\n    }\n    \n    /**\n     * Adds a list of values relating to one Box and Whisker entity to the \n     * table.  The various median values are calculated.\n     *\n     * @param item  a box and whisker item (<code>null</code> not permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #add(List, Comparable, Comparable)\n     */\n    public void add(BoxAndWhiskerItem item, Comparable rowKey, \n            Comparable columnKey) {\n\n        this.data.addObject(item, rowKey, columnKey);\n        \n        // update cached min and max values\n        int r = this.data.getRowIndex(rowKey);\n        int c = this.data.getColumnIndex(columnKey);\n        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn \n                == c) || (this.minimumRangeValueRow == r \n                && this.minimumRangeValueColumn == c))  {\n            updateBounds();\n        }\n        \n            double minval = Double.NaN;\n            if (item.getMinOutlier() != null) {\n                minval = item.getMinOutlier().doubleValue();\n            }\n            double maxval = Double.NaN;\n            if (item.getMaxOutlier() != null) {\n                maxval = item.getMaxOutlier().doubleValue();\n            }\n        \n            if (Double.isNaN(this.maximumRangeValue)) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n            else if (maxval > this.maximumRangeValue) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n        \n            if (Double.isNaN(this.minimumRangeValue)) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n            else if (minval < this.minimumRangeValue) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n        \n        this.rangeBounds = new Range(this.minimumRangeValue,\n              this.maximumRangeValue);\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Return an item from within the dataset.\n     * \n     * @param row  the row index.\n     * @param column  the column index.\n     * \n     * @return The item.\n     */\n    public BoxAndWhiskerItem getItem(int row, int column) {\n        return (BoxAndWhiskerItem) this.data.getObject(row, column);  \n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     * \n     * @see #getMedianValue(int, int)\n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        return getMedianValue(row, column);\n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the columnKey.\n     *\n     * @return The value.\n     * \n     * @see #getMedianValue(Comparable, Comparable)\n     * @see #getValue(int, int)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        return getMedianValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the mean value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The mean value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMeanValue(int row, int column) {\n\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(row, \n                column);\n        if (item != null) {\n            result = item.getMean();\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the mean value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The mean value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMeanValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMean();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the median value for an item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The median value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMedianValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(row, \n                column);\n        if (item != null) {\n            result = item.getMedian();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the median value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the columnKey.\n     *\n     * @return The median value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMedianValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMedian();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first quartile value.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The first quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ1Value(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getQ1();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first quartile value.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The first quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ1Value(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getQ1();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the third quartile value.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The third quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ3Value(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getQ3();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the third quartile value.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The third quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ3Value(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getQ3();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the column key.\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     */\n    public int getColumnIndex(Comparable key) {\n        return this.data.getColumnIndex(key);\n    }\n\n    /**\n     * Returns a column key.\n     *\n     * @param column  the column index (zero-based).\n     *\n     * @return The column key.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public Comparable getColumnKey(int column) {\n        return this.data.getColumnKey(column);\n    }\n\n    /**\n     * Returns the column keys.\n     *\n     * @return The keys.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return this.data.getColumnKeys();\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the row key.\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     */\n    public int getRowIndex(Comparable key) {\n        return this.data.getRowIndex(key);\n    }\n\n    /**\n     * Returns a row key.\n     *\n     * @param row  the row index (zero-based).\n     *\n     * @return The row key.\n     * \n     * @see #getRowIndex(Comparable)\n     */\n    public Comparable getRowKey(int row) {\n        return this.data.getRowKey(row);\n    }\n\n    /**\n     * Returns the row keys.\n     *\n     * @return The keys.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return this.data.getRowKeys();\n    }\n\n    /**\n     * Returns the number of rows in the table.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.data.getRowCount();\n    }\n\n    /**\n     * Returns the number of columns in the table.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.data.getColumnCount();\n    }\n\n    /**\n     * Returns the minimum y-value in the dataset.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The minimum value.\n     * \n     * @see #getRangeUpperBound(boolean)\n     */\n    public double getRangeLowerBound(boolean includeInterval) {\n        return this.minimumRangeValue;\n    }\n\n    /**\n     * Returns the maximum y-value in the dataset.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The maximum value.\n     * \n     * @see #getRangeLowerBound(boolean)\n     */\n    public double getRangeUpperBound(boolean includeInterval) {\n        return this.maximumRangeValue;\n    }\n\n    /**\n     * Returns the range of the values in this dataset's range.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The range.\n     */\n    public Range getRangeBounds(boolean includeInterval) {\n        return this.rangeBounds;\n    }\n    \n    /**\n     * Returns the minimum regular (non outlier) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The minimum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinRegularValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMinRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum regular (non outlier) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The minimum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinRegularValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMinRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum regular (non outlier) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The maximum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxRegularValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMaxRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum regular (non outlier) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The maximum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxRegularValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMaxRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum outlier (non farout) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The minimum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinOutlier(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMinOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum outlier (non farout) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The minimum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinOutlier(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMinOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum outlier (non farout) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The maximum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxOutlier(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMaxOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum outlier (non farout) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The maximum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxOutlier(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMaxOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of outlier values for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return A list of outlier values.\n     * \n     * @see #getItem(int, int)\n     */\n    public List getOutliers(int row, int column) {\n        List result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getOutliers();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of outlier values for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return A list of outlier values.\n     * \n     * @see #getItem(int, int)\n     */\n    public List getOutliers(Comparable rowKey, Comparable columnKey) {\n        List result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getOutliers();\n        }\n        return result;\n    }\n    \n    /**\n     * Resets the cached bounds, by iterating over the entire dataset to find\n     * the current bounds.\n     */\n    private void updateBounds() {\n        this.minimumRangeValue = Double.NaN;\n        this.maximumRangeValue = Double.NaN;\n    }\n    \n    /**\n     * Tests this dataset for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;   \n        }\n        if (obj instanceof DefaultBoxAndWhiskerCategoryDataset) {\n            DefaultBoxAndWhiskerCategoryDataset dataset \n                    = (DefaultBoxAndWhiskerCategoryDataset) obj;\n            return ObjectUtilities.equal(this.data, dataset.data);\n        }\n        return false;\n    }\n    \n    /**\n     * Returns a clone of this dataset.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultBoxAndWhiskerCategoryDataset clone \n                = (DefaultBoxAndWhiskerCategoryDataset) super.clone();\n        clone.data = (KeyedObjects2D) this.data.clone();\n        return clone;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * DefaultBoxAndWhiskerCategoryDataset.java\n * ----------------------------------------\n * (C) Copyright 2003-2007, by David Browning and Contributors.\n *\n * Original Author:  David Browning (for Australian Institute of Marine \n *                   Science);\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 05-Aug-2003 : Version 1, contributed by David Browning (DG);\n * 27-Aug-2003 : Moved from org.jfree.data --> org.jfree.data.statistics (DG);\n * 12-Nov-2003 : Changed 'data' from private to protected and added a new 'add' \n *               method as proposed by Tim Bardzil.  Also removed old code (DG);\n * 01-Mar-2004 : Added equals() method (DG);\n * 18-Nov-2004 : Updates for changes in RangeInfo interface (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for the 1.0.0 \n *               release (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 02-Feb-2007 : Removed author tags from all over JFreeChart sources (DG);\n * 17-Apr-2007 : Fixed bug 1701822 (DG);\n * 13-Jun-2007 : Fixed error in previous patch (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 28-Sep-2007 : Fixed cloning bug (DG);\n * 02-Oct-2007 : Fixed bug in updating cached bounds (DG);\n * 03-Oct-2007 : Fixed another bug in updating cached bounds (DG);\n *\n */\n\npackage org.jfree.data.statistics;\n\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.data.KeyedObjects2D;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.general.AbstractDataset;\n\n/**\n * A convenience class that provides a default implementation of the\n * {@link BoxAndWhiskerCategoryDataset} interface.\n */\npublic class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n        implements BoxAndWhiskerCategoryDataset, RangeInfo, PublicCloneable {\n\n    /** Storage for the data. */\n    protected KeyedObjects2D data;\n\n    /** The minimum range value. */\n    private double minimumRangeValue;\n    \n    /** The row index for the cell that the minimum range value comes from. */\n    private int minimumRangeValueRow;\n    \n    /** \n     * The column index for the cell that the minimum range value comes from. \n     */\n    private int minimumRangeValueColumn;\n\n    /** The maximum range value. */\n    private double maximumRangeValue;\n\n    /** The row index for the cell that the maximum range value comes from. */\n    private int maximumRangeValueRow;\n    \n    /** \n     * The column index for the cell that the maximum range value comes from. \n     */\n    private int maximumRangeValueColumn;\n    \n    /** The range of values. */\n    private Range rangeBounds;\n\n    /**\n     * Creates a new dataset.\n     */\n    public DefaultBoxAndWhiskerCategoryDataset() {\n        this.data = new KeyedObjects2D();\n        this.minimumRangeValue = Double.NaN;\n        this.minimumRangeValueRow = -1;\n        this.minimumRangeValueColumn = -1;\n        this.maximumRangeValue = Double.NaN;\n        this.maximumRangeValueRow = -1;\n        this.maximumRangeValueColumn = -1;\n        this.rangeBounds = new Range(0.0, 0.0);\n    }\n\n    /**\n     * Adds a list of values relating to one box-and-whisker entity to the \n     * table.  The various median values are calculated.\n     *\n     * @param list  a collection of values from which the various medians will \n     *              be calculated.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #add(BoxAndWhiskerItem, Comparable, Comparable)\n     */\n    public void add(List list, Comparable rowKey, Comparable columnKey) {\n        BoxAndWhiskerItem item = BoxAndWhiskerCalculator\n                .calculateBoxAndWhiskerStatistics(list);\n        add(item, rowKey, columnKey);\n    }\n    \n    /**\n     * Adds a list of values relating to one Box and Whisker entity to the \n     * table.  The various median values are calculated.\n     *\n     * @param item  a box and whisker item (<code>null</code> not permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #add(List, Comparable, Comparable)\n     */\n    public void add(BoxAndWhiskerItem item, Comparable rowKey, \n            Comparable columnKey) {\n\n        this.data.addObject(item, rowKey, columnKey);\n        \n        // update cached min and max values\n        int r = this.data.getRowIndex(rowKey);\n        int c = this.data.getColumnIndex(columnKey);\n        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn \n                == c) || (this.minimumRangeValueRow == r \n                && this.minimumRangeValueColumn == c))  {\n            updateBounds();\n        }\n        else {\n        \n            double minval = Double.NaN;\n            if (item.getMinOutlier() != null) {\n                minval = item.getMinOutlier().doubleValue();\n            }\n            double maxval = Double.NaN;\n            if (item.getMaxOutlier() != null) {\n                maxval = item.getMaxOutlier().doubleValue();\n            }\n        \n            if (Double.isNaN(this.maximumRangeValue)) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n            else if (maxval > this.maximumRangeValue) {\n                this.maximumRangeValue = maxval;\n                this.maximumRangeValueRow = r;\n                this.maximumRangeValueColumn = c;\n            }\n        \n            if (Double.isNaN(this.minimumRangeValue)) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n            else if (minval < this.minimumRangeValue) {\n                this.minimumRangeValue = minval;\n                this.minimumRangeValueRow = r;\n                this.minimumRangeValueColumn = c;\n            }\n        }\n        \n        this.rangeBounds = new Range(this.minimumRangeValue,\n              this.maximumRangeValue);\n        fireDatasetChanged();\n\n    }\n\n    /**\n     * Return an item from within the dataset.\n     * \n     * @param row  the row index.\n     * @param column  the column index.\n     * \n     * @return The item.\n     */\n    public BoxAndWhiskerItem getItem(int row, int column) {\n        return (BoxAndWhiskerItem) this.data.getObject(row, column);  \n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     * \n     * @see #getMedianValue(int, int)\n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        return getMedianValue(row, column);\n    }\n\n    /**\n     * Returns the value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the columnKey.\n     *\n     * @return The value.\n     * \n     * @see #getMedianValue(Comparable, Comparable)\n     * @see #getValue(int, int)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        return getMedianValue(rowKey, columnKey);\n    }\n\n    /**\n     * Returns the mean value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The mean value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMeanValue(int row, int column) {\n\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(row, \n                column);\n        if (item != null) {\n            result = item.getMean();\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the mean value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The mean value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMeanValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMean();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the median value for an item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     *\n     * @return The median value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMedianValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(row, \n                column);\n        if (item != null) {\n            result = item.getMedian();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the median value for an item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the columnKey.\n     *\n     * @return The median value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMedianValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMedian();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first quartile value.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The first quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ1Value(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getQ1();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first quartile value.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The first quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ1Value(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getQ1();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the third quartile value.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The third quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ3Value(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getQ3();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the third quartile value.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The third quartile value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getQ3Value(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getQ3();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the column key.\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     */\n    public int getColumnIndex(Comparable key) {\n        return this.data.getColumnIndex(key);\n    }\n\n    /**\n     * Returns a column key.\n     *\n     * @param column  the column index (zero-based).\n     *\n     * @return The column key.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public Comparable getColumnKey(int column) {\n        return this.data.getColumnKey(column);\n    }\n\n    /**\n     * Returns the column keys.\n     *\n     * @return The keys.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return this.data.getColumnKeys();\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the row key.\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     */\n    public int getRowIndex(Comparable key) {\n        return this.data.getRowIndex(key);\n    }\n\n    /**\n     * Returns a row key.\n     *\n     * @param row  the row index (zero-based).\n     *\n     * @return The row key.\n     * \n     * @see #getRowIndex(Comparable)\n     */\n    public Comparable getRowKey(int row) {\n        return this.data.getRowKey(row);\n    }\n\n    /**\n     * Returns the row keys.\n     *\n     * @return The keys.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return this.data.getRowKeys();\n    }\n\n    /**\n     * Returns the number of rows in the table.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.data.getRowCount();\n    }\n\n    /**\n     * Returns the number of columns in the table.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.data.getColumnCount();\n    }\n\n    /**\n     * Returns the minimum y-value in the dataset.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The minimum value.\n     * \n     * @see #getRangeUpperBound(boolean)\n     */\n    public double getRangeLowerBound(boolean includeInterval) {\n        return this.minimumRangeValue;\n    }\n\n    /**\n     * Returns the maximum y-value in the dataset.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The maximum value.\n     * \n     * @see #getRangeLowerBound(boolean)\n     */\n    public double getRangeUpperBound(boolean includeInterval) {\n        return this.maximumRangeValue;\n    }\n\n    /**\n     * Returns the range of the values in this dataset's range.\n     *\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * \n     * @return The range.\n     */\n    public Range getRangeBounds(boolean includeInterval) {\n        return this.rangeBounds;\n    }\n    \n    /**\n     * Returns the minimum regular (non outlier) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The minimum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinRegularValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMinRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum regular (non outlier) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The minimum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinRegularValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMinRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum regular (non outlier) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The maximum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxRegularValue(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMaxRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum regular (non outlier) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The maximum regular value.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxRegularValue(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMaxRegularValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum outlier (non farout) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The minimum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinOutlier(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMinOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum outlier (non farout) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The minimum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMinOutlier(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMinOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum outlier (non farout) value for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return The maximum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxOutlier(int row, int column) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getMaxOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum outlier (non farout) value for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return The maximum outlier.\n     * \n     * @see #getItem(int, int)\n     */\n    public Number getMaxOutlier(Comparable rowKey, Comparable columnKey) {\n        Number result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getMaxOutlier();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of outlier values for an item.\n     * \n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * \n     * @return A list of outlier values.\n     * \n     * @see #getItem(int, int)\n     */\n    public List getOutliers(int row, int column) {\n        List result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                row, column);\n        if (item != null) {\n            result = item.getOutliers();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of outlier values for an item.\n     * \n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * \n     * @return A list of outlier values.\n     * \n     * @see #getItem(int, int)\n     */\n    public List getOutliers(Comparable rowKey, Comparable columnKey) {\n        List result = null;\n        BoxAndWhiskerItem item = (BoxAndWhiskerItem) this.data.getObject(\n                rowKey, columnKey);\n        if (item != null) {\n            result = item.getOutliers();\n        }\n        return result;\n    }\n    \n    /**\n     * Resets the cached bounds, by iterating over the entire dataset to find\n     * the current bounds.\n     */\n    private void updateBounds() {\n        this.minimumRangeValue = Double.NaN;\n        this.minimumRangeValueRow = -1;\n        this.minimumRangeValueColumn = -1;\n        this.maximumRangeValue = Double.NaN;\n        this.maximumRangeValueRow = -1;\n        this.maximumRangeValueColumn = -1;\n        int rowCount = getRowCount();\n        int columnCount = getColumnCount();\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                BoxAndWhiskerItem item = getItem(r, c);\n                if (item != null) {\n                    Number min = item.getMinOutlier();\n                    if (min != null) {\n                        double minv = min.doubleValue();\n                        if (!Double.isNaN(minv)) {\n                            if (minv < this.minimumRangeValue || Double.isNaN(\n                                    this.minimumRangeValue)) {\n                                this.minimumRangeValue = minv;\n                                this.minimumRangeValueRow = r;\n                                this.minimumRangeValueColumn = c;\n                            }\n                        }\n                    }\n                    Number max = item.getMaxOutlier();\n                    if (max != null) {\n                        double maxv = max.doubleValue();\n                        if (!Double.isNaN(maxv)) {\n                            if (maxv > this.maximumRangeValue || Double.isNaN(\n                                    this.maximumRangeValue)) {\n                                this.maximumRangeValue = maxv;\n                                this.maximumRangeValueRow = r;\n                                this.maximumRangeValueColumn = c;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Tests this dataset for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;   \n        }\n        if (obj instanceof DefaultBoxAndWhiskerCategoryDataset) {\n            DefaultBoxAndWhiskerCategoryDataset dataset \n                    = (DefaultBoxAndWhiskerCategoryDataset) obj;\n            return ObjectUtilities.equal(this.data, dataset.data);\n        }\n        return false;\n    }\n    \n    /**\n     * Returns a clone of this dataset.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if cloning is not possible.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultBoxAndWhiskerCategoryDataset clone \n                = (DefaultBoxAndWhiskerCategoryDataset) super.clone();\n        clone.data = (KeyedObjects2D) this.data.clone();\n        return clone;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 22, "classes_modified": [{"class_name": "org.jfree.data.KeyedObjects2D", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ------------------\n * KeyedObject2D.java\n * ------------------\n * (C) Copyright 2003-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 05-Feb-2003 : Version 1 (DG);\n * 01-Mar-2004 : Added equals() and clone() methods and implemented \n *               Serializable (DG);\n * 03-Oct-2007 : Updated getObject() to handle modified behaviour in \n *               KeyedObjects class (DG);\n *\n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\n\n/**\n * A data structure that stores zero, one or many objects, where each object is\n * associated with two keys (a 'row' key and a 'column' key).\n */\npublic class KeyedObjects2D implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -1015873563138522374L;\n    \n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public KeyedObjects2D() {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the object for a given row and column.\n     *\n     * @param row  the row index (in the range 0 to getRowCount() - 1).\n     * @param column  the column index (in the range 0 to getColumnCount() - 1).\n     *\n     * @return The object (possibly <code>null</code>).\n     * \n     * @see #getObject(Comparable, Comparable)\n     */\n    public Object getObject(int row, int column) {\n        Object result = null;\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            if (columnKey != null) {\n                int index = rowData.getIndex(columnKey);\n                if (index >= 0) {\n                    result = rowData.getObject(columnKey);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (zero based).\n     *\n     * @return The row index.\n     * \n     * @see #getRowIndex(Comparable)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key.\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     */\n    public int getRowIndex(Comparable key) {\n        return this.rowKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the row keys.\n     *\n     * @return The row keys (never <code>null</code>).\n     * \n     * @see #getRowKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column.\n     *\n     * @return The key.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key.\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     */\n    public int getColumnIndex(Comparable key) {\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys.\n     *\n     * @return The column keys (never <code>null</code>).\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the object for the given row and column keys.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The object (possibly <code>null</code>).\n     * \n     * @throws IllegalArgumentException if <code>rowKey<code> or \n     *         <code>columnKey</code> is <code>null</code>.\n     * @throws UnknownKeyException if <code>rowKey</code> or \n     *         <code>columnKey</code> is not recognised.\n     */\n    public Object getObject(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        int row = this.rowKeys.indexOf(rowKey);\n        if (row < 0) {\n            throw new UnknownKeyException(\"Row key (\" + rowKey \n                    + \") not recognised.\");\n        }\n        int column = this.columnKeys.indexOf(columnKey);\n        if (column < 0) {\n            throw new UnknownKeyException(\"Column key (\" + columnKey \n                    + \") not recognised.\");\n        }\n        if (row >= 0) {\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n            return rowData.getObject(columnKey);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Adds an object to the table.  Performs the same function as setObject().\n     *\n     * @param object  the object.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     */\n    public void addObject(Object object, Comparable rowKey, \n            Comparable columnKey) {\n        setObject(object, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates an object.\n     *\n     * @param object  the object.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     */\n    public void setObject(Object object, Comparable rowKey, \n            Comparable columnKey) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        KeyedObjects row;\n        int rowIndex = this.rowKeys.indexOf(rowKey);\n        if (rowIndex >= 0) {\n            row = (KeyedObjects) this.rows.get(rowIndex);\n        }\n        else {\n            this.rowKeys.add(rowKey);\n            row = new KeyedObjects();\n            this.rows.add(row);\n        }\n        row.setObject(columnKey, object);\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n\n    }\n\n    /**\n     * Removes an object from the table by setting it to <code>null</code>.  If\n     * all the objects in the specified row and/or column are now \n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addObject(Object, Comparable, Comparable)\n     */\n    public void removeObject(Comparable rowKey, Comparable columnKey) {\n        setObject(null, rowKey, columnKey);\n        \n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; \n             item++) {\n            if (row.getObject(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n        \n        // 2. check whether the column is now empty.\n        \n        \n    }\n\n    /**\n     * Removes an entire row from the table.\n     *\n     * @param rowIndex  the row index.\n     * \n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes an entire row from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.\n     * \n     * @see #removeColumn(Comparable)\n     */\n    public void removeRow(Comparable rowKey) {\n        int index = getRowIndex(rowKey);\n        removeRow(index);\n    }\n\n    /**\n     * Removes an entire column from the table.\n     *\n     * @param columnIndex  the column index.\n     * \n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes an entire column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.\n     * \n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n        int index = getColumnIndex(columnKey);\n        if (index < 0) {\n            throw new UnknownKeyException(\"Column key (\" + columnKey \n                    + \") not recognised.\");\n        }\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            KeyedObjects rowData = (KeyedObjects) iterator.next();\n                rowData.removeValue(columnKey);\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object to test (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof KeyedObjects2D)) {\n            return false;\n        }\n        \n        KeyedObjects2D that = (KeyedObjects2D) obj;\n        if (!getRowKeys().equals(that.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(that.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != that.getRowCount()) {\n            return false;\n        }\n        int colCount = getColumnCount();\n        if (colCount != that.getColumnCount()) {\n            return false;\n        }\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Object v1 = getObject(r, c);\n                Object v2 = that.getObject(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hashcode for this object.\n     * \n     * @return A hashcode.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        KeyedObjects2D clone = (KeyedObjects2D) super.clone();\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n        clone.rows = new java.util.ArrayList(this.rows.size());\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            KeyedObjects row = (KeyedObjects) iterator.next();\n            clone.rows.add(row.clone());\n        }\n        return clone;\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ------------------\n * KeyedObject2D.java\n * ------------------\n * (C) Copyright 2003-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 05-Feb-2003 : Version 1 (DG);\n * 01-Mar-2004 : Added equals() and clone() methods and implemented \n *               Serializable (DG);\n * 03-Oct-2007 : Updated getObject() to handle modified behaviour in \n *               KeyedObjects class (DG);\n *\n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\n\n/**\n * A data structure that stores zero, one or many objects, where each object is\n * associated with two keys (a 'row' key and a 'column' key).\n */\npublic class KeyedObjects2D implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -1015873563138522374L;\n    \n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public KeyedObjects2D() {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the object for a given row and column.\n     *\n     * @param row  the row index (in the range 0 to getRowCount() - 1).\n     * @param column  the column index (in the range 0 to getColumnCount() - 1).\n     *\n     * @return The object (possibly <code>null</code>).\n     * \n     * @see #getObject(Comparable, Comparable)\n     */\n    public Object getObject(int row, int column) {\n        Object result = null;\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            if (columnKey != null) {\n                int index = rowData.getIndex(columnKey);\n                if (index >= 0) {\n                    result = rowData.getObject(columnKey);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (zero based).\n     *\n     * @return The row index.\n     * \n     * @see #getRowIndex(Comparable)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key.\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     */\n    public int getRowIndex(Comparable key) {\n        return this.rowKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the row keys.\n     *\n     * @return The row keys (never <code>null</code>).\n     * \n     * @see #getRowKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column.\n     *\n     * @return The key.\n     * \n     * @see #getColumnIndex(Comparable)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key.\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     */\n    public int getColumnIndex(Comparable key) {\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys.\n     *\n     * @return The column keys (never <code>null</code>).\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the object for the given row and column keys.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The object (possibly <code>null</code>).\n     * \n     * @throws IllegalArgumentException if <code>rowKey<code> or \n     *         <code>columnKey</code> is <code>null</code>.\n     * @throws UnknownKeyException if <code>rowKey</code> or \n     *         <code>columnKey</code> is not recognised.\n     */\n    public Object getObject(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        int row = this.rowKeys.indexOf(rowKey);\n        if (row < 0) {\n            throw new UnknownKeyException(\"Row key (\" + rowKey \n                    + \") not recognised.\");\n        }\n        int column = this.columnKeys.indexOf(columnKey);\n        if (column < 0) {\n            throw new UnknownKeyException(\"Column key (\" + columnKey \n                    + \") not recognised.\");\n        }\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n        int index = rowData.getIndex(columnKey);\n        if (index >= 0) {\n            return rowData.getObject(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Adds an object to the table.  Performs the same function as setObject().\n     *\n     * @param object  the object.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     */\n    public void addObject(Object object, Comparable rowKey, \n            Comparable columnKey) {\n        setObject(object, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates an object.\n     *\n     * @param object  the object.\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     */\n    public void setObject(Object object, Comparable rowKey, \n            Comparable columnKey) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        KeyedObjects row;\n        int rowIndex = this.rowKeys.indexOf(rowKey);\n        if (rowIndex >= 0) {\n            row = (KeyedObjects) this.rows.get(rowIndex);\n        }\n        else {\n            this.rowKeys.add(rowKey);\n            row = new KeyedObjects();\n            this.rows.add(row);\n        }\n        row.setObject(columnKey, object);\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n\n    }\n\n    /**\n     * Removes an object from the table by setting it to <code>null</code>.  If\n     * all the objects in the specified row and/or column are now \n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addObject(Object, Comparable, Comparable)\n     */\n    public void removeObject(Comparable rowKey, Comparable columnKey) {\n        setObject(null, rowKey, columnKey);\n        \n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; \n             item++) {\n            if (row.getObject(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n        \n        // 2. check whether the column is now empty.\n        allNull = true;\n        \n        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n             item++) {\n            row = (KeyedObjects) this.rows.get(item);\n            int columnIndex = row.getIndex(columnKey);\n            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n                 item++) {\n                row = (KeyedObjects) this.rows.get(item);\n                int columnIndex = row.getIndex(columnKey);\n                if (columnIndex >= 0) {\n                    row.removeValue(columnIndex);\n                }\n            }\n            this.columnKeys.remove(columnKey);\n        }\n    }\n\n    /**\n     * Removes an entire row from the table.\n     *\n     * @param rowIndex  the row index.\n     * \n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes an entire row from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.\n     * \n     * @see #removeColumn(Comparable)\n     */\n    public void removeRow(Comparable rowKey) {\n        int index = getRowIndex(rowKey);\n        if (index < 0) {\n            throw new UnknownKeyException(\"Row key (\" + rowKey \n                    + \") not recognised.\");\n        }\n        removeRow(index);\n    }\n\n    /**\n     * Removes an entire column from the table.\n     *\n     * @param columnIndex  the column index.\n     * \n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes an entire column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if <code>rowKey</code> is not recognised.\n     * \n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n        int index = getColumnIndex(columnKey);\n        if (index < 0) {\n            throw new UnknownKeyException(\"Column key (\" + columnKey \n                    + \") not recognised.\");\n        }\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            KeyedObjects rowData = (KeyedObjects) iterator.next();\n            int i = rowData.getIndex(columnKey);\n            if (i >= 0) {\n                rowData.removeValue(i);\n            }\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object to test (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof KeyedObjects2D)) {\n            return false;\n        }\n        \n        KeyedObjects2D that = (KeyedObjects2D) obj;\n        if (!getRowKeys().equals(that.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(that.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != that.getRowCount()) {\n            return false;\n        }\n        int colCount = getColumnCount();\n        if (colCount != that.getColumnCount()) {\n            return false;\n        }\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Object v1 = getObject(r, c);\n                Object v2 = that.getObject(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hashcode for this object.\n     * \n     * @return A hashcode.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        KeyedObjects2D clone = (KeyedObjects2D) super.clone();\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n        clone.rows = new java.util.ArrayList(this.rows.size());\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            KeyedObjects row = (KeyedObjects) iterator.next();\n            clone.rows.add(row.clone());\n        }\n        return clone;\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 23, "classes_modified": [{"class_name": "org.jfree.chart.renderer.category.MinMaxCategoryRenderer", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------------\n * MinMaxCategoryRenderer.java\n * ---------------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  Tomer Peretz;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Christian W. Zuckschwerdt;\n *                   Nicolas Brodu (for Astrium and EADS Corporate Research \n *                   Center);\n *\n * $Id: MinMaxCategoryRenderer.java,v 1.6.2.8 2007/06/01 15:12:15 mungady Exp $\n *\n * Changes:\n * --------\n * 29-May-2002 : Version 1 (TP);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 24-Oct-2002 : Amendments for changes in CategoryDataset interface and \n *               CategoryToolTipGenerator interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 17-Jan-2003 : Moved plot classes to a separate package (DG);\n * 10-Apr-2003 : Changed CategoryDataset to KeyedValues2DDataset in drawItem() \n *               method (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 08-Sep-2003 : Implemented Serializable (NB);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 05-Nov-2004 : Modified drawItem() signature (DG);\n * 17-Nov-2005 : Added change events and argument checks (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 02-Feb-2007 : Removed author tags all over JFreeChart sources (DG);\n * 09-Mar-2007 : Fixed problem with horizontal rendering (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 28-Sep-2007 : Added equals() method override (DG);\n * \n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport javax.swing.Icon;\n\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.category.CategoryDataset;\n\n/**\n * Renderer for drawing min max plot. This renderer draws all the series under \n * the same category in the same x position using <code>objectIcon</code> and \n * a line from the maximum value to the minimum value.\n * <p>\n * For use with the {@link org.jfree.chart.plot.CategoryPlot} class.\n */\npublic class MinMaxCategoryRenderer extends AbstractCategoryItemRenderer {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 2935615937671064911L;\n    \n    /** A flag indicating whether or not lines are drawn between XY points. */\n    private boolean plotLines = false;\n\n    /** \n     * The paint of the line between the minimum value and the maximum value.\n     */\n    private transient Paint groupPaint = Color.black;\n\n    /** \n     * The stroke of the line between the minimum value and the maximum value.\n     */\n    private transient Stroke groupStroke = new BasicStroke(1.0f);\n\n    /** The icon used to indicate the minimum value.*/\n    private transient Icon minIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0,\n            360, Arc2D.OPEN), null, Color.black);\n\n    /** The icon used to indicate the maximum value.*/\n    private transient Icon maxIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0,\n            360, Arc2D.OPEN), null, Color.black);\n\n    /** The icon used to indicate the values.*/\n    private transient Icon objectIcon = getIcon(new Line2D.Double(-4, 0, 4, 0),\n            false, true);\n\n    /** The last category. */\n    private int lastCategory = -1;\n\n    /** The minimum. */\n    private double min;\n\n    /** The maximum. */\n    private double max;\n\n    /**\n     * Default constructor.\n     */\n    public MinMaxCategoryRenderer() {\n        super();\n    }\n\n    /**\n     * Gets whether or not lines are drawn between category points.\n     *\n     * @return boolean true if line will be drawn between sequenced categories,\n     *         otherwise false.\n     *         \n     * @see #setDrawLines(boolean)\n     */\n    public boolean isDrawLines() {\n        return this.plotLines;\n    }\n\n    /**\n     * Sets the flag that controls whether or not lines are drawn to connect\n     * the items within a series and sends a {@link RendererChangeEvent} to \n     * all registered listeners.\n     *\n     * @param draw  the new value of the flag.\n     * \n     * @see #isDrawLines()\n     */\n    public void setDrawLines(boolean draw) {\n        if (this.plotLines != draw) {\n            this.plotLines = draw;\n            this.notifyListeners(new RendererChangeEvent(this));\n        }\n        \n    }\n\n    /**\n     * Returns the paint used to draw the line between the minimum and maximum\n     * value items in each category.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setGroupPaint(Paint)\n     */\n    public Paint getGroupPaint() {\n        return this.groupPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the line between the minimum and maximum\n     * value items in each category and sends a {@link RendererChangeEvent} to\n     * all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getGroupPaint()\n     */\n    public void setGroupPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.groupPaint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw the line between the minimum and maximum\n     * value items in each category.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setGroupStroke(Stroke)\n     */\n    public Stroke getGroupStroke() {\n        return this.groupStroke;\n    }\n\n    /**\n     * Sets the stroke of the line between the minimum value and the maximum \n     * value and sends a {@link RendererChangeEvent} to all registered \n     * listeners.\n     *\n     * @param stroke the new stroke (<code>null</code> not permitted).\n     */\n    public void setGroupStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.groupStroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));        \n    }\n\n    /**\n     * Returns the icon drawn for each data item.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setObjectIcon(Icon)\n     */\n    public Icon getObjectIcon() {\n        return this.objectIcon;\n    }\n\n    /**\n     * Sets the icon drawn for each data item.\n     *\n     * @param icon  the icon.\n     * \n     * @see #getObjectIcon()\n     */\n    public void setObjectIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.objectIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the icon displayed for the maximum value data item within each\n     * category.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setMaxIcon(Icon)\n     */\n    public Icon getMaxIcon() {\n        return this.maxIcon;\n    }\n\n    /**\n     * Sets the icon displayed for the maximum value data item within each\n     * category and sends a {@link RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param icon  the icon (<code>null</code> not permitted).\n     * \n     * @see #getMaxIcon()\n     */\n    public void setMaxIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.maxIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the icon displayed for the minimum value data item within each\n     * category.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setMinIcon(Icon)\n     */\n    public Icon getMinIcon() {\n        return this.minIcon;\n    }\n\n    /**\n     * Sets the icon displayed for the minimum value data item within each\n     * category and sends a {@link RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param icon  the icon (<code>null</code> not permitted).\n     * \n     * @see #getMinIcon()\n     */\n    public void setMinIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.minIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Draw a single data item.\n     *\n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the area in which the data is drawn.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param pass  the pass index.\n     */\n    public void drawItem(Graphics2D g2, CategoryItemRendererState state,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            int pass) {\n\n        // first check the number we are plotting...\n        Number value = dataset.getValue(row, column);\n        if (value != null) {\n            // current data point...\n            double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), \n                    dataArea, plot.getDomainAxisEdge());\n            double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, \n                    plot.getRangeAxisEdge());\n            g2.setPaint(getItemPaint(row, column));\n            g2.setStroke(getItemStroke(row, column));\n            Shape shape = null;\n            shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);\n            \n            PlotOrientation orient = plot.getOrientation();\n            if (orient == PlotOrientation.VERTICAL) {\n                this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);\n            }\n            else {\n                this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);                \n            }\n            \n            if (this.lastCategory == column) {\n                if (this.min > value.doubleValue()) {\n                    this.min = value.doubleValue();\n                }\n                if (this.max < value.doubleValue()) {\n                    this.max = value.doubleValue();\n                }\n                \n                // last series, so we are ready to draw the min and max\n                if (dataset.getRowCount() - 1 == row) {\n                    g2.setPaint(this.groupPaint);\n                    g2.setStroke(this.groupStroke);\n                    double minY = rangeAxis.valueToJava2D(this.min, dataArea, \n                            plot.getRangeAxisEdge());\n                    double maxY = rangeAxis.valueToJava2D(this.max, dataArea, \n                            plot.getRangeAxisEdge());\n                    \n                    if (orient == PlotOrientation.VERTICAL) {\n                        g2.draw(new Line2D.Double(x1, minY, x1, maxY));\n                        this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);\n                        this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);\n                    }\n                    else {\n                        g2.draw(new Line2D.Double(minY, x1, maxY, x1));\n                        this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);\n                        this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);                        \n                    }\n                }\n            }\n            else {  // reset the min and max\n                this.lastCategory = column;\n                this.min = value.doubleValue();\n                this.max = value.doubleValue();\n            }\n            \n            // connect to the previous point\n            if (this.plotLines) {\n                if (column != 0) {\n                    Number previousValue = dataset.getValue(row, column - 1);\n                    if (previousValue != null) {\n                        // previous data point...\n                        double previous = previousValue.doubleValue();\n                        double x0 = domainAxis.getCategoryMiddle(column - 1, \n                                getColumnCount(), dataArea,\n                                plot.getDomainAxisEdge());\n                        double y0 = rangeAxis.valueToJava2D(previous, dataArea,\n                                plot.getRangeAxisEdge());\n                        g2.setPaint(getItemPaint(row, column));\n                        g2.setStroke(getItemStroke(row, column));\n                        Line2D line;\n                        if (orient == PlotOrientation.VERTICAL) {\n                            line = new Line2D.Double(x0, y0, x1, y1);\n                        }\n                        else {\n                            line = new Line2D.Double(y0, x0, y1, x1);                            \n                        }\n                        g2.draw(line);\n                    }\n                }\n            }\n\n            // add an item entity, if this information is being collected\n            EntityCollection entities = state.getEntityCollection();\n            if (entities != null && shape != null) {\n                addItemEntity(entities, dataset, row, column, shape);\n            }\n        }\n    }\n    \n    /**\n     * Tests this instance for equality with an arbitrary object.  The icon fields\n     * are NOT included in the test, so this implementation is a little weak.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     *\n     * @since 1.0.7\n     */\n\n    /**\n     * Returns an icon.\n     *\n     * @param shape  the shape.\n     * @param fillPaint  the fill paint.\n     * @param outlinePaint  the outline paint.\n     *\n     * @return The icon.\n     */\n    private Icon getIcon(Shape shape, final Paint fillPaint, \n                        final Paint outlinePaint) {\n\n      final int width = shape.getBounds().width;\n      final int height = shape.getBounds().height;\n      final GeneralPath path = new GeneralPath(shape);\n      return new Icon() {\n          public void paintIcon(Component c, Graphics g, int x, int y) {\n              Graphics2D g2 = (Graphics2D) g;\n              path.transform(AffineTransform.getTranslateInstance(x, y));\n              if (fillPaint != null) {\n                  g2.setPaint(fillPaint);\n                  g2.fill(path);\n              }\n              if (outlinePaint != null) {\n                  g2.setPaint(outlinePaint);\n                  g2.draw(path);\n              }\n              path.transform(AffineTransform.getTranslateInstance(-x, -y));\n        }\n\n        public int getIconWidth() {\n            return width;\n        }\n\n        public int getIconHeight() {\n            return height;\n        }\n\n      };\n    }\n\n    /**\n     * Returns an icon from a shape.\n     *\n     * @param shape  the shape.\n     * @param fill  the fill flag.\n     * @param outline  the outline flag.\n     *\n     * @return The icon.\n     */\n    private Icon getIcon(Shape shape, final boolean fill, \n            final boolean outline) {\n        final int width = shape.getBounds().width;\n        final int height = shape.getBounds().height;\n        final GeneralPath path = new GeneralPath(shape);\n        return new Icon() {\n            public void paintIcon(Component c, Graphics g, int x, int y) {\n                Graphics2D g2 = (Graphics2D) g;\n                path.transform(AffineTransform.getTranslateInstance(x, y));\n                if (fill) {\n                    g2.fill(path);\n                }\n                if (outline) {\n                    g2.draw(path);\n                }\n                path.transform(AffineTransform.getTranslateInstance(-x, -y));\n            }\n\n            public int getIconWidth() {\n                return width;\n            }\n\n            public int getIconHeight() {\n                return height;\n            }\n        };\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.groupStroke, stream);\n        SerialUtilities.writePaint(this.groupPaint, stream);\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.groupStroke = SerialUtilities.readStroke(stream);\n        this.groupPaint = SerialUtilities.readPaint(stream);\n          \n        this.minIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0, 360, \n                Arc2D.OPEN), null, Color.black);\n        this.maxIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0, 360, \n                Arc2D.OPEN), null, Color.black);\n        this.objectIcon = getIcon(new Line2D.Double(-4, 0, 4, 0), false, true);\n    }\n    \n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------------\n * MinMaxCategoryRenderer.java\n * ---------------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  Tomer Peretz;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Christian W. Zuckschwerdt;\n *                   Nicolas Brodu (for Astrium and EADS Corporate Research \n *                   Center);\n *\n * $Id: MinMaxCategoryRenderer.java,v 1.6.2.8 2007/06/01 15:12:15 mungady Exp $\n *\n * Changes:\n * --------\n * 29-May-2002 : Version 1 (TP);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 24-Oct-2002 : Amendments for changes in CategoryDataset interface and \n *               CategoryToolTipGenerator interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 17-Jan-2003 : Moved plot classes to a separate package (DG);\n * 10-Apr-2003 : Changed CategoryDataset to KeyedValues2DDataset in drawItem() \n *               method (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 08-Sep-2003 : Implemented Serializable (NB);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 05-Nov-2004 : Modified drawItem() signature (DG);\n * 17-Nov-2005 : Added change events and argument checks (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 02-Feb-2007 : Removed author tags all over JFreeChart sources (DG);\n * 09-Mar-2007 : Fixed problem with horizontal rendering (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 28-Sep-2007 : Added equals() method override (DG);\n * \n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport javax.swing.Icon;\n\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.category.CategoryDataset;\n\n/**\n * Renderer for drawing min max plot. This renderer draws all the series under \n * the same category in the same x position using <code>objectIcon</code> and \n * a line from the maximum value to the minimum value.\n * <p>\n * For use with the {@link org.jfree.chart.plot.CategoryPlot} class.\n */\npublic class MinMaxCategoryRenderer extends AbstractCategoryItemRenderer {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 2935615937671064911L;\n    \n    /** A flag indicating whether or not lines are drawn between XY points. */\n    private boolean plotLines = false;\n\n    /** \n     * The paint of the line between the minimum value and the maximum value.\n     */\n    private transient Paint groupPaint = Color.black;\n\n    /** \n     * The stroke of the line between the minimum value and the maximum value.\n     */\n    private transient Stroke groupStroke = new BasicStroke(1.0f);\n\n    /** The icon used to indicate the minimum value.*/\n    private transient Icon minIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0,\n            360, Arc2D.OPEN), null, Color.black);\n\n    /** The icon used to indicate the maximum value.*/\n    private transient Icon maxIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0,\n            360, Arc2D.OPEN), null, Color.black);\n\n    /** The icon used to indicate the values.*/\n    private transient Icon objectIcon = getIcon(new Line2D.Double(-4, 0, 4, 0),\n            false, true);\n\n    /** The last category. */\n    private int lastCategory = -1;\n\n    /** The minimum. */\n    private double min;\n\n    /** The maximum. */\n    private double max;\n\n    /**\n     * Default constructor.\n     */\n    public MinMaxCategoryRenderer() {\n        super();\n    }\n\n    /**\n     * Gets whether or not lines are drawn between category points.\n     *\n     * @return boolean true if line will be drawn between sequenced categories,\n     *         otherwise false.\n     *         \n     * @see #setDrawLines(boolean)\n     */\n    public boolean isDrawLines() {\n        return this.plotLines;\n    }\n\n    /**\n     * Sets the flag that controls whether or not lines are drawn to connect\n     * the items within a series and sends a {@link RendererChangeEvent} to \n     * all registered listeners.\n     *\n     * @param draw  the new value of the flag.\n     * \n     * @see #isDrawLines()\n     */\n    public void setDrawLines(boolean draw) {\n        if (this.plotLines != draw) {\n            this.plotLines = draw;\n            this.notifyListeners(new RendererChangeEvent(this));\n        }\n        \n    }\n\n    /**\n     * Returns the paint used to draw the line between the minimum and maximum\n     * value items in each category.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setGroupPaint(Paint)\n     */\n    public Paint getGroupPaint() {\n        return this.groupPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the line between the minimum and maximum\n     * value items in each category and sends a {@link RendererChangeEvent} to\n     * all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getGroupPaint()\n     */\n    public void setGroupPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.groupPaint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw the line between the minimum and maximum\n     * value items in each category.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setGroupStroke(Stroke)\n     */\n    public Stroke getGroupStroke() {\n        return this.groupStroke;\n    }\n\n    /**\n     * Sets the stroke of the line between the minimum value and the maximum \n     * value and sends a {@link RendererChangeEvent} to all registered \n     * listeners.\n     *\n     * @param stroke the new stroke (<code>null</code> not permitted).\n     */\n    public void setGroupStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.groupStroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));        \n    }\n\n    /**\n     * Returns the icon drawn for each data item.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setObjectIcon(Icon)\n     */\n    public Icon getObjectIcon() {\n        return this.objectIcon;\n    }\n\n    /**\n     * Sets the icon drawn for each data item.\n     *\n     * @param icon  the icon.\n     * \n     * @see #getObjectIcon()\n     */\n    public void setObjectIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.objectIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the icon displayed for the maximum value data item within each\n     * category.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setMaxIcon(Icon)\n     */\n    public Icon getMaxIcon() {\n        return this.maxIcon;\n    }\n\n    /**\n     * Sets the icon displayed for the maximum value data item within each\n     * category and sends a {@link RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param icon  the icon (<code>null</code> not permitted).\n     * \n     * @see #getMaxIcon()\n     */\n    public void setMaxIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.maxIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the icon displayed for the minimum value data item within each\n     * category.\n     *\n     * @return The icon (never <code>null</code>).\n     * \n     * @see #setMinIcon(Icon)\n     */\n    public Icon getMinIcon() {\n        return this.minIcon;\n    }\n\n    /**\n     * Sets the icon displayed for the minimum value data item within each\n     * category and sends a {@link RendererChangeEvent} to all registered\n     * listeners.\n     *\n     * @param icon  the icon (<code>null</code> not permitted).\n     * \n     * @see #getMinIcon()\n     */\n    public void setMinIcon(Icon icon) {\n        if (icon == null) {\n            throw new IllegalArgumentException(\"Null 'icon' argument.\");\n        }\n        this.minIcon = icon;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Draw a single data item.\n     *\n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the area in which the data is drawn.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param pass  the pass index.\n     */\n    public void drawItem(Graphics2D g2, CategoryItemRendererState state,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            int pass) {\n\n        // first check the number we are plotting...\n        Number value = dataset.getValue(row, column);\n        if (value != null) {\n            // current data point...\n            double x1 = domainAxis.getCategoryMiddle(column, getColumnCount(), \n                    dataArea, plot.getDomainAxisEdge());\n            double y1 = rangeAxis.valueToJava2D(value.doubleValue(), dataArea, \n                    plot.getRangeAxisEdge());\n            g2.setPaint(getItemPaint(row, column));\n            g2.setStroke(getItemStroke(row, column));\n            Shape shape = null;\n            shape = new Rectangle2D.Double(x1 - 4, y1 - 4, 8.0, 8.0);\n            \n            PlotOrientation orient = plot.getOrientation();\n            if (orient == PlotOrientation.VERTICAL) {\n                this.objectIcon.paintIcon(null, g2, (int) x1, (int) y1);\n            }\n            else {\n                this.objectIcon.paintIcon(null, g2, (int) y1, (int) x1);                \n            }\n            \n            if (this.lastCategory == column) {\n                if (this.min > value.doubleValue()) {\n                    this.min = value.doubleValue();\n                }\n                if (this.max < value.doubleValue()) {\n                    this.max = value.doubleValue();\n                }\n                \n                // last series, so we are ready to draw the min and max\n                if (dataset.getRowCount() - 1 == row) {\n                    g2.setPaint(this.groupPaint);\n                    g2.setStroke(this.groupStroke);\n                    double minY = rangeAxis.valueToJava2D(this.min, dataArea, \n                            plot.getRangeAxisEdge());\n                    double maxY = rangeAxis.valueToJava2D(this.max, dataArea, \n                            plot.getRangeAxisEdge());\n                    \n                    if (orient == PlotOrientation.VERTICAL) {\n                        g2.draw(new Line2D.Double(x1, minY, x1, maxY));\n                        this.minIcon.paintIcon(null, g2, (int) x1, (int) minY);\n                        this.maxIcon.paintIcon(null, g2, (int) x1, (int) maxY);\n                    }\n                    else {\n                        g2.draw(new Line2D.Double(minY, x1, maxY, x1));\n                        this.minIcon.paintIcon(null, g2, (int) minY, (int) x1);\n                        this.maxIcon.paintIcon(null, g2, (int) maxY, (int) x1);                        \n                    }\n                }\n            }\n            else {  // reset the min and max\n                this.lastCategory = column;\n                this.min = value.doubleValue();\n                this.max = value.doubleValue();\n            }\n            \n            // connect to the previous point\n            if (this.plotLines) {\n                if (column != 0) {\n                    Number previousValue = dataset.getValue(row, column - 1);\n                    if (previousValue != null) {\n                        // previous data point...\n                        double previous = previousValue.doubleValue();\n                        double x0 = domainAxis.getCategoryMiddle(column - 1, \n                                getColumnCount(), dataArea,\n                                plot.getDomainAxisEdge());\n                        double y0 = rangeAxis.valueToJava2D(previous, dataArea,\n                                plot.getRangeAxisEdge());\n                        g2.setPaint(getItemPaint(row, column));\n                        g2.setStroke(getItemStroke(row, column));\n                        Line2D line;\n                        if (orient == PlotOrientation.VERTICAL) {\n                            line = new Line2D.Double(x0, y0, x1, y1);\n                        }\n                        else {\n                            line = new Line2D.Double(y0, x0, y1, x1);                            \n                        }\n                        g2.draw(line);\n                    }\n                }\n            }\n\n            // add an item entity, if this information is being collected\n            EntityCollection entities = state.getEntityCollection();\n            if (entities != null && shape != null) {\n                addItemEntity(entities, dataset, row, column, shape);\n            }\n        }\n    }\n    \n    /**\n     * Tests this instance for equality with an arbitrary object.  The icon fields\n     * are NOT included in the test, so this implementation is a little weak.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     *\n     * @since 1.0.7\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MinMaxCategoryRenderer)) {\n            return false;\n        }\n        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;\n        if (this.plotLines != that.plotLines) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {\n            return false;\n        }\n        if (!this.groupStroke.equals(that.groupStroke)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns an icon.\n     *\n     * @param shape  the shape.\n     * @param fillPaint  the fill paint.\n     * @param outlinePaint  the outline paint.\n     *\n     * @return The icon.\n     */\n    private Icon getIcon(Shape shape, final Paint fillPaint, \n                        final Paint outlinePaint) {\n\n      final int width = shape.getBounds().width;\n      final int height = shape.getBounds().height;\n      final GeneralPath path = new GeneralPath(shape);\n      return new Icon() {\n          public void paintIcon(Component c, Graphics g, int x, int y) {\n              Graphics2D g2 = (Graphics2D) g;\n              path.transform(AffineTransform.getTranslateInstance(x, y));\n              if (fillPaint != null) {\n                  g2.setPaint(fillPaint);\n                  g2.fill(path);\n              }\n              if (outlinePaint != null) {\n                  g2.setPaint(outlinePaint);\n                  g2.draw(path);\n              }\n              path.transform(AffineTransform.getTranslateInstance(-x, -y));\n        }\n\n        public int getIconWidth() {\n            return width;\n        }\n\n        public int getIconHeight() {\n            return height;\n        }\n\n      };\n    }\n\n    /**\n     * Returns an icon from a shape.\n     *\n     * @param shape  the shape.\n     * @param fill  the fill flag.\n     * @param outline  the outline flag.\n     *\n     * @return The icon.\n     */\n    private Icon getIcon(Shape shape, final boolean fill, \n            final boolean outline) {\n        final int width = shape.getBounds().width;\n        final int height = shape.getBounds().height;\n        final GeneralPath path = new GeneralPath(shape);\n        return new Icon() {\n            public void paintIcon(Component c, Graphics g, int x, int y) {\n                Graphics2D g2 = (Graphics2D) g;\n                path.transform(AffineTransform.getTranslateInstance(x, y));\n                if (fill) {\n                    g2.fill(path);\n                }\n                if (outline) {\n                    g2.draw(path);\n                }\n                path.transform(AffineTransform.getTranslateInstance(-x, -y));\n            }\n\n            public int getIconWidth() {\n                return width;\n            }\n\n            public int getIconHeight() {\n                return height;\n            }\n        };\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.groupStroke, stream);\n        SerialUtilities.writePaint(this.groupPaint, stream);\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.groupStroke = SerialUtilities.readStroke(stream);\n        this.groupPaint = SerialUtilities.readPaint(stream);\n          \n        this.minIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0, 360, \n                Arc2D.OPEN), null, Color.black);\n        this.maxIcon = getIcon(new Arc2D.Double(-4, -4, 8, 8, 0, 360, \n                Arc2D.OPEN), null, Color.black);\n        this.objectIcon = getIcon(new Line2D.Double(-4, 0, 4, 0), false, true);\n    }\n    \n}\n"}]}
{"project": "Chart", "bug_id": 24, "classes_modified": [{"class_name": "org.jfree.chart.renderer.GrayPaintScale", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -------------------\n * GrayPaintScale.java\n * -------------------\n * (C) Copyright 2006, 2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * $Id: GrayPaintScale.java,v 1.1.2.1 2007/01/31 14:15:16 mungady Exp $\n *\n * Changes\n * -------\n * 05-Jul-2006 : Version 1 (DG);\n * 31-Jan-2007 : Renamed min and max to lowerBound and upperBound (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 26-Sep-2007 : Fixed bug 1767315, problem in getPaint() method (DG);\n * \n */\n\npackage org.jfree.chart.renderer;\n\nimport java.awt.Color;\nimport java.awt.Paint;\nimport java.io.Serializable;\n\nimport org.jfree.chart.util.PublicCloneable;\n\n/**\n * A paint scale that returns shades of gray.\n * \n * @since 1.0.4\n */\npublic class GrayPaintScale \n        implements PaintScale, PublicCloneable, Serializable {\n\n    /** The lower bound. */\n    private double lowerBound;\n    \n    /** The upper bound. */\n    private double upperBound;\n    \n    /**\n     * Creates a new <code>GrayPaintScale</code> instance with default values.\n     */\n    public GrayPaintScale() {\n        this(0.0, 1.0);\n    }\n    \n    /**\n     * Creates a new paint scale for values in the specified range.\n     * \n     * @param lowerBound  the lower bound.\n     * @param upperBound  the upper bound.\n     * \n     * @throws IllegalArgumentException if <code>lowerBound</code> is not\n     *       less than <code>upperBound</code>.\n     */\n    public GrayPaintScale(double lowerBound, double upperBound) {\n        if (lowerBound >= upperBound) {\n            throw new IllegalArgumentException(\n                    \"Requires lowerBound < upperBound.\");\n        }\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n    }\n    \n    /**\n     * Returns the lower bound.\n     * \n     * @return The lower bound.\n     * \n     * @see #getUpperBound()\n     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Returns the upper bound.\n     * \n     * @return The upper bound.\n     * \n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((value - this.lowerBound) / (this.upperBound \n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n    \n    /**\n     * Tests this <code>GrayPaintScale</code> instance for equality with an\n     * arbitrary object.  This method returns <code>true</code> if and only\n     * if:\n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>GrayPaintScale</code>;</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof GrayPaintScale)) {\n            return false;\n        }\n        GrayPaintScale that = (GrayPaintScale) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n        }\n        if (this.upperBound != that.upperBound) {\n            return false;\n        }\n        return true;    \n    }\n    \n    /**\n     * Returns a clone of this <code>GrayPaintScale</code> instance.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if there is a problem cloning this\n     *     instance.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n    \n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -------------------\n * GrayPaintScale.java\n * -------------------\n * (C) Copyright 2006, 2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * $Id: GrayPaintScale.java,v 1.1.2.1 2007/01/31 14:15:16 mungady Exp $\n *\n * Changes\n * -------\n * 05-Jul-2006 : Version 1 (DG);\n * 31-Jan-2007 : Renamed min and max to lowerBound and upperBound (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 26-Sep-2007 : Fixed bug 1767315, problem in getPaint() method (DG);\n * \n */\n\npackage org.jfree.chart.renderer;\n\nimport java.awt.Color;\nimport java.awt.Paint;\nimport java.io.Serializable;\n\nimport org.jfree.chart.util.PublicCloneable;\n\n/**\n * A paint scale that returns shades of gray.\n * \n * @since 1.0.4\n */\npublic class GrayPaintScale \n        implements PaintScale, PublicCloneable, Serializable {\n\n    /** The lower bound. */\n    private double lowerBound;\n    \n    /** The upper bound. */\n    private double upperBound;\n    \n    /**\n     * Creates a new <code>GrayPaintScale</code> instance with default values.\n     */\n    public GrayPaintScale() {\n        this(0.0, 1.0);\n    }\n    \n    /**\n     * Creates a new paint scale for values in the specified range.\n     * \n     * @param lowerBound  the lower bound.\n     * @param upperBound  the upper bound.\n     * \n     * @throws IllegalArgumentException if <code>lowerBound</code> is not\n     *       less than <code>upperBound</code>.\n     */\n    public GrayPaintScale(double lowerBound, double upperBound) {\n        if (lowerBound >= upperBound) {\n            throw new IllegalArgumentException(\n                    \"Requires lowerBound < upperBound.\");\n        }\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n    }\n    \n    /**\n     * Returns the lower bound.\n     * \n     * @return The lower bound.\n     * \n     * @see #getUpperBound()\n     */\n    public double getLowerBound() {\n        return this.lowerBound;\n    }\n\n    /**\n     * Returns the upper bound.\n     * \n     * @return The upper bound.\n     * \n     * @see #getLowerBound()\n     */\n    public double getUpperBound() {\n        return this.upperBound;\n    }\n\n    /**\n     * Returns a paint for the specified value.\n     * \n     * @param value  the value (must be within the range specified by the\n     *         lower and upper bounds for the scale).\n     * \n     * @return A paint for the specified value.\n     */\n    public Paint getPaint(double value) {\n        double v = Math.max(value, this.lowerBound);\n        v = Math.min(v, this.upperBound);\n        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                - this.lowerBound) * 255.0);\n        return new Color(g, g, g);\n    }\n    \n    /**\n     * Tests this <code>GrayPaintScale</code> instance for equality with an\n     * arbitrary object.  This method returns <code>true</code> if and only\n     * if:\n     * <ul>\n     * <li><code>obj</code> is not <code>null</code>;</li>\n     * <li><code>obj</code> is an instance of <code>GrayPaintScale</code>;</li>\n     * </ul>\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof GrayPaintScale)) {\n            return false;\n        }\n        GrayPaintScale that = (GrayPaintScale) obj;\n        if (this.lowerBound != that.lowerBound) {\n            return false;\n        }\n        if (this.upperBound != that.upperBound) {\n            return false;\n        }\n        return true;    \n    }\n    \n    /**\n     * Returns a clone of this <code>GrayPaintScale</code> instance.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if there is a problem cloning this\n     *     instance.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n    \n}\n"}]}
{"project": "Chart", "bug_id": 25, "classes_modified": [{"class_name": "org.jfree.chart.renderer.category.StatisticalBarRenderer", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------------\n * StatisticalBarRenderer.java\n * ---------------------------\n * (C) Copyright 2002-2007, by Pascal Collet and Contributors.\n *\n * Original Author:  Pascal Collet;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Christian W. Zuckschwerdt;\n *\n * $Id: StatisticalBarRenderer.java,v 1.4.2.6 2007/02/02 15:52:07 mungady Exp $\n *\n * Changes\n * -------\n * 21-Aug-2002 : Version 1, contributed by Pascal Collet (DG);\n * 01-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 24-Oct-2002 : Changes to dataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 05-Feb-2003 : Updates for new DefaultStatisticalCategoryDataset (DG);\n * 25-Mar-2003 : Implemented Serializable (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 06-Oct-2003 : Corrected typo in exception message (DG);\n * 05-Nov-2004 : Modified drawItem() signature (DG);\n * 15-Jun-2005 : Added errorIndicatorPaint attribute (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 19-May-2006 : Added support for tooltips and URLs (DG);\n * 12-Jul-2006 : Added support for item labels (DG);\n * 02-Feb-2007 : Removed author tags all over JFreeChart sources (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Added errorIndicatorStroke attribute (DG);\n * 11-Jul-2007 : Fixed serialization for new errorIndicatorStroke field (DG);\n * 28-Aug-2007 : Fixed NullPointerException - see bug 1779941 (DG);\n * \n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.labels.CategoryItemLabelGenerator;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\n\n/**\n * A renderer that handles the drawing a bar plot where\n * each bar has a mean value and a standard deviation line.\n */\npublic class StatisticalBarRenderer extends BarRenderer\n                                    implements CategoryItemRenderer, \n                                               Cloneable, PublicCloneable, \n                                               Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -4986038395414039117L;\n    \n    /** The paint used to show the error indicator. */\n    private transient Paint errorIndicatorPaint;\n    \n    /**\n     * The stroke used to draw the error indicator. \n     * \n     * @since 1.2.0\n     */\n    private transient Stroke errorIndicatorStroke;\n    \n    /**\n     * Default constructor.\n     */\n    public StatisticalBarRenderer() {\n        super();\n        this.errorIndicatorPaint = Color.gray;\n        this.errorIndicatorStroke = new BasicStroke(0.5f);\n    }\n\n    /**\n     * Returns the paint used for the error indicators.\n     * \n     * @return The paint used for the error indicators (possibly \n     *         <code>null</code>).\n     *         \n     * @see #setErrorIndicatorPaint(Paint)\n     */\n    public Paint getErrorIndicatorPaint() {\n        return this.errorIndicatorPaint;   \n    }\n\n    /**\n     * Sets the paint used for the error indicators (if <code>null</code>, \n     * the item outline paint is used instead)\n     * \n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getErrorIndicatorPaint()\n     */\n    public void setErrorIndicatorPaint(Paint paint) {\n        this.errorIndicatorPaint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used for the error indicators.\n     * \n     * @return The stroke (possibly <code>null</code>).\n     *         \n     * @see #setErrorIndicatorStroke(Stroke)\n     *\n     * @since 1.2.0\n     */\n    public Stroke getErrorIndicatorStroke() {\n        return this.errorIndicatorStroke;   \n    }\n\n    /**\n     * Sets the stroke used for the error indicators (if <code>null</code>, \n     * the item outline stroke is used instead)\n     * \n     * @param stroke  the stroke (<code>null</code> permitted).\n     * \n     * @see #getErrorIndicatorStroke()\n     *\n     * @since 1.2.0\n     */\n    public void setErrorIndicatorStroke(Stroke stroke) {\n        this.errorIndicatorStroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    \n    /**\n     * Draws the bar with its standard deviation line range for a single \n     * (series, category) data item.\n     *\n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param data  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param pass  the pass index.\n     */\n    public void drawItem(Graphics2D g2,\n                         CategoryItemRendererState state,\n                         Rectangle2D dataArea,\n                         CategoryPlot plot,\n                         CategoryAxis domainAxis,\n                         ValueAxis rangeAxis,\n                         CategoryDataset data,\n                         int row,\n                         int column,\n                         int pass) {\n\n        // defensive check\n        if (!(data instanceof StatisticalCategoryDataset)) {\n            throw new IllegalArgumentException(\n                \"Requires StatisticalCategoryDataset.\");\n        }\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n\n        PlotOrientation orientation = plot.getOrientation();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                    rangeAxis, statData, row, column);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n                    statData, row, column);\n        }\n    }\n                \n    /**\n     * Draws an item for a plot with a horizontal orientation.\n     * \n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     */\n    protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int row,\n                                      int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR Y\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n                dataArea, xAxisLocation);\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectY = rectY + row * state.getBarWidth();\n        }\n\n        // BAR X\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n        \n            Line2D line = null;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }\n\n    /**\n     * Draws an item for a plot with a vertical orientation.\n     * \n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     */\n    protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int row,\n                                    int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR X\n        double rectX = domainAxis.getCategoryStart(\n            column, getColumnCount(), dataArea, xAxisLocation\n        );\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectX = rectX + row * state.getBarWidth();\n        }\n\n        // BAR Y\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n            Line2D line = null;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }\n    \n    /**\n     * Tests this renderer for equality with an arbitrary object.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;   \n        }\n        if (!(obj instanceof StatisticalBarRenderer)) {\n            return false;   \n        }\n        if (!super.equals(obj)) {\n            return false;   \n        }\n        StatisticalBarRenderer that = (StatisticalBarRenderer) obj;\n        if (!PaintUtilities.equal(this.errorIndicatorPaint, \n                that.errorIndicatorPaint)) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.errorIndicatorPaint, stream);\n        SerialUtilities.writeStroke(this.errorIndicatorStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.errorIndicatorPaint = SerialUtilities.readPaint(stream);\n        this.errorIndicatorStroke = SerialUtilities.readStroke(stream);\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------------------\n * StatisticalBarRenderer.java\n * ---------------------------\n * (C) Copyright 2002-2007, by Pascal Collet and Contributors.\n *\n * Original Author:  Pascal Collet;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Christian W. Zuckschwerdt;\n *\n * $Id: StatisticalBarRenderer.java,v 1.4.2.6 2007/02/02 15:52:07 mungady Exp $\n *\n * Changes\n * -------\n * 21-Aug-2002 : Version 1, contributed by Pascal Collet (DG);\n * 01-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 24-Oct-2002 : Changes to dataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 05-Feb-2003 : Updates for new DefaultStatisticalCategoryDataset (DG);\n * 25-Mar-2003 : Implemented Serializable (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 06-Oct-2003 : Corrected typo in exception message (DG);\n * 05-Nov-2004 : Modified drawItem() signature (DG);\n * 15-Jun-2005 : Added errorIndicatorPaint attribute (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 19-May-2006 : Added support for tooltips and URLs (DG);\n * 12-Jul-2006 : Added support for item labels (DG);\n * 02-Feb-2007 : Removed author tags all over JFreeChart sources (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Added errorIndicatorStroke attribute (DG);\n * 11-Jul-2007 : Fixed serialization for new errorIndicatorStroke field (DG);\n * 28-Aug-2007 : Fixed NullPointerException - see bug 1779941 (DG);\n * \n */\n\npackage org.jfree.chart.renderer.category;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.labels.CategoryItemLabelGenerator;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.PlotOrientation;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\n\n/**\n * A renderer that handles the drawing a bar plot where\n * each bar has a mean value and a standard deviation line.\n */\npublic class StatisticalBarRenderer extends BarRenderer\n                                    implements CategoryItemRenderer, \n                                               Cloneable, PublicCloneable, \n                                               Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -4986038395414039117L;\n    \n    /** The paint used to show the error indicator. */\n    private transient Paint errorIndicatorPaint;\n    \n    /**\n     * The stroke used to draw the error indicator. \n     * \n     * @since 1.2.0\n     */\n    private transient Stroke errorIndicatorStroke;\n    \n    /**\n     * Default constructor.\n     */\n    public StatisticalBarRenderer() {\n        super();\n        this.errorIndicatorPaint = Color.gray;\n        this.errorIndicatorStroke = new BasicStroke(0.5f);\n    }\n\n    /**\n     * Returns the paint used for the error indicators.\n     * \n     * @return The paint used for the error indicators (possibly \n     *         <code>null</code>).\n     *         \n     * @see #setErrorIndicatorPaint(Paint)\n     */\n    public Paint getErrorIndicatorPaint() {\n        return this.errorIndicatorPaint;   \n    }\n\n    /**\n     * Sets the paint used for the error indicators (if <code>null</code>, \n     * the item outline paint is used instead)\n     * \n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getErrorIndicatorPaint()\n     */\n    public void setErrorIndicatorPaint(Paint paint) {\n        this.errorIndicatorPaint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used for the error indicators.\n     * \n     * @return The stroke (possibly <code>null</code>).\n     *         \n     * @see #setErrorIndicatorStroke(Stroke)\n     *\n     * @since 1.2.0\n     */\n    public Stroke getErrorIndicatorStroke() {\n        return this.errorIndicatorStroke;   \n    }\n\n    /**\n     * Sets the stroke used for the error indicators (if <code>null</code>, \n     * the item outline stroke is used instead)\n     * \n     * @param stroke  the stroke (<code>null</code> permitted).\n     * \n     * @see #getErrorIndicatorStroke()\n     *\n     * @since 1.2.0\n     */\n    public void setErrorIndicatorStroke(Stroke stroke) {\n        this.errorIndicatorStroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    \n    /**\n     * Draws the bar with its standard deviation line range for a single \n     * (series, category) data item.\n     *\n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param data  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param pass  the pass index.\n     */\n    public void drawItem(Graphics2D g2,\n                         CategoryItemRendererState state,\n                         Rectangle2D dataArea,\n                         CategoryPlot plot,\n                         CategoryAxis domainAxis,\n                         ValueAxis rangeAxis,\n                         CategoryDataset data,\n                         int row,\n                         int column,\n                         int pass) {\n\n        // defensive check\n        if (!(data instanceof StatisticalCategoryDataset)) {\n            throw new IllegalArgumentException(\n                \"Requires StatisticalCategoryDataset.\");\n        }\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n\n        PlotOrientation orientation = plot.getOrientation();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                    rangeAxis, statData, row, column);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n                    statData, row, column);\n        }\n    }\n                \n    /**\n     * Draws an item for a plot with a horizontal orientation.\n     * \n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     */\n    protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int row,\n                                      int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR Y\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n                dataArea, xAxisLocation);\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectY = rectY + row * state.getBarWidth();\n        }\n\n        // BAR X\n        Number meanValue = dataset.getMeanValue(row, column);\n        if (meanValue == null) {\n            return;\n        }\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n        Number n = dataset.getStdDevValue(row, column);\n        if (n != null) {\n            double valueDelta = n.doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n        \n            Line2D line = null;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n        }\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }\n\n    /**\n     * Draws an item for a plot with a vertical orientation.\n     * \n     * @param g2  the graphics device.\n     * @param state  the renderer state.\n     * @param dataArea  the data area.\n     * @param plot  the plot.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the data.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     */\n    protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int row,\n                                    int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR X\n        double rectX = domainAxis.getCategoryStart(\n            column, getColumnCount(), dataArea, xAxisLocation\n        );\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectX = rectX + row * state.getBarWidth();\n        }\n\n        // BAR Y\n        Number meanValue = dataset.getMeanValue(row, column);\n        if (meanValue == null) {\n            return;\n        }\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n        Number n = dataset.getStdDevValue(row, column);\n        if (n != null) {\n            double valueDelta = n.doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n            Line2D line = null;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n        }\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }\n    \n    /**\n     * Tests this renderer for equality with an arbitrary object.\n     * \n     * @param obj  the object (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;   \n        }\n        if (!(obj instanceof StatisticalBarRenderer)) {\n            return false;   \n        }\n        if (!super.equals(obj)) {\n            return false;   \n        }\n        StatisticalBarRenderer that = (StatisticalBarRenderer) obj;\n        if (!PaintUtilities.equal(this.errorIndicatorPaint, \n                that.errorIndicatorPaint)) {\n            return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.errorIndicatorPaint, stream);\n        SerialUtilities.writeStroke(this.errorIndicatorStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.errorIndicatorPaint = SerialUtilities.readPaint(stream);\n        this.errorIndicatorStroke = SerialUtilities.readStroke(stream);\n    }\n\n}\n"}]}
{"project": "Chart", "bug_id": 26, "classes_modified": [{"class_name": "org.jfree.chart.axis.Axis", "buggy_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------\n * Axis.java\n * ---------\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bill Kelemen; Nicolas Brodu\n *\n * $Id: Axis.java,v 1.11.2.4 2006/08/23 10:24:26 mungady Exp $\n *\n * Changes (from 21-Aug-2001)\n * --------------------------\n * 21-Aug-2001 : Added standard header, fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 07-Nov-2001 : Allow null axis labels (DG);\n *             : Added default font values (DG);\n * 13-Nov-2001 : Modified the setPlot() method to check compatibility between \n *               the axis and the plot (DG);\n * 30-Nov-2001 : Changed default font from \"Arial\" --> \"SansSerif\" (DG);\n * 06-Dec-2001 : Allow null in setPlot() method (BK);\n * 06-Mar-2002 : Added AxisConstants interface (DG);\n * 23-Apr-2002 : Added a visible property.  Moved drawVerticalString to \n *               RefineryUtilities.  Added fixedDimension property for use in \n *               combined plots (DG);\n * 25-Jun-2002 : Removed unnecessary imports (DG);\n * 05-Sep-2002 : Added attribute for tick mark paint (DG);\n * 18-Sep-2002 : Fixed errors reported by Checkstyle (DG);\n * 07-Nov-2002 : Added attributes to control the inside and outside length of \n *               the tick marks (DG);\n * 08-Nov-2002 : Moved to new package com.jrefinery.chart.axis (DG);\n * 18-Nov-2002 : Added axis location to refreshTicks() parameters (DG);\n * 15-Jan-2003 : Removed monolithic constructor (DG);\n * 17-Jan-2003 : Moved plot classes to separate package (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Jul-2003 : Modified reserveSpace method (DG);\n * 13-Aug-2003 : Implemented Cloneable (DG);\n * 11-Sep-2003 : Took care of listeners while cloning (NB);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 06-Nov-2003 : Modified refreshTicks() signature (DG);\n * 06-Jan-2004 : Added axis line attributes (DG);\n * 16-Mar-2004 : Added plot state to draw() method (DG);\n * 07-Apr-2004 : Modified text bounds calculation (DG);\n * 18-May-2004 : Eliminated AxisConstants.java (DG);\n * 30-Sep-2004 : Moved drawRotatedString() from RefineryUtilities --> \n *               TextUtilities (DG);\n * 04-Oct-2004 : Modified getLabelEnclosure() method to treat an empty String \n *               the same way as a null string - see bug 1026521 (DG);\n * 21-Apr-2005 : Replaced Insets with RectangleInsets (DG);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 01-Jun-2005 : Added hasListener() method for unit testing (DG);\n * 08-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * ------------- JFREECHART 1.0.0 ---------------------------------------------\n * 22-Aug-2006 : API doc updates (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 02-Jul-2007 : Modifications to support entities for axis labels (DG);\n * \n */\n\npackage org.jfree.chart.axis;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.EventListener;\nimport java.util.List;\n\nimport javax.swing.event.EventListenerList;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.entity.AxisLabelEntity;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.AxisChangeEvent;\nimport org.jfree.chart.event.AxisChangeListener;\nimport org.jfree.chart.plot.Plot;\nimport org.jfree.chart.plot.PlotRenderingInfo;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\n\n/**\n * The base class for all axes in JFreeChart.  Subclasses are divided into \n * those that display values ({@link ValueAxis}) and those that display \n * categories ({@link CategoryAxis}).\n */\npublic abstract class Axis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7719289504573298271L;\n    \n    /** The default axis visibility. */\n    public static final boolean DEFAULT_AXIS_VISIBLE = true;\n\n    /** The default axis label font. */\n    public static final Font DEFAULT_AXIS_LABEL_FONT = new Font(\n            \"SansSerif\", Font.PLAIN, 12);\n\n    /** The default axis label paint. */\n    public static final Paint DEFAULT_AXIS_LABEL_PAINT = Color.black;\n\n    /** The default axis label insets. */\n    public static final RectangleInsets DEFAULT_AXIS_LABEL_INSETS \n            = new RectangleInsets(3.0, 3.0, 3.0, 3.0);\n\n    /** The default axis line paint. */\n    public static final Paint DEFAULT_AXIS_LINE_PAINT = Color.gray;\n    \n    /** The default axis line stroke. */\n    public static final Stroke DEFAULT_AXIS_LINE_STROKE = new BasicStroke(1.0f);\n\n    /** The default tick labels visibility. */\n    public static final boolean DEFAULT_TICK_LABELS_VISIBLE = true;\n\n    /** The default tick label font. */\n    public static final Font DEFAULT_TICK_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** The default tick label paint. */\n    public static final Paint DEFAULT_TICK_LABEL_PAINT = Color.black;\n\n    /** The default tick label insets. */\n    public static final RectangleInsets DEFAULT_TICK_LABEL_INSETS \n            = new RectangleInsets(2.0, 4.0, 2.0, 4.0);\n\n    /** The default tick marks visible. */\n    public static final boolean DEFAULT_TICK_MARKS_VISIBLE = true;\n\n    /** The default tick stroke. */\n    public static final Stroke DEFAULT_TICK_MARK_STROKE = new BasicStroke(1);\n\n    /** The default tick paint. */\n    public static final Paint DEFAULT_TICK_MARK_PAINT = Color.gray;\n\n    /** The default tick mark inside length. */\n    public static final float DEFAULT_TICK_MARK_INSIDE_LENGTH = 0.0f;\n\n    /** The default tick mark outside length. */\n    public static final float DEFAULT_TICK_MARK_OUTSIDE_LENGTH = 2.0f;\n\n    /** A flag indicating whether or not the axis is visible. */\n    private boolean visible;\n\n    /** The label for the axis. */\n    private String label;\n\n    /** The font for displaying the axis label. */\n    private Font labelFont;\n\n    /** The paint for drawing the axis label. */\n    private transient Paint labelPaint;\n\n    /** The insets for the axis label. */\n    private RectangleInsets labelInsets;\n\n    /** The label angle. */\n    private double labelAngle;\n    \n    /**\n     * The tool tip text for the label (<code>null</code> is permitted).\n     * \n     * @since 1.2.0\n     */\n    private String labelToolTip;\n\n    /**\n     * The URL for the label (<code>null</code> is permitted).\n     * \n     * @since 1.2.0.\n     */\n    private String labelURL;\n    \n    /** A flag that controls whether or not the axis line is visible. */\n    private boolean axisLineVisible;\n\n    /** The stroke used for the axis line. */\n    private transient Stroke axisLineStroke;\n    \n    /** The paint used for the axis line. */\n    private transient Paint axisLinePaint;\n    \n    /** \n     * A flag that indicates whether or not tick labels are visible for the \n     * axis. \n     */\n    private boolean tickLabelsVisible;\n\n    /** The font used to display the tick labels. */\n    private Font tickLabelFont;\n\n    /** The color used to display the tick labels. */\n    private transient Paint tickLabelPaint;\n\n    /** The blank space around each tick label. */\n    private RectangleInsets tickLabelInsets;\n\n    /** \n     * A flag that indicates whether or not tick marks are visible for the \n     * axis. \n     */\n    private boolean tickMarksVisible;\n\n    /** The length of the tick mark inside the data area (zero permitted). */\n    private float tickMarkInsideLength;\n\n    /** The length of the tick mark outside the data area (zero permitted). */\n    private float tickMarkOutsideLength;\n\n    /** The stroke used to draw tick marks. */\n    private transient Stroke tickMarkStroke;\n\n    /** The paint used to draw tick marks. */\n    private transient Paint tickMarkPaint;\n\n    /** The fixed (horizontal or vertical) dimension for the axis. */\n    private double fixedDimension;\n\n    /** \n     * A reference back to the plot that the axis is assigned to (can be \n     * <code>null</code>). \n     */\n    private transient Plot plot;\n\n    /** Storage for registered listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * Constructs an axis, using default values where necessary.\n     *\n     * @param label  the axis label (<code>null</code> permitted).\n     */\n    protected Axis(String label) {\n\n        this.label = label;\n        this.visible = DEFAULT_AXIS_VISIBLE;\n        this.labelFont = DEFAULT_AXIS_LABEL_FONT;\n        this.labelPaint = DEFAULT_AXIS_LABEL_PAINT;\n        this.labelInsets = DEFAULT_AXIS_LABEL_INSETS;\n        this.labelAngle = 0.0;\n        this.labelToolTip = null;\n        this.labelURL = null;\n        \n        this.axisLineVisible = true;\n        this.axisLinePaint = DEFAULT_AXIS_LINE_PAINT;\n        this.axisLineStroke = DEFAULT_AXIS_LINE_STROKE;\n        \n        this.tickLabelsVisible = DEFAULT_TICK_LABELS_VISIBLE;\n        this.tickLabelFont = DEFAULT_TICK_LABEL_FONT;\n        this.tickLabelPaint = DEFAULT_TICK_LABEL_PAINT;\n        this.tickLabelInsets = DEFAULT_TICK_LABEL_INSETS;\n        \n        this.tickMarksVisible = DEFAULT_TICK_MARKS_VISIBLE;\n        this.tickMarkStroke = DEFAULT_TICK_MARK_STROKE;\n        this.tickMarkPaint = DEFAULT_TICK_MARK_PAINT;\n        this.tickMarkInsideLength = DEFAULT_TICK_MARK_INSIDE_LENGTH;\n        this.tickMarkOutsideLength = DEFAULT_TICK_MARK_OUTSIDE_LENGTH;\n\n        this.plot = null;\n\n        this.listenerList = new EventListenerList();\n\n    }\n\n    /**\n     * Returns <code>true</code> if the axis is visible, and \n     * <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     * \n     * @see #setVisible(boolean)\n     */\n    public boolean isVisible() {\n        return this.visible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis is visible and sends \n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isVisible()\n     */\n    public void setVisible(boolean flag) {\n        if (flag != this.visible) {\n            this.visible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the label for the axis.\n     *\n     * @return The label for the axis (<code>null</code> possible).\n     * \n     * @see #getLabelFont()\n     * @see #getLabelPaint()\n     * @see #setLabel(String)\n     */\n    public String getLabel() {\n        return this.label;\n    }\n\n    /**\n     * Sets the label for the axis and sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param label  the new label (<code>null</code> permitted).\n     * \n     * @see #getLabel()\n     * @see #setLabelFont(Font)\n     * @see #setLabelPaint(Paint)\n     */\n    public void setLabel(String label) {\n        \n        String existing = this.label;\n        if (existing != null) {\n            if (!existing.equals(label)) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n        else {\n            if (label != null) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n\n    }\n\n    /**\n     * Returns the font for the axis label.\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the font for the axis label and sends an {@link AxisChangeEvent} \n     * to all registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     * \n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        if (!this.labelFont.equals(font)) {\n            this.labelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the color/shade used to draw the axis label.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the axis label and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the insets for the label (that is, the amount of blank space\n     * that should be left around the label).\n     *\n     * @return The label insets (never <code>null</code>).\n     * \n     * @see #setLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getLabelInsets() {\n        return this.labelInsets;\n    }\n\n    /**\n     * Sets the insets for the axis label, and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets (<code>null</code> not permitted).\n     * \n     * @see #getLabelInsets()\n     */\n    public void setLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");   \n        }\n        if (!insets.equals(this.labelInsets)) {\n            this.labelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the angle of the axis label.\n     *\n     * @return The angle (in radians).\n     * \n     * @see #setLabelAngle(double)\n     */\n    public double getLabelAngle() {\n        return this.labelAngle;\n    }\n\n    /**\n     * Sets the angle for the label and sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     * \n     * @see #getLabelAngle()\n     */\n    public void setLabelAngle(double angle) {\n        this.labelAngle = angle;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the tool tip text for the axis label.\n     * \n     * @return The tool tip text (possibly <code>null</code>).\n     * \n     * @see #setLabelToolTip(String)\n     * \n     * @since 1.2.0\n     */\n    public String getLabelToolTip() {\n        return this.labelToolTip;\n    }\n    \n    /**\n     * Sets the tool tip text for the axis label and sends a .\n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param text  the tool tip text (<code>null</code> permitted).\n     * \n     * @see #getLabelToolTip()\n     * \n     * @since 1.2.0\n     */\n    public void setLabelToolTip(String text) {\n        this.labelToolTip = text;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the URL text for the axis label.\n     * \n     * @return The URL (possibly <code>null</code>).\n     * \n     * @see #setLabelURL(String)\n     * \n     * @since 1.2.0\n     */\n    public String getLabelURL() {\n        return this.labelURL;\n    }\n    \n    /**\n     * Sets the URL for the axis label and sends an {@link AxisChangeEvent} to\n     * all registered listeners.\n     * \n     * @param url  the URL (<code>null</code> permitted).\n     * \n     * @see #getLabelURL()\n     * \n     * @since 1.2.0\n     */\n    public void setLabelURL(String url) {\n        this.labelURL = url;\n        notifyListeners(new AxisChangeEvent(this));        \n    }\n    \n    /**\n     * A flag that controls whether or not the axis line is drawn.\n     * \n     * @return A boolean.\n     * \n     * @see #getAxisLinePaint()\n     * @see #getAxisLineStroke()\n     * @see #setAxisLineVisible(boolean)\n     */\n    public boolean isAxisLineVisible() {\n        return this.axisLineVisible;\n    }\n    \n    /**\n     * Sets a flag that controls whether or not the axis line is visible and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param visible  the flag.\n     * \n     * @see #isAxisLineVisible()\n     * @see #setAxisLinePaint(Paint)\n     * @see #setAxisLineStroke(Stroke)\n     */\n    public void setAxisLineVisible(boolean visible) {\n        this.axisLineVisible = visible;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the paint used to draw the axis line.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setAxisLinePaint(Paint)\n     */\n    public Paint getAxisLinePaint() {\n        return this.axisLinePaint;\n    }\n    \n    /**\n     * Sets the paint used to draw the axis line and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getAxisLinePaint()\n     */\n    public void setAxisLinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.axisLinePaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used to draw the axis line.\n     * \n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setAxisLineStroke(Stroke)\n     */\n    public Stroke getAxisLineStroke() {\n        return this.axisLineStroke;\n    }\n    \n    /**\n     * Sets the stroke used to draw the axis line and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getAxisLineStroke()\n     */\n    public void setAxisLineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.axisLineStroke = stroke;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns a flag indicating whether or not the tick labels are visible.\n     *\n     * @return The flag.\n     * \n     * @see #getTickLabelFont()\n     * @see #getTickLabelPaint()\n     * @see #setTickLabelsVisible(boolean)\n     */\n    public boolean isTickLabelsVisible() {\n        return this.tickLabelsVisible;\n    }\n\n    /**\n     * Sets the flag that determines whether or not the tick labels are \n     * visible and sends an {@link AxisChangeEvent} to all registered \n     * listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isTickLabelsVisible()\n     * @see #setTickLabelFont(Font)\n     * @see #setTickLabelPaint(Paint)\n     */\n    public void setTickLabelsVisible(boolean flag) {\n\n        if (flag != this.tickLabelsVisible) {\n            this.tickLabelsVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the font used for the tick labels (if showing).\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setTickLabelFont(Font)\n     */\n    public Font getTickLabelFont() {\n        return this.tickLabelFont;\n    }\n\n    /**\n     * Sets the font for the tick labels and sends an {@link AxisChangeEvent} \n     * to all registered listeners.\n     *\n     * @param font  the font (<code>null</code> not allowed).\n     * \n     * @see #getTickLabelFont()\n     */\n    public void setTickLabelFont(Font font) {\n\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n\n        if (!this.tickLabelFont.equals(font)) {\n            this.tickLabelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the color/shade used for the tick labels.\n     *\n     * @return The paint used for the tick labels.\n     * \n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick labels (if they are showing) and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getTickLabelPaint()\n     */\n    public void setTickLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickLabelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the insets for the tick labels.\n     *\n     * @return The insets (never <code>null</code>).\n     * \n     * @see #setTickLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getTickLabelInsets() {\n        return this.tickLabelInsets;\n    }\n\n    /**\n     * Sets the insets for the tick labels and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets (<code>null</code> not permitted).\n     * \n     * @see #getTickLabelInsets()\n     */\n    public void setTickLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        if (!this.tickLabelInsets.equals(insets)) {\n            this.tickLabelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the flag that indicates whether or not the tick marks are\n     * showing.\n     *\n     * @return The flag that indicates whether or not the tick marks are \n     *         showing.\n     *         \n     * @see #setTickMarksVisible(boolean)\n     */\n    public boolean isTickMarksVisible() {\n        return this.tickMarksVisible;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the tick marks are showing\n     * and sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isTickMarksVisible()\n     */\n    public void setTickMarksVisible(boolean flag) {\n        if (flag != this.tickMarksVisible) {\n            this.tickMarksVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the inside length of the tick marks.\n     *\n     * @return The length.\n     * \n     * @see #getTickMarkOutsideLength()\n     * @see #setTickMarkInsideLength(float)\n     */\n    public float getTickMarkInsideLength() {\n        return this.tickMarkInsideLength;\n    }\n\n    /**\n     * Sets the inside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     * \n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkInsideLength(float length) {\n        this.tickMarkInsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the outside length of the tick marks.\n     *\n     * @return The length.\n     * \n     * @see #getTickMarkInsideLength()\n     * @see #setTickMarkOutsideLength(float)\n     */\n    public float getTickMarkOutsideLength() {\n        return this.tickMarkOutsideLength;\n    }\n\n    /**\n     * Sets the outside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     * \n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkOutsideLength(float length) {\n        this.tickMarkOutsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw tick marks.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setTickMarkStroke(Stroke)\n     */\n    public Stroke getTickMarkStroke() {\n        return this.tickMarkStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getTickMarkStroke()\n     */\n    public void setTickMarkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        if (!this.tickMarkStroke.equals(stroke)) {\n            this.tickMarkStroke = stroke;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the paint used to draw tick marks (if they are showing).\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setTickMarkPaint(Paint)\n     */\n    public Paint getTickMarkPaint() {\n        return this.tickMarkPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick marks and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getTickMarkPaint()\n     */\n    public void setTickMarkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickMarkPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the plot that the axis is assigned to.  This method will return \n     * <code>null</code> if the axis is not currently assigned to a plot.\n     *\n     * @return The plot that the axis is assigned to (possibly \n     *         <code>null</code>).\n     *         \n     * @see #setPlot(Plot)\n     */\n    public Plot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Sets a reference to the plot that the axis is assigned to.\n     * <P>\n     * This method is used internally, you shouldn't need to call it yourself.\n     *\n     * @param plot  the plot.\n     * \n     * @see #getPlot()\n     */\n    public void setPlot(Plot plot) {\n        this.plot = plot;\n        configure();\n    }\n\n    /**\n     * Returns the fixed dimension for the axis.\n     *\n     * @return The fixed dimension.\n     * \n     * @see #setFixedDimension(double)\n     */\n    public double getFixedDimension() {\n        return this.fixedDimension;\n    }\n\n    /**\n     * Sets the fixed dimension for the axis.\n     * <P>\n     * This is used when combining more than one plot on a chart.  In this case,\n     * there may be several axes that need to have the same height or width so\n     * that they are aligned.  This method is used to fix a dimension for the\n     * axis (the context determines whether the dimension is horizontal or\n     * vertical).\n     *\n     * @param dimension  the fixed dimension.\n     * \n     * @see #getFixedDimension()\n     */\n    public void setFixedDimension(double dimension) {\n        this.fixedDimension = dimension;\n    }\n\n    /**\n     * Configures the axis to work with the current plot.  Override this method\n     * to perform any special processing (such as auto-rescaling).\n     */\n    public abstract void configure();\n\n    /**\n     * Estimates the space (height or width) required to draw the axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the plot (including axes) should \n     *                  be drawn.\n     * @param edge  the axis location.\n     * @param space  space already reserved.\n     *\n     * @return The space required to draw the axis (including pre-reserved \n     *         space).\n     */\n    public abstract AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n                                           Rectangle2D plotArea, \n                                           RectangleEdge edge, \n                                           AxisSpace space);\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param cursor  the cursor location (determines where to draw the axis).\n     * @param plotArea  the area within which the axes and plot should be drawn.\n     * @param dataArea  the area within which the data should be drawn.\n     * @param edge  the axis location (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot \n     *                   (<code>null</code> permitted).\n     * \n     * @return The axis state (never <code>null</code>).\n     */\n    public abstract AxisState draw(Graphics2D g2, \n                                   double cursor,\n                                   Rectangle2D plotArea, \n                                   Rectangle2D dataArea,\n                                   RectangleEdge edge,\n                                   PlotRenderingInfo plotState);\n\n    /**\n     * Calculates the positions of the ticks for the axis, storing the results\n     * in the tick list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the edge on which the axis is located.\n     * \n     * @return The list of ticks.\n     */\n    public abstract List refreshTicks(Graphics2D g2, \n                                      AxisState state,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge);\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     * \n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object for notification of changes to the axis.\n     *\n     * @param listener  the object to deregister.\n     * \n     * @see #addChangeListener(AxisChangeListener)\n     */\n    public void removeChangeListener(AxisChangeListener listener) {\n        this.listenerList.remove(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is registered with\n     * the dataset as a listener.  Most applications won't need to call this \n     * method, it exists mainly for use by unit testing code.\n     * \n     * @param listener  the listener.\n     * \n     * @return A boolean.\n     */\n    public boolean hasListener(EventListener listener) {\n        List list = Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\n    }\n    \n    /**\n     * Notifies all registered listeners that the axis has changed.\n     * The AxisChangeEvent provides information about the change.\n     *\n     * @param event  information about the change to the axis.\n     */\n    protected void notifyListeners(AxisChangeEvent event) {\n\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == AxisChangeListener.class) {\n                ((AxisChangeListener) listeners[i + 1]).axisChanged(event);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a rectangle that encloses the axis label.  This is typically \n     * used for layout purposes (it gives the maximum dimensions of the label).\n     *\n     * @param g2  the graphics device.\n     * @param edge  the edge of the plot area along which the axis is measuring.\n     *\n     * @return The enclosing rectangle.\n     */\n    protected Rectangle2D getLabelEnclosure(Graphics2D g2, RectangleEdge edge) {\n\n        Rectangle2D result = new Rectangle2D.Double();\n        String axisLabel = getLabel();\n        if (axisLabel != null && !axisLabel.equals(\"\")) {\n            FontMetrics fm = g2.getFontMetrics(getLabelFont());\n            Rectangle2D bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);\n            RectangleInsets insets = getLabelInsets();\n            bounds = insets.createOutsetRectangle(bounds);\n            double angle = getLabelAngle();\n            if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n                angle = angle - Math.PI / 2.0;\n            }\n            double x = bounds.getCenterX();\n            double y = bounds.getCenterY();\n            AffineTransform transformer \n                = AffineTransform.getRotateInstance(angle, x, y);\n            Shape labelBounds = transformer.createTransformedShape(bounds);\n            result = labelBounds.getBounds2D();\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state (<code>null</code> not permitted).\n     * @param plotState  the plot state (<code>null</code> permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }\n\n    /**\n     * Draws an axis line at the current cursor position and edge.\n     * \n     * @param g2  the graphics device.\n     * @param cursor  the cursor position.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     */\n    protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        \n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        g2.draw(axisLine);\n        \n    }\n\n    /**\n     * Returns a clone of the axis.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if some component of the axis does \n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Axis clone = (Axis) super.clone();\n        // It's up to the plot which clones up to restore the correct references\n        clone.plot = null;        \n        clone.listenerList = new EventListenerList();\n        return clone;\n    }\n    \n    /**\n     * Tests this axis for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Axis)) {\n            return false;\n        }\n        Axis that = (Axis) obj;\n        if (this.visible != that.visible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.label, that.label)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelInsets, that.labelInsets)) {\n            return false;\n        }\n        if (this.labelAngle != that.labelAngle) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelToolTip, that.labelToolTip)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelURL, that.labelURL)) {\n            return false;\n        }\n        if (this.axisLineVisible != that.axisLineVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisLineStroke, that.axisLineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.axisLinePaint, that.axisLinePaint)) {\n            return false;\n        }\n        if (this.tickLabelsVisible != that.tickLabelsVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickLabelFont, that.tickLabelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.tickLabelPaint, that.tickLabelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.tickLabelInsets, that.tickLabelInsets\n        )) {\n            return false;\n        }\n        if (this.tickMarksVisible != that.tickMarksVisible) {\n            return false;\n        }\n        if (this.tickMarkInsideLength != that.tickMarkInsideLength) {\n            return false;\n        }                  \n        if (this.tickMarkOutsideLength != that.tickMarkOutsideLength) {\n            return false;\n        }                  \n        if (!PaintUtilities.equal(this.tickMarkPaint, that.tickMarkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickMarkStroke, that.tickMarkStroke)) {\n            return false;\n        }\n        if (this.fixedDimension != that.fixedDimension) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.tickLabelPaint, stream);\n        SerialUtilities.writeStroke(this.axisLineStroke, stream);\n        SerialUtilities.writePaint(this.axisLinePaint, stream);\n        SerialUtilities.writeStroke(this.tickMarkStroke, stream);\n        SerialUtilities.writePaint(this.tickMarkPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.tickLabelPaint = SerialUtilities.readPaint(stream);\n        this.axisLineStroke = SerialUtilities.readStroke(stream);\n        this.axisLinePaint = SerialUtilities.readPaint(stream);\n        this.tickMarkStroke = SerialUtilities.readStroke(stream);\n        this.tickMarkPaint = SerialUtilities.readPaint(stream);\n        this.listenerList = new EventListenerList();\n    }\n\n}\n", "fixed_version": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------\n * Axis.java\n * ---------\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bill Kelemen; Nicolas Brodu\n *\n * $Id: Axis.java,v 1.11.2.4 2006/08/23 10:24:26 mungady Exp $\n *\n * Changes (from 21-Aug-2001)\n * --------------------------\n * 21-Aug-2001 : Added standard header, fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 07-Nov-2001 : Allow null axis labels (DG);\n *             : Added default font values (DG);\n * 13-Nov-2001 : Modified the setPlot() method to check compatibility between \n *               the axis and the plot (DG);\n * 30-Nov-2001 : Changed default font from \"Arial\" --> \"SansSerif\" (DG);\n * 06-Dec-2001 : Allow null in setPlot() method (BK);\n * 06-Mar-2002 : Added AxisConstants interface (DG);\n * 23-Apr-2002 : Added a visible property.  Moved drawVerticalString to \n *               RefineryUtilities.  Added fixedDimension property for use in \n *               combined plots (DG);\n * 25-Jun-2002 : Removed unnecessary imports (DG);\n * 05-Sep-2002 : Added attribute for tick mark paint (DG);\n * 18-Sep-2002 : Fixed errors reported by Checkstyle (DG);\n * 07-Nov-2002 : Added attributes to control the inside and outside length of \n *               the tick marks (DG);\n * 08-Nov-2002 : Moved to new package com.jrefinery.chart.axis (DG);\n * 18-Nov-2002 : Added axis location to refreshTicks() parameters (DG);\n * 15-Jan-2003 : Removed monolithic constructor (DG);\n * 17-Jan-2003 : Moved plot classes to separate package (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Jul-2003 : Modified reserveSpace method (DG);\n * 13-Aug-2003 : Implemented Cloneable (DG);\n * 11-Sep-2003 : Took care of listeners while cloning (NB);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 06-Nov-2003 : Modified refreshTicks() signature (DG);\n * 06-Jan-2004 : Added axis line attributes (DG);\n * 16-Mar-2004 : Added plot state to draw() method (DG);\n * 07-Apr-2004 : Modified text bounds calculation (DG);\n * 18-May-2004 : Eliminated AxisConstants.java (DG);\n * 30-Sep-2004 : Moved drawRotatedString() from RefineryUtilities --> \n *               TextUtilities (DG);\n * 04-Oct-2004 : Modified getLabelEnclosure() method to treat an empty String \n *               the same way as a null string - see bug 1026521 (DG);\n * 21-Apr-2005 : Replaced Insets with RectangleInsets (DG);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 01-Jun-2005 : Added hasListener() method for unit testing (DG);\n * 08-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * ------------- JFREECHART 1.0.0 ---------------------------------------------\n * 22-Aug-2006 : API doc updates (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 02-Jul-2007 : Modifications to support entities for axis labels (DG);\n * \n */\n\npackage org.jfree.chart.axis;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.EventListener;\nimport java.util.List;\n\nimport javax.swing.event.EventListenerList;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.entity.AxisLabelEntity;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.event.AxisChangeEvent;\nimport org.jfree.chart.event.AxisChangeListener;\nimport org.jfree.chart.plot.Plot;\nimport org.jfree.chart.plot.PlotRenderingInfo;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\n\n/**\n * The base class for all axes in JFreeChart.  Subclasses are divided into \n * those that display values ({@link ValueAxis}) and those that display \n * categories ({@link CategoryAxis}).\n */\npublic abstract class Axis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7719289504573298271L;\n    \n    /** The default axis visibility. */\n    public static final boolean DEFAULT_AXIS_VISIBLE = true;\n\n    /** The default axis label font. */\n    public static final Font DEFAULT_AXIS_LABEL_FONT = new Font(\n            \"SansSerif\", Font.PLAIN, 12);\n\n    /** The default axis label paint. */\n    public static final Paint DEFAULT_AXIS_LABEL_PAINT = Color.black;\n\n    /** The default axis label insets. */\n    public static final RectangleInsets DEFAULT_AXIS_LABEL_INSETS \n            = new RectangleInsets(3.0, 3.0, 3.0, 3.0);\n\n    /** The default axis line paint. */\n    public static final Paint DEFAULT_AXIS_LINE_PAINT = Color.gray;\n    \n    /** The default axis line stroke. */\n    public static final Stroke DEFAULT_AXIS_LINE_STROKE = new BasicStroke(1.0f);\n\n    /** The default tick labels visibility. */\n    public static final boolean DEFAULT_TICK_LABELS_VISIBLE = true;\n\n    /** The default tick label font. */\n    public static final Font DEFAULT_TICK_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** The default tick label paint. */\n    public static final Paint DEFAULT_TICK_LABEL_PAINT = Color.black;\n\n    /** The default tick label insets. */\n    public static final RectangleInsets DEFAULT_TICK_LABEL_INSETS \n            = new RectangleInsets(2.0, 4.0, 2.0, 4.0);\n\n    /** The default tick marks visible. */\n    public static final boolean DEFAULT_TICK_MARKS_VISIBLE = true;\n\n    /** The default tick stroke. */\n    public static final Stroke DEFAULT_TICK_MARK_STROKE = new BasicStroke(1);\n\n    /** The default tick paint. */\n    public static final Paint DEFAULT_TICK_MARK_PAINT = Color.gray;\n\n    /** The default tick mark inside length. */\n    public static final float DEFAULT_TICK_MARK_INSIDE_LENGTH = 0.0f;\n\n    /** The default tick mark outside length. */\n    public static final float DEFAULT_TICK_MARK_OUTSIDE_LENGTH = 2.0f;\n\n    /** A flag indicating whether or not the axis is visible. */\n    private boolean visible;\n\n    /** The label for the axis. */\n    private String label;\n\n    /** The font for displaying the axis label. */\n    private Font labelFont;\n\n    /** The paint for drawing the axis label. */\n    private transient Paint labelPaint;\n\n    /** The insets for the axis label. */\n    private RectangleInsets labelInsets;\n\n    /** The label angle. */\n    private double labelAngle;\n    \n    /**\n     * The tool tip text for the label (<code>null</code> is permitted).\n     * \n     * @since 1.2.0\n     */\n    private String labelToolTip;\n\n    /**\n     * The URL for the label (<code>null</code> is permitted).\n     * \n     * @since 1.2.0.\n     */\n    private String labelURL;\n    \n    /** A flag that controls whether or not the axis line is visible. */\n    private boolean axisLineVisible;\n\n    /** The stroke used for the axis line. */\n    private transient Stroke axisLineStroke;\n    \n    /** The paint used for the axis line. */\n    private transient Paint axisLinePaint;\n    \n    /** \n     * A flag that indicates whether or not tick labels are visible for the \n     * axis. \n     */\n    private boolean tickLabelsVisible;\n\n    /** The font used to display the tick labels. */\n    private Font tickLabelFont;\n\n    /** The color used to display the tick labels. */\n    private transient Paint tickLabelPaint;\n\n    /** The blank space around each tick label. */\n    private RectangleInsets tickLabelInsets;\n\n    /** \n     * A flag that indicates whether or not tick marks are visible for the \n     * axis. \n     */\n    private boolean tickMarksVisible;\n\n    /** The length of the tick mark inside the data area (zero permitted). */\n    private float tickMarkInsideLength;\n\n    /** The length of the tick mark outside the data area (zero permitted). */\n    private float tickMarkOutsideLength;\n\n    /** The stroke used to draw tick marks. */\n    private transient Stroke tickMarkStroke;\n\n    /** The paint used to draw tick marks. */\n    private transient Paint tickMarkPaint;\n\n    /** The fixed (horizontal or vertical) dimension for the axis. */\n    private double fixedDimension;\n\n    /** \n     * A reference back to the plot that the axis is assigned to (can be \n     * <code>null</code>). \n     */\n    private transient Plot plot;\n\n    /** Storage for registered listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * Constructs an axis, using default values where necessary.\n     *\n     * @param label  the axis label (<code>null</code> permitted).\n     */\n    protected Axis(String label) {\n\n        this.label = label;\n        this.visible = DEFAULT_AXIS_VISIBLE;\n        this.labelFont = DEFAULT_AXIS_LABEL_FONT;\n        this.labelPaint = DEFAULT_AXIS_LABEL_PAINT;\n        this.labelInsets = DEFAULT_AXIS_LABEL_INSETS;\n        this.labelAngle = 0.0;\n        this.labelToolTip = null;\n        this.labelURL = null;\n        \n        this.axisLineVisible = true;\n        this.axisLinePaint = DEFAULT_AXIS_LINE_PAINT;\n        this.axisLineStroke = DEFAULT_AXIS_LINE_STROKE;\n        \n        this.tickLabelsVisible = DEFAULT_TICK_LABELS_VISIBLE;\n        this.tickLabelFont = DEFAULT_TICK_LABEL_FONT;\n        this.tickLabelPaint = DEFAULT_TICK_LABEL_PAINT;\n        this.tickLabelInsets = DEFAULT_TICK_LABEL_INSETS;\n        \n        this.tickMarksVisible = DEFAULT_TICK_MARKS_VISIBLE;\n        this.tickMarkStroke = DEFAULT_TICK_MARK_STROKE;\n        this.tickMarkPaint = DEFAULT_TICK_MARK_PAINT;\n        this.tickMarkInsideLength = DEFAULT_TICK_MARK_INSIDE_LENGTH;\n        this.tickMarkOutsideLength = DEFAULT_TICK_MARK_OUTSIDE_LENGTH;\n\n        this.plot = null;\n\n        this.listenerList = new EventListenerList();\n\n    }\n\n    /**\n     * Returns <code>true</code> if the axis is visible, and \n     * <code>false</code> otherwise.\n     *\n     * @return A boolean.\n     * \n     * @see #setVisible(boolean)\n     */\n    public boolean isVisible() {\n        return this.visible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis is visible and sends \n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isVisible()\n     */\n    public void setVisible(boolean flag) {\n        if (flag != this.visible) {\n            this.visible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the label for the axis.\n     *\n     * @return The label for the axis (<code>null</code> possible).\n     * \n     * @see #getLabelFont()\n     * @see #getLabelPaint()\n     * @see #setLabel(String)\n     */\n    public String getLabel() {\n        return this.label;\n    }\n\n    /**\n     * Sets the label for the axis and sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param label  the new label (<code>null</code> permitted).\n     * \n     * @see #getLabel()\n     * @see #setLabelFont(Font)\n     * @see #setLabelPaint(Paint)\n     */\n    public void setLabel(String label) {\n        \n        String existing = this.label;\n        if (existing != null) {\n            if (!existing.equals(label)) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n        else {\n            if (label != null) {\n                this.label = label;\n                notifyListeners(new AxisChangeEvent(this));\n            }\n        }\n\n    }\n\n    /**\n     * Returns the font for the axis label.\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the font for the axis label and sends an {@link AxisChangeEvent} \n     * to all registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     * \n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        if (!this.labelFont.equals(font)) {\n            this.labelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the color/shade used to draw the axis label.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the axis label and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the insets for the label (that is, the amount of blank space\n     * that should be left around the label).\n     *\n     * @return The label insets (never <code>null</code>).\n     * \n     * @see #setLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getLabelInsets() {\n        return this.labelInsets;\n    }\n\n    /**\n     * Sets the insets for the axis label, and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets (<code>null</code> not permitted).\n     * \n     * @see #getLabelInsets()\n     */\n    public void setLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");   \n        }\n        if (!insets.equals(this.labelInsets)) {\n            this.labelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the angle of the axis label.\n     *\n     * @return The angle (in radians).\n     * \n     * @see #setLabelAngle(double)\n     */\n    public double getLabelAngle() {\n        return this.labelAngle;\n    }\n\n    /**\n     * Sets the angle for the label and sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     * \n     * @see #getLabelAngle()\n     */\n    public void setLabelAngle(double angle) {\n        this.labelAngle = angle;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the tool tip text for the axis label.\n     * \n     * @return The tool tip text (possibly <code>null</code>).\n     * \n     * @see #setLabelToolTip(String)\n     * \n     * @since 1.2.0\n     */\n    public String getLabelToolTip() {\n        return this.labelToolTip;\n    }\n    \n    /**\n     * Sets the tool tip text for the axis label and sends a .\n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param text  the tool tip text (<code>null</code> permitted).\n     * \n     * @see #getLabelToolTip()\n     * \n     * @since 1.2.0\n     */\n    public void setLabelToolTip(String text) {\n        this.labelToolTip = text;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the URL text for the axis label.\n     * \n     * @return The URL (possibly <code>null</code>).\n     * \n     * @see #setLabelURL(String)\n     * \n     * @since 1.2.0\n     */\n    public String getLabelURL() {\n        return this.labelURL;\n    }\n    \n    /**\n     * Sets the URL for the axis label and sends an {@link AxisChangeEvent} to\n     * all registered listeners.\n     * \n     * @param url  the URL (<code>null</code> permitted).\n     * \n     * @see #getLabelURL()\n     * \n     * @since 1.2.0\n     */\n    public void setLabelURL(String url) {\n        this.labelURL = url;\n        notifyListeners(new AxisChangeEvent(this));        \n    }\n    \n    /**\n     * A flag that controls whether or not the axis line is drawn.\n     * \n     * @return A boolean.\n     * \n     * @see #getAxisLinePaint()\n     * @see #getAxisLineStroke()\n     * @see #setAxisLineVisible(boolean)\n     */\n    public boolean isAxisLineVisible() {\n        return this.axisLineVisible;\n    }\n    \n    /**\n     * Sets a flag that controls whether or not the axis line is visible and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param visible  the flag.\n     * \n     * @see #isAxisLineVisible()\n     * @see #setAxisLinePaint(Paint)\n     * @see #setAxisLineStroke(Stroke)\n     */\n    public void setAxisLineVisible(boolean visible) {\n        this.axisLineVisible = visible;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the paint used to draw the axis line.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setAxisLinePaint(Paint)\n     */\n    public Paint getAxisLinePaint() {\n        return this.axisLinePaint;\n    }\n    \n    /**\n     * Sets the paint used to draw the axis line and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getAxisLinePaint()\n     */\n    public void setAxisLinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.axisLinePaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used to draw the axis line.\n     * \n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setAxisLineStroke(Stroke)\n     */\n    public Stroke getAxisLineStroke() {\n        return this.axisLineStroke;\n    }\n    \n    /**\n     * Sets the stroke used to draw the axis line and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getAxisLineStroke()\n     */\n    public void setAxisLineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.axisLineStroke = stroke;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n    \n    /**\n     * Returns a flag indicating whether or not the tick labels are visible.\n     *\n     * @return The flag.\n     * \n     * @see #getTickLabelFont()\n     * @see #getTickLabelPaint()\n     * @see #setTickLabelsVisible(boolean)\n     */\n    public boolean isTickLabelsVisible() {\n        return this.tickLabelsVisible;\n    }\n\n    /**\n     * Sets the flag that determines whether or not the tick labels are \n     * visible and sends an {@link AxisChangeEvent} to all registered \n     * listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isTickLabelsVisible()\n     * @see #setTickLabelFont(Font)\n     * @see #setTickLabelPaint(Paint)\n     */\n    public void setTickLabelsVisible(boolean flag) {\n\n        if (flag != this.tickLabelsVisible) {\n            this.tickLabelsVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the font used for the tick labels (if showing).\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setTickLabelFont(Font)\n     */\n    public Font getTickLabelFont() {\n        return this.tickLabelFont;\n    }\n\n    /**\n     * Sets the font for the tick labels and sends an {@link AxisChangeEvent} \n     * to all registered listeners.\n     *\n     * @param font  the font (<code>null</code> not allowed).\n     * \n     * @see #getTickLabelFont()\n     */\n    public void setTickLabelFont(Font font) {\n\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n\n        if (!this.tickLabelFont.equals(font)) {\n            this.tickLabelFont = font;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns the color/shade used for the tick labels.\n     *\n     * @return The paint used for the tick labels.\n     * \n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick labels (if they are showing) and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getTickLabelPaint()\n     */\n    public void setTickLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickLabelPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the insets for the tick labels.\n     *\n     * @return The insets (never <code>null</code>).\n     * \n     * @see #setTickLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getTickLabelInsets() {\n        return this.tickLabelInsets;\n    }\n\n    /**\n     * Sets the insets for the tick labels and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets (<code>null</code> not permitted).\n     * \n     * @see #getTickLabelInsets()\n     */\n    public void setTickLabelInsets(RectangleInsets insets) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        if (!this.tickLabelInsets.equals(insets)) {\n            this.tickLabelInsets = insets;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the flag that indicates whether or not the tick marks are\n     * showing.\n     *\n     * @return The flag that indicates whether or not the tick marks are \n     *         showing.\n     *         \n     * @see #setTickMarksVisible(boolean)\n     */\n    public boolean isTickMarksVisible() {\n        return this.tickMarksVisible;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the tick marks are showing\n     * and sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isTickMarksVisible()\n     */\n    public void setTickMarksVisible(boolean flag) {\n        if (flag != this.tickMarksVisible) {\n            this.tickMarksVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the inside length of the tick marks.\n     *\n     * @return The length.\n     * \n     * @see #getTickMarkOutsideLength()\n     * @see #setTickMarkInsideLength(float)\n     */\n    public float getTickMarkInsideLength() {\n        return this.tickMarkInsideLength;\n    }\n\n    /**\n     * Sets the inside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     * \n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkInsideLength(float length) {\n        this.tickMarkInsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the outside length of the tick marks.\n     *\n     * @return The length.\n     * \n     * @see #getTickMarkInsideLength()\n     * @see #setTickMarkOutsideLength(float)\n     */\n    public float getTickMarkOutsideLength() {\n        return this.tickMarkOutsideLength;\n    }\n\n    /**\n     * Sets the outside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     * \n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkOutsideLength(float length) {\n        this.tickMarkOutsideLength = length;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke used to draw tick marks.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setTickMarkStroke(Stroke)\n     */\n    public Stroke getTickMarkStroke() {\n        return this.tickMarkStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getTickMarkStroke()\n     */\n    public void setTickMarkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        if (!this.tickMarkStroke.equals(stroke)) {\n            this.tickMarkStroke = stroke;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }\n\n    /**\n     * Returns the paint used to draw tick marks (if they are showing).\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setTickMarkPaint(Paint)\n     */\n    public Paint getTickMarkPaint() {\n        return this.tickMarkPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick marks and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getTickMarkPaint()\n     */\n    public void setTickMarkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.tickMarkPaint = paint;\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns the plot that the axis is assigned to.  This method will return \n     * <code>null</code> if the axis is not currently assigned to a plot.\n     *\n     * @return The plot that the axis is assigned to (possibly \n     *         <code>null</code>).\n     *         \n     * @see #setPlot(Plot)\n     */\n    public Plot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Sets a reference to the plot that the axis is assigned to.\n     * <P>\n     * This method is used internally, you shouldn't need to call it yourself.\n     *\n     * @param plot  the plot.\n     * \n     * @see #getPlot()\n     */\n    public void setPlot(Plot plot) {\n        this.plot = plot;\n        configure();\n    }\n\n    /**\n     * Returns the fixed dimension for the axis.\n     *\n     * @return The fixed dimension.\n     * \n     * @see #setFixedDimension(double)\n     */\n    public double getFixedDimension() {\n        return this.fixedDimension;\n    }\n\n    /**\n     * Sets the fixed dimension for the axis.\n     * <P>\n     * This is used when combining more than one plot on a chart.  In this case,\n     * there may be several axes that need to have the same height or width so\n     * that they are aligned.  This method is used to fix a dimension for the\n     * axis (the context determines whether the dimension is horizontal or\n     * vertical).\n     *\n     * @param dimension  the fixed dimension.\n     * \n     * @see #getFixedDimension()\n     */\n    public void setFixedDimension(double dimension) {\n        this.fixedDimension = dimension;\n    }\n\n    /**\n     * Configures the axis to work with the current plot.  Override this method\n     * to perform any special processing (such as auto-rescaling).\n     */\n    public abstract void configure();\n\n    /**\n     * Estimates the space (height or width) required to draw the axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the plot (including axes) should \n     *                  be drawn.\n     * @param edge  the axis location.\n     * @param space  space already reserved.\n     *\n     * @return The space required to draw the axis (including pre-reserved \n     *         space).\n     */\n    public abstract AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n                                           Rectangle2D plotArea, \n                                           RectangleEdge edge, \n                                           AxisSpace space);\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param cursor  the cursor location (determines where to draw the axis).\n     * @param plotArea  the area within which the axes and plot should be drawn.\n     * @param dataArea  the area within which the data should be drawn.\n     * @param edge  the axis location (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot \n     *                   (<code>null</code> permitted).\n     * \n     * @return The axis state (never <code>null</code>).\n     */\n    public abstract AxisState draw(Graphics2D g2, \n                                   double cursor,\n                                   Rectangle2D plotArea, \n                                   Rectangle2D dataArea,\n                                   RectangleEdge edge,\n                                   PlotRenderingInfo plotState);\n\n    /**\n     * Calculates the positions of the ticks for the axis, storing the results\n     * in the tick list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the edge on which the axis is located.\n     * \n     * @return The list of ticks.\n     */\n    public abstract List refreshTicks(Graphics2D g2, \n                                      AxisState state,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge);\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     * \n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object for notification of changes to the axis.\n     *\n     * @param listener  the object to deregister.\n     * \n     * @see #addChangeListener(AxisChangeListener)\n     */\n    public void removeChangeListener(AxisChangeListener listener) {\n        this.listenerList.remove(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Returns <code>true</code> if the specified object is registered with\n     * the dataset as a listener.  Most applications won't need to call this \n     * method, it exists mainly for use by unit testing code.\n     * \n     * @param listener  the listener.\n     * \n     * @return A boolean.\n     */\n    public boolean hasListener(EventListener listener) {\n        List list = Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\n    }\n    \n    /**\n     * Notifies all registered listeners that the axis has changed.\n     * The AxisChangeEvent provides information about the change.\n     *\n     * @param event  information about the change to the axis.\n     */\n    protected void notifyListeners(AxisChangeEvent event) {\n\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == AxisChangeListener.class) {\n                ((AxisChangeListener) listeners[i + 1]).axisChanged(event);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a rectangle that encloses the axis label.  This is typically \n     * used for layout purposes (it gives the maximum dimensions of the label).\n     *\n     * @param g2  the graphics device.\n     * @param edge  the edge of the plot area along which the axis is measuring.\n     *\n     * @return The enclosing rectangle.\n     */\n    protected Rectangle2D getLabelEnclosure(Graphics2D g2, RectangleEdge edge) {\n\n        Rectangle2D result = new Rectangle2D.Double();\n        String axisLabel = getLabel();\n        if (axisLabel != null && !axisLabel.equals(\"\")) {\n            FontMetrics fm = g2.getFontMetrics(getLabelFont());\n            Rectangle2D bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);\n            RectangleInsets insets = getLabelInsets();\n            bounds = insets.createOutsetRectangle(bounds);\n            double angle = getLabelAngle();\n            if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n                angle = angle - Math.PI / 2.0;\n            }\n            double x = bounds.getCenterX();\n            double y = bounds.getCenterY();\n            AffineTransform transformer \n                = AffineTransform.getRotateInstance(angle, x, y);\n            Shape labelBounds = transformer.createTransformedShape(bounds);\n            result = labelBounds.getBounds2D();\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state (<code>null</code> not permitted).\n     * @param plotState  the plot state (<code>null</code> permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n            if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n            }\n        }\n        return state;\n\n    }\n\n    /**\n     * Draws an axis line at the current cursor position and edge.\n     * \n     * @param g2  the graphics device.\n     * @param cursor  the cursor position.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     */\n    protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        \n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        g2.draw(axisLine);\n        \n    }\n\n    /**\n     * Returns a clone of the axis.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException if some component of the axis does \n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Axis clone = (Axis) super.clone();\n        // It's up to the plot which clones up to restore the correct references\n        clone.plot = null;        \n        clone.listenerList = new EventListenerList();\n        return clone;\n    }\n    \n    /**\n     * Tests this axis for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Axis)) {\n            return false;\n        }\n        Axis that = (Axis) obj;\n        if (this.visible != that.visible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.label, that.label)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelInsets, that.labelInsets)) {\n            return false;\n        }\n        if (this.labelAngle != that.labelAngle) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelToolTip, that.labelToolTip)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelURL, that.labelURL)) {\n            return false;\n        }\n        if (this.axisLineVisible != that.axisLineVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisLineStroke, that.axisLineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.axisLinePaint, that.axisLinePaint)) {\n            return false;\n        }\n        if (this.tickLabelsVisible != that.tickLabelsVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickLabelFont, that.tickLabelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.tickLabelPaint, that.tickLabelPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.tickLabelInsets, that.tickLabelInsets\n        )) {\n            return false;\n        }\n        if (this.tickMarksVisible != that.tickMarksVisible) {\n            return false;\n        }\n        if (this.tickMarkInsideLength != that.tickMarkInsideLength) {\n            return false;\n        }                  \n        if (this.tickMarkOutsideLength != that.tickMarkOutsideLength) {\n            return false;\n        }                  \n        if (!PaintUtilities.equal(this.tickMarkPaint, that.tickMarkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.tickMarkStroke, that.tickMarkStroke)) {\n            return false;\n        }\n        if (this.fixedDimension != that.fixedDimension) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.tickLabelPaint, stream);\n        SerialUtilities.writeStroke(this.axisLineStroke, stream);\n        SerialUtilities.writePaint(this.axisLinePaint, stream);\n        SerialUtilities.writeStroke(this.tickMarkStroke, stream);\n        SerialUtilities.writePaint(this.tickMarkPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.tickLabelPaint = SerialUtilities.readPaint(stream);\n        this.axisLineStroke = SerialUtilities.readStroke(stream);\n        this.axisLinePaint = SerialUtilities.readPaint(stream);\n        this.tickMarkStroke = SerialUtilities.readStroke(stream);\n        this.tickMarkPaint = SerialUtilities.readPaint(stream);\n        this.listenerList = new EventListenerList();\n    }\n\n}\n"}]}
